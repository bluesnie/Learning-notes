# 数据库三大范式

## 第一范式（1NF）（原子不可分性）

        所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，
        而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。
        在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。
        
        说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。
        不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。

## 第二范式（2NF）（消除非主键部分依赖）
        
        在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）
        
        第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
        第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。
        例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。
        在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，
        无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加）
        
        第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，
        那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，
        以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

## 第三范式（3NF）（消除传递依赖）

        在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）
        
        第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。
        简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。
        例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。
        那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。
        简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。
        
# 范式应用实例

## 第一范式（1NF）
        
        数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
        在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。
        因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。
        首先我们确定一下要设计的内容包括那些。学号、学生姓名、年龄、性别、课程名称、课程学分、系别、学科成绩，系办地址、系办电话等信息。
        为了简单我们暂时只考虑这些字段信息。我们对于这些信息，所关心的问题有如下几个方面。
        学生有那些基本信息？
        学生选了那些课，成绩是什么？
        每个课的学分是多少？
        学生属于那个系，系的基本信息是什么？
        
## 第二范式（2NF）
        
        首先我们考虑，把所有这些信息放到一个表中（学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话）下面存在如下的依赖关系。
        (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
        问题分析
        姓名和年龄不依于课程，即不完全依赖于主属性因此不满足第二范式的要求，会产生如下问题：
        数据冗余：同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。
        更新异常：
        1）若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。
        2）假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
        删除异常 ：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。
        解决方案
        把选课关系表SelectCourse改为如下三个表：
        学生：Student（学号，姓名，年龄，性别，系别，系办地址、系办电话）；
        课程：Course（课程名称,学分）；
        选课关系：SelectCourse（学号，课程名称，成绩）。
       
## 第三范式（3NF）
        
        接着看上面的学生表Student（学号，姓名，年龄，性别，系别，系办地址、系办电话），关键字为单一关键字"学号"，因为存在如下决定关系：
        （学号）→ （姓名，年龄，性别，系别，系办地址、系办电话
        但是还存在下面的决定关系：
        （学号） → (系别）→（系办地点，系办电话）
        即存在非关键字段"系办地点"、"系办电话"对关键字段"学号"的传递函数依赖。
        它也会存在数据冗余、更新异常、插入异常和删除异常的情况。
        根据第三范式把学生关系表分为如下两个表就可以满足第三范式了：
        学生：（学号，姓名，年龄，性别，系别）；
        系别：（系别，系办地址、系办电话）。
        上面的数据库表就是符合I，Ⅱ，Ⅲ范式的，消除了数据冗余、更新异常、插入异常和删除异常。