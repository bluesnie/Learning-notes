{"./":{"url":"./","title":"Introduction","keywords":"","body":"datetime:2019/6/14 9:04 author:nzb 笔记格式：{ { } } 写成 { { } } ， { % % } 写成 { % % }，空格隔开 gitbook 生成文档 注意：SUMMARY.md 目录中有的 markdown 才会转成静态 html, 并且才能全局搜索得到 电子书 学习笔记 Linux 入门基础 Linux系统简介 Linux系统安装 Linux使用注意事项 Linux各目录的作用 服务器注意事项 Linux常用命令 强大的文本编辑器Vim Linux软件包管理 Linux中的用户管理 Linux权限管理 Linux的文件系统管理 Shell Linux的服务管理 Linux系统管理 Linux日志管理 Linux启动管理 Linux备份与恢复 Python Python语言基础 Python PEP8编码规范 | 初识Python | 语言元素 分支结构 | 循环结构 | 构造程序逻辑 | 函数和模块的使用 字符串和常用数据结构 | 面向对象编程基础 | 面向对象编程进阶 图形用户界面和游戏开发 | 文件和异常 | 字符串和正则表达式 进程和线程 | 网络编程入门 | 网络应用开发 | 图像和文档处理 | logging日志模块 单元测试unittest基础 | 单元测试unittest进阶 | 单元测试unittest集成篇 Python语言进阶 常用数据结构 函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器 面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式 迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 / 并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await asynico异步编程 Python 第三方库 Django 快速上手 | 深入模型 | 静态资源和Ajax请求 | Django模板系统 Django的View(视图) | Django的路由系统 | Django ORM相关操作 Cookie、Session和分页 | Form、ModelForm组件 | 中间件 Django-REST-framework Django生命周期) | Django中间件 Django-Rest-framework组件: 认证 | 权限 | 频率控制(节流) | 版本(全局配置就行) | 解析器(全局配置就行) 序列化 | 分页 | 视图 | 路由 | 渲染器 | django组件：content-type Django项目开发经验 登录相关 | 异常处理手柄 | 过滤相关 | 存储类重写 | 序列化相关 | 自动化测试 | 接口加速缓存 PyQt5 导航 窗口 / 按钮 / 垂直布局和水平布局 / 栅格布局 / 布局添加标签和背景图 单选框 / 复选框 / 键盘提示 / 行编辑器 / 按钮组 / 布局组 / 无边框窗口 框架 / 分离器 / 滑动条 / 滚动条 / 刻度盘 / 上下拨号 / 生成随机数 进度条 / 工具框 / 菜单栏工具栏 / 文档编辑框 / 字体文本框 / 颜色文本框 打印 / 打印预览 / 打印PDF / 消息提示框 / 右键菜单 / 选项卡 / 堆叠小部件 可停靠的窗口小部件 / 日历 / 单选下拉框 / 首字母模糊填充 / 打开更多窗口 时间编辑 / 列表部件 / PySide Qt简介 界面设计师QtDesigner 发布程序 常用控件1 常用控件2 常用控件3 常用控件4 OpenCV 图像基本操作 图像处理 Pyinstaller pyInstaller打包基础 ZeroMQ zmq基础 GoLang GoLang简明教程 Go语言简明教程 Gin-简明教程 Go2新特性简明教程 Protobuf简明教程 RPC&TLS鉴权简明教程 WebAssembly(Wasm)简明教程 Test单元测试简明教程 Mock(gomock)简明教程 Mmap-文件内存映射简明教程 Context并发编程简明教程 GoLang基础 GoLang发展史 打印输出 变量和常量 数据类型 运算符 流程控制 数组 切片 map 函数 time包日期函数 指针 结构体 GoMod及包 接口 协程 反射 文件和目录操作 7daysGoLang 目录 7天用Go从零实现Web框架 - Gee 第一天：前置知识(http.Handler接口) 第二天：上下文设计(Context) 第三天：Trie树路由(Router) 第四天：分组控制(Group) 第五天：中间件(Middleware) 第六天：HTML模板(Template) 第七天：错误恢复(Panic Recover) C++ C++基础 C++初始 | 数据类型 | 运算符 流程控制 | 数组 数据库基础和进阶 关系型数据库MySQL 关系型数据库概述 MySQL的安装和使用 SQL的使用 DDL - 数据定义语言 - create / drop / alter DML - 数据操作语言 - insert / delete / update / select DCL - 数据控制语言 - grant / revoke 相关知识 范式理论 - 设计二维表的指导思想 数据完整性 数据一致性 在Python中操作MySQL 计算机二级 | 数据库三大范式 | MySQL主从复制 NoSQL入门 NoSQL概述 | Redis概述 | Mongo概述 Redeis Redis安装与配置文件 Redis基础 Redis键 | Redis字符串 | Redis哈希 | Redis列表 | Redis集合 | Redis有序集合 | Redis发布订阅 Redis多数据库 | Redis事务 | Redis数据淘汰策略 | Redis持久化 | Redis缓存与数据库Mysql一致性方案 Redis开发规范 数据分析 数学基础 高等数学 | 概率论 | 微积分 | SVD | 似然函数 | 后验概率估计 | 拉格朗日乘子法 | 核函数 梯度 | 概率分布与概率密度 | 泰勒公式 | 激活函数 | 熵 | 特征值与特征向量 | 矩阵 数据分析库 numpy基础 | pandas基础 | pandas连接合并追加 | matplotlib基础 Web前端 Web前端入门 | HTML5 | CSS | JavaScript jQuery | jQuery-UI | Vue.js | RESTful规范 ROS 什么是ROS Catkin工作空间编译系统 ROS通信架构上 ROS通信架构下 常用工具 roscpp rospy 工具 Docker 基本组成 / 容器相关技术简介 / 客户端与守护进程 / 守护进程的配置和操作 远程访问 / 容器 / 容器中部署静态网站 / 查看和删除镜像 / 获取和推送镜像 构建镜像 / DockerFile指令 / 构建过程 / 容器的网络连接 / 容器的数据卷 数据卷容器 / 数据卷的备份和还原 Docker入门PDF Docker部署Django Uwsgi+Nginx+MySQL+Redis Docker简单部署Django的FastDFS Git 帮助信息 / git配置(全局配置) / 初始化项目 / 查看状态 / 添加文件 / 提交文件 / 查看提交日志 查看文件修改前后的区别 / git跟踪rename文件和移动文件 / 删除文件 / 恢复文件 / 恢复提交 重置提交指针 / 查看、创建、切换分支 / 查看两个分支的区别 / 合并分支 / 解决合并冲突 / 重命名和删除分支 保存修改进度 / 添加别名 / 全局忽略跟踪文件 / 项目级忽略文件 / 创建远程版本库 / 推送版本库 修改远程仓库地址 / 克隆版本库到本地 / 更新本地版本库 / 基于版本库开发自己的版本库 / 添加pull request / 添加贡献者 Nginx 基础 进阶 工作所学技能或知识 福建路阳有限公司 上海快仓自动化有限公司 面试 技术面试必备基础知识 操作系统 网络 数据库 系统设计 数据结构与算法 算法 算法 算法图解 线性表 栈 队列 特殊矩阵压缩存储 串 树与二叉树 面试题 2020 理财 基金 基金基础 纯债基金 股票型基金 大数据指数基金 ETF基金 LOF基金 四大行业指数 基金进价 分级基金 避险基金 量化基金 QDII基金 FOF基金 其他 基金定投 基金投资术语 投资误区 全球配置 场外基金开户和买卖实操 场内基金开户和买卖实操 看懂股票行情 基金套牢怎么办 股票 股票市场常用名称解释 看盘 早盘 盘后 大盘分时图分析技巧 K线图 "},"Linux/Linux.html":{"url":"Linux/Linux.html","title":"入门基础","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux Linux系统简介 UNIX和Linux发展史 1965年，贝尔实验室：MULTICS计划 69年，贝尔实验室的肯汤普森：为了游戏开发UNICS/UNIX系统 62年，美国军方：ARPA：阿帕网，NCP协议——》TCP/IP协议 71年，可汤普森和丹尼斯里奇发明C语言，重写UNIX UNIX主要发行版本：AIX(IBM)、HP-UX(HP)、Solaris(Sun)、Linux(Intel,AMD……)、BSD 1991年，芬兰大学生Linus Torvalds开发linux内核。大学教授开发minix，但是不接受外来代码，所以李纳斯独自开发，由社区共同维护。 Linux内核版本号：主版本.次版本.末版本 linux内核官网 Linux发行版本：两大派系redhat和debian 开源软件简介 商业软件和开源软件（开源≠免费） 开源软件：apache、NGINX、MySQL、php、mongoDB、python、Ruby、Perl、Go、Rust、Swift、Java 开源软件的特点：使用自由（绝大多数免费）、研究自由（源代码）、散步和改良的自由 支撑互联网的开源技术（LAMP）：Linux，Apache，MySQL，PHP Linux应用领域 基于Linux的企业服务器 踩点网站：发数据包根据相应嗅探服务器 世界前500服务器 嵌入式应用 手机，平板：Android底层是Linux 智能家电，航空系统，银行系统…… 在电影娱乐业 特效，图形处理渲染 Linux学习方法 Linux只考虑应用性和稳定性 善于观察提示信息，查找文档，自己解决问题 学习英文：Command not found和No Such file or directory 忘掉Windows的操作习惯 计划，专注，坚持，练习 Linux系统安装 VMware虚拟机安装 VMware官网下载，不推荐安装双系统 特点： 不需要分区就能在物理机上使用两种以上的操作系统 物理机和虚拟机能实现网络通信 可以设定并随时修改虚拟机操作系统的硬件环境 要求： CPU：主频1GHz以上 内存：1GB以上 硬盘：8GB以上 镜像下载：官网下载: 几个版本：DVD版本，Everything版本，minimal版本，LiveGnome版本，KdeLive版本，livecd版本，NetInstall版本 系统分区 主分区：最多只能有4个 扩展分区：最多只能有一个；主分区加扩展分区最多有4个；不能写入数据，只能包含逻辑分区 逻辑分区：可以和主分区一样正确的写入数据和格式化 注意：兄弟连这套视频录制时间较为久远，当时的硬盘分区形式是MBR的，所以上述的分区限制也只 是针对MBR分区形式，对于GPT分区形式而言，则没有上述限制了。 电脑根据主板的不同（BOIS或者UEFI），会决定硬盘选择MBR分区方案还是GPT分区方案： BIOS + MBR UEFI + GPT 两者区别： 也就是说，电脑使用传统BIOS主板，建议使用MBR分区方案；电脑使用UEFI主板，建议使用GPT分区方案 MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。 MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。 在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。 硬盘分区的作用： 把一块大硬盘分成几块 格式化的作用： 写入文件系统（1.把硬盘分成一个个等大小的数据块 同时2.建立一个inode列表） Linux中的所有硬件都是文件： 硬盘文件名： IDE硬盘：/dev/hd[a-d] SCSI/SATA/USB硬盘：/dev/sd[a-p] 光驱：/dev/cdrom或/dev/sr0 鼠标：/dev/mouse 分区文件名： /dev/hda[数字] /dev/sda[数字] 挂载： 给分区分配挂载点 /根分区 swap交换分区（内存两倍，最大不超多2GB） /boot启动分区（200MB足够） 总结： 分区：把大硬盘分为小的分区 格式化：写入文件系统，同时会清空数据 分区设备文件名：给每个分区定义设备文件名 挂在：给每个分区分配挂载点，这个挂在点必须是空目录 Linux系统安装 把镜像加进去，点击启动，然后用图形界面配置分区和其他的自定义选项，确定定义root用户的密码和普通用户的账号和密码。然后等待安装完成即可。 远程登陆管理工具 三种网络连接方式： 桥接模式：虚拟机使用物理网卡 NAT模式：虚拟机使用vmnet8虚拟网卡 Host-only模式：虚拟机使用vmnet1虚拟网卡，并且只能和本机通信 临时配置ip：ifconfig ens33 192.168.XXX.XXX 永久配置ip： 查看网络接口：ifconfig 去网络接口的配置文件进行修改 [root@bogon ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33/ ens33是网卡接口 配置文件 TYPE=“Ethernet” PROXY_METHOD=“none” BROWSER_ONLY=“no” BOOTPROTO=“none” //dhcp是自动获取 DEFROUTE=“yes” IPV4_FAILURE_FATAL=“no” IPV6INIT=“yes” IPV6_AUTOCONF=“yes” IPV6_DEFROUTE=“yes” IPV6_FAILURE_FATAL=“no” IPV6_ADDR_GEN_MODE=“stable-privacy” NAME=“ens33” UUID=“d8ee940a-1a27-4417-9ae8-88a5364ee4d1” DEVICE=“ens33” ONBOOT=“yes” //引导激活 IPADDR=172.16.10.188 //ip地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=172.16.10.254 //网关 DNS1=222.88.88.88 //DNS Linux使用注意事项（新手必看） Linux 严格区分大小写 和 Windows 不同，Linux 是严格区分大小写的，包括文件名和目录名、命令、命令选项、配置文件设置选项等。 例如，Windows 系统桌面上有一个名为 Demo 的文件夹，当我们在桌面上再新建一个名为 demo 的文件夹时，系统会提示文件夹命名冲突；而 Linux 系统不会，Linux 系统认为 Demo 文件和 demo 文件不是同一个文件，因此在 Linux 系统中，Demo 文件和 demo 文件可以位于同一目录下。 因此，初学者在操作 Linux 系统时要注意区分大小写的不同。 Linux 中所有内容（包括硬件设备）以文件形式保存 Linux 中所有内容都是以文件的形式保存和管理的（硬件设备也是文件），这和 Windows 完全不同，Windows 是通过设备管理器来管理硬件的。比如说，Linux 的设备文件保存在 /dev/ 目录中，硬盘文件是 /dev/sd[a-p]，光盘文件是 /dev/hdc 等。 Linux 不靠扩展名区分文件类型 我们都知道，Windows 是依赖扩展名区分文件类型的，比如，\".txt\" 是文本文件、\".exe\" 是执行文件、\".ini\" 是配置文件、\".mp4\" 是小电影等。但 Linux 不是。 Linux 系统通过权限位标识来确定文件类型，且文件类型的种类也不像 Windows 下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux 的可执行文件不过就是普通文件被赋予了可执行权限而已。 Linux 中的一些特殊文件还是要求写 \"扩展名\" 的，但大家小心，并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种： 压缩包：Linux 下常见的压缩文件名有 .gz、.bz2、.zip、.tar.gz、.tar.bz2、.tgz 等。为什么压缩包一定要写扩展名呢？很简单，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用。 二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用\".rpm\"扩展名结尾，目的同样是让管理员一目了然。 程序文件：Shell 脚本一般用 \".sh\" 扩展名结尾，其他还有用 \".c\" 扩展名结尾的 C 语言文件等。 网页文件：网页文件一般使用 \"*.php\" 等结尾，不过这是网页服务器的要求，而不是 Linux 的要求。 在此不一一列举了，还有如日常使用较多的图片文件、视频文件、Office 文件等，也是如此。 Linux中所有存储设备都必须在挂载之后才能使用 Linux 中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U 盘和光盘。 挂载其实就是给这些存储设备分配盘符，只不过 Windows 中的盘符用英文字母表示，而 Linux 中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为 Windows 的盘符），把设备文件（如 /dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载。这个过程是通过挂载命令实现的，具体的挂载命令后续会讲。 Windows 下的程序不能直接在 Linux 中使用 Linux 和 Windows 是不同的操作系统，两者的安装软件不能混用。例如，Windows 系统上的 QQ 软件安装包无法直接放到 Linux 上使用。 系统之间存在的这一差异，有弊也有利。弊端很明显，就是所有的软件要想安装在 Linux 系统上，必须单独开发针对 Linux 系统的版本（也可以依赖模拟器软件运行）；好处则是能感染 Windows 系统的病毒（或木马）对 Linux 无效。 Linux各目录的作用 /bin/：存放系统命令 /sbin/：存放系统目录，只有超级用户能用 /usr/bin/：存放系统命令，单用户模式不能执行 /usr/sbin/ ：存放系统命令，只有超级用户能用，单用户模式不能执行 /boot/ ：系统启动目录，内核和启动引导程序 /dev/ ：硬件设备文件目录 /etc/ ：linux默认的配置文件保存目录 /home/：普通用户家目录 /root/：超级用户家目录 /lib/：系统调用的函数库 /lost+found/：当系统意外崩溃时，每个分区都含有的存放的文件碎片用来修复 /media/：挂载目录，挂载媒体设备 /mnt/：挂载目录，挂载U盘，移动硬盘，和其他操作系统的分区 /misc/：挂载目录，挂载NFS服务的共享目录 /opt/：第三方安装的软件的保存目录，也可以放到 /usr/local/ 下 /proc/：存放在内存里面，存放系统的内核，进程，外部设备 /sys/：存放在内存里面，存放系统的内核相关的东西 /srv/ ：服务数据目录 /tmp/ ：临时目录，可以清空 /usr/：系统资源目录 /var/：动态资源保存目录，日志，邮件，数据库 服务器注意事项 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 远程配置防火墙（过滤不是防病毒，比如允许某个端口运行访问）时不要把自己踢出服务器 指定合理的密码规范和定期更新 合理分配权限 定期备份重要数据和日志（系统备份：etc、boot、usr等目录） Linux常用命令 文件处理命令 ls（list） ls [参数] [路径] ls -l：查看文件所有属性 ls -d：查看目录本身（而不是查看目录下的信息） ls -i：查看文件的inode号 ls -h：人性化显示（文件大小以K, M显示） ls -s：显示文件占用的块的数量 ls -a：查看隐藏文件 mkdir（make directories）创建目录：mkdir [参数] [目录] mkdir -p：递归创建目录 cd（change directories） 切换目录：cd [路径] pwd（print work directories） 查看完整工作路径 rmdir （remove empty directories） 删除空目录：rmdir [目录名] cp（copy） 复制文件或目录：cp -rp [原文件或目录] [目标目录] cp -r：复制目录 cp -p：原文件和新文件属性完全一致 注：复制的同时可以改名 mv（move） 剪切文件、改名：mv [原文件或目录] [目标目录] 注：移动的同时可以改名 rm（remove） 删除文件或目录：rm -rf [文件或目录] rm -r：文件夹递归删除（删除目录） rm -f：强制删除，不询问 注： 删除之前做好备份 误删除之后对硬盘少做读写操作 touch 创建空文件：touch [文件名] cat 显示文件内容：cat [文件名] cat -n：显示行号 tac 显示文件内容（反向查看）：tac[文件名] more 分页显示文件：空格翻页，回车换行，q退出 查看命令帮助信息时就是使用more来查看 less 分页显示文件（可向上翻页）：空格翻页，回车换行，q退出，还可以pageup回翻页，上箭头网上翻一行，还可以搜索：/关 键词，再按n搜索下一个匹配的 head 显示文件前面几行：head [参数] [文件名] head -m：指定看前几行，默认前10行 tail 显示文件后面几行：tail [参数] [文件名] tail -n：指定看后几行，默认后10行 tail -f：动态看文件动态变化 ln（link） 生成链接文件：ln [原文件] [目标文件] ln -s：生成软链接 软连接特征：类似Windows快捷方式 lrwxrwxrwx：软连接的权限不起作用，还是要看源文件权限 文件大小：很小，只是符号链接 箭头指向源文件 什么时候需要用到软连接？Windows时你什么时候需要用到快捷方式时就用 ln：生成硬链接 硬链接特征 拷贝cp -p + 同步更新：cp -p的区别是硬链接文件和原文件可以同步更新 硬链接通过inode号来区分 不能跨分区 不能针对目录 硬链接和软连接的区别 1.硬链接不能跨分区 2.硬链接不能针对目录 权限管理命令 chmod（change the permissions mode of a life） 改变文件或目录权限：chmod [参数] [文件或目录] chmod [u/g/o/a] [+/-/=] [r/w/x] u：所有者；g：所属组；a：所有人；举例：chmod u+w；chmod u+x, o-wr chmod 三位数XXX：r—4，w—2，x—1：举例：rwxr-xr-x：755 （最常用） chmod -R：递归修改目录及目录下的权限 注释：深入理解文件的wrx和目录的wrx的意义 删除一个文件的权限不是对这个文件有写权限，而是对这个文件的目录有写权限 一个目录往往都是同时有r和x权限，可进入目录和查看目录下的文件 chown（change file ownership） 改变文件或目录所有者：chown [用户名] [文件或目录]：只有管理员root能执行 例：chown root:testgroup /test/ chgrp（change file group ownership） 改变文件或目录所属组：chgrp [组名] [文件或目录]：只有管理员root能执行 注：每个文件都只有一个user和一个group，某些others拥有拥有共同的权限，这些others在一个组里，也就是group所属组。所属者user可以不在所属组group里面，并且一个用户可以在不同的组里。 相关的命令是： groupadd YYY //创建组 useradd -g YYY XXX //创建用户并将YYY设置为其主要组 usermod -g ZZZ XXX //修改用户XXX的主要组为ZZZ umask（the user file-creation mask） 显示、设置文件的缺省权限 umask -S：人性化显示默认权限，以rwx形式显示新建文件缺省权限 umask：显示掩码（非人性化） 比如：0022，权限 实际上为：777 - 022 = 755 注：Linux中，默认创建的文件是没有可执行权限的（touch 创建的文件），所以文件是666，目录是777 umask 三位数：修改掩码，使默认权限变化umask 023；中文修改户的掩码为0023，权限为：754，并不建议修改 文件搜索命令 尽量少搜索，特别是在高峰期时 find 文件精准搜索：find [搜索范围] [匹配条件] find [搜索范围] -name：根据文件名搜索 find [搜索范围] -iname：根据文件名搜索，不区分大小写 注：通配符：*，？，[] *：匹配多个字符；举例：find /ete -name init（模糊搜索，包含即可） ？：匹配单个字符；举例：find /ete -name init???（搜索以init开头后面还有3个字符的文件） find [搜索范围] -size [+/-]n： +n：大于； -n：小于，只有数据块（0.5KB）个数； n：等于 find [搜索范围] -user：根据所有者查找 find [搜索范围] -group：根据所属组查找 find [搜索范围] -amin [-/+]分钟数：查找指定时间内或者超过该时间被修改过访问时间的文件(access) find [搜索范围] -cmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件属性的文件(change) find [搜索范围] -mmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件内容的文件(modify) 还可以在两个查找条件之间加上 -a ：一个是同时满足(and) -o ：一个是满足任意一个即可(or) 或者-exec/-ok 命令 [空格] {} [空格] \\； 对搜索结果执行操作 示例：find ./ -name test.txt -exec ls -l {} \\; -ok：是对后面的命令逐个询问 find [搜索范围] -type：根据文件类型查找 find [搜索范围] -inum：根据inode号查找 locate 模糊查找：locate 文件名 系统里所有的文件都会定期收录到/var/lib/mlocate.db这个文件库里，locate就是在这个里去找，但是新的文件没别收录进去，所以就找不到，需要手动更新文件资料库updatedb （但是tmp目录下不收录进去） locate -i：不区分大小写 which 查找命令的地址和别名alias：which 命令名 whereis 查找命令地址和其帮助文档的位置：whereis 命令名 grep 在文件里面查找字串匹配的行并输出：grep [-iv] [指定字串] [文件] grep -i：不区分大小写，查找指定字串所在的行 grep -v：排除指定字串所在的行 指定字串前面加个 ^ 表示以什么字串开头 帮助命令 man （manual）或 info （information） 查看命令和配置文件的帮助信息，浏览和more操作一样：man 命令名/配置文件名 帮助类型里1是命令的帮助，5是配置文件的帮助 For Example：man 1 passwd，man 5 passwd whatis 更加简单的命令查询，查看命令作用 apropos 更加简单的配置文件查询 –-help 得到信息更加简单：命令 ––help help 获得shell的内置命令的帮助，比如：cd，pwd，umask，if等 用户管理命令 useradd和passwd 新建用户和修改密码 who和w 查看当前登录用户名：tty是本地登录，pts表示远程登录 who简单信息 w 其中第一行：当前时间，已经运行的时间（服务器），多少个用户登录，服务器负载均衡（CPU，内存等负载情况）这行类型也可以 通过uptime获得 IDLE：表示用户空闲时间（多久没操作了） JCPU：累计占用的CPU时间 PCPU ：当前用户登录后占用CPU的时间 WHAT：当前执行的操作 压缩解压命令 几种压缩格式 .gz .zip .bz2 gzip（GNU zip）和 gunzip/gzip -d （GNU unzip） 压缩/解压文件：gzip/gunzip [文件] 解压缩：gunzip[文件] 或 gzip -d [文件] 只能压缩文件，不能压缩目录，并且不保留原文件 压缩文件后缀：.gz tar 打包目录：tar [选项] [压缩后文件名] [目录（可以多个空格隔开）] tar -c：打包 tar -x：解包 tar -v：显示详细信息 tar -f：指定文件名 tar -z：打包的同时压缩，或者解包的时候解压缩,适用于压缩解压gz tar -j：同-z，适用于压缩解压bz2 举例：tar -cvf XXX.tar YYY gzip XXX.tar ，最后生成XXX.tar.gz 。或者直接tar -zcvf打包压缩一部合成，反向是tar -zxvf 压缩文件后缀：.tar.gz zip和unzip 压缩文件或目录：zip [选项] [压缩后文件名] [文件或目录]，压缩比不高 压缩后能保留原文件 zip -r：压缩目录 压缩文件后缀：.zip bzip2和bunzip2 bzip2 /bunzip2 [选项] [文件] bzip2 -k：压缩的同时保留原文件 bunzip -k：解压的同时保留原文件 gzip的升级版本，压缩比较好 用tar生成.tar.bz2文件：tar -cjf xxx.tar.bz2 xxx 压缩文件后缀：.bz2 网络命令 write 给在线用户发信息，以ctrl+D保存结束：write wall （write all） 给当前在线的所有用户发送信息：wall [信息内容] ping 测试网络连通性：ping 选项 [IP地址] 网络踩点，Linux会一直ping下去 ping -c 次数：定义ping的次数 ifconfig （interface configure） 查看当前系统网卡信息和设置网卡信息（临时的）：ifconfig 网卡名称 IP地址 mail 查看和发送邮件：mail [用户名] 不一定要在线 mail 用户名：发送 mail：查看的子命令： q：退出 help(帮助)， 数字(查看指定邮件)， 列表：h(列表)， 删除：d 数字(删) last 日志查询命令，统计系统的所有登录信息： lastlog 查看用户最后登录的信息 lastlog -u uid：查看指定用户上次登录的信息 traceroute 跟踪节点的路径：traceroute ip地址 netstat 显示网络相关信息：netstat [选项] netstat -t：TCP协议（有3次握手） netstat -u：UDP协议（无3次握手，快，但是不保证数据收到） netstat -l：监听 netstat -r：路由 netstat -n：显示ip地址和端口号 最常用的三种组合命令： netstat -tlun：查看本机监听的端口 1：标志协议：TCP/UDP 2：数据包接收队列：0代表网络通畅 3：数据包发送队列：0代表网络通畅 4：本机IP地址和端口（主要查看的内容） 5：监测状态：TCP才有，UDP没有（你可以直接发送，不管在不在线，不需要监听） netstat -an：查看本机所有的网络连接 跟-tlun的区别是可以查看正在连接的服务 netstat -rn：查看本机路由表 setup redhat系linux独有 配置网络的工具：永久生效 配置玩需要重启网络服务：service network restart 挂载命令 mount mount [-t 文件系统] 设备文件名 挂载点 举例：mount -t iso9660 /dev/sr0 /mnt/cdrom /dev/sr0：设备文件名，系统默认的 umount 卸载：umount 设备文件名 关机重启命令 shutdown shutdown [选项] 时间 shutdown -h 时间（new）：关机 shutdown -r 时间：重启 shutdown -c：取消前一个关机命令 谨慎操作 其他关机命令：halt,poweroff,init 0 其他重启命令：reboot,init 6 init 系统运行级别： 0：关机， 1：单用户， 2：不含NFS服务的多用户， 3：完全多用户， 4：未分配， 5：图形界面， 6：重启 /etc/inittab配置文件里面有运行级别的信息，方便查询，也可以改运行级别 init 数字：设置系统运行级别，临时更改 runlevel：查询系统运行级别 logout和exit 都是退出登录：logout退出是把因为你注销了登陆机而把你踢出的退出，exit是你直接退出连接的机器。 强大的文本编辑器:Vim 概述 Vim是linux中的一款使用最广的文本编辑器，全屏幕编辑器。 可以建立，编辑，显示文本文件。 它没有菜单只有命令. 三种模式 命令模式：输的东西都会当做命令处理 插入模式 后：a/A（行末） 前：i/I（行首） 行：o（光标下）/O（光标上）进入 退出模式：ESC键 常用操作 :set ic————搜索时不区分大小写 行号相关： :set nu————显示行号 :set nonu————关闭行号 定位相关 gg————快速定位到第一行 G————快速定位到最后一行 nG————快速定位到第n行 :n————快速定位到第n行 $————快速定位到行尾 0————快速定位到行首 删除相关 x————删除光标后字符 X————删除光标前字符 nx————删除光标后n个字符 dd————删除一行 dd————删除当前行，ndd删除当前行和下面的n-1行 dG————删除当前行到文件末尾 D————删除光标到行尾 :2,8d————删除第2行到第8行 复制粘贴替换相关 yy————复制当前行 nyy————复制当前行和下面的n-1行 p————粘贴到光标上一行 P————粘贴到光标下一行 dd/ndd 和 p/P ————剪切（删除和粘贴组合） r————替换当前字符 R————从当前位置一直往后替换（进入替换模式，esc退出模式） u————恢复 ctrl+r————撤销恢复 /string————搜索命令，按n找下一个 :%s/old/new/g————全文替换old为new :n1,n2s/old/new/g————n1到n2行替换old为new 退出保存相关 :w————保存（相当于Windows的ctrl+r） :w filename————另存为 :wq————保存并退出 ZZ————保存并退出 :q!————不保存退出 :wq!————强制保存退出，针对只读文件可以强行保存(只有文件所有者和root才可以) 使用技巧 查看命令的执行结果：:!命令 查看命令的地址：:!which 命令名 导入内容到文件中 导入文件内容：:r 导入文件地址(路径) 导入命令执行结果：:r !命令 导入命令的地址：:r !which 命令 导入当前时间：:r !date 定义快捷键 :map 快捷键（Ctrl + v + 自己想要的数字或字母） 触发命令 关键词自动替换 :ab mymail XXXXXXX@gmail.com 输入mymail是自动替换为你的邮箱地址 多行注释与取消注释 方法一 注释：Ctrl + v 行首选择多行，I（大写的i，shift + i），插入# ，ESC退出命令模式 取消注释：Ctrl + v 行首选择多行，d 方法二 :n,n+10s/^/#/g：注释n行到n+10行 :n,n+10s/^#//g：取消注释（注意行首尖叫号 ^） 所有配置都是临时的，要永久需要写入配置文件里，存放在用户的家目录下，.vimrc，如果没有的话就自己新建一个也ok Linux软件包管理 软件包管理简介 软件包分类： 源码包：包括脚本安装包 二进制包：RPM包，系统默认包（ubuntu中是deb包），源码包编译后的包 源码包的优点 开源 可以自由选择所需的功能 软件是便宜安装，所以更加是个自己的系统，更加稳定也效率更高 卸载方便（直接把目录删除） 源码包的缺点 安装步骤多 编译并安装时间过长 因为是编译安装，安装过程中一旦报错新手很难解决 RPM包优点 包管理系统简单，只需要几个命令就可以实现软件包的安装，升级，查询和卸载 安装速度比源码包快很多 RPM包缺点 不能看见原代码 功能选择不如源码包灵活 依赖性 RPM包管理 rpm命令管理 RPM包名和包全名 RPM包的依赖性：树形依赖，环形依赖，模块依赖(以.iso.数组结束的就是模块依赖，也叫库文件依赖模块依赖查询网站) 安装和升级使用包全名，卸载和查询使用包名（在/var/lib/rpm/中的数据库总搜索） RPM安装：rpm -ivh 包全名 -i（install）：安装 -v（verbose）：显示详细信息 -h（hash）：显示进度 --nodeps：不检测依赖性（该选项不用） RPM升级：rpm -Uvh 包全名 -U（upgrade）：升级 RPM卸载：rpm -e 包名,也要考虑依赖性，当有包被依赖时，此时这个包不能删掉 -e（erase）：卸载 RPM查询包：查询包还是用RPM，yum没有查询功能 查询包是否安装：rpm -q 包名 -q（query） 查询所有安装的包：rpm -qa -a（all） RPM查询包详细信息：rpm -qi 包名 -i（information） RPM查询未安装包的详细信息：rpm -qip 包全名 -p（package） RPM查询文件安装位置：rpm -ql 包名 -l（list） RPM查询未安装包的文件安装的默认位置：rpm -qlp 包名 RPM查询系统文件属于哪个rpm包：rpm -qf 系统文件名 -f（file） RPM查询软件包的依赖性：rpm -qR 包名 -R（requires） RPM查询未安装软件包的依赖性：rpm -qRp 包全名 RPM包校验：rpm -V 包名 -V（verify） RPM包中文件提取（用来修复系统）： rpm2cpio 包全名 | cpio -idv . 包中的文件绝对路径 -i（copy-in模式）：还原 -d：还原时自动新建目录 -v：显示还原过程 yum在线管理 既可以用在线yum源文件服务器，也可以用本地光盘作为yum源文件服务器。 会自动解决依赖性问题 更换yum源：保存在/etc/yum.repos.d/目录下 查询：yum list 搜索：yum search 包名 安装：yum -y install 包名 -y（yes） 升级：yum -y update 包名 yum -y update：不写包名，直接升级全部（包括Linux内核，远程升级了的话不能开机，需要本地配置文件），慎用 卸载，会卸载所有依赖的包：yum -y remove 包名 Linux服务器应该采用最小化安装的原则，用什么装什么 装完了最好不要用yum卸载，也不要随便升级 yum的软件组管理： 查询所有可用的软件组列表：yum grouplist 安装指定软件组：yum groupinstall 软件包组名 卸载指定软件组：yum groupremove 软件包组名 用光盘做yum源：修改/etc/yum.repos.d/下的media配置文件，该源为关盘挂载点，注意：配置文件的格式要求很严格，注释应该顶头写。 源码包管理 区别： 安装前的区别：概念上的区别，见上述 安装后的区别：安装位置的区别 RPM包（一个软件）的默认安装位置： /etc/：配置文件 /usr/bin/：可执行的命令 /usr/lib/：程序所使用的函数库 /usr/share/doc/：基本的软件使用手册 /usr/share/man/：版主文档 /var/www/html/：服务器类软件的默认网页位置 源码包的安装位置： 需要手动指定安装目录：一般推荐/usr/local/软件名/ RPM包和源码包安装软件带来的影响：启动服务的方式不同 RPM包在/etc/rc.d/init.d/下有执行文件，采用两种方式启动： /etc/rc.d/init.d/httpd start service httpd start 源码包的服务启动方式不能用系统服务管理命令例如service来管理 只能在/usr/local/软件名/bin/执行软件码 start 目录下启动服务 Apache源码包的具体安装步骤： 安装C语言编译器：gcc 下载apache的源码包：path 确认源码保存位置/usr/local/src/ 确认软件安装位置：/usr/local/ 如何确认安装过程报错安装过程停止并出现error，warning，no等提示语言 解压缩下载的源码包：tar -zxvf 源码包名 进入解压缩目录：INSTALL和README时安装说明和使用说明 执行./configure --prefix=默认安装目录：编译前准备 定义需要的功能选项 检测系统环境是否符合安装要求 把定义好的的功能选项和检测系统环境的信息都写入Makefile文件（./configure过程会生成），用于后续的编译 执行make：编译 如果前两步报错，执行make clean，清空过程中生成的临时文件。 执行make install：安装 删除源码包安装的软件：直接rm -rf /usr/local/软件名/ 脚本安装包与软件包管理 脚本安装包不是独立的软件包类型，常见安装的是源码包 人为包安装过程写成额自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装 非常类似于windows下软件的安装方式 Webmin是一个基于Web的Linux系统管理界面，可以通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务。下载软件，下载后解压缩，并进入解压缩目录，执行.sh安装脚本,最后登录ip地址的自己配置的端口号进入该网站即可 如何选择包安装？ 如果对外服务，选择源码包安装，例如：Apache 如果本机使用，RPM包安装，例如：gcc编译器 Linux中的用户管理 用户配置文件 越是安全性要求高的服务器越需要对用户权限等级制度和服务器操作规范有很高的要求，linux中主要通过用户配置文件来查看和修改用户信息 主要有四个配置文件：/etc/passwd，/etc/shadow，/etc/group，/etc/gshadow /etc/passwd：用户信息文件 格式（7个字段） 用户名称； 密码标志； UID：用户ID 0：超级用户 1—499：系统用户:不能登录，不能删除 500—65535：普通用户 GID：组ID：这里是初始组ID不是附加组ID 用户说明：备注 家目录； 普通用户：/home/用户名/ 超级用户：/root/ Shell 命令解释器类型，默认是bash /etc/shadow：影子文件 是passwd的影子，默认权限：000 格式（9个字段） 用户名称； 加密密码； SHA512加密，可以暴力破解 如果密码是：“!!”和 “*”，表示没有密码，不能登录 密码最后一此修改时间；时间戳表示：使用1970年1月一日作为标准时间，每过一天时间戳加1 两次密码修改间隔（天）； 密码时效天数（-1永不失效）； 密码修改到期前的警告天数； 密码到期后的宽限天数； 账号失效时间；时间戳表示 保留字段 时间戳换算： 时间戳—>日期：date -d \"1970-01-01 16066 days\" 日期—>时间戳：echo$(($(date --date=\"2014/01/06\" +%s)/86400+1)) /etc/group&/etc/gshadow：组信息文件&组密码文件 /etc/group格式（4个字段） 组名， 组密码标志， GID， 组中附加用户 /etc/gshadow格式（4个字段） 组名， 组密码(默认没有，也不推荐使用)， 组管理员用户名， 组中附加用户 Linux中查看用户的初始组的方法：查询etc/passwd和/etc/group，两两对照查看 用户管理相关文件 用户的家目录：（会自动生成） 普通用户：/home/用户名/：权限700 超级用户：/root/：权限550 用户的邮箱： /var/spool/mail/用户名/ 用户模板目录：就是母板，新建用户会默认创建在用户家目录下 把/etc/skel/目录下的文件复制到用户家目录下 /etc/skel/ 用户管理命令 useradd 创建用户：useradd [选项] 用户名 新建一个用户实际上就是在上述六个地方生成了默认信息，所以手工修改上述六个地方就可以手工添加用户 useradd -u UID：指定自定义UID useradd -d 家目录：指定自定义家目录 useradd -c 用户说明：指定自定义用户说明 useradd -g 组名：指定自定义初始组组名 不建议修改 useradd -G 组名1,组名2：指定自定义附加组组名 useradd -s shell：指定自定义登录shell，默认是/bin/bash 用户默认值配置文件：/etc/default/useradd 和 /etc/login.defs passwd 修改用户密码：passwd [选项] 用户名 超级用户可以改任意用户密码 普通用户只能给自己设密码passwd whoami：查看当前用户 passwd -S 用户名 ：查看密码状态，就是shadow里面的信息，仅root用户可用 passwd -l 用户名 ：锁定用户，实际是在shadow中的密码前面加了“!”，仅root用户可用 passwd -u 用户名 ：解锁用户 passwd --stdin 用户名 ：使用字符串作为用户密码 例如：echo \"123\" | passwd --stdin 用户名，shell编程添加多个用户时使用 usermod 修改用户信息：usermod [选项] 用户名 usermod -u UID：修改UID usermod -c 用户说明：修改用户说明 usermod -G 组名1,组名2：修改附加组 usermod -g 组名：修改初始组（不推荐） usermod -L：锁定用户（Lock） usermod -U：解锁用户（Unlock） chage 修改用户密码状态：chage [选项] 用户名 chage -l：查询密码详细状态 chage -d 日期：修改密码最后一次更改日期 chage -m 天数：修改两次密码修改间隔 chage -M 天数：修改密码有效期 chage -W 天数：修改密码过期前警告天数 chage -I 天数：修改宽限天数 chage -E 日期：修改账号失效时间 注意：实际是对shadow文件里面的信息进行修改，chage -d 0 用户名 使用最多，把用户的修改密码时间归零，强制用户第一次登陆系统必须修改密码 userdel 删除用户：userdel [选项] 用户名 userdel -r 用户名：删除用户的同时删掉家目录 不推荐手工创建用户，但是可以手工删除用户的相关信息： etc/passwd etc/shadow etc/group etc/gshadow var/spool/mail/用户名 /home/用户名/ 手工把上面6个位置和要删除的用户的相关信息删除就可以了 id 查询用户uid，gid和附加组：id 用户名 su 用户切换：su [选项] 用户名 su - 用户名 ：连带用户的环境变量一起切换，中间减号绝对不能省去，省去就不会切换环境变量 su - root -c 命令名：不切换root，只是执行root权限才能执行的命令 用户组管理命令 groupadd 添加用户组：groupadd [选项] 组名 groupadd -g（GID）组名：指定组ID groupmod groupmod -g 新组id 旧组id groupmod -n 新组名 旧组名 尽量不修改 groupdel groupdel 组名：要想删除一个组，这个组中不允许有初始用户存在 gpasswd 把用户添入组或者从组中删除：gpasswd [选项] 组名 gpasswd -a 用户名：把用户加入组 gpasswd -a 用户名 组名 gpasswd -d 用户名：把用户从组中删除 gpasswd -d 用户名 组名 注：也可以直接在/etc/group文件里添加附加组(不推荐改初始组) 总结： Linux中用户和用户组的关系是： Linux权限管理 ACL权限 ACL权限的简介和开启方式 任何一个文件在一个时刻只能有一个所有者和所属组 ACL权限用来解决文件的权限身份不够用的情况 ACL权限需要分区支持： dumpe2fs -h /dev/sda5/ 查看是否支持acl选项，如果不支持。 /dev/sda5/ 为df -h 查看根分区对应的文件系统 可以临时开启：mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限 或者永久开启：vim /etc/fstab，然后重启系统 在根分区的defaults后面加个：,act 慎用：任何错误都会导致挂载失败 ACL权限类似于windows的权限设置方法，就是不考虑user，group和others的权限设置，单独添加一个用户或者一个用户组对一个文件或者目录的权限 查看与设定ACL权限 getfacl 查看ACL的权限：getfacle 文件名 setfacl 设置ACL的权限：setfacl [选项 ] 文件名 setfacl -m u/g/m：用户名/组名/不写权限 文件名：设定文件的ACL权限 setfacl -m u:用户名:权限 文件名：设定文件用户的ACL权限 为用户分配ACL权限，使用“u:用户名:权限”格式 例：setfacl -m u:user1:rwx /test/ setfacl -m g:组名:不写权限 文件名：设定文件用户组的ACL权限 为组分配ACL权限，使用“g:组名:权限”格式 setfacl -x ：删除指定的ACL权限 setfacl -b ：删除所有的ACL权限 setfacl -d ：设定默认ACL权限 setfacl -k ：删除默认ACL权限 setfacl -R ：递归设定ACL权限 最大有效权限与删除ACL权限 最大有效权限mask：可以通过getfacl 文件名来查看ACL的权限，里面有mask，可以通过控制mask的值来修改默认最大有效权限。 需要注意的是mask权限不会影响当前文件所有者，只会影响ACL权限和所属组的权限 setfacl -x u/g:用户名/组名 文件名：删除文件指定的ACL权限 setfacl -b 文件名：删除文件所有ACL权限 默认ACL和递归ACL权限（只能针对目录） setfacl -m d:u/g: 用户名/组名:权限 文件名：设定父目录的默认ACL权限，父目录里所有的新建文件都会继承父目录的ACL权限 d参数就是设置默认的ACL权限 setfacl -k：删除父目录的默认ACL权限 setfacl -m [选项] -R 文件名：递归设定文件夹的ACL权限 setfacl -m u:test:rx -R 文件名 文件特殊权限 SetUID：在所有者的x位置上变成了s针对二进制文件 passwd命令拥有SetUID权限，所以普通用户能修改自己密码 四个条件缺一不可： 只有二进制文件（例如命令和脚本文件）才能设定SUID权限 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的属主身份 SUID权限只在该程序执行过程中生效，也就是身份改变旨在程序执行过程中有效 我们通常会看到4777，2777，1777的权限标识，依次是加了SUID，SGID，SBIT权限 4代表SUID 2代表SGID 1代表SBIT 设定SetUID的方法 4代表SUID chmod 4755 文件名 chmod u+s 文件名 取消SetUID的方法 chmod 755 文件名 chmod u-s 文件名 可以用chmod来赋予和删除SUID SetUID是非常危险的，一个命令只要有了s权限，例如passwd命令，普通用户就可以通过执行这个命令获得passwd的属主身份，也就是进入root权限。 比如：给vim加了SetUID后，普通用户就会有root权限，例如：修改/etc/passwd文件，非常危险。 关键目录应严格控制写权限（普通写权限，不是SetUID权限）。比如“/”、“/usr”等 用户的密码设置要严格遵守密码三原则 对系统中默认应该具有SetUID权限的文件作出备份，定时检查有没有这之外的文件被设置了SetUID权限 SetGID：在所属组的x位置上变成了s 针对二进制文件和目录 针对二进制文件，四个条件缺一不可： 只有可执行的二进制文件才能设置 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的所属组身份 SUID权限只在该程序执行过程中生效，也就是所属组身份改变旨在程序执行过程中有效 注：例如/usr/bin/locate命令 针对目录，三个条件缺一不可： 普通用户必须对此目录拥有r和x权限，才能进入该目录 普通用户在此目录中的有效组会变成此目录的所属组 若普通用户对此目录拥有w权限时，新建的文件的默认组不是文件自己的初始组，而是这个目录自己的所属组 可以用chmod来赋予和删除SGID 设定SetGID的方法 2代表SGID chmod 2755 文件名/二进制文件 chmod g+s 文件名/二进制文件 取消SetGID的方法 chmod 2755 文件名/二进制文件 chmod g-s 文件名/二进制文件 Sticky BIT(黏着位)：在其他人的x位置上变成了t 针对目录 三个条件缺一不可： 只有目录才能设定SBIT权限 普通用户必须对该目录有x和w权限 有了SBIT，普通用户即使有目录的w权限，也不能删除其他用户建立的文件 设定SBIT的方法 1代表SBIT chmod 1755 文件名 chmod o+s 文件名 取消SBIT的方法 chmod 1755 文件名 chmod o-s 文件名 需要注意的安全性： 需要定期对系统中含有SUID或者SGID权限的文件进行检查，如果有异常多出来的含有该权限的文件，如果多出来了，是一个极大的安全隐患，需要手工清除。 文件系统属性chattr权限 chattr（change file attributes on a linux file system） 格式：chattr [+-=] [选项] 文件或目录名 符号 +：增加权限 -：删除权限 =：等于某权限 选项 i： 1.对文件：不允许任何用户（包括root用户）对文件进行任何修改，只能读 2.对目录：任何用户（包括root用户）只能在目录下修改文件内容，但是不能删除和创建文件 a： 1.对文件：任何用户（包括root用户）只能对文件增加数据，但是不能删除和修改现有数据 2.对目录：任何用户（包括root用户）只能在目录中建立和修改文件里的内容，但是不能删除文件 lsattr 查看文件系统属性：lsattr 选项 文件名 lsattr -a 文件名：显示所有文件和目录 lsattr -d 文件名：若文件时目录，仅列出目录自己的属性 系统命令sudo权限 之前学的是对文件的操作权限，sudo是对系统命令的权限。 sudo权限是root把本来只能超级用户执行的命令赋予普通用户的执行 root权限先执行命令visudo命令 实际修改的是：/etc/sudoers文件 在这一行root ALL=(ALL) ALL下面添加 root ALL=(ALL) ALL 给用户 格式：用户名 被管理主机的地址 = （可使用的身份）授权命令（绝对路径） 第一个ALL：允许在命令在哪台计算机上执行 第二个ALL：把前面的用户转变成这个身份，一般不用 第三个ALL：所有命令，应该写具体权限 %wheel ALL=(ALL) ALL 给组 %组名 被管理主机的地址=（可使用的身份）授权命令 （绝对路径） 例如：jack ALL=/sbin/shutdown -r now：授权jack能重启服务器的权限 sudo -l：查看自己能用那些sudo命令 sudo：执行sudo命令：sudo [绝对路径命令] 注意：vim命令不用设置sudo给普通用户，否则会拥有root的所有权限，非常危险 Linux的文件系统管理 分区和系统文件 分区类型 对于硬盘分区形式是MBR的 分区图 一： 二： 规定了：1、2、3、4只能分配给主分区（主分区最多4个），所以逻辑分区从5开始 主分区：总共最多只能分4个 扩展分区： 包含逻辑分区 只能有一个 也算作主分区的一种 主分区+扩展分区 不能存储数据和格式化 必须再分成逻辑分区才能使用 如果是IDE硬盘，Linux最多支持59个逻辑分区 如果是SCSI硬盘，Linux最多支持11个逻辑分区 对于GPT分区形式而言，没有上述限制 文件系统 Linux的文件系统可分为 ext2：是ext文件系统的升级版本，最大支持16TB的分区和最大2TB的文件（1TB=1024G=1024*1024KB） ext3：是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性，最大支持16TB的分区和最大2TB的文件（1TB=1024G=1024*1024KB） ext4：是ext3文件系统的升级版本，ext4在性能、伸缩性和可靠性方面进行了大量改进。 向下兼容EXT3 最大1EB文件文件系统和16TB文件（1EB=1024PB=1024*1024TB） 无限数量子目录 Extents连续数据块概念 多块分配 延迟分配 持久预分配 快速FSCK 日志校验 无日志模式 在线碎片整理 inode增强 默认弃用barrier等，默认CentOS 6.3的默认文件系统 swap： vfat： Windows文件系统为：FAT16、FAT32、FAT64和NTFS。而格式化的目的就是写入文件系统 文件系统常用命令 df命令，du命令，fsck命令，dumpe2fs命令 df df [选项] df -a： 显示所有分区 df -h：人性化显示。(一般用来统计系统空间大小) du du [选项] [目录或文件名] du -a：显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量 du -h ：人性化显示 du -s：弥补ls命令的不足，可以统计文件夹包括里面的内容的大小而不是单单文件夹的大小。(一般用来统计文件大小)，避免服务器高运载下使用 df和du的区别 du只是面向文件的，只会计算文件或目录占用的空间； df是从文件系统角度考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除但是程序并没有释放空间）， 所以df看到的才是真正的可以使用的空间 fsck 文件系统修复命令，不需要自己手动执行：fsck [选项] 分区设备文件名 系统会自动执行，除非需要手动去执行，否则不用管 fsck -a 分区设备文件名：不用显示用户提示，自动修复文件系统 fsck -y 分区设备文件名：自动修复，和-a作用一致，不过有些文件系统只支持-y dumpe2fs 显示磁盘状态：dumpe2fs 分区设备文件名 显示ext2、ext3、ext4文件系统的超级块和块组信息 挂载命令 将设备文件名和绑定到盘符(挂载点)上，Windows是自动，Linux默认是手动分配 mount -l：查询异已挂载的设备，加-l会显示卷标名 mount -a：依据配置文件/etc/fstab中的内容，自动挂载 mount 挂载命令格式：mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点 -t：文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L：卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载 -o：特殊选项：可以制度挂载的额外选项 没特殊需求不需要加特殊选项 挂载光盘和U盘 Linux中的分区时开机自动挂载，但是光盘和U盘时手动挂载，系统准备了/mnt/和/media/来挂载 /mnt：挂载U盘 /media：挂载光盘 挂载光盘步骤 sr0和cdrom都可以作为设备文件名 建立挂载点：mkdir /mnt/cdrom/ 挂载：mount -t iso9660 /dev/cdrom /mnt/cdrom/或者mount /dev/sr0 /mnt/cdrom 设备文件名：/dev/cdrom和/dev/sr0是固定的 去挂载点访问：cd /mnt/cdrom/ 在拿走光盘之前需要先卸载光盘：umount 设备文件名或挂载点 挂载U盘步骤 U盘的设备文件名是自动识别的，用fdisk -l查看 建立挂载点：mkdir /mnt/usb/ 挂载：mount -t vfat /dev/sdb1 /mnt/usb/ /dev/sdb1：fdisk -l 查看的 去挂载点访问：cd /mnt/usb/ 在拔U盘之前需要先卸载光盘：umount 设备文件名或挂载点 注意： 挂载U盘只能用本机或者虚拟机，不能用远程工具 Linux默认是不支持NTFS文件系统的外设的，U盘只能FAT格式的 Linux如何支持NTFS文件系统 Linux系统的内核中已经把市面上常见的驱动包括了，所以安装系统后一般不需要安装驱动，Linux会自动匹配识别，如果Linux默认没有把一个文件系统的驱动加载进来，我们就需要手动去安装驱动。 几种让Linux支持NTFS文件系统的方法： 内核重新编译 第三方的插件：ntfs-3g 内核编译太麻烦，太高端，一般选择“ntfs-3g插件”来实现 安装步骤： 解压：tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz 进入解压目录：cd ntfs-3g_ntfsprogs-2013.1.13 编译前准备：./configure 编译：make 编译安装：make install 挂载NTFS分区的硬盘：mount -t ntfs-3g 设备文件名 挂载点 fdisk分区 fdisk命令分区过程 虚拟机添加新硬盘，并用fdisk -l查询新硬盘是否被识别 若已识别新硬盘/dev/sdb/，就开始为新硬盘分区 进入fdisk交互模式：fdisk /dev/sdb/ partprobe 分完区后必须执行这个命令，重新读取分区表信息 然后格式化分区 mkfs -t ext4 /dev/sdb1 mkfs -t ext4 /dev/sdb5 最后创建挂载点并挂载 mkdir /disk1 mkdir /disk5 mount /dev/sdb1 /disk1/ mount /dev/sdb1 /disk5/ fdisk -l：查看，两个分区挂载完毕 分区自动挂载和/etc/fstab文件修复 上面的mount命令挂载只能临时生效，每次重启都要手动挂载硬盘，要想永久生效，就要修改/etc/fstab配置文件的内容。 添加了挂载信息后，执行mount -a，依据配置文件/etc/fstab中的内容，自动挂载 万一/etc/fstab文件写错了，会导致系统崩溃 /etc/fstab文件修复 出错后按提示进入root操作界面，发现/etc/fstab文件是只读 执行：mount -o remount,rw / 就可以修改/etc/fstab文件了，就可以修复了。 分配swap分区 free 查看内存与swap分区使用状况 新建swap分区 fdisk /dev/sdb 进入分区交互模式 记得修改分区ID号为82 使用t修改分区ID号 l：查看分区类型 partprobe mkswap /dev/sdb6 格式化 swapon /dev/sdb6 加入swap分区 swapoff /dev/sdb6 取消swap分区 swap分区开机自动挂载 Shell Shell基础 Shell概述 shell就是Linux中的命令解释器，说白了，就是一个命令行的交互界面。 与Linux不同Windows中就是图形的交互界面。 shell还是一个强大的编程语言，因为它可以直接调用Linux的系统命令。 Shell的种类： Bourne Shell语法类：sh，ksh，Bash，psh，zsh C Shell语法类（只要同于BSD的Linux版本中）：csh，tcsh Bash Shell：Bash与sh兼容，是目前的主流 在文件/etc/shells中，可以查看Linux中默认支持的Shell类型，在命令行下输入shell的名字就可以切换shell类型 Shell脚本的执行方式 echo 输出指定内容：echo [选项] [输出内容] echo -e：支持反斜线的字符转换 支持颜色输出 First Script # ！bin/bash：表示以下代码为shell 执行方法 第一种： chmod 755 hello.sh ./hello.sh 第二种： bash hello.sh 注意：如果一个shell脚本在Windows中编辑完成，在Linux中发现运行出错，这是因为Windows和Linux格式不同，你可以用cat -A [文件名] 来验证，换行符不同。解决方法就是用命令dos2unix将Windows格式转化为Linux格式 Bash的基本功能 历史命令与命令补全 history 历史命令：history [选项] [历史命令保存文件] history n：显示最近的n条命令 history -d n：删除第n条命令 history -c：清空历史命令 history -w：把缓存中的历史命令写入每个用户的缓存文件~/.bash_history 历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改 使用 使用上，下箭头的方式调用历史命令， 使用“!n”重复执行第n条历史命令 使用“!!”重复执行上一条命令 使用“!字符串”重复执行最后一条以该字符串开头的命令 命令与文件补全 在Bash中，命令与文件补全是非常方便与实用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全 命令别名与常用快捷键 命令别名 alias 查询命令别名，实际就是查看~/.bashrc文件的内容 alias 别名=\"原命令\" 设定命令别名；For Example：alias vi='vim' unalias 删除别名：unalias 别名 命令执行的顺序： 第一顺位执行用绝对路径或相对路径的命令 第二顺位执行别名 第三顺位执行Bash的内部命令（内部命令就时用whereis找不到的Linux自带命令） 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一的命令（外部命令） 让别名永久生效：写入~/.bashrc配置文件 常用快捷键 Ctrl+下列的字母 c：强制终止当前命令 l：清屏 u：剪切光标之前的内容 k：剪切光标后的内容 y：粘贴 r：搜索历史 d：退出当前终端，相当于logout z：暂停进程，放入后台 建议别用 s：暂停屏幕输出 q：恢复屏幕输出 输入输出重定向 标准输入输出设备 键盘：/dev/stdin：标准输入：0文件描述符 显示器：/dev/sdtout：标准输出：1文件描述符 显示器：/dev/sdterr：标准错误输出：2文件描述符 输出重定向 改变输出方向，把命令的正确或者输出结果输出到指定的文件中 正确输出和错误输出同时保存进一个文件中： 以覆盖的方式： 命令 > 文件 2>&1 > ：覆盖 2>&1 ：是标准格式 命令 &> 文件 以追加的方式： 命令 >> 文件 2>&1 >> ：追加 2>>&1 ：是标准格式 命令 &>> 文件 比较简洁 把正确的输出保存进文件A，错误的输出保存进文件B： 命令 >>文件A 2>>文件B 输入重定向： 后面既可以直接加文件名，也可以将输入重定向作为输入，不过后者在结果中不会显示文件名，因为它指挥识别输入的文件内容流 wc wc [选项] [文件名]，用得不多 wc -c：统计字节数 wc -w：统计单词数 wc -l：统计行数 多命令顺序执行与管道符 多命令顺序执行 ;：两个命令都会执行 命令1;命令2 &&：命令1正确执行，命令2才会执行 命令1 && 命令2，例子：源码安装的时候，make && make install ||：命令1错误执行，命令2才会执行 命令1 || 命令2 dd命令 磁盘复制命令，和cp命令不同，dd可以复制特殊文件，分区甚至整个硬盘。主要的作用就是磁盘复制 dd if=输入文件 of=输出文件 bs=多少字节数作为一个块 count=块的个数 if=输入文件 ：指定源文件或源设备 of=输出文件：指定目标文件或目标设备 bs=字节数：指定一次输入/输出多少字节，即把这些字节看做一个数据块 count=个数：指定输入/输出多少个数据块 例子：date;dd if=/dev/zero of=/root/testfile bs=1k count=100000;date 用来显示磁盘复制的时间 命令 && echo yes || echo no shell编程里面应用判断命令是否执行成功：如果命令执行成功，输出yes，执行失败，输出no 管道符 命令1的正确输出作为命令2的操作对象：命令1 | 命令2 grep 在文件中搜索符合条件的字符串：grep [选项] \"搜索内容\" grep -i：忽略大小写 grep -n：输出行号 grep -v：反向查找 grep –color=auto：搜索出的关键字用颜色显示 netstat -an | grep ESTABLISHED 通配符与其他特殊符号 通配符 ?：匹配一个任意字符 *：匹配任何内容（0个或任意多个字符） []：匹配中括号中的任意一个 [-]：匹配中括号中范围内任意一个 [^]：逻辑非，表示匹配任意一个不是中括号内的一个字符0-9表示任意一个不是数字的字符 通配符是用来匹配文件名的，通配符通常会用来删除指定范围的文件 特殊符号 单引号中的所有符号都是符号 echo '$SHELL' 双引号中的符号可能会有特殊意义 echo \"$SHELL\" 反引号和$() 符号中的内容是系统命令 反引号：`` $()：推荐使用 echo \"$(ls)\"和echo '$(ls)' echo \"$(ls)\"：双引号输出ls查询的结果 echo '$(ls)'：单引号输出$(ls) # ：开头时注释 $：用来调用变量 \\：用来将特殊符号变成普通符号 Bash的变量 变量分类 用户自定义变量 环境变量 主要保存的是和系统操作环境相关的数据，允许新建 位置参数变量 主要用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的，是预定义变量的一种 预定义变量 是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的 变量命名规则 由字母、数字和下划线组成，但是变量名不能用数字开头 bash中，变量的默认类型都是字符串型，如果要进行数值运算，需要指定变量类型为数值型 变量用等号连接值，等号左右两侧不能有空格 变量名若有空格，需要单引号或双引号包括 变量值中可以用转义符\\让特殊字符失去特殊含义 变量值可以进行叠加，不过变量需要用双引号包括“$变量名”或${变量名}包括 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令 环境变量名建议大写 用户自定义变量 用户自定义变量（本地变量） name=”jack” 可以叠加： newname=\"$name\"yang newname=${name}yang $ 调用变量：$变量名 set 查看系统中所有的变量 unset 删除变量：unset 变量名 环境变量 本地变量只在当前的shell中生效 环境变量会在当前和这个shell的所有子shell中生效，如果把环境变量写入相关的文件，那么这个环境变量会在所有的shell中生效 用pstree可以查看shell的父子关系 export 申明普通变量为环境变量：export 变量名=变量值 env 专门查看环境变量 unset 删除变量：unset 变量名 常用系统环境变量 PATH 查找系统命令的变量 tab键补全和外部命令的查找都是根据$PATH来的 可以用变量叠加的方式把自己的命令加到$PATH中，PATH=\"$PATH\":/root/test.sh PS1 定义系统提示符的变量 echo $PS1 查看 PS1='格式' 自定义命令提示符 位置参数变量 不建议写位置参数脚本，其他人不知道各个位置参数的用处 $n：$0表示命令本身，之后就是命令行参数 $*：所有参数，把所有参数当作一个整体 $@：所有参数，把参数区别对待 $#：所有参数的个数 举例 ./test.sh 11 22 预定义变量 $?：返回上一次执行结果正确与否 $$：当前进程的PID $!：后台运行的最后一个进程的PID read 接收键盘输入：read [选项] [变量名] -p “提示信息”：在等待read输入时，输出提示信息 必须携带 -t 秒数：限定时间，指定等待时间 必须携带 -n 字符数：限定字符数，不加-n就要回车键结束 -s：隐藏输入的信息，适用于输入密码时 举例 Bash的运算 数值运算与运算符 数值运算 Linux中变量默认类型时字符串 declare 声明变量类型：declare [+/-][选项] 变量名 -：给变量设定类型属性 -i：将变量声明为整数类型 -x：将变量声明为环境变量 +：取消变量的类型属性 -p：显示指定变量的被声明的类型 举例:（四种计算格式，最常用的是第三种） aa=11；bb=22 declare -i cc=$aa+$bb cc=$(expr $aa + $bb) cc的值是aa和bb的和，注意“+”好左右两侧必须有空格 cc=$(($aa+$bb)) 双小括号：运算；单小括号：系统命令 cc=$[$aa+$bb] 运算符 越靠上的优先级越高 示例 变量测试与内容替换 需要的时候对照使用 环境变量配置文件 环境变量配置文件简介 source 不需要重新登录，让修改后的配置文件直接生效 source 配置文件 . 配置文件 `“.” 就是source的缩写，注意“.”后面有个空格` 环境变量配置文件中主要就是定义对系统的操作环境生效的系统默认环境变量，比如PATH，HISTSIZE，PS1，HOSTNAME等 主要的5个配置文件 /etc/profile：针对所有用户 /etc/profile.d/*.sh：针对所有用户 ~/.bash_profile：针对单个用户 ~/.bashrc：针对单个用户 /etc/bashrc：针对所有用户 环境变量配置文件作用 环境变量配置文件调用的顺序 /etc/profile：针对所有用户 USER变量 LOGNAME变量 MAIL变量 PATH变量 HOSTNAME变量 HISTNAME变量 HISTSIZE变量 umask 调用/etc/profile.d/*.sh文件 /etc/profile.d/*.sh：针对所有用户 执行profile.d目录下所有sh文件 ~/.bash_profile：针对单个用户 追加PATH：在PATH变量后面加上了:$HOME/bin这个目录 调用~/.bashrc ~/.bashrc：针对单个用户 定义别名 /etc/bashrc：针对所有用户 定义别名和PS1（登录提示符） 会重复调用PATH，umask啥的，但是只针对no login shell的情况，就是直接敲sh进入一个shell的情况 其他配置文件和登录信息 注销时的配置文件：~/.bash_logout 可以清空一些环境变量等 历史命令的保存文件：~/.bash_history 排错依据 登录信息 本地终端欢迎信息：/etc/issue 远程终端欢迎信息：/etc/issue.net 转义符在该文件中不能使用，只能纯文本登录 是否生效由ssh的配置文件/etc/ssh/sshd/config决定，要加入Banner /etc/issue.net，重启ssh服务生效：service sshd restart 登陆后的欢迎信息：/etc/motd（本地和远程都适用） 推荐特效字符定制网站ASCII Generator Shell编程 基础正则表达式 正则表达式和通配符区别 通配符：在系统中搜索匹配文件名，是完全匹配。支持命令ls，find，cp，他们不认识正则表达式 正则表达式：用来在文件中匹配符合条件的字符串，是包含匹配。支持命令：grep，awk，sed *：前一个字符匹配0次或者任意多次 .：匹配任意一个字符（换行符除外） ^：匹配以后面字符作为行首的行 $：匹配以后面字符作为行尾的行 ^$：匹配空白行 []：匹配中括号中的指定的任意一个字符 ：匹配除中括号中的字符外的任意一个字符 \\：转义符 {n}：表示其前面的字符恰好出现n次 {n,}：表示其前面的字符出现不少于n次 {n,m}：表示其前面的字符至少出现n次，最多出现m次 字符截取命令 grep 提取符合条件的行 -c：只输出匹配行的计数 -i：不区分大小写 -v：显示不包含匹配文本的所有行 cut 提取符合条件的列：cut [选项] 文件名 -f 列号：提取第几列 -d 分隔符：按照指定分隔符分割列，默认是制表符tab 示例 cat/etc/passwd | grep /bin/bash | grep -v root | cut -d \":\" -f 1：用来提取出普通用户名 df -h | grep \"sda5\" | cut -f 5：用来提取硬盘的使用率 如果是空格，则不能很好使用，需要更复杂的awk命令 printf 按找类型输出格式输出内容，使用awk时格式化输出：printf \"输出类型输出格式\" 输出内容 %ns：输出字符串 n是数字代指输出几个字符 %ni：输出整数 n是数字代指输出几个数字 %m.nf：输出浮点数 m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。 \\n，\\r，\\t：换行，回车，tab键 printf '%s %s %s' 1 2 3 4 5 6：最后输出结果按照%s %s %s格式分为两组 printf命令不能用管道符，只能printf %s $(cat XXX.txt) 在awk命令的输出中支持print和printf命令 print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令） printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符 awk 截取列： cut可以截取字符时，使用cut，否则使用awk 很强大的命令，可以说是一门编程语言 格式：awk ’条件1{动作1} 条件2{动作2} 条件3{动作3}‘ 文件名 前面可以加管道符 动作 格式化输出：printf 流程控制语句 示例 awk ‘{printf $2 “\\t” $6 “\\n”}’ XXX.txt df -h | awk '{printf $1 \"\\t\" $5 \"\\t\" $6}'：可以处理空格，弥补了cut的不足，但是awk很多命令很复杂 df -h | grep sda5 | awk ’{print $5}‘ | cut -d \"%\" -f 1 print可以在awk里面使用默认结尾加个换行符 BEGIN：在所有命令执行之前先执行BEGIN后面的语句块,awk默认是先读入一行再执行后面的语句 END：在所有语句处理完后执行 FS：指定分隔符，awk ’{FS=\":\"}‘ awk ‘{FS=\":\"} {print $1 \"\\t\" $3}’ /etc/passwd awk ‘BEGIN{FS=\":\"} {print $1 \"\\t\" $3}’ /etc/passwd awk还支持条件判断：awk ’$6>=87 {printf $2 \"\\n\"}‘： sed 数据的流编辑器，主要是用来将数据进行选取、替换、删除、新增的命令 vim只能修改文件，sed还可以直接修改管道符传过来的流 格式：sed [选项] ‘[动作]’ 文件名 选项： -n：sed默认把所有数据都输出到屏幕，加上-n表示只把经过sed修改过后的行输出到屏幕 -e：允许对输入数据应用多条sed命令编辑 -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出 会改变源文件，比较危险，不建议使用 动作： a：行后追加（多行时，行尾要加\\） sed ‘2a hello’ XXX.txt c：替换（多行时，行尾要加\\） sed ‘4c no the line’ XXX.txt：替换第二行 i：行前插入（多行时，行尾要加\\） sed ‘2i hello \\ world’ XXX.txt：在第二行前面插入 d：删除 sed ‘2,4d’ XXX.txt：删除第二行（没加-i选项不会修改源文件，只是删除输出的结果） p：打印 sed ‘2p’ XXX.txt：打印第二行 s：字串替换 sed ‘4s old/new/g’ XXX.txt：替换第四行的旧字符串替换为新字符串 字符处理命令 sort 排序（可接收管道符数据）：sort [选项] 文件名 -f：忽略大小写 -r：反向排序 -t ：指定分隔符，默认分隔符是制表符 -n：按照数值大小来排，默认使用字符串型排序 -k n[,m]：按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾） wc： 统计字符（可接收管道符数据）：wc [选项] 文件名 -l：只统计行数 -c：只统计字符数 -w：只统计单词数 条件判断 两种判断格式 test -e XXX.txt [ -e XXX.txt ]：注意首尾各有一个空格 shell中常用 示例 [ -d /root ] && echo \"yes\" || echo \"no\"：如果是目录yes，否则no 按照文件类型判断 -e：判断文件是否存在（存在为真） -b：判断文件是否存在，并且是否是块设备文件 -c：判断文件是否存在，并且是否是字符设备文件 -d：判断文件是否存在，并且是否是目录文件 -f：判断文件是否存在，并且是否是普通文件 -L：判断文件是否存在，并且是否是链接文件 -p：判断文件是否存在，并且是否是管道文件 -S：判断文件是否存在，并且是否是套接字文件 -s：判断文件是否存在，并且是否是非空 按照文件权限进行判断 -r：判断文件是否存在，并且是否该文件有读权限，u，g，o中任意一个有都为真 -w：判断文件是否存在，并且是否该文件有写权限，u，g，o中任意一个有都为真 -x：判断文件是否存在，并且是否该文件有执行权限，u，g，o中任意一个有都为真 -u：判断文件是否存在，并且是否该文件有SUID权限，u，g，o中任意一个有都为真 -g：判断文件是否存在，并且是否该文件有SGID权限，u，g，o中任意一个有都为真 -k：判断文件是否存在，并且是否该文件有SBIT权限，u，g，o中任意一个有都为真 两个文件之间进行比较 文件1 -nt 文件2：判断文件1的修改时间是否比文件2新 文件1 -ot 文件2：判断文件1的修改时间是否比文件2旧 文件1 -ef 文件2：判断文件1的inode号是否和文件2一致，可以用来判断两个文件是不是互为硬链接 两个整数之间比较 整数1 -eq 整数2：相等 整数1 -ne 整数2：不等 整数1 -gt 整数2：大于 整数1 -lt 整数2：小于 整数1 -ge 整数2：大于等于 整数1 -le 整数2：小于等于 示例：[ 3 -lt 2 ] && echo yes || echo no 字符串的判断 -z：判断是否为空 判断变量是否为空：[ -z \"$name\" ] && echo yes || echo no -n：判断是否为非空 字串1 == 字串2：判断是否相等 字串1 != 字串2：判断是否不等 多重条件判断 判断1 -a 判断2：逻辑与 示例： aa = 10 [ -n \"$aa\" -a \"$aa\" -gt 9 ] && echo yes || echo no 判断1 -o 判断2：逻辑或 ! 判断：逻辑非 注意!后面有空格 流程判断 if语句 和[-d /root] && echo \"yes\" || echo \"no\"作用一样，但更直观 单分支if 实例 双分支if 多分支if case语句 for循环 第一种语法 示例 第二种语法 示例 while循环和until编程 while循环 示例 until循环 示例 Linux的服务管理 服务简介与分类 Linux服务分类 RPM包默认安装的服务 独立的服务 基于xinetd（超级守护进程）服务 源码包安装的服务（第三方源码包） 服务的启动与自启动 查询已安装的服务 RPM包安装的服务：chkconfig --list 查看RPM包安装的服务按照运行级别的自启动状态。 查看是否在系统下次启动时自启动，而不是查看服务是否当前已启动 查询当前启动的服务 ps aux netstat service --status-all 源码包安装的服务：没有命令，只能去服务安装位置查看，一般在/usr/local/下 其实源码包和RPM包安装的服务在Linux中的区别就是安装位置不同 源码包安装在指定位置，一般是/usr/local/下 RPM包安装在默认位置中，配置文件在/etc/下，启动命令在/etc/rc.d/init.d/下，分散到很多文件夹下 RPM包安装服务的管理 RPM包安装的服务默认保存位置：(特殊文件有自己的默认保存位置) 独立服务的管理 启动方式 /etc/init.d/ 独立服务名 start | stop | status | restart 推荐使用 service 独立服务名 start | stop | restart | status rea hat独有，service 相当于/etc/inin.d 自启动方式 方式一：打开自启动：chkconfig [--level 运行级别] [独立服务名] on 不支持源码包安装的服务 关闭自启动：chkconfig 独立服务名 off 默认就是：2345 方式二：修改/etc/rc.d/rc.local文件，加入需要自启动的服务名 推荐 方式三：使用ntsysv命令管理自启动，图形界面很直观 red hat专有 基于xinetd(超级守护进程)服务的管理 默认情况下Linux是没有xinted的，需要手动安装yum -y install xinetd 然后用chkconfig --list查看，基于xinetd的服务不占用内存，但是需要的响应时间更长 基于xinetd的服务的启动，修改/etc/xinetd.d/下对应的服务的配置文件,然后service xinetd restart 基于xinetd的服务的自启动： chkconfig 服务名 on和chkconfig 服务名 off 图形界面工具：ntsysv 基于xinetd的启动和自启动是通用的，两者区分不是很严格，这种设置不利于管理，所以现在基于xinetd的服务越来越少了 自启动关闭，服务也会关闭，2者相通 源码包安装服务的管理 源码包安装的服务默认保存位置：/usr/local/ 源码包安装服务的启动和关闭(用绝对路径的启动脚本启动)：/usr/local/apache2/bin/apachectl start|stop 一般每一个源码包都有安装说明INSTALL，应该查看里面的启动方法 源码包安装服务的自启动： vim /etc/rc.d/rc.local加入/usr/local/apache2/bin/apachectl start 把源码包服务的启动脚本软连接到/etc/init.d/目录下和chkconfig --add 服务名，就可以实现service，chkconfig和ntsysv命令管理源码包安装服务，但是并不推荐，容易混乱。 总结 Linux系统管理 进程管理 进程管理的作用：（下面优先级由高到低） 判断服务器的健康状态（CPU、内存的占用情况） 常用命令：top 查看系统中的所有进程 命令：ps aux 和 ps -el 和 pstree 杀死进程 不常用，尽可能正常操作结束服务，不能正常关闭时再用 进程查看 ps aux 查看系统中所有进程，查看BSD操作系统格式 ps -le 查看系统中所有进程，Linux格式 输出格式的作用 ps aux top 查看系统健康状态：top [选项] 需要的时候使用，top命令比较耗资源 -d 秒数：默认每3秒更新一次，可指定 ？或h：显示交互模式的帮助 P：以CPU使用率排序，默认选项 M：以内存使用率排序 N：以PID排序 q：退出top top命令的显示 重点关注最后一个平均负载(除以 Cpu 核数，如果大于 1.5，表示超出负荷，小于 1.5 基本正常) 重点关注第4个CPU的空闲率 重点关注第3个内存的空闲率 pstree 查看进程树：pstree [选项] -p：显示进程的PID -u：显示进程的所属用户 进程终止 正常命令不能终止服务时才使用 kill kill [信号] PID -l：查看kill支持的信号 小写l -1 PID：重启进程 -9 PID：终止进程 killall 按照进程名杀死，选项和kill通用：killall [选项] [信号] 进程名 -i：有询问 -I：忽略进程名的大小写 大写的i pkill 按照进程名杀死，选项和kill通用：pkill [选项] [信号] 进程名 也可以加t选项跟终端号：pkill -t 终端号：按照终端号踢出用户，用 w 命令查询系统中登录的用户，然后用终端号来踢 工作管理 类似Windows的最小化 把进程放入后台 命令后面加&：后台继续运行 在命令执行过程中，按下ctrl+z快捷键：放入后台即暂停 jobs 查看后台的工作：jobs [-l] -l：显示工作的PID 注意：“+”号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作；“-”号代表倒数第二个放入后台的工作。 fg 恢复后台暂停的工作恢复到前台运行：fg %工作号 %工作号：%号可以省略，但是注意工作号和PID的区别 bg 恢复后台暂停的工作恢复到后台运行：bg %工作号 %工作号：%号可以省略，但是注意工作号和PID的区别 但是不能恢复和前台有交互的命令比如top命令和vim命令，因为就是给用户展示，后台运行没意义 注意：工作号≠PID 系统资源查看 vmstat 监视系统资源使用情况： vmstat [刷新延时(s) 刷新次数] 和top内容差不多，但更简洁 dmesg 开机时内核检测，一般结合grep使用 free 查看内存使用情况：free [选项] -b：以字节为单位显示 -k：以KB为单位显示（默认就是） -m：以MB为单位显示 -g：以GB为单位显示 查看CPU信息： cat /proc/cupinfo：每次开机都会更新 dmesg | grep CPU uptime：实际就是top命令第一行，跟w看到的一样 uname 查看系统与内核相关信息：uname [选项] -a：查看系统所有相关信息 -r：查看内核版本 -s：查看内核名称 file /bin/ls 判断当前系统的位数（通过系统外部命令的位数来推测） lsb_release -a 查询Linux系统的发行版本 lsof 列出进程打开或使用的文件信息：lsof [选项] -s 字符串：只列出以字符串开头的进程打开的文件 -u 用户名：只列出某个用户的进程打开的文件 -p pid：列出某个PID进程打开的文件 系统定时任务 前提：必须启动crond服务：service crond restart，并且chkconfig crond on，Linux系统都是默认启动和自启动的 crontab 设置系统定时任务：crontab [选项] -e：编辑crontab定时任务 打开文件编辑的格式是： * command或执行脚本 第一个*：分钟（0-59） 第二个*：小时（0-23） 第三个*：天（1-31） 第四个*：月（1-12） 第五个*：星期（0-7，0和7都代表星期日） 特殊符号： 示例 定期脚本里面的日期输出需要加“\\”转义符，原本：date +%y%m%d，定时任务里的脚本：date +\\%y\\%m\\%d -l：查询crontab任务 -r：删除当前用户所有的crontab任务 删一个任务，进去编辑删除需要删除的任务（vim操作） Linux日志管理 日志管理简介 百度百科简介：系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。 服务器出现问题先查看日志，才能找准原因 CentOS7中原来的日志服务syslogd被rsyslogd取代，两者兼容 确认服务是否启动和自启动： ps aux | grep rsyslogd chkconfig --list | grep rsylog 常见的日志的作用 RPM包安装的服务日志也会在/var/log/目录下 源码包安装的服务日志在源码包指定目录（一般是/usr/local）中，这些日志不是有rsyslogd服务来管理的，而是由各个服务使用自己的日志管理文档来记录自身日志 你安装了这些服务就会有 rsyslogd日志服务 日志文件格式 事件产生的时间 产生事件的服务器的主机名 产生事件的服务名或程序名 事件的具体信息 /etc/rsyslog.conf配置文件 格式 * authpriv.* /var/log/secure * 服务名称 [连接符号] 日志等级 日志记录位置 `authpriv：服务名称 .：连接符号 *：日志等级` * 服务名称，连接符，日志等级，日志记录位置都有多个，内容很多，自行百度。 常见的服务 连接符号 “*”不是连接符号，是所有日志等级 日志等级 从低等级到高等级（上到下） 日志记录位置 日志轮替 如果日志都记录在一个文件中，那么可能会占据大量存储空间，纯文本文档打开会非常慢，所以日志需要处理：切割（把大日志按天切割成小的）+轮换（删除旧的，保存新的） 日志文件的命名规则 如果配置文件中有“dateext”参数，那么日志会用日期作为后缀，例如：“secure-20200603”，只需要保存指定的日志个数，删除多余的日志文件即可 推荐使用 如果没有“dateext”参数，那么日志文件就需要改名了，当第一次使用日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志。第二次时，1变2，0变1，又新建0，以此类推 配置文件 /etc/logrotate.conf 只要是RPM包安装的服务，它默认已经支持轮替，但是源码包安装的服务需要vim /etc/logrotate.conf，然后手动加入轮替 示例 logrotate logrotate [选项] 配置文件名 如果此命令没有选项，则会按照配置文件中的条件进行日志轮替 logrotate -v /etc/logrotate.conf：显示日志轮替过程 logrotate -f /etc/logrotate.conf：强制轮替，不管日志轮替的条件是否已经满足 Linux启动管理 CentOS 6.x的启动管理 运行级别：7个级别 runlevel：查看运行级别 init 运行级别：改变当前运行级别 vim /etc/inittab：永久修改系统默认运行级别，写上id:3:initdefault 不要把0和6设为默认级别 CentOS6系统启动过程：针对MBR模式 initramfs内存文件系统 CentOS 6.x中使用initramfs内存文件系统去嗲了Centos5.x中的initrd RAM Disk。他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的的内核模块，比如USB、SATA、SCSI硬盘的驱动和LVM、PAID文件系统的驱动 查看 不能在boot目录下做操作 调用/etc/init/rcS.conf配置文件 主要功能是两个 先调用/etc/rc.d/rc.sysinit，然后又/etc/rc.d/rc.sysinit配置文件进行Linux系统初始化 然后再调用/etc/inittab，然后由/etc/inittab配置文件确定系统的默认运行级别 调用/etc/rc.d/rc文件 启动引导程序grub Grub配置文件：/boot/grub/grub.conf 格式： default=0： 默认启动第一个系统 timeout=5： 等待时间，默认是5秒 splashimage=(hd0,0)/grub/splash.xpm.gz：指定grub启动时的背景图像文件的保存位置 hiddenmenu： 隐藏菜单 title CentOS(2.6.32-279.el6.i686)： 标题 root (hd0,0)： 指启动程序的保存分区 kernel /vmlinuz-2.6.32-279.el6.i686 ro： 定义了内核加载时的选项 initrd /initramfs-2.6.32-279.el6.i686.img： initramfs内存文件系统镜像文件的所在位置 系统修复模式 单用户模式常见的错误修复 遗忘root密码 修改系统默认运行级别 光盘修复模式 这些是后门，说的Linux针对的是网络安全 Linux备份与恢复 备份概述 Linux中需要备份的数据：/root/目录，/home/目录，/var/spool/mail/目录，/etc/目录，其他目录 安装的服务的数据也需要备份 apache需要备份的数据：配置文件，网页主目录，日志文件 mysql需要备份的数据 源码包安装的：/usr/local/mysql/data/ RPM包安装的：/var/lib/mysql 备份策略 完全备份：效果最高，但需要更大的硬盘空间 增量备份：每次备份只备份新的数据，占用空间少，但是恢复起来麻烦 差异备份：每次备份都只备份完全备份中不存在的，折中方法 备份命令 完全备份完全可以用tar打包压缩来做，但是如果是差异备份就会非常麻烦，这时就需要用到Linux为数据备份量是打造的备份和恢复命令dump命令和restore命令 dump dump [选项] 备份之后的文件名 原文件名或目录 -级别：0到9个备份级别 0是完全备份，1就是第一次增量备份，以此类推9就是第9次增量备份 -f 文件名：指定备份之后的文件名 -u：把备份时间记录在/etc/dumpdates文件中 -v：显示备份过程 -j：把备份文件压缩为.bz2格式 -W：查看详情，显示允许被dump的分区的备份等级及备份时间 注意：dump命令只有在备份分区的时候才能增量备份，备份普通目录或文件只能完全备份 示例 restore restore [模式选项] [选项] 四个模式 不能混用 -C：比较备份数据和实际数据的变化 -i：交互模式，手工选择需要恢复的文件 -t：查看模式，用于查看备份文件中拥有哪些数据 -r：还原模式，用于数据还原 一个选项 -f：指定备份文件的文件名 "},"Linux/基础/01-Linux系统简介.html":{"url":"Linux/基础/01-Linux系统简介.html","title":"Linux系统简介","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux系统简介 UNIX和Linux发展史 1965年，贝尔实验室：MULTICS计划 69年，贝尔实验室的肯汤普森：为了游戏开发UNICS/UNIX系统 62年，美国军方：ARPA：阿帕网，NCP协议——》TCP/IP协议 71年，可汤普森和丹尼斯里奇发明C语言，重写UNIX UNIX主要发行版本：AIX(IBM)、HP-UX(HP)、Solaris(Sun)、Linux(Intel,AMD……)、BSD 1991年，芬兰大学生Linus Torvalds开发linux内核。大学教授开发minix，但是不接受外来代码，所以李纳斯独自开发，由社区共同维护。 Linux内核版本号：主版本.次版本.末版本 linux内核官网 Linux发行版本：两大派系redhat和debian 开源软件简介 商业软件和开源软件（开源≠免费） 开源软件：apache、NGINX、MySQL、php、mongoDB、python、Ruby、Perl、Go、Rust、Swift、Java 开源软件的特点：使用自由（绝大多数免费）、研究自由（源代码）、散步和改良的自由 支撑互联网的开源技术（LAMP）：Linux，Apache，MySQL，PHP Linux应用领域 基于Linux的企业服务器 踩点网站：发数据包根据相应嗅探服务器 世界前500服务器 嵌入式应用 手机，平板：Android底层是Linux 智能家电，航空系统，银行系统…… 在电影娱乐业 特效，图形处理渲染 Linux学习方法 Linux只考虑应用性和稳定性 善于观察提示信息，查找文档，自己解决问题 学习英文：Command not found和No Such file or directory 忘掉Windows的操作习惯 计划，专注，坚持，练习 "},"Linux/基础/02-Linux系统安装.html":{"url":"Linux/基础/02-Linux系统安装.html","title":"Linux系统安装","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux系统安装 VMware虚拟机安装 VMware官网下载，不推荐安装双系统 特点： 不需要分区就能在物理机上使用两种以上的操作系统 物理机和虚拟机能实现网络通信 可以设定并随时修改虚拟机操作系统的硬件环境 要求： CPU：主频1GHz以上 内存：1GB以上 硬盘：8GB以上 镜像下载：官网下载: 几个版本：DVD版本，Everything版本，minimal版本，LiveGnome版本，KdeLive版本，livecd版本，NetInstall版本 系统分区 主分区：最多只能有4个 扩展分区：最多只能有一个；主分区加扩展分区最多有4个；不能写入数据，只能包含逻辑分区 逻辑分区：可以和主分区一样正确的写入数据和格式化 注意：兄弟连这套视频录制时间较为久远，当时的硬盘分区形式是MBR的，所以上述的分区限制也只 是针对MBR分区形式，对于GPT分区形式而言，则没有上述限制了。 电脑根据主板的不同（BOIS或者UEFI），会决定硬盘选择MBR分区方案还是GPT分区方案： BIOS + MBR UEFI + GPT 两者区别： 也就是说，电脑使用传统BIOS主板，建议使用MBR分区方案；电脑使用UEFI主板，建议使用GPT分区方案 MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。 MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。 在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。 硬盘分区的作用： 把一块大硬盘分成几块 格式化的作用： 写入文件系统（1.把硬盘分成一个个等大小的数据块 同时2.建立一个inode列表） Linux中的所有硬件都是文件： 硬盘文件名： IDE硬盘：/dev/hd[a-d] SCSI/SATA/USB硬盘：/dev/sd[a-p] 光驱：/dev/cdrom或/dev/sr0 鼠标：/dev/mouse 分区文件名： /dev/hda[数字] /dev/sda[数字] 挂载： 给分区分配挂载点 /根分区 swap交换分区（内存两倍，最大不超多2GB） /boot启动分区（200MB足够） 总结： 分区：把大硬盘分为小的分区 格式化：写入文件系统，同时会清空数据 分区设备文件名：给每个分区定义设备文件名 挂在：给每个分区分配挂载点，这个挂在点必须是空目录 Linux系统安装 把镜像加进去，点击启动，然后用图形界面配置分区和其他的自定义选项，确定定义root用户的密码和普通用户的账号和密码。然后等待安装完成即可。 远程登陆管理工具 三种网络连接方式： 桥接模式：虚拟机使用物理网卡 NAT模式：虚拟机使用vmnet8虚拟网卡 Host-only模式：虚拟机使用vmnet1虚拟网卡，并且只能和本机通信 临时配置ip：ifconfig ens33 192.168.XXX.XXX 永久配置ip： 查看网络接口：ifconfig 去网络接口的配置文件进行修改 [root@bogon ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33/ ens33是网卡接口 配置文件 TYPE=“Ethernet” PROXY_METHOD=“none” BROWSER_ONLY=“no” BOOTPROTO=“none” //dhcp是自动获取 DEFROUTE=“yes” IPV4_FAILURE_FATAL=“no” IPV6INIT=“yes” IPV6_AUTOCONF=“yes” IPV6_DEFROUTE=“yes” IPV6_FAILURE_FATAL=“no” IPV6_ADDR_GEN_MODE=“stable-privacy” NAME=“ens33” UUID=“d8ee940a-1a27-4417-9ae8-88a5364ee4d1” DEVICE=“ens33” ONBOOT=“yes” //引导激活 IPADDR=172.16.10.188 //ip地址 NETMASK=255.255.255.0 //子网掩码 GATEWAY=172.16.10.254 //网关 DNS1=222.88.88.88 //DNS "},"Linux/基础/03-Linux使用注意事项-新手必看.html":{"url":"Linux/基础/03-Linux使用注意事项-新手必看.html","title":"Linux使用注意事项","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux使用注意事项（新手必看） Linux 严格区分大小写 和 Windows 不同，Linux 是严格区分大小写的，包括文件名和目录名、命令、命令选项、配置文件设置选项等。 例如，Windows 系统桌面上有一个名为 Demo 的文件夹，当我们在桌面上再新建一个名为 demo 的文件夹时，系统会提示文件夹命名冲突；而 Linux 系统不会，Linux 系统认为 Demo 文件和 demo 文件不是同一个文件，因此在 Linux 系统中，Demo 文件和 demo 文件可以位于同一目录下。 因此，初学者在操作 Linux 系统时要注意区分大小写的不同。 Linux 中所有内容（包括硬件设备）以文件形式保存 Linux 中所有内容都是以文件的形式保存和管理的（硬件设备也是文件），这和 Windows 完全不同，Windows 是通过设备管理器来管理硬件的。比如说，Linux 的设备文件保存在 /dev/ 目录中，硬盘文件是 /dev/sd[a-p]，光盘文件是 /dev/hdc 等。 Linux 不靠扩展名区分文件类型 我们都知道，Windows 是依赖扩展名区分文件类型的，比如，\".txt\" 是文本文件、\".exe\" 是执行文件、\".ini\" 是配置文件、\".mp4\" 是小电影等。但 Linux 不是。 Linux 系统通过权限位标识来确定文件类型，且文件类型的种类也不像 Windows 下那么多，常见的文件类型只有普通文件、目录、链接文件、块设备文件、字符设备文件等几种。Linux 的可执行文件不过就是普通文件被赋予了可执行权限而已。 Linux 中的一些特殊文件还是要求写 \"扩展名\" 的，但大家小心，并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有以下几种： 压缩包：Linux 下常见的压缩文件名有 .gz、.bz2、.zip、.tar.gz、.tar.bz2、.tgz 等。为什么压缩包一定要写扩展名呢？很简单，如果不写清楚扩展名，那么管理员不容易判断压缩包的格式，虽然有命令可以帮助判断，但是直观一点更加方便。另外，就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用。 二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有的 RPM 包都用\".rpm\"扩展名结尾，目的同样是让管理员一目了然。 程序文件：Shell 脚本一般用 \".sh\" 扩展名结尾，其他还有用 \".c\" 扩展名结尾的 C 语言文件等。 网页文件：网页文件一般使用 \"*.php\" 等结尾，不过这是网页服务器的要求，而不是 Linux 的要求。 在此不一一列举了，还有如日常使用较多的图片文件、视频文件、Office 文件等，也是如此。 Linux中所有存储设备都必须在挂载之后才能使用 Linux 中所有的存储设备都有自己的设备文件名，这些设备文件必须在挂载之后才能使用，包括硬盘、U 盘和光盘。 挂载其实就是给这些存储设备分配盘符，只不过 Windows 中的盘符用英文字母表示，而 Linux 中的盘符则是一个已经建立的空目录。我们把这些空目录叫作挂载点（可以理解为 Windows 的盘符），把设备文件（如 /dev/sdb）和挂载点（已经建立的空目录）连接的过程叫作挂载。这个过程是通过挂载命令实现的，具体的挂载命令后续会讲。 Windows 下的程序不能直接在 Linux 中使用 Linux 和 Windows 是不同的操作系统，两者的安装软件不能混用。例如，Windows 系统上的 QQ 软件安装包无法直接放到 Linux 上使用。 系统之间存在的这一差异，有弊也有利。弊端很明显，就是所有的软件要想安装在 Linux 系统上，必须单独开发针对 Linux 系统的版本（也可以依赖模拟器软件运行）；好处则是能感染 Windows 系统的病毒（或木马）对 Linux 无效。 "},"Linux/基础/04-Linux各目录的作用.html":{"url":"Linux/基础/04-Linux各目录的作用.html","title":"Linux各目录的作用","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux各目录的作用 /bin/：存放系统命令 /sbin/：存放系统目录，只有超级用户能用 /usr/bin/：存放系统命令，单用户模式不能执行 /usr/sbin/ ：存放系统命令，只有超级用户能用，单用户模式不能执行 /boot/ ：系统启动目录，内核和启动引导程序 /dev/ ：硬件设备文件目录 /etc/ ：linux默认的配置文件保存目录 /home/：普通用户家目录 /root/：超级用户家目录 /lib/：系统调用的函数库 /lost+found/：当系统意外崩溃时，每个分区都含有的存放的文件碎片用来修复 /media/：挂载目录，挂载媒体设备 /mnt/：挂载目录，挂载U盘，移动硬盘，和其他操作系统的分区 /misc/：挂载目录，挂载NFS服务的共享目录 /opt/：第三方安装的软件的保存目录，也可以放到 /usr/local/ 下 /proc/：存放在内存里面，存放系统的内核，进程，外部设备 /sys/：存放在内存里面，存放系统的内核相关的东西 /srv/ ：服务数据目录 /tmp/ ：临时目录，可以清空 /usr/：系统资源目录 /var/：动态资源保存目录，日志，邮件，数据库 "},"Linux/基础/05-服务器注意事项.html":{"url":"Linux/基础/05-服务器注意事项.html","title":"服务器注意事项","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb 服务器注意事项 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 远程配置防火墙（过滤不是防病毒，比如允许某个端口运行访问）时不要把自己踢出服务器 指定合理的密码规范和定期更新 合理分配权限 定期备份重要数据和日志（系统备份：etc、boot、usr等目录） "},"Linux/基础/06-Linux常用命令.html":{"url":"Linux/基础/06-Linux常用命令.html","title":"Linux常用命令","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux常用命令 文件处理命令 ls（list） ls [参数] [路径] ls -l：查看文件所有属性 ls -d：查看目录本身（而不是查看目录下的信息） ls -i：查看文件的inode号 ls -h：人性化显示（文件大小以K, M显示） ls -s：显示文件占用的块的数量 ls -a：查看隐藏文件 mkdir（make directories）创建目录：mkdir [参数] [目录] mkdir -p：递归创建目录 cd（change directories） 切换目录：cd [路径] pwd（print work directories） 查看完整工作路径 rmdir （remove empty directories） 删除空目录：rmdir [目录名] cp（copy） 复制文件或目录：cp -rp [原文件或目录] [目标目录] cp -r：复制目录 cp -p：原文件和新文件属性完全一致 注：复制的同时可以改名 mv（move） 剪切文件、改名：mv [原文件或目录] [目标目录] 注：移动的同时可以改名 rm（remove） 删除文件或目录：rm -rf [文件或目录] rm -r：文件夹递归删除（删除目录） rm -f：强制删除，不询问 注： 删除之前做好备份 误删除之后对硬盘少做读写操作 touch 创建空文件：touch [文件名] cat 显示文件内容：cat [文件名] cat -n：显示行号 tac 显示文件内容（反向查看）：tac[文件名] more 分页显示文件：空格翻页，回车换行，q退出 查看命令帮助信息时就是使用more来查看 less 分页显示文件（可向上翻页）：空格翻页，回车换行，q退出，还可以pageup回翻页，上箭头网上翻一行，还可以搜索：/关 键词，再按n搜索下一个匹配的 head 显示文件前面几行：head [参数] [文件名] head -m：指定看前几行，默认前10行 tail 显示文件后面几行：tail [参数] [文件名] tail -n：指定看后几行，默认后10行 tail -f：动态看文件动态变化 ln（link） 生成链接文件：ln [原文件] [目标文件] ln -s：生成软链接 软连接特征：类似Windows快捷方式 lrwxrwxrwx：软连接的权限不起作用，还是要看源文件权限 文件大小：很小，只是符号链接 箭头指向源文件 什么时候需要用到软连接？Windows时你什么时候需要用到快捷方式时就用 ln：生成硬链接 硬链接特征 拷贝cp -p + 同步更新：cp -p的区别是硬链接文件和原文件可以同步更新 硬链接通过inode号来区分 不能跨分区 不能针对目录 硬链接和软连接的区别 1.硬链接不能跨分区 2.硬链接不能针对目录 权限管理命令 chmod（change the permissions mode of a life） 改变文件或目录权限：chmod [参数] [文件或目录] chmod [u/g/o/a] [+/-/=] [r/w/x] u：所有者；g：所属组；a：所有人；举例：chmod u+w；chmod u+x, o-wr chmod 三位数XXX：r—4，w—2，x—1：举例：rwxr-xr-x：755 （最常用） chmod -R：递归修改目录及目录下的权限 注释：深入理解文件的wrx和目录的wrx的意义 删除一个文件的权限不是对这个文件有写权限，而是对这个文件的目录有写权限 一个目录往往都是同时有r和x权限，可进入目录和查看目录下的文件 chown（change file ownership） 改变文件或目录所有者：chown [用户名] [文件或目录]：只有管理员root能执行 例：chown root:testgroup /test/ chgrp（change file group ownership） 改变文件或目录所属组：chgrp [组名] [文件或目录]：只有管理员root能执行 注：每个文件都只有一个user和一个group，某些others拥有拥有共同的权限，这些others在一个组里，也就是group所属组。所属者user可以不在所属组group里面，并且一个用户可以在不同的组里。 相关的命令是： groupadd YYY //创建组 useradd -g YYY XXX //创建用户并将YYY设置为其主要组 usermod -g ZZZ XXX //修改用户XXX的主要组为ZZZ umask（the user file-creation mask） 显示、设置文件的缺省权限 umask -S：人性化显示默认权限，以rwx形式显示新建文件缺省权限 umask：显示掩码（非人性化） 比如：0022，权限 实际上为：777 - 022 = 755 注：Linux中，默认创建的文件是没有可执行权限的（touch 创建的文件），所以文件是666，目录是777 umask 三位数：修改掩码，使默认权限变化umask 023；中文修改户的掩码为0023，权限为：754，并不建议修改 文件搜索命令 尽量少搜索，特别是在高峰期时 find 文件精准搜索：find [搜索范围] [匹配条件] find [搜索范围] -name：根据文件名搜索 find [搜索范围] -iname：根据文件名搜索，不区分大小写 注：通配符：*，？，[] *：匹配多个字符；举例：find /ete -name init（模糊搜索，包含即可） ？：匹配单个字符；举例：find /ete -name init???（搜索以init开头后面还有3个字符的文件） find [搜索范围] -size [+/-]n： +n：大于； -n：小于，只有数据块（0.5KB）个数； n：等于 find [搜索范围] -user：根据所有者查找 find [搜索范围] -group：根据所属组查找 find [搜索范围] -amin [-/+]分钟数：查找指定时间内或者超过该时间被修改过访问时间的文件(access) find [搜索范围] -cmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件属性的文件(change) find [搜索范围] -mmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件内容的文件(modify) 还可以在两个查找条件之间加上 -a ：一个是同时满足(and) -o ：一个是满足任意一个即可(or) 或者-exec/-ok 命令 [空格] {} [空格] \\； 对搜索结果执行操作 示例：find ./ -name test.txt -exec ls -l {} \\; -ok：是对后面的命令逐个询问 find [搜索范围] -type：根据文件类型查找 find [搜索范围] -inum：根据inode号查找 locate 模糊查找：locate 文件名 系统里所有的文件都会定期收录到/var/lib/mlocate.db这个文件库里，locate就是在这个里去找，但是新的文件没别收录进去，所以就找不到，需要手动更新文件资料库updatedb （但是tmp目录下不收录进去） locate -i：不区分大小写 which 查找命令的地址和别名alias：which 命令名 whereis 查找命令地址和其帮助文档的位置：whereis 命令名 grep 在文件里面查找字串匹配的行并输出：grep [-iv] [指定字串] [文件] grep -i：不区分大小写，查找指定字串所在的行 grep -v：排除指定字串所在的行 指定字串前面加个 ^ 表示以什么字串开头 帮助命令 man （manual）或 info （information） 查看命令和配置文件的帮助信息，浏览和more操作一样：man 命令名/配置文件名 帮助类型里1是命令的帮助，5是配置文件的帮助 For Example：man 1 passwd，man 5 passwd whatis 更加简单的命令查询，查看命令作用 apropos 更加简单的配置文件查询 –-help 得到信息更加简单：命令 ––help help 获得shell的内置命令的帮助，比如：cd，pwd，umask，if等 用户管理命令 useradd和passwd 新建用户和修改密码 who和w 查看当前登录用户名：tty是本地登录，pts表示远程登录 who简单信息 w 其中第一行：当前时间，已经运行的时间（服务器），多少个用户登录，服务器负载均衡（CPU，内存等负载情况）这行类型也可以 通过uptime获得 IDLE：表示用户空闲时间（多久没操作了） JCPU：累计占用的CPU时间 PCPU ：当前用户登录后占用CPU的时间 WHAT：当前执行的操作 压缩解压命令 几种压缩格式 .gz .zip .bz2 gzip（GNU zip）和 gunzip/gzip -d （GNU unzip） 压缩/解压文件：gzip/gunzip [文件] 解压缩：gunzip[文件] 或 gzip -d [文件] 只能压缩文件，不能压缩目录，并且不保留原文件 压缩文件后缀：.gz tar 打包目录：tar [选项] [压缩后文件名] [目录（可以多个空格隔开）] tar -c：打包 tar -x：解包 tar -v：显示详细信息 tar -f：指定文件名 tar -z：打包的同时压缩，或者解包的时候解压缩,适用于压缩解压gz tar -j：同-z，适用于压缩解压bz2 举例：tar -cvf XXX.tar YYY gzip XXX.tar ，最后生成XXX.tar.gz 。或者直接tar -zcvf打包压缩一部合成，反向是tar -zxvf 压缩文件后缀：.tar.gz zip和unzip 压缩文件或目录：zip [选项] [压缩后文件名] [文件或目录]，压缩比不高 压缩后能保留原文件 zip -r：压缩目录 压缩文件后缀：.zip bzip2和bunzip2 bzip2 /bunzip2 [选项] [文件] bzip2 -k：压缩的同时保留原文件 bunzip -k：解压的同时保留原文件 gzip的升级版本，压缩比较好 用tar生成.tar.bz2文件：tar -cjf xxx.tar.bz2 xxx 压缩文件后缀：.bz2 网络命令 write 给在线用户发信息，以ctrl+D保存结束：write wall （write all） 给当前在线的所有用户发送信息：wall [信息内容] ping 测试网络连通性：ping 选项 [IP地址] 网络踩点，Linux会一直ping下去 ping -c 次数：定义ping的次数 ifconfig （interface configure） 查看当前系统网卡信息和设置网卡信息（临时的）：ifconfig 网卡名称 IP地址 mail 查看和发送邮件：mail [用户名] 不一定要在线 mail 用户名：发送 mail：查看的子命令： q：退出 help(帮助)， 数字(查看指定邮件)， 列表：h(列表)， 删除：d 数字(删) last 日志查询命令，统计系统的所有登录信息： lastlog 查看用户最后登录的信息 lastlog -u uid：查看指定用户上次登录的信息 traceroute 跟踪节点的路径：traceroute ip地址 netstat 显示网络相关信息：netstat [选项] netstat -t：TCP协议（有3次握手） netstat -u：UDP协议（无3次握手，快，但是不保证数据收到） netstat -l：监听 netstat -r：路由 netstat -n：显示ip地址和端口号 最常用的三种组合命令： netstat -tlun：查看本机监听的端口 1：标志协议：TCP/UDP 2：数据包接收队列：0代表网络通畅 3：数据包发送队列：0代表网络通畅 4：本机IP地址和端口（主要查看的内容） 5：监测状态：TCP才有，UDP没有（你可以直接发送，不管在不在线，不需要监听） netstat -an：查看本机所有的网络连接 跟-tlun的区别是可以查看正在连接的服务 netstat -rn：查看本机路由表 setup redhat系linux独有 配置网络的工具：永久生效 配置玩需要重启网络服务：service network restart 挂载命令 mount mount [-t 文件系统] 设备文件名 挂载点 举例：mount -t iso9660 /dev/sr0 /mnt/cdrom /dev/sr0：设备文件名，系统默认的 umount 卸载：umount 设备文件名 关机重启命令 shutdown shutdown [选项] 时间 shutdown -h 时间（new）：关机 shutdown -r 时间：重启 shutdown -c：取消前一个关机命令 谨慎操作 其他关机命令：halt,poweroff,init 0 其他重启命令：reboot,init 6 init 系统运行级别： 0：关机， 1：单用户， 2：不含NFS服务的多用户， 3：完全多用户， 4：未分配， 5：图形界面， 6：重启 /etc/inittab配置文件里面有运行级别的信息，方便查询，也可以改运行级别 init 数字：设置系统运行级别，临时更改 runlevel：查询系统运行级别 logout和exit 都是退出登录：logout退出是把因为你注销了登陆机而把你踢出的退出，exit是你直接退出连接的机器。 "},"Linux/基础/07-强大的文本编辑器Vim.html":{"url":"Linux/基础/07-强大的文本编辑器Vim.html","title":"强大的文本编辑器Vim","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb 强大的文本编辑器:Vim 概述 Vim是linux中的一款使用最广的文本编辑器，全屏幕编辑器。 可以建立，编辑，显示文本文件。 它没有菜单只有命令. 三种模式 命令模式：输的东西都会当做命令处理 插入模式 后：a/A（行末） 前：i/I（行首） 行：o（光标下）/O（光标上）进入 退出模式：ESC键 常用操作 :set ic————搜索时不区分大小写 行号相关： :set nu————显示行号 :set nonu————关闭行号 定位相关 gg————快速定位到第一行 G————快速定位到最后一行 nG————快速定位到第n行 :n————快速定位到第n行 $————快速定位到行尾 0————快速定位到行首 删除相关 x————删除光标后字符 X————删除光标前字符 nx————删除光标后n个字符 dd————删除一行 dd————删除当前行，ndd删除当前行和下面的n-1行 dG————删除当前行到文件末尾 D————删除光标到行尾 :2,8d————删除第2行到第8行 复制粘贴替换相关 yy————复制当前行 nyy————复制当前行和下面的n-1行 p————粘贴到光标上一行 P————粘贴到光标下一行 dd/ndd 和 p/P ————剪切（删除和粘贴组合） r————替换当前字符 R————从当前位置一直往后替换（进入替换模式，esc退出模式） u————恢复 ctrl+r————撤销恢复 /string————搜索命令，按n找下一个 :%s/old/new/g————全文替换old为new :n1,n2s/old/new/g————n1到n2行替换old为new 退出保存相关 :w————保存（相当于Windows的ctrl+r） :w filename————另存为 :wq————保存并退出 ZZ————保存并退出 :q!————不保存退出 :wq!————强制保存退出，针对只读文件可以强行保存(只有文件所有者和root才可以) 使用技巧 查看命令的执行结果：:!命令 查看命令的地址：:!which 命令名 导入内容到文件中 导入文件内容：:r 导入文件地址(路径) 导入命令执行结果：:r !命令 导入命令的地址：:r !which 命令 导入当前时间：:r !date 定义快捷键 :map 快捷键（Ctrl + v + 自己想要的数字或字母） 触发命令 关键词自动替换 :ab mymail XXXXXXX@gmail.com 输入mymail是自动替换为你的邮箱地址 多行注释与取消注释 方法一 注释：Ctrl + v 行首选择多行，I（大写的i，shift + i），插入# ，ESC退出命令模式 取消注释：Ctrl + v 行首选择多行，d 方法二 :n,n+10s/^/#/g：注释n行到n+10行 :n,n+10s/^#//g：取消注释（注意行首尖叫号 ^） 所有配置都是临时的，要永久需要写入配置文件里，存放在用户的家目录下，.vimrc，如果没有的话就自己新建一个也ok "},"Linux/基础/08-Linux软件包管理.html":{"url":"Linux/基础/08-Linux软件包管理.html","title":"Linux软件包管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux软件包管理 软件包管理简介 软件包分类： 源码包：包括脚本安装包 二进制包：RPM包，系统默认包（ubuntu中是deb包），源码包编译后的包 源码包的优点 开源 可以自由选择所需的功能 软件是便宜安装，所以更加是个自己的系统，更加稳定也效率更高 卸载方便（直接把目录删除） 源码包的缺点 安装步骤多 编译并安装时间过长 因为是编译安装，安装过程中一旦报错新手很难解决 RPM包优点 包管理系统简单，只需要几个命令就可以实现软件包的安装，升级，查询和卸载 安装速度比源码包快很多 RPM包缺点 不能看见原代码 功能选择不如源码包灵活 依赖性 RPM包管理 rpm命令管理 RPM包名和包全名 RPM包的依赖性：树形依赖，环形依赖，模块依赖(以.iso.数组结束的就是模块依赖，也叫库文件依赖模块依赖查询网站) 安装和升级使用包全名，卸载和查询使用包名（在/var/lib/rpm/中的数据库总搜索） RPM安装：rpm -ivh 包全名 -i（install）：安装 -v（verbose）：显示详细信息 -h（hash）：显示进度 --nodeps：不检测依赖性（该选项不用） RPM升级：rpm -Uvh 包全名 -U（upgrade）：升级 RPM卸载：rpm -e 包名,也要考虑依赖性，当有包被依赖时，此时这个包不能删掉 -e（erase）：卸载 RPM查询包：查询包还是用RPM，yum没有查询功能 查询包是否安装：rpm -q 包名 -q（query） 查询所有安装的包：rpm -qa -a（all） RPM查询包详细信息：rpm -qi 包名 -i（information） RPM查询未安装包的详细信息：rpm -qip 包全名 -p（package） RPM查询文件安装位置：rpm -ql 包名 -l（list） RPM查询未安装包的文件安装的默认位置：rpm -qlp 包名 RPM查询系统文件属于哪个rpm包：rpm -qf 系统文件名 -f（file） RPM查询软件包的依赖性：rpm -qR 包名 -R（requires） RPM查询未安装软件包的依赖性：rpm -qRp 包全名 RPM包校验：rpm -V 包名 -V（verify） RPM包中文件提取（用来修复系统）： rpm2cpio 包全名 | cpio -idv . 包中的文件绝对路径 -i（copy-in模式）：还原 -d：还原时自动新建目录 -v：显示还原过程 yum在线管理 既可以用在线yum源文件服务器，也可以用本地光盘作为yum源文件服务器。 会自动解决依赖性问题 更换yum源：保存在/etc/yum.repos.d/目录下 查询：yum list 搜索：yum search 包名 安装：yum -y install 包名 -y（yes） 升级：yum -y update 包名 yum -y update：不写包名，直接升级全部（包括Linux内核，远程升级了的话不能开机，需要本地配置文件），慎用 卸载，会卸载所有依赖的包：yum -y remove 包名 Linux服务器应该采用最小化安装的原则，用什么装什么 装完了最好不要用yum卸载，也不要随便升级 yum的软件组管理： 查询所有可用的软件组列表：yum grouplist 安装指定软件组：yum groupinstall 软件包组名 卸载指定软件组：yum groupremove 软件包组名 用光盘做yum源：修改/etc/yum.repos.d/下的media配置文件，该源为关盘挂载点，注意：配置文件的格式要求很严格，注释应该顶头写。 源码包管理 区别： 安装前的区别：概念上的区别，见上述 安装后的区别：安装位置的区别 RPM包（一个软件）的默认安装位置： /etc/：配置文件 /usr/bin/：可执行的命令 /usr/lib/：程序所使用的函数库 /usr/share/doc/：基本的软件使用手册 /usr/share/man/：版主文档 /var/www/html/：服务器类软件的默认网页位置 源码包的安装位置： 需要手动指定安装目录：一般推荐/usr/local/软件名/ RPM包和源码包安装软件带来的影响：启动服务的方式不同 RPM包在/etc/rc.d/init.d/下有执行文件，采用两种方式启动： /etc/rc.d/init.d/httpd start service httpd start 源码包的服务启动方式不能用系统服务管理命令例如service来管理 只能在/usr/local/软件名/bin/执行软件码 start 目录下启动服务 Apache源码包的具体安装步骤： 安装C语言编译器：gcc 下载apache的源码包：path 确认源码保存位置/usr/local/src/ 确认软件安装位置：/usr/local/ 如何确认安装过程报错安装过程停止并出现error，warning，no等提示语言 解压缩下载的源码包：tar -zxvf 源码包名 进入解压缩目录：INSTALL和README时安装说明和使用说明 执行./configure --prefix=默认安装目录：编译前准备 定义需要的功能选项 检测系统环境是否符合安装要求 把定义好的的功能选项和检测系统环境的信息都写入Makefile文件（./configure过程会生成），用于后续的编译 执行make：编译 如果前两步报错，执行make clean，清空过程中生成的临时文件。 执行make install：安装 删除源码包安装的软件：直接rm -rf /usr/local/软件名/ 脚本安装包与软件包管理 脚本安装包不是独立的软件包类型，常见安装的是源码包 人为包安装过程写成额自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装 非常类似于windows下软件的安装方式 Webmin是一个基于Web的Linux系统管理界面，可以通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务。下载软件，下载后解压缩，并进入解压缩目录，执行.sh安装脚本,最后登录ip地址的自己配置的端口号进入该网站即可 如何选择包安装？ 如果对外服务，选择源码包安装，例如：Apache 如果本机使用，RPM包安装，例如：gcc编译器 "},"Linux/基础/09-Linux中的用户管理.html":{"url":"Linux/基础/09-Linux中的用户管理.html","title":"Linux中的用户管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux中的用户管理 用户配置文件 越是安全性要求高的服务器越需要对用户权限等级制度和服务器操作规范有很高的要求，linux中主要通过用户配置文件来查看和修改用户信息 主要有四个配置文件：/etc/passwd，/etc/shadow，/etc/group，/etc/gshadow /etc/passwd：用户信息文件 格式（7个字段） 用户名称； 密码标志； UID：用户ID 0：超级用户 1—499：系统用户:不能登录，不能删除 500—65535：普通用户 GID：组ID：这里是初始组ID不是附加组ID 用户说明：备注 家目录； 普通用户：/home/用户名/ 超级用户：/root/ Shell 命令解释器类型，默认是bash /etc/shadow：影子文件 是passwd的影子，默认权限：000 格式（9个字段） 用户名称； 加密密码； SHA512加密，可以暴力破解 如果密码是：“!!”和 “*”，表示没有密码，不能登录 密码最后一此修改时间；时间戳表示：使用1970年1月一日作为标准时间，每过一天时间戳加1 两次密码修改间隔（天）； 密码时效天数（-1永不失效）； 密码修改到期前的警告天数； 密码到期后的宽限天数； 账号失效时间；时间戳表示 保留字段 时间戳换算： 时间戳—>日期：date -d \"1970-01-01 16066 days\" 日期—>时间戳：echo$(($(date --date=\"2014/01/06\" +%s)/86400+1)) /etc/group&/etc/gshadow：组信息文件&组密码文件 /etc/group格式（4个字段） 组名， 组密码标志， GID， 组中附加用户 /etc/gshadow格式（4个字段） 组名， 组密码(默认没有，也不推荐使用)， 组管理员用户名， 组中附加用户 Linux中查看用户的初始组的方法：查询etc/passwd和/etc/group，两两对照查看 用户管理相关文件 用户的家目录：（会自动生成） 普通用户：/home/用户名/：权限700 超级用户：/root/：权限550 用户的邮箱： /var/spool/mail/用户名/ 用户模板目录：就是母板，新建用户会默认创建在用户家目录下 把/etc/skel/目录下的文件复制到用户家目录下 /etc/skel/ 用户管理命令 useradd 创建用户：useradd [选项] 用户名 新建一个用户实际上就是在上述六个地方生成了默认信息，所以手工修改上述六个地方就可以手工添加用户 useradd -u UID：指定自定义UID useradd -d 家目录：指定自定义家目录 useradd -c 用户说明：指定自定义用户说明 useradd -g 组名：指定自定义初始组组名 不建议修改 useradd -G 组名1,组名2：指定自定义附加组组名 useradd -s shell：指定自定义登录shell，默认是/bin/bash 用户默认值配置文件：/etc/default/useradd 和 /etc/login.defs passwd 修改用户密码：passwd [选项] 用户名 超级用户可以改任意用户密码 普通用户只能给自己设密码passwd whoami：查看当前用户 passwd -S 用户名 ：查看密码状态，就是shadow里面的信息，仅root用户可用 passwd -l 用户名 ：锁定用户，实际是在shadow中的密码前面加了“!”，仅root用户可用 passwd -u 用户名 ：解锁用户 passwd --stdin 用户名 ：使用字符串作为用户密码 例如：echo \"123\" | passwd --stdin 用户名，shell编程添加多个用户时使用 usermod 修改用户信息：usermod [选项] 用户名 usermod -u UID：修改UID usermod -c 用户说明：修改用户说明 usermod -G 组名1,组名2：修改附加组 usermod -g 组名：修改初始组（不推荐） usermod -L：锁定用户（Lock） usermod -U：解锁用户（Unlock） chage 修改用户密码状态：chage [选项] 用户名 chage -l：查询密码详细状态 chage -d 日期：修改密码最后一次更改日期 chage -m 天数：修改两次密码修改间隔 chage -M 天数：修改密码有效期 chage -W 天数：修改密码过期前警告天数 chage -I 天数：修改宽限天数 chage -E 日期：修改账号失效时间 注意：实际是对shadow文件里面的信息进行修改，chage -d 0 用户名 使用最多，把用户的修改密码时间归零，强制用户第一次登陆系统必须修改密码 userdel 删除用户：userdel [选项] 用户名 userdel -r 用户名：删除用户的同时删掉家目录 不推荐手工创建用户，但是可以手工删除用户的相关信息： etc/passwd etc/shadow etc/group etc/gshadow var/spool/mail/用户名 /home/用户名/ 手工把上面6个位置和要删除的用户的相关信息删除就可以了 id 查询用户uid，gid和附加组：id 用户名 su 用户切换：su [选项] 用户名 su - 用户名 ：连带用户的环境变量一起切换，中间减号绝对不能省去，省去就不会切换环境变量 su - root -c 命令名：不切换root，只是执行root权限才能执行的命令 用户组管理命令 groupadd 添加用户组：groupadd [选项] 组名 groupadd -g（GID）组名：指定组ID groupmod groupmod -g 新组id 旧组id groupmod -n 新组名 旧组名 尽量不修改 groupdel groupdel 组名：要想删除一个组，这个组中不允许有初始用户存在 gpasswd 把用户添入组或者从组中删除：gpasswd [选项] 组名 gpasswd -a 用户名：把用户加入组 gpasswd -a 用户名 组名 gpasswd -d 用户名：把用户从组中删除 gpasswd -d 用户名 组名 注：也可以直接在/etc/group文件里添加附加组(不推荐改初始组) 总结： Linux中用户和用户组的关系是： "},"Linux/基础/10-Linux权限管理.html":{"url":"Linux/基础/10-Linux权限管理.html","title":"Linux权限管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux权限管理 ACL权限 ACL权限的简介和开启方式 任何一个文件在一个时刻只能有一个所有者和所属组 ACL权限用来解决文件的权限身份不够用的情况 ACL权限需要分区支持： dumpe2fs -h /dev/sda5/ 查看是否支持acl选项，如果不支持。 /dev/sda5/ 为df -h 查看根分区对应的文件系统 可以临时开启：mount -o remount,acl / 重新挂载根分区，并挂载加入acl权限 或者永久开启：vim /etc/fstab，然后重启系统 在根分区的defaults后面加个：,act 慎用：任何错误都会导致挂载失败 ACL权限类似于windows的权限设置方法，就是不考虑user，group和others的权限设置，单独添加一个用户或者一个用户组对一个文件或者目录的权限 查看与设定ACL权限 getfacl 查看ACL的权限：getfacle 文件名 setfacl 设置ACL的权限：setfacl [选项 ] 文件名 setfacl -m u/g/m：用户名/组名/不写权限 文件名：设定文件的ACL权限 setfacl -m u:用户名:权限 文件名：设定文件用户的ACL权限 为用户分配ACL权限，使用“u:用户名:权限”格式 例：setfacl -m u:user1:rwx /test/ setfacl -m g:组名:不写权限 文件名：设定文件用户组的ACL权限 为组分配ACL权限，使用“g:组名:权限”格式 setfacl -x ：删除指定的ACL权限 setfacl -b ：删除所有的ACL权限 setfacl -d ：设定默认ACL权限 setfacl -k ：删除默认ACL权限 setfacl -R ：递归设定ACL权限 最大有效权限与删除ACL权限 最大有效权限mask：可以通过getfacl 文件名来查看ACL的权限，里面有mask，可以通过控制mask的值来修改默认最大有效权限。 需要注意的是mask权限不会影响当前文件所有者，只会影响ACL权限和所属组的权限 setfacl -x u/g:用户名/组名 文件名：删除文件指定的ACL权限 setfacl -b 文件名：删除文件所有ACL权限 默认ACL和递归ACL权限（只能针对目录） setfacl -m d:u/g: 用户名/组名:权限 文件名：设定父目录的默认ACL权限，父目录里所有的新建文件都会继承父目录的ACL权限 d参数就是设置默认的ACL权限 setfacl -k：删除父目录的默认ACL权限 setfacl -m [选项] -R 文件名：递归设定文件夹的ACL权限 setfacl -m u:test:rx -R 文件名 文件特殊权限 SetUID：在所有者的x位置上变成了s针对二进制文件 passwd命令拥有SetUID权限，所以普通用户能修改自己密码 四个条件缺一不可： 只有二进制文件（例如命令和脚本文件）才能设定SUID权限 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的属主身份 SUID权限只在该程序执行过程中生效，也就是身份改变旨在程序执行过程中有效 我们通常会看到4777，2777，1777的权限标识，依次是加了SUID，SGID，SBIT权限 4代表SUID 2代表SGID 1代表SBIT 设定SetUID的方法 4代表SUID chmod 4755 文件名 chmod u+s 文件名 取消SetUID的方法 chmod 755 文件名 chmod u-s 文件名 可以用chmod来赋予和删除SUID SetUID是非常危险的，一个命令只要有了s权限，例如passwd命令，普通用户就可以通过执行这个命令获得passwd的属主身份，也就是进入root权限。 比如：给vim加了SetUID后，普通用户就会有root权限，例如：修改/etc/passwd文件，非常危险。 关键目录应严格控制写权限（普通写权限，不是SetUID权限）。比如“/”、“/usr”等 用户的密码设置要严格遵守密码三原则 对系统中默认应该具有SetUID权限的文件作出备份，定时检查有没有这之外的文件被设置了SetUID权限 SetGID：在所属组的x位置上变成了s 针对二进制文件和目录 针对二进制文件，四个条件缺一不可： 只有可执行的二进制文件才能设置 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的所属组身份 SUID权限只在该程序执行过程中生效，也就是所属组身份改变旨在程序执行过程中有效 注：例如/usr/bin/locate命令 针对目录，三个条件缺一不可： 普通用户必须对此目录拥有r和x权限，才能进入该目录 普通用户在此目录中的有效组会变成此目录的所属组 若普通用户对此目录拥有w权限时，新建的文件的默认组不是文件自己的初始组，而是这个目录自己的所属组 可以用chmod来赋予和删除SGID 设定SetGID的方法 2代表SGID chmod 2755 文件名/二进制文件 chmod g+s 文件名/二进制文件 取消SetGID的方法 chmod 2755 文件名/二进制文件 chmod g-s 文件名/二进制文件 Sticky BIT(黏着位)：在其他人的x位置上变成了t 针对目录 三个条件缺一不可： 只有目录才能设定SBIT权限 普通用户必须对该目录有x和w权限 有了SBIT，普通用户即使有目录的w权限，也不能删除其他用户建立的文件 设定SBIT的方法 1代表SBIT chmod 1755 文件名 chmod o+s 文件名 取消SBIT的方法 chmod 1755 文件名 chmod o-s 文件名 需要注意的安全性： 需要定期对系统中含有SUID或者SGID权限的文件进行检查，如果有异常多出来的含有该权限的文件，如果多出来了，是一个极大的安全隐患，需要手工清除。 文件系统属性chattr权限 chattr（change file attributes on a linux file system） 格式：chattr [+-=] [选项] 文件或目录名 符号 +：增加权限 -：删除权限 =：等于某权限 选项 i： 1.对文件：不允许任何用户（包括root用户）对文件进行任何修改，只能读 2.对目录：任何用户（包括root用户）只能在目录下修改文件内容，但是不能删除和创建文件 a： 1.对文件：任何用户（包括root用户）只能对文件增加数据，但是不能删除和修改现有数据 2.对目录：任何用户（包括root用户）只能在目录中建立和修改文件里的内容，但是不能删除文件 lsattr 查看文件系统属性：lsattr 选项 文件名 lsattr -a 文件名：显示所有文件和目录 lsattr -d 文件名：若文件时目录，仅列出目录自己的属性 系统命令sudo权限 之前学的是对文件的操作权限，sudo是对系统命令的权限。 sudo权限是root把本来只能超级用户执行的命令赋予普通用户的执行 root权限先执行命令visudo命令 实际修改的是：/etc/sudoers文件 在这一行root ALL=(ALL) ALL下面添加 root ALL=(ALL) ALL 给用户 格式：用户名 被管理主机的地址 = （可使用的身份）授权命令（绝对路径） 第一个ALL：允许在命令在哪台计算机上执行 第二个ALL：把前面的用户转变成这个身份，一般不用 第三个ALL：所有命令，应该写具体权限 %wheel ALL=(ALL) ALL 给组 %组名 被管理主机的地址=（可使用的身份）授权命令 （绝对路径） 例如：jack ALL=/sbin/shutdown -r now：授权jack能重启服务器的权限 sudo -l：查看自己能用那些sudo命令 sudo：执行sudo命令：sudo [绝对路径命令] 注意：vim命令不用设置sudo给普通用户，否则会拥有root的所有权限，非常危险 "},"Linux/基础/11-Linux的文件系统管理.html":{"url":"Linux/基础/11-Linux的文件系统管理.html","title":"Linux的文件系统管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux的文件系统管理 分区和系统文件 分区类型 对于硬盘分区形式是MBR的 分区图 一： 二： 规定了：1、2、3、4只能分配给主分区（主分区最多4个），所以逻辑分区从5开始 主分区：总共最多只能分4个 扩展分区： 包含逻辑分区 只能有一个 也算作主分区的一种 主分区+扩展分区 不能存储数据和格式化 必须再分成逻辑分区才能使用 如果是IDE硬盘，Linux最多支持59个逻辑分区 如果是SCSI硬盘，Linux最多支持11个逻辑分区 对于GPT分区形式而言，没有上述限制 文件系统 Linux的文件系统可分为 ext2：是ext文件系统的升级版本，最大支持16TB的分区和最大2TB的文件（1TB=1024G=1024*1024KB） ext3：是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性，最大支持16TB的分区和最大2TB的文件（1TB=1024G=1024*1024KB） ext4：是ext3文件系统的升级版本，ext4在性能、伸缩性和可靠性方面进行了大量改进。 向下兼容EXT3 最大1EB文件文件系统和16TB文件（1EB=1024PB=1024*1024TB） 无限数量子目录 Extents连续数据块概念 多块分配 延迟分配 持久预分配 快速FSCK 日志校验 无日志模式 在线碎片整理 inode增强 默认弃用barrier等，默认CentOS 6.3的默认文件系统 swap： vfat： Windows文件系统为：FAT16、FAT32、FAT64和NTFS。而格式化的目的就是写入文件系统 文件系统常用命令 df命令，du命令，fsck命令，dumpe2fs命令 df df [选项] df -a： 显示所有分区 df -h：人性化显示。(一般用来统计系统空间大小) du du [选项] [目录或文件名] du -a：显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量 du -h ：人性化显示 du -s：弥补ls命令的不足，可以统计文件夹包括里面的内容的大小而不是单单文件夹的大小。(一般用来统计文件大小)，避免服务器高运载下使用 df和du的区别 du只是面向文件的，只会计算文件或目录占用的空间； df是从文件系统角度考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除但是程序并没有释放空间）， 所以df看到的才是真正的可以使用的空间 fsck 文件系统修复命令，不需要自己手动执行：fsck [选项] 分区设备文件名 系统会自动执行，除非需要手动去执行，否则不用管 fsck -a 分区设备文件名：不用显示用户提示，自动修复文件系统 fsck -y 分区设备文件名：自动修复，和-a作用一致，不过有些文件系统只支持-y dumpe2fs 显示磁盘状态：dumpe2fs 分区设备文件名 显示ext2、ext3、ext4文件系统的超级块和块组信息 挂载命令 将设备文件名和绑定到盘符(挂载点)上，Windows是自动，Linux默认是手动分配 mount -l：查询异已挂载的设备，加-l会显示卷标名 mount -a：依据配置文件/etc/fstab中的内容，自动挂载 mount 挂载命令格式：mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点 -t：文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统 -L：卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载 -o：特殊选项：可以制度挂载的额外选项 没特殊需求不需要加特殊选项 挂载光盘和U盘 Linux中的分区时开机自动挂载，但是光盘和U盘时手动挂载，系统准备了/mnt/和/media/来挂载 /mnt：挂载U盘 /media：挂载光盘 挂载光盘步骤 sr0和cdrom都可以作为设备文件名 建立挂载点：mkdir /mnt/cdrom/ 挂载：mount -t iso9660 /dev/cdrom /mnt/cdrom/或者mount /dev/sr0 /mnt/cdrom 设备文件名：/dev/cdrom和/dev/sr0是固定的 去挂载点访问：cd /mnt/cdrom/ 在拿走光盘之前需要先卸载光盘：umount 设备文件名或挂载点 挂载U盘步骤 U盘的设备文件名是自动识别的，用fdisk -l查看 建立挂载点：mkdir /mnt/usb/ 挂载：mount -t vfat /dev/sdb1 /mnt/usb/ /dev/sdb1：fdisk -l 查看的 去挂载点访问：cd /mnt/usb/ 在拔U盘之前需要先卸载光盘：umount 设备文件名或挂载点 注意： 挂载U盘只能用本机或者虚拟机，不能用远程工具 Linux默认是不支持NTFS文件系统的外设的，U盘只能FAT格式的 Linux如何支持NTFS文件系统 Linux系统的内核中已经把市面上常见的驱动包括了，所以安装系统后一般不需要安装驱动，Linux会自动匹配识别，如果Linux默认没有把一个文件系统的驱动加载进来，我们就需要手动去安装驱动。 几种让Linux支持NTFS文件系统的方法： 内核重新编译 第三方的插件：ntfs-3g 内核编译太麻烦，太高端，一般选择“ntfs-3g插件”来实现 安装步骤： 解压：tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz 进入解压目录：cd ntfs-3g_ntfsprogs-2013.1.13 编译前准备：./configure 编译：make 编译安装：make install 挂载NTFS分区的硬盘：mount -t ntfs-3g 设备文件名 挂载点 fdisk分区 fdisk命令分区过程 虚拟机添加新硬盘，并用fdisk -l查询新硬盘是否被识别 若已识别新硬盘/dev/sdb/，就开始为新硬盘分区 进入fdisk交互模式：fdisk /dev/sdb/ partprobe 分完区后必须执行这个命令，重新读取分区表信息 然后格式化分区 mkfs -t ext4 /dev/sdb1 mkfs -t ext4 /dev/sdb5 最后创建挂载点并挂载 mkdir /disk1 mkdir /disk5 mount /dev/sdb1 /disk1/ mount /dev/sdb1 /disk5/ fdisk -l：查看，两个分区挂载完毕 分区自动挂载和/etc/fstab文件修复 上面的mount命令挂载只能临时生效，每次重启都要手动挂载硬盘，要想永久生效，就要修改/etc/fstab配置文件的内容。 添加了挂载信息后，执行mount -a，依据配置文件/etc/fstab中的内容，自动挂载 万一/etc/fstab文件写错了，会导致系统崩溃 /etc/fstab文件修复 出错后按提示进入root操作界面，发现/etc/fstab文件是只读 执行：mount -o remount,rw / 就可以修改/etc/fstab文件了，就可以修复了。 分配swap分区 free 查看内存与swap分区使用状况 新建swap分区 fdisk /dev/sdb 进入分区交互模式 记得修改分区ID号为82 使用t修改分区ID号 l：查看分区类型 partprobe mkswap /dev/sdb6 格式化 swapon /dev/sdb6 加入swap分区 swapoff /dev/sdb6 取消swap分区 swap分区开机自动挂载 "},"Linux/基础/12-Shell.html":{"url":"Linux/基础/12-Shell.html","title":"Shell","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Shell Shell基础 Shell概述 shell就是Linux中的命令解释器，说白了，就是一个命令行的交互界面。 与Linux不同Windows中就是图形的交互界面。 shell还是一个强大的编程语言，因为它可以直接调用Linux的系统命令。 Shell的种类： Bourne Shell语法类：sh，ksh，Bash，psh，zsh C Shell语法类（只要同于BSD的Linux版本中）：csh，tcsh Bash Shell：Bash与sh兼容，是目前的主流 在文件/etc/shells中，可以查看Linux中默认支持的Shell类型，在命令行下输入shell的名字就可以切换shell类型 Shell脚本的执行方式 echo 输出指定内容：echo [选项] [输出内容] echo -e：支持反斜线的字符转换 支持颜色输出 First Script # ！bin/bash：表示以下代码为shell 执行方法 第一种： chmod 755 hello.sh ./hello.sh 第二种： bash hello.sh 注意：如果一个shell脚本在Windows中编辑完成，在Linux中发现运行出错，这是因为Windows和Linux格式不同，你可以用cat -A [文件名] 来验证，换行符不同。解决方法就是用命令dos2unix将Windows格式转化为Linux格式 Bash的基本功能 历史命令与命令补全 history 历史命令：history [选项] [历史命令保存文件] history n：显示最近的n条命令 history -d n：删除第n条命令 history -c：清空历史命令 history -w：把缓存中的历史命令写入每个用户的缓存文件~/.bash_history 历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改 使用 使用上，下箭头的方式调用历史命令， 使用“!n”重复执行第n条历史命令 使用“!!”重复执行上一条命令 使用“!字符串”重复执行最后一条以该字符串开头的命令 命令与文件补全 在Bash中，命令与文件补全是非常方便与实用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全 命令别名与常用快捷键 命令别名 alias 查询命令别名，实际就是查看~/.bashrc文件的内容 alias 别名=\"原命令\" 设定命令别名；For Example：alias vi='vim' unalias 删除别名：unalias 别名 命令执行的顺序： 第一顺位执行用绝对路径或相对路径的命令 第二顺位执行别名 第三顺位执行Bash的内部命令（内部命令就时用whereis找不到的Linux自带命令） 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一的命令（外部命令） 让别名永久生效：写入~/.bashrc配置文件 常用快捷键 Ctrl+下列的字母 c：强制终止当前命令 l：清屏 u：剪切光标之前的内容 k：剪切光标后的内容 y：粘贴 r：搜索历史 d：退出当前终端，相当于logout z：暂停进程，放入后台 建议别用 s：暂停屏幕输出 q：恢复屏幕输出 输入输出重定向 标准输入输出设备 键盘：/dev/stdin：标准输入：0文件描述符 显示器：/dev/sdtout：标准输出：1文件描述符 显示器：/dev/sdterr：标准错误输出：2文件描述符 输出重定向 改变输出方向，把命令的正确或者输出结果输出到指定的文件中 正确输出和错误输出同时保存进一个文件中： 以覆盖的方式： 命令 > 文件 2>&1 > ：覆盖 2>&1 ：是标准格式 命令 &> 文件 以追加的方式： 命令 >> 文件 2>&1 >> ：追加 2>>&1 ：是标准格式 命令 &>> 文件 比较简洁 把正确的输出保存进文件A，错误的输出保存进文件B： 命令 >>文件A 2>>文件B 输入重定向： 后面既可以直接加文件名，也可以将输入重定向作为输入，不过后者在结果中不会显示文件名，因为它指挥识别输入的文件内容流 wc wc [选项] [文件名]，用得不多 wc -c：统计字节数 wc -w：统计单词数 wc -l：统计行数 多命令顺序执行与管道符 多命令顺序执行 ;：两个命令都会执行 命令1;命令2 &&：命令1正确执行，命令2才会执行 命令1 && 命令2，例子：源码安装的时候，make && make install ||：命令1错误执行，命令2才会执行 命令1 || 命令2 dd命令 磁盘复制命令，和cp命令不同，dd可以复制特殊文件，分区甚至整个硬盘。主要的作用就是磁盘复制 dd if=输入文件 of=输出文件 bs=多少字节数作为一个块 count=块的个数 if=输入文件 ：指定源文件或源设备 of=输出文件：指定目标文件或目标设备 bs=字节数：指定一次输入/输出多少字节，即把这些字节看做一个数据块 count=个数：指定输入/输出多少个数据块 例子：date;dd if=/dev/zero of=/root/testfile bs=1k count=100000;date 用来显示磁盘复制的时间 命令 && echo yes || echo no shell编程里面应用判断命令是否执行成功：如果命令执行成功，输出yes，执行失败，输出no 管道符 命令1的正确输出作为命令2的操作对象：命令1 | 命令2 grep 在文件中搜索符合条件的字符串：grep [选项] \"搜索内容\" grep -i：忽略大小写 grep -n：输出行号 grep -v：反向查找 grep –color=auto：搜索出的关键字用颜色显示 netstat -an | grep ESTABLISHED 通配符与其他特殊符号 通配符 ?：匹配一个任意字符 *：匹配任何内容（0个或任意多个字符） []：匹配中括号中的任意一个 [-]：匹配中括号中范围内任意一个 [^]：逻辑非，表示匹配任意一个不是中括号内的一个字符0-9表示任意一个不是数字的字符 通配符是用来匹配文件名的，通配符通常会用来删除指定范围的文件 特殊符号 单引号中的所有符号都是符号 echo '$SHELL' 双引号中的符号可能会有特殊意义 echo \"$SHELL\" 反引号和$() 符号中的内容是系统命令 反引号：`` $()：推荐使用 echo \"$(ls)\"和echo '$(ls)' echo \"$(ls)\"：双引号输出ls查询的结果 echo '$(ls)'：单引号输出$(ls) # ：开头时注释 $：用来调用变量 \\：用来将特殊符号变成普通符号 Bash的变量 变量分类 用户自定义变量 环境变量 主要保存的是和系统操作环境相关的数据，允许新建 位置参数变量 主要用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的，是预定义变量的一种 预定义变量 是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的 变量命名规则 由字母、数字和下划线组成，但是变量名不能用数字开头 bash中，变量的默认类型都是字符串型，如果要进行数值运算，需要指定变量类型为数值型 变量用等号连接值，等号左右两侧不能有空格 变量名若有空格，需要单引号或双引号包括 变量值中可以用转义符\\让特殊字符失去特殊含义 变量值可以进行叠加，不过变量需要用双引号包括“$变量名”或${变量名}包括 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令 环境变量名建议大写 用户自定义变量 用户自定义变量（本地变量） name=”jack” 可以叠加： newname=\"$name\"yang newname=${name}yang $ 调用变量：$变量名 set 查看系统中所有的变量 unset 删除变量：unset 变量名 环境变量 本地变量只在当前的shell中生效 环境变量会在当前和这个shell的所有子shell中生效，如果把环境变量写入相关的文件，那么这个环境变量会在所有的shell中生效 用pstree可以查看shell的父子关系 export 申明普通变量为环境变量：export 变量名=变量值 env 专门查看环境变量 unset 删除变量：unset 变量名 常用系统环境变量 PATH 查找系统命令的变量 tab键补全和外部命令的查找都是根据$PATH来的 可以用变量叠加的方式把自己的命令加到$PATH中，PATH=\"$PATH\":/root/test.sh PS1 定义系统提示符的变量 echo $PS1 查看 PS1='格式' 自定义命令提示符 位置参数变量 不建议写位置参数脚本，其他人不知道各个位置参数的用处 $n：$0表示命令本身，之后就是命令行参数 $*：所有参数，把所有参数当作一个整体 $@：所有参数，把参数区别对待 $#：所有参数的个数 举例 ./test.sh 11 22 预定义变量 $?：返回上一次执行结果正确与否 $$：当前进程的PID $!：后台运行的最后一个进程的PID read 接收键盘输入：read [选项] [变量名] -p “提示信息”：在等待read输入时，输出提示信息 必须携带 -t 秒数：限定时间，指定等待时间 必须携带 -n 字符数：限定字符数，不加-n就要回车键结束 -s：隐藏输入的信息，适用于输入密码时 举例 Bash的运算 数值运算与运算符 数值运算 Linux中变量默认类型时字符串 declare 声明变量类型：declare [+/-][选项] 变量名 -：给变量设定类型属性 -i：将变量声明为整数类型 -x：将变量声明为环境变量 +：取消变量的类型属性 -p：显示指定变量的被声明的类型 举例:（四种计算格式，最常用的是第三种） aa=11；bb=22 declare -i cc=$aa+$bb cc=$(expr $aa + $bb) cc的值是aa和bb的和，注意“+”好左右两侧必须有空格 cc=$(($aa+$bb)) 双小括号：运算；单小括号：系统命令 cc=$[$aa+$bb] 运算符 越靠上的优先级越高 示例 变量测试与内容替换 需要的时候对照使用 环境变量配置文件 环境变量配置文件简介 source 不需要重新登录，让修改后的配置文件直接生效 source 配置文件 . 配置文件 `“.” 就是source的缩写，注意“.”后面有个空格` 环境变量配置文件中主要就是定义对系统的操作环境生效的系统默认环境变量，比如PATH，HISTSIZE，PS1，HOSTNAME等 主要的5个配置文件 /etc/profile：针对所有用户 /etc/profile.d/*.sh：针对所有用户 ~/.bash_profile：针对单个用户 ~/.bashrc：针对单个用户 /etc/bashrc：针对所有用户 环境变量配置文件作用 环境变量配置文件调用的顺序 /etc/profile：针对所有用户 USER变量 LOGNAME变量 MAIL变量 PATH变量 HOSTNAME变量 HISTNAME变量 HISTSIZE变量 umask 调用/etc/profile.d/*.sh文件 /etc/profile.d/*.sh：针对所有用户 执行profile.d目录下所有sh文件 ~/.bash_profile：针对单个用户 追加PATH：在PATH变量后面加上了:$HOME/bin这个目录 调用~/.bashrc ~/.bashrc：针对单个用户 定义别名 /etc/bashrc：针对所有用户 定义别名和PS1（登录提示符） 会重复调用PATH，umask啥的，但是只针对no login shell的情况，就是直接敲sh进入一个shell的情况 其他配置文件和登录信息 注销时的配置文件：~/.bash_logout 可以清空一些环境变量等 历史命令的保存文件：~/.bash_history 排错依据 登录信息 本地终端欢迎信息：/etc/issue 远程终端欢迎信息：/etc/issue.net 转义符在该文件中不能使用，只能纯文本登录 是否生效由ssh的配置文件/etc/ssh/sshd/config决定，要加入Banner /etc/issue.net，重启ssh服务生效：service sshd restart 登陆后的欢迎信息：/etc/motd（本地和远程都适用） 推荐特效字符定制网站ASCII Generator Shell编程 基础正则表达式 正则表达式和通配符区别 通配符：在系统中搜索匹配文件名，是完全匹配。支持命令ls，find，cp，他们不认识正则表达式 正则表达式：用来在文件中匹配符合条件的字符串，是包含匹配。支持命令：grep，awk，sed *：前一个字符匹配0次或者任意多次 .：匹配任意一个字符（换行符除外） ^：匹配以后面字符作为行首的行 $：匹配以后面字符作为行尾的行 ^$：匹配空白行 []：匹配中括号中的指定的任意一个字符 ：匹配除中括号中的字符外的任意一个字符 \\：转义符 {n}：表示其前面的字符恰好出现n次 {n,}：表示其前面的字符出现不少于n次 {n,m}：表示其前面的字符至少出现n次，最多出现m次 字符截取命令 grep 提取符合条件的行 -c：只输出匹配行的计数 -i：不区分大小写 -v：显示不包含匹配文本的所有行 cut 提取符合条件的列：cut [选项] 文件名 -f 列号：提取第几列 -d 分隔符：按照指定分隔符分割列，默认是制表符tab 示例 cat/etc/passwd | grep /bin/bash | grep -v root | cut -d \":\" -f 1：用来提取出普通用户名 df -h | grep \"sda5\" | cut -f 5：用来提取硬盘的使用率 如果是空格，则不能很好使用，需要更复杂的awk命令 printf 按找类型输出格式输出内容，使用awk时格式化输出：printf \"输出类型输出格式\" 输出内容 %ns：输出字符串 n是数字代指输出几个字符 %ni：输出整数 n是数字代指输出几个数字 %m.nf：输出浮点数 m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。 \\n，\\r，\\t：换行，回车，tab键 printf '%s %s %s' 1 2 3 4 5 6：最后输出结果按照%s %s %s格式分为两组 printf命令不能用管道符，只能printf %s $(cat XXX.txt) 在awk命令的输出中支持print和printf命令 print：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令） printf：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工加入换行符 awk 截取列： cut可以截取字符时，使用cut，否则使用awk 很强大的命令，可以说是一门编程语言 格式：awk ’条件1{动作1} 条件2{动作2} 条件3{动作3}‘ 文件名 前面可以加管道符 动作 格式化输出：printf 流程控制语句 示例 awk ‘{printf $2 “\\t” $6 “\\n”}’ XXX.txt df -h | awk '{printf $1 \"\\t\" $5 \"\\t\" $6}'：可以处理空格，弥补了cut的不足，但是awk很多命令很复杂 df -h | grep sda5 | awk ’{print $5}‘ | cut -d \"%\" -f 1 print可以在awk里面使用默认结尾加个换行符 BEGIN：在所有命令执行之前先执行BEGIN后面的语句块,awk默认是先读入一行再执行后面的语句 END：在所有语句处理完后执行 FS：指定分隔符，awk ’{FS=\":\"}‘ awk ‘{FS=\":\"} {print $1 \"\\t\" $3}’ /etc/passwd awk ‘BEGIN{FS=\":\"} {print $1 \"\\t\" $3}’ /etc/passwd awk还支持条件判断：awk ’$6>=87 {printf $2 \"\\n\"}‘： sed 数据的流编辑器，主要是用来将数据进行选取、替换、删除、新增的命令 vim只能修改文件，sed还可以直接修改管道符传过来的流 格式：sed [选项] ‘[动作]’ 文件名 选项： -n：sed默认把所有数据都输出到屏幕，加上-n表示只把经过sed修改过后的行输出到屏幕 -e：允许对输入数据应用多条sed命令编辑 -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出 会改变源文件，比较危险，不建议使用 动作： a：行后追加（多行时，行尾要加\\） sed ‘2a hello’ XXX.txt c：替换（多行时，行尾要加\\） sed ‘4c no the line’ XXX.txt：替换第二行 i：行前插入（多行时，行尾要加\\） sed ‘2i hello \\ world’ XXX.txt：在第二行前面插入 d：删除 sed ‘2,4d’ XXX.txt：删除第二行（没加-i选项不会修改源文件，只是删除输出的结果） p：打印 sed ‘2p’ XXX.txt：打印第二行 s：字串替换 sed ‘4s old/new/g’ XXX.txt：替换第四行的旧字符串替换为新字符串 字符处理命令 sort 排序（可接收管道符数据）：sort [选项] 文件名 -f：忽略大小写 -r：反向排序 -t ：指定分隔符，默认分隔符是制表符 -n：按照数值大小来排，默认使用字符串型排序 -k n[,m]：按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾） wc： 统计字符（可接收管道符数据）：wc [选项] 文件名 -l：只统计行数 -c：只统计字符数 -w：只统计单词数 条件判断 两种判断格式 test -e XXX.txt [ -e XXX.txt ]：注意首尾各有一个空格 shell中常用 示例 [ -d /root ] && echo \"yes\" || echo \"no\"：如果是目录yes，否则no 按照文件类型判断 -e：判断文件是否存在（存在为真） -b：判断文件是否存在，并且是否是块设备文件 -c：判断文件是否存在，并且是否是字符设备文件 -d：判断文件是否存在，并且是否是目录文件 -f：判断文件是否存在，并且是否是普通文件 -L：判断文件是否存在，并且是否是链接文件 -p：判断文件是否存在，并且是否是管道文件 -S：判断文件是否存在，并且是否是套接字文件 -s：判断文件是否存在，并且是否是非空 按照文件权限进行判断 -r：判断文件是否存在，并且是否该文件有读权限，u，g，o中任意一个有都为真 -w：判断文件是否存在，并且是否该文件有写权限，u，g，o中任意一个有都为真 -x：判断文件是否存在，并且是否该文件有执行权限，u，g，o中任意一个有都为真 -u：判断文件是否存在，并且是否该文件有SUID权限，u，g，o中任意一个有都为真 -g：判断文件是否存在，并且是否该文件有SGID权限，u，g，o中任意一个有都为真 -k：判断文件是否存在，并且是否该文件有SBIT权限，u，g，o中任意一个有都为真 两个文件之间进行比较 文件1 -nt 文件2：判断文件1的修改时间是否比文件2新 文件1 -ot 文件2：判断文件1的修改时间是否比文件2旧 文件1 -ef 文件2：判断文件1的inode号是否和文件2一致，可以用来判断两个文件是不是互为硬链接 两个整数之间比较 整数1 -eq 整数2：相等 整数1 -ne 整数2：不等 整数1 -gt 整数2：大于 整数1 -lt 整数2：小于 整数1 -ge 整数2：大于等于 整数1 -le 整数2：小于等于 示例：[ 3 -lt 2 ] && echo yes || echo no 字符串的判断 -z：判断是否为空 判断变量是否为空：[ -z \"$name\" ] && echo yes || echo no -n：判断是否为非空 字串1 == 字串2：判断是否相等 字串1 != 字串2：判断是否不等 多重条件判断 判断1 -a 判断2：逻辑与 示例： aa = 10 [ -n \"$aa\" -a \"$aa\" -gt 9 ] && echo yes || echo no 判断1 -o 判断2：逻辑或 ! 判断：逻辑非 注意!后面有空格 流程判断 if语句 和[-d /root] && echo \"yes\" || echo \"no\"作用一样，但更直观 单分支if 实例 双分支if 多分支if case语句 for循环 第一种语法 示例 第二种语法 示例 while循环和until编程 while循环 示例 until循环 示例 "},"Linux/基础/13-Linux的服务管理.html":{"url":"Linux/基础/13-Linux的服务管理.html","title":"Linux的服务管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux的服务管理 服务简介与分类 Linux服务分类 RPM包默认安装的服务 独立的服务 基于xinetd（超级守护进程）服务 源码包安装的服务（第三方源码包） 服务的启动与自启动 查询已安装的服务 RPM包安装的服务：chkconfig --list 查看RPM包安装的服务按照运行级别的自启动状态。 查看是否在系统下次启动时自启动，而不是查看服务是否当前已启动 查询当前启动的服务 ps aux netstat service --status-all 源码包安装的服务：没有命令，只能去服务安装位置查看，一般在/usr/local/下 其实源码包和RPM包安装的服务在Linux中的区别就是安装位置不同 源码包安装在指定位置，一般是/usr/local/下 RPM包安装在默认位置中，配置文件在/etc/下，启动命令在/etc/rc.d/init.d/下，分散到很多文件夹下 RPM包安装服务的管理 RPM包安装的服务默认保存位置：(特殊文件有自己的默认保存位置) 独立服务的管理 启动方式 /etc/init.d/ 独立服务名 start | stop | status | restart 推荐使用 service 独立服务名 start | stop | restart | status rea hat独有，service 相当于/etc/inin.d 自启动方式 方式一：打开自启动：chkconfig [--level 运行级别] [独立服务名] on 不支持源码包安装的服务 关闭自启动：chkconfig 独立服务名 off 默认就是：2345 方式二：修改/etc/rc.d/rc.local文件，加入需要自启动的服务名 推荐 方式三：使用ntsysv命令管理自启动，图形界面很直观 red hat专有 基于xinetd(超级守护进程)服务的管理 默认情况下Linux是没有xinted的，需要手动安装yum -y install xinetd 然后用chkconfig --list查看，基于xinetd的服务不占用内存，但是需要的响应时间更长 基于xinetd的服务的启动，修改/etc/xinetd.d/下对应的服务的配置文件,然后service xinetd restart 基于xinetd的服务的自启动： chkconfig 服务名 on和chkconfig 服务名 off 图形界面工具：ntsysv 基于xinetd的启动和自启动是通用的，两者区分不是很严格，这种设置不利于管理，所以现在基于xinetd的服务越来越少了 自启动关闭，服务也会关闭，2者相通 源码包安装服务的管理 源码包安装的服务默认保存位置：/usr/local/ 源码包安装服务的启动和关闭(用绝对路径的启动脚本启动)：/usr/local/apache2/bin/apachectl start|stop 一般每一个源码包都有安装说明INSTALL，应该查看里面的启动方法 源码包安装服务的自启动： vim /etc/rc.d/rc.local加入/usr/local/apache2/bin/apachectl start 把源码包服务的启动脚本软连接到/etc/init.d/目录下和chkconfig --add 服务名，就可以实现service，chkconfig和ntsysv命令管理源码包安装服务，但是并不推荐，容易混乱。 总结 "},"Linux/基础/14-Linux系统管理.html":{"url":"Linux/基础/14-Linux系统管理.html","title":"Linux系统管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux系统管理 进程管理 进程管理的作用：（下面优先级由高到低） 判断服务器的健康状态（CPU、内存的占用情况） 常用命令：top 查看系统中的所有进程 命令：ps aux 和 ps -el 和 pstree 杀死进程 不常用，尽可能正常操作结束服务，不能正常关闭时再用 进程查看 ps aux 查看系统中所有进程，查看BSD操作系统格式 ps -le 查看系统中所有进程，Linux格式 输出格式的作用 ps aux top 查看系统健康状态：top [选项] 需要的时候使用，top命令比较耗资源 -d 秒数：默认每3秒更新一次，可指定 ？或h：显示交互模式的帮助 P：以CPU使用率排序，默认选项 M：以内存使用率排序 N：以PID排序 q：退出top top命令的显示 重点关注最后一个平均负载(除以 Cpu 核数，如果大于 1.5，表示超出负荷，小于 1.5 基本正常) 重点关注第4个CPU的空闲率 重点关注第3个内存的空闲率 pstree 查看进程树：pstree [选项] -p：显示进程的PID -u：显示进程的所属用户 进程终止 正常命令不能终止服务时才使用 kill kill [信号] PID -l：查看kill支持的信号 小写l -1 PID：重启进程 -9 PID：终止进程 killall 按照进程名杀死，选项和kill通用：killall [选项] [信号] 进程名 -i：有询问 -I：忽略进程名的大小写 大写的i pkill 按照进程名杀死，选项和kill通用：pkill [选项] [信号] 进程名 也可以加t选项跟终端号：pkill -t 终端号：按照终端号踢出用户，用 w 命令查询系统中登录的用户，然后用终端号来踢 工作管理 类似Windows的最小化 把进程放入后台 命令后面加&：后台继续运行 在命令执行过程中，按下ctrl+z快捷键：放入后台即暂停 jobs 查看后台的工作：jobs [-l] -l：显示工作的PID 注意：“+”号代表最近一个放入后台的工作，也是工作恢复时，默认恢复的工作；“-”号代表倒数第二个放入后台的工作。 fg 恢复后台暂停的工作恢复到前台运行：fg %工作号 %工作号：%号可以省略，但是注意工作号和PID的区别 bg 恢复后台暂停的工作恢复到后台运行：bg %工作号 %工作号：%号可以省略，但是注意工作号和PID的区别 但是不能恢复和前台有交互的命令比如top命令和vim命令，因为就是给用户展示，后台运行没意义 注意：工作号≠PID 系统资源查看 vmstat 监视系统资源使用情况： vmstat [刷新延时(s) 刷新次数] 和top内容差不多，但更简洁 dmesg 开机时内核检测，一般结合grep使用 free 查看内存使用情况：free [选项] -b：以字节为单位显示 -k：以KB为单位显示（默认就是） -m：以MB为单位显示 -g：以GB为单位显示 查看CPU信息： cat /proc/cupinfo：每次开机都会更新 dmesg | grep CPU uptime：实际就是top命令第一行，跟w看到的一样 uname 查看系统与内核相关信息：uname [选项] -a：查看系统所有相关信息 -r：查看内核版本 -s：查看内核名称 file /bin/ls 判断当前系统的位数（通过系统外部命令的位数来推测） lsb_release -a 查询Linux系统的发行版本 lsof 列出进程打开或使用的文件信息：lsof [选项] -s 字符串：只列出以字符串开头的进程打开的文件 -u 用户名：只列出某个用户的进程打开的文件 -p pid：列出某个PID进程打开的文件 系统定时任务 前提：必须启动crond服务：service crond restart，并且chkconfig crond on，Linux系统都是默认启动和自启动的 crontab 设置系统定时任务：crontab [选项] -e：编辑crontab定时任务 打开文件编辑的格式是： * command或执行脚本 第一个*：分钟（0-59） 第二个*：小时（0-23） 第三个*：天（1-31） 第四个*：月（1-12） 第五个*：星期（0-7，0和7都代表星期日） 特殊符号： 示例 定期脚本里面的日期输出需要加“\\”转义符，原本：date +%y%m%d，定时任务里的脚本：date +\\%y\\%m\\%d -l：查询crontab任务 -r：删除当前用户所有的crontab任务 删一个任务，进去编辑删除需要删除的任务（vim操作） "},"Linux/基础/15-Linux日志管理.html":{"url":"Linux/基础/15-Linux日志管理.html","title":"Linux日志管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux日志管理 日志管理简介 百度百科简介：系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。 服务器出现问题先查看日志，才能找准原因 CentOS7中原来的日志服务syslogd被rsyslogd取代，两者兼容 确认服务是否启动和自启动： ps aux | grep rsyslogd chkconfig --list | grep rsylog 常见的日志的作用 RPM包安装的服务日志也会在/var/log/目录下 源码包安装的服务日志在源码包指定目录（一般是/usr/local）中，这些日志不是有rsyslogd服务来管理的，而是由各个服务使用自己的日志管理文档来记录自身日志 你安装了这些服务就会有 rsyslogd日志服务 日志文件格式 事件产生的时间 产生事件的服务器的主机名 产生事件的服务名或程序名 事件的具体信息 /etc/rsyslog.conf配置文件 格式 * authpriv.* /var/log/secure * 服务名称 [连接符号] 日志等级 日志记录位置 `authpriv：服务名称 .：连接符号 *：日志等级` * 服务名称，连接符，日志等级，日志记录位置都有多个，内容很多，自行百度。 常见的服务 连接符号 “*”不是连接符号，是所有日志等级 日志等级 从低等级到高等级（上到下） 日志记录位置 日志轮替 如果日志都记录在一个文件中，那么可能会占据大量存储空间，纯文本文档打开会非常慢，所以日志需要处理：切割（把大日志按天切割成小的）+轮换（删除旧的，保存新的） 日志文件的命名规则 如果配置文件中有“dateext”参数，那么日志会用日期作为后缀，例如：“secure-20200603”，只需要保存指定的日志个数，删除多余的日志文件即可 推荐使用 如果没有“dateext”参数，那么日志文件就需要改名了，当第一次使用日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志。第二次时，1变2，0变1，又新建0，以此类推 配置文件 /etc/logrotate.conf 只要是RPM包安装的服务，它默认已经支持轮替，但是源码包安装的服务需要vim /etc/logrotate.conf，然后手动加入轮替 示例 logrotate logrotate [选项] 配置文件名 如果此命令没有选项，则会按照配置文件中的条件进行日志轮替 logrotate -v /etc/logrotate.conf：显示日志轮替过程 logrotate -f /etc/logrotate.conf：强制轮替，不管日志轮替的条件是否已经满足 "},"Linux/基础/16-Linux启动管理.html":{"url":"Linux/基础/16-Linux启动管理.html","title":"Linux启动管理","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux启动管理 CentOS 6.x的启动管理 运行级别：7个级别 runlevel：查看运行级别 init 运行级别：改变当前运行级别 vim /etc/inittab：永久修改系统默认运行级别，写上id:3:initdefault 不要把0和6设为默认级别 CentOS6系统启动过程：针对MBR模式 initramfs内存文件系统 CentOS 6.x中使用initramfs内存文件系统去嗲了Centos5.x中的initrd RAM Disk。他们的作用类似，可以通过启动引导程序加载到内存中，然后加载启动过程中所需要的的内核模块，比如USB、SATA、SCSI硬盘的驱动和LVM、PAID文件系统的驱动 查看 不能在boot目录下做操作 调用/etc/init/rcS.conf配置文件 主要功能是两个 先调用/etc/rc.d/rc.sysinit，然后又/etc/rc.d/rc.sysinit配置文件进行Linux系统初始化 然后再调用/etc/inittab，然后由/etc/inittab配置文件确定系统的默认运行级别 调用/etc/rc.d/rc文件 启动引导程序grub Grub配置文件：/boot/grub/grub.conf 格式： default=0： 默认启动第一个系统 timeout=5： 等待时间，默认是5秒 splashimage=(hd0,0)/grub/splash.xpm.gz：指定grub启动时的背景图像文件的保存位置 hiddenmenu： 隐藏菜单 title CentOS(2.6.32-279.el6.i686)： 标题 root (hd0,0)： 指启动程序的保存分区 kernel /vmlinuz-2.6.32-279.el6.i686 ro： 定义了内核加载时的选项 initrd /initramfs-2.6.32-279.el6.i686.img： initramfs内存文件系统镜像文件的所在位置 系统修复模式 单用户模式常见的错误修复 遗忘root密码 修改系统默认运行级别 光盘修复模式 这些是后门，说的Linux针对的是网络安全 "},"Linux/基础/17-Linux备份与恢复.html":{"url":"Linux/基础/17-Linux备份与恢复.html","title":"Linux备份与恢复","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Linux备份与恢复 备份概述 Linux中需要备份的数据：/root/目录，/home/目录，/var/spool/mail/目录，/etc/目录，其他目录 安装的服务的数据也需要备份 apache需要备份的数据：配置文件，网页主目录，日志文件 mysql需要备份的数据 源码包安装的：/usr/local/mysql/data/ RPM包安装的：/var/lib/mysql 备份策略 完全备份：效果最高，但需要更大的硬盘空间 增量备份：每次备份只备份新的数据，占用空间少，但是恢复起来麻烦 差异备份：每次备份都只备份完全备份中不存在的，折中方法 备份命令 完全备份完全可以用tar打包压缩来做，但是如果是差异备份就会非常麻烦，这时就需要用到Linux为数据备份量是打造的备份和恢复命令dump命令和restore命令 dump dump [选项] 备份之后的文件名 原文件名或目录 -级别：0到9个备份级别 0是完全备份，1就是第一次增量备份，以此类推9就是第9次增量备份 -f 文件名：指定备份之后的文件名 -u：把备份时间记录在/etc/dumpdates文件中 -v：显示备份过程 -j：把备份文件压缩为.bz2格式 -W：查看详情，显示允许被dump的分区的备份等级及备份时间 注意：dump命令只有在备份分区的时候才能增量备份，备份普通目录或文件只能完全备份 示例 restore restore [模式选项] [选项] 四个模式 不能混用 -C：比较备份数据和实际数据的变化 -i：交互模式，手工选择需要恢复的文件 -t：查看模式，用于查看备份文件中拥有哪些数据 -r：还原模式，用于数据还原 一个选项 -f：指定备份文件的文件名 "},"Python/PEP8.html":{"url":"Python/PEP8.html","title":"Python PEP8编码规范 ","keywords":"","body":"Python编码规范指南 详情参考：https://www.python.org/dev/peps/pep-0008/ 缩进 每级缩进使用4个空格。 连续行应该对齐折叠元素，无论是垂直的Python的隐式行连接圆括号内的，中括号内的，大括号内的，还是使用悬挂缩进[5]。 使用悬挂缩进应注意以下几点； 1、第一行没有参数并且使用更多的缩进来区别它本身和连续行。 风格良好： # 与分界符对齐。 foo = long_function_name(var_one, var_two, var_three, var_four) # 包括更多的缩进以区别于其他的。 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 悬挂缩进应增加一个级别 foo = long_function_name( var_one, var_two, var_three, var_four) 风格不良： # 第一行参数禁止不使用垂直对齐 foo = long_function_name(var_one, var_two, var_three, var_four) # 当无法区分缩进时，需要进一步缩进 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 2、对于连续行，4个空格规则是可选的。 可选的： # 悬挂缩进可能缩进不是4个空格 foo = long_function_name( var_one, var_two, var_three, var_four) 3、if语句条件块足够长时需要编写多行，值得注意的是两个字符组成的关键字（例如if），加上一个空格，加上开括号为多行条件的后续行创建一个4个空格的缩进。 这可以给嵌入if内的缩进语句产生视觉冲突，这也自然被缩进4个空格。这个PEP没有明确如何（是否）进一步区分条件行和if语句内的嵌入行。 这种情况下，可以接受的选项包括，但不仅限于： # 没有额外的缩进 if (this_is_one_thing and that_is_another_thing): do_something() # 添加一行注释，这将为编辑器支持语法高亮提供一些区分。 # supporting syntax highlighting. if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something() # 在条件连接行，增加额外的缩进 if (this_is_one_thing and that_is_another_thing): do_something() 4、多行结构中的结束花括号/中括号/圆括号是最后一行的第一个非空白字符， 如： my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 或者是最后一行的第一个字符， 如： my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 制表符还是空格？ 空格是缩进方法的首选。 制表符仅用于与已经用制表符做缩进的代码保持一致。 Python3不允许混用制表符和空格来缩进。 Python2代码混用制表符和空格缩进，将被转化为只使用空格。 调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！ 行的最大长度 限制所有行最多79个字符。 下垂的长块结构限制为更少的文本（文档字符串或注释），行的长度应该限制在72个字符。 限制编辑器窗口宽度使得并排打开多个文件成为可能，并且使用代码审查工具显示相邻列的两个版本工作正常。 绝大多数工具的默认折叠会破坏代码的可视化结构，使其更难以理解。编辑器中的窗口宽度设置为80个字符。即使该工具将在最后一列中标记 字形。一些基于网络的工具可能不会提供动态的自动换行。 有些团队强烈喜欢较长的行长度。对于代码维护完全或主要由一个团队的，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到 100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。 Python标准库采取保守做法，要求行限制到79个字符（文档字符串/注释到72个字符）。 折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面使用小括号来变成多行。连续行使用反斜杠更好。 反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠： with open('/path/to/some/file/you/want/to/read') as file_1, \\ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) （为进一步思考With语句的多行缩进，见前面多行if语句的讨论。） 另一个这样的例子是assert语句。 确保适当的连续行缩进。 换行应该在二元操作符的前面还是后面？ 风格良好： # 好的做法：很容易看出二元操作符和被操作对象的关系 income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 风格不良： # 不好的做法：操作符和被操作符的对象是分离的 income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 空行 顶级函数和类的定义之间有两行空行。 类内部的函数定义之间有一行空行。 额外的空行用来（谨慎地）分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。 在函数中谨慎地使用空行来表示逻辑部分。 Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。 注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。 源文件编码 在源文件中一直使用utf-8编码，在python2中使用ascll编码。 文件，在python2 中使用ascll编码，在python3中使用utf-8编码 导入 导入通常是单独一行，例如： 风格良好： import os import sys from subprocess import Popen, PIPE 风格不良： import sys, os 导入常常位于文件顶部，在模块注释和字符串文档之后，在模块的全局变量和常量之前。 导入应该按照以下顺序分组： 1. 标准库导入 2. 相关的第三方导入 3. 特定的本地应用/库导入 在每个导入组之间放一行空行。 把任何相关__all__规范放在导入之后。 推荐绝对导入，因为它们更易读，并且如果导入系统配置的不正确（例如当包中的一个目录结束于sys.path） 它们有更好的表现（至少给出更好的错误信息）： import mypkg.sibling from mypkg import sibling from mypkg.sibling import example 明确的相对导入可以用来接受替代绝对导入，特别是处理复杂包布局时，绝对导入过于冗长。 from . import sibling from .sibling import example 标准库代码应该避免复杂包布局并使用绝对导入。 隐式的相对导入应该永远不被使用，并且在Python3中已经移除。 从一个包含类的模块中导入类时，通常下面这样是好的写法： from myclass import MyClass from foo.bar.yourclass import YourClass 如果这种写法导致本地名字冲突，那么就这样写： import myclass import foo.bar.yourclass 并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。 避免使用通配符导入（from import *），因为它们使哪些名字出现在命名空间变得不清楚，这混淆了读者和许多自动化工具。 通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口， 该接口定义从一个可选的加速器模块并且哪些定义将被重写提前并不知道）。 用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。 模块级别的内置属性 模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后， 任意import语句之前，from __future__导入除外。Python强制要求from __future__导入必须在任何代码之前，只能在模块级文档字符串之后。 \"\"\"This is the example module. This module does stuff. \"\"\" from __future__ import barry_as_FLUFL __all__ = ['a', 'b', 'c'] __version__ = '0.1' __author__ = 'Cardinal Biggles' import os import sys 字符串引号 Python中，单引号字符串和双引号字符串是一样的。本PEP不建议如此。建议选择一条规则并坚持下去。当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠。这提高可读性。 三引号字符串，与PEP 257 文档字符串规范一致总是使用双引号字符。 表达式和语句中的空格 以下情况避免使用多余的空格： 紧挨着小括号，中括号或大括号。 Yes: spam(ham[1], {eggs: 2}) No: spam( ham[ 1 ], { eggs: 2 } ) 紧挨在逗号，分号或冒号前： Yes: if x == 4: print x, y; x, y = y, x No: if x == 4 : print x , y ; x , y = y , x 在切片中冒号像一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。 例外：当一个切片参数被省略时，该空格被省略。 风格良好： ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] 风格不良： ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] 紧挨着左括号之前，函数调用的参数列表的开始处： Yes: spam(1) No: spam (1) 紧挨着索引或切片开始的左括号之前： Yes: dct['key'] = lst[index] No: dct ['key'] = lst [index] 为了与另外的赋值（或其它）操作符对齐，不止一个空格。 Yes: x = 1 y = 2 long_variable = 3 No: x = 1 y = 2 long_variable = 3 其它建议 始终避免行尾空白。因为它们通常不可见，容易导致困惑：如果\\后面跟了一个空格，它就不是一个有效的续行符了。 很多编辑器不保存行尾空白，CPython项目中也设置了commit前检查以拒绝行尾空白的存在。 始终在这些二元操作符的两边放置一个空格：赋值（= ），增强赋值（+= ，-= 等）， 比较（== ， ， != ， <> ， = ，in ， not in ，is ，is not ），布尔（and ，or ，not ）。 如果使用了不同优先级的操作符，在低优先级操作符周围增加空格（一个或多个）。不要使用多于一个空格，二元运算符两侧空格数量相等。 Yes: i = i + 1 submitted += 1 x = x*2 - 1 hypot2 = x*x + y*y c = (a+b) * (a-b) No: i=i+1 submitted +=1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) 当=符号用于指示关键字参数或默认参数值时，它周围不要使用空格。 Yes: def complex(real, imag=0.0): return magic(r=real, i=imag) No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 带注解的函数使用正常的冒号规则，并且在->两侧增加一个空格： Yes: def munge(input: AnyStr): ... def munge() -> AnyStr: ... No: def munge(input:AnyStr): ... def munge()->PosInt: ... 如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。 Yes: def munge(sep: AnyStr = None): ... def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... No: def munge(input: AnyStr=None): ... def munge(input: AnyStr, limit = 1000): ... 不鼓励使用复合语句（同一行有多条语句）。 风格良好: if foo == 'blah': do_blah_thing() do_one() do_two() do_three() 最好不要: if foo == 'blah': do_blah_thing() do_one(); do_two(); do_three() 尽管有时if/for/while的同一行跟一小段代码，在一个多条子句的语句中不要如此。避免折叠长行！ 最好不要: if foo == 'blah': do_blah_thing() for x in lst: total += x while t 什么时候使用尾部逗号？ 尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。 为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）： Yes: FILES = ('setup.cfg',) OK, but confusing: FILES = 'setup.cfg', 当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。 通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。 Yes: FILES = [ 'setup.cfg', 'tox.ini', ] initialize(FILES, error=True, ) No: FILES = ['setup.cfg', 'tox.ini',] initialize(FILES, error=True,) 注释 同代码相矛盾的注释比没有注释更差。当代码修改时，始终优先更新注释！ 注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符（不更改标识符的情况下！）。 如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。 在句尾的句号后边使用两个空格。 写英语注释时，遵循断词和空格。 非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。 非英语国家的Python程序员：请写下你的意见，在英语中，除非你是120%肯定，代码将不会被不讲你的语言的人阅读。 注释块 注释块通常适用于一些（或全部）紧跟其后的代码，并且那些代码应使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非注释里面的文本有缩进）。 注释块内的段落之间由仅包含#的行隔开。 行内注释 谨慎地使用行内注释。 行内注释就是注释和代码在同一行，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。 如果行内注释指出的是显而易见，那么它就是不必要的。不要使用无效注释，主要是说明其目的 不要这样做： x = x + 1 # Increment x But sometimes, this is useful: x = x + 1 # Compensate for border 文档字符串 编写好的文档字符串（即“代码”）约定在PEP 257中是永存的。 为所有公共模块，函数，类和方法书写文档字符串。对非公开的方法书写文档字符串是没有必要的，但应该写注释描述这个方法是做什么的。 这些注释应该写在def行后面。 PEP 257描述了好的文档字符串约定。最重要的是，多行文档字符串以一行\"\"\"结束，例如： yes: \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于只有一行的文档字符串，\"\"\"同一行上。 命名规范 使用单独的小写字母（b） 使用单独的大写字母（B） 使用小写字母（lowercase） 使用小写字母和下划线（lower_case_with_underscores） 使用大写字母（UPPERCASE） 使用大写字母和下划线（UPPER_CASE_WITH_UPPERCASE） 驼峰式写法（CamelCase）：在使用缩写的时候，大写优于小写例如HTTPServer优于HttpServer 首字母大写，然后使用下划线是一种丑陋的写法 1、避免使用的名称 在写变量的时候，尽量避免小写的l和大写字母O和大写字母I，主要原因是容易和数字中1,0相混淆。当想使用‘l’时，用‘L’代替。 2、包名和模块名 模块尽量使用简短的全部小写的名称，如果可以增加可读性那么可以使用下划线，python的包不推荐使用下划线， 但是在引用其他语言写的扩展包中可以使用下划线来表示区分 3、类名称 类名称主要遵循为CapWords约定，表示为首字母大写 4、类型变量名称 类型变量名称应该首字母大写，并且尽量短，比如：T, AnyStr, Num。对于协变量和有协变行为的变量，建议添加后缀__co或者__contra。 5、异常名 因为异常应该是类，所以类的命名规则在这里也同样适用。然而，异常名（如果这个异常确实是一个错误）应该使用后缀“Error”。 6、全局变量名 （希望这些变量是在一个模块内使用。）这些规则和那些有关函数的规则是相同的。 模块设计为通过from M import *来使用，应使用__all__机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加下划线（可能你像表明这些全局变量是“非公开模块”）。 7、函数名 函数名应该是小写字母，必要时单词用下划线分开以提高可读性。 混合大小写仅用于这种风格已经占主导地位的上下文（例如threading.py），以保持向后兼容性。 8、函数和方法参数 使用self做实例化方法的第一个参数。 使用cls做类方法的第一个参数。 如果函数的参数名与保留关键字冲突，最好是为参数名添加一个后置下划线而不是使用缩写或拼写错误。 因此class_ 比clss好。（也许使用同义词来避免更好。）。 9、常量 常量通常定义于模块级别并且所有的字母都是大写，单词用下划线分开。例如MAX_OVERFLOW和TOTAL。 "},"Python/Python语言基础/00-初识Python.html":{"url":"Python/Python语言基础/00-初识Python.html","title":"初识Python","keywords":"","body":"datetime:2019/6/29 9:04 author:nzb 初识Python Python简介 Python的历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面又出现了Java和C#实现的版本Jython和IronPython，以及PyPy、Brython、Pyston等其他实现），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，同时提供了“列表”和“字典”等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了实现完整的垃圾回收)，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（如修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以查看一篇名为《Python简史》的博文。 Python的优缺点 Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python的缺点主要集中在以下几点。 执行效率稍低，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被淡化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 Python的应用领域 目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。 搭建编程环境 Windows环境 可以在Python官方网站下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装Python 3.x，需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.6 to PATH”（将Python 3.6添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议使用自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示。如果稍后运行Python程序时，出现因为缺失一些动态链接库文件而导致Python解释器无法工作的问题，可以按照后面说的方法加以解决。如果系统显示api-ms-win-crt*.dll文件缺失，可以参照《api-ms-win-crt*.dll缺失原因分析和解决方法》一文讲解的方法进行处理或者直接在微软官网下载Visual C++ Redistributable for Visual Studio 2015文件进行修复；如果是因为更新Windows的DirectX之后导致某些动态链接库文件缺失问题，可以下载一个DirectX修复工具进行修复。 Linux环境 Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。 安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。 yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python源代码并解压缩到指定目录。 wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz xz -d Python-3.7.3.tar.xz tar -xvf Python-3.7.3.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。 cd Python-3.7.3 ./configure --prefix=/usr/local/python37 --enable-optimizations make && make install 修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。 cd ~ vim .bash_profile # ... 此处省略上面的代码 ... export PATH=$PATH:/usr/local/python37/bin # ... 此处省略下面的代码 ... source .bash_profile macOS环境 macOS也自带了Python 2.x版本，可以通过Python的官方网站提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，可以通过执行python3命令来启动3.x版本的Python解释器。 从终端运行Python程序 确认Python的版本 可以Windows的命令行提示符中键入下面的命令。 python --version 或者是在Linux或macOS系统的终端中键入下面的命令。 python3 --version 当然也可以先输入python或python3进入交互式环境，再执行以下的代码检查Python的版本。 import sys print(sys.version_info) print(sys.version) 编写Python源代码 可以用文本编辑工具（推荐使用Sublime、TextMate、Visual Studio Code等高级文本编辑工具）编写Python源代码并用py作为后缀名保存该文件，代码内容如下所示。 print('hello, world!') 运行程序 切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了\"hello, world!\"。 python hello.py 或 python3 hello.py 代码中的注释 注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾 \"\"\" 第一个Python程序 - hello, world! 向伟大的Dennis M. Ritchie先生致敬 Version: 0.1 Author: 骆昊 \"\"\" print('hello, world!') # print(\"你好,世界！\") print('你好', '世界') print('hello', 'world', sep=', ', end='!') print('goodbye, world', end='!\\n') 其他工具介绍 IDLE - 自带的集成开发工具 IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。 IPython - 更好的交互式编程工具 IPython是一种基于Python的交互式解释器。相较于原生的Python交互式环境，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。 pip install ipython 或 pip3 install ipython 安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。 当然，我们也可以通过安装Jupyter工具并运行名为notebook的程序在浏览器窗口中进行交互式代码编写操作。 pip install jupyter 或 pip3 intall jupyter 然后执行下面的命令： jupyter notebook Sublime - 文本编辑神器 首先可以通过官方网站下载安装程序安装Sublime 3或Sublime 2。 安装包管理工具。 通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。 Sublime 3 import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) Sublime 2 import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read());print('Please restart Sublime Text to finish installation') 手动安装浏览器输入 https://sublime.wbond.net/Package%20Control.sublime-package 下载这个文件 下载好以后，打开sublime text，选择菜单Preferences->Browse Packages... 打开安装目录 此时会进入到一个叫做Packages的目录下，点击进入上一层目录Sublime Text3，在此目录下有一个文件夹叫做Installed Packages，把刚才下载的文件放到这里就可以了。然后重启sublime text3，观察Preferences菜单最下边是否有Package Settings 和Package Control两个选项，如果有，则代表安装成功了。 安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件： SublimeCodeIntel - 代码自动补全工具插件。 Emmet - 前端开发代码模板插件。 Git - 版本控制工具插件。 Python PEP8 Autoformat - PEP8规范自动格式化插件。 ConvertToUTF8 - 将本地编码转换为UTF-8。 说明：事实上Visual Studio Code可能是更好的选择，它不用花钱并提供了更为完整和强大的功能。 PyCharm - Python开发神器 PyCharm的安装、配置和使用在《玩转PyCharm》进行了介绍，有兴趣的读者可以选择阅读。 练习 在Python交互环境中查看下面的代码结果，并试着将这些内容翻译成中文。 import this 说明：当前键入上面的命令后会在交互式环境中看到如下所示的输出，这段内容被称为“Python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 学习使用turtle在屏幕上绘制图形。 说明：turtle是Python内置的一个非常有趣的模块，特别适用于让小朋友体会什么是编程，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言. import turtle turtle.pensize(4) turtle.pencolor('red') turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.mainloop() "},"Python/Python语言基础/01-语言元素.html":{"url":"Python/Python语言基础/01-语言元素.html","title":"语言元素","keywords":"","body":"datetime:2019/5/14 9:38 author:nzb 语言元素 指令和程序 计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们使用的计算机虽然器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于“冯·诺依曼结构”的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用维基百科或者百度百科科普一下。 变量和类型 在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量命名 需要符合PEP8要求 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> 右移，左移 & 按位与 ^ ` ` 按位异或，按位或 > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= ` =`^= >>= （复合）赋值运算符 说明：在实际开发中，如果搞不清楚优先级可以使用括号来确保运算的执行顺序。 练习 练习1：华氏温度转摄氏温度。 \"\"\" 将华氏温度转换为摄氏温度 F = 1.8C + 32 \"\"\" f = float(input('请输入华氏温度: ')) c = (f - 32) / 1.8 print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 练习2：输入圆的半径计算计算周长和面积。 \"\"\" 输入半径计算圆的周长和面积 \"\"\" import math radius = float(input('请输入圆的半径: ')) perimeter = 2 * math.pi * radius area = math.pi * radius * radius print('周长: %.2f' % perimeter) print('面积: %.2f' % area) 练习3：输入年份判断是不是闰年。 \"\"\" 输入年份 如果是闰年输出True 否则输出False \"\"\" year = int(input('请输入年份: ')) # 如果代码太长写成一行不便于阅读 可以使用\\或()折行 is_leap = (year % 4 == 0 and year % 100 != 0 or year % 400 == 0) print(is_leap) "},"Python/Python语言基础/02-分支结构.html":{"url":"Python/Python语言基础/02-分支结构.html","title":"分支结构","keywords":"","body":"datetime:2019/5/14 9:38 author:nzb 分支结构 分支结构的应用场景 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。类似的场景还有很多，给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。 if语句的使用 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。 \"\"\" 用户身份验证 \"\"\" username = input('请输入用户名: ') password = input('请输入口令: ') # 如果希望输入口令时 终端中没有回显 可以使用getpass模块的getpass函数 # import getpass # password = getpass.getpass('请输入口令: ') if username == 'admin' and password == '123456': print('身份验证成功!') else: print('身份验证失败!') 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值。 \"\"\" 分段函数求值 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 elif x >= -1: y = x + 2 else: y = 5 * x + 3 print('f(%.2f) = %.2f' % (x, y)) 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。 \"\"\" 分段函数求值 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 else: if x >= -1: y = x + 2 else: y = 5 * x + 3 print('f(%.2f) = %.2f' % (x, y)) 说明：大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提出这个观点是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，如果可以使用扁平化的结构就不要去用嵌套，因此之前的写法是更好的做法。 练习 练习1：英制单位与公制单位互换 \"\"\" 英制单位英寸和公制单位厘米互换 \"\"\" value = float(input('请输入长度: ')) unit = input('请输入单位: ') if unit == 'in' or unit == '英寸': print('%f英寸 = %f厘米' % (value, value * 2.54)) elif unit == 'cm' or unit == '厘米': print('%f厘米 = %f英寸' % (value, value / 2.54)) else: print('请输入有效的单位') 练习2：掷骰子决定做什么 \"\"\" 掷骰子决定做什么事情 \"\"\" from random import randint face = randint(1, 6) if face == 1: result = '唱首歌' elif face == 2: result = '跳个舞' elif face == 3: result = '学狗叫' elif face == 4: result = '做俯卧撑' elif face == 5: result = '念绕口令' else: result = '讲冷笑话' print(result) 说明：上面的代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。 练习3：百分制成绩转等级制 \"\"\" 百分制成绩转等级制成绩 90分以上 --> A 80分~89分 --> B 70分~79分 --> C 60分~69分 --> D 60分以下 --> E \"\"\" score = float(input('请输入成绩: ')) if score >= 90: grade = 'A' elif score >= 80: grade = 'B' elif score >= 70: grade = 'C' elif score >= 60: grade = 'D' else: grade = 'E' print('对应的等级是:', grade) 练习4：输入三条边长如果能构成三角形就计算周长和面积 \"\"\" 判断输入的边长能否构成三角形 如果能则计算出三角形的周长和面积 \"\"\" import math a = float(input('a = ')) b = float(input('b = ')) c = float(input('c = ')) if a + b > c and a + c > b and b + c > a: print('周长: %f' % (a + b + c)) p = (a + b + c) / 2 area = math.sqrt(p * (p - a) * (p - b) * (p - c)) print('面积: %f' % (area)) else: print('不能构成三角形') 说明：上面的代码中使用了math模块的sqrt函数来计算平方根。用边长计算三角形面积的公式叫做海伦公式。 练习5：个人所得税计算器。 \"\"\" 输入月收入和五险一金计算个人所得税 \"\"\" salary = float(input('本月收入: ')) insurance = float(input('五险一金: ')) diff = salary - insurance - 3500 if diff 说明：上面的代码中使用了Python内置的abs()函数取绝对值来处理-0的问题。 "},"Python/Python语言基础/03-循环结构.html":{"url":"Python/Python语言基础/03-循环结构.html","title":"循环结构","keywords":"","body":"datetime:2019/5/14 9:49 author:nzb 循环结构 循环结构的应用场景 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个\"hello, world\"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for-in循环 如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环，例如下面代码中计算$\\sum_{n=1}^{100}n$。 \"\"\" 用for循环实现1~100求和 \"\"\" sum = 0 for x in range(101): sum += x print(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。 \"\"\" 用for循环实现1~100之间的偶数求和 \"\"\" sum = 0 for x in range(2, 101, 2): sum += x print(sum) 也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。 \"\"\" 用for循环实现1~100之间的偶数求和 \"\"\" sum = 0 for x in range(1, 101): if x % 2 == 0: sum += x print(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 \"\"\" 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 \"\"\" import random answer = random.randint(1, 100) counter = 0 while True: counter += 1 number = int(input('请输入: ')) if number answer: print('小一点') else: print('恭喜你猜对了!') break print('你总共猜了%d次' % counter) if counter > 7: print('你的智商余额明显不足') 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 \"\"\" 输出乘法口诀表(九九表) \"\"\" for i in range(1, 10): for j in range(1, i + 1): print('%d*%d=%d' % (i, j, i * j), end='\\t') print() 练习 练习1：输入一个数判断是不是素数。 \"\"\" 输入一个正整数判断它是不是素数 \"\"\" from math import sqrt num = int(input('请输入一个正整数: ')) end = int(sqrt(num)) is_prime = True for x in range(2, end + 1): if num % x == 0: is_prime = False break if is_prime and num != 1: print('%d是素数' % num) else: print('%d不是素数' % num) 练习2：输入两个正整数，计算最大公约数和最小公倍数。 \"\"\" 输入两个正整数计算最大公约数和最小公倍数 \"\"\" x = int(input('x = ')) y = int(input('y = ')) if x > y: x, y = y, x for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: print('%d和%d的最大公约数是%d' % (x, y, factor)) print('%d和%d的最小公倍数是%d' % (x, y, x * y // factor)) break 练习3：打印三角形图案。 \"\"\" 打印各种三角形图案 * ** *** **** ***** * ** *** **** ***** * *** ***** ******* ********* \"\"\" row = int(input('请输入行数: ')) for i in range(row): for _ in range(i + 1): print('*', end='') print() for i in range(row): for j in range(row): if j "},"Python/Python语言基础/04-练习.html":{"url":"Python/Python语言基础/04-练习.html","title":"构造程序逻辑","keywords":"","body":"datetime:2019/5/14 9:51 author:nzb 练习 练习清单 寻找“水仙花数”。 寻找“完美数”。 “百钱百鸡”问题。 生成“斐波拉切数列”。 Craps赌博游戏。 "},"Python/Python语言基础/05-函数和模块的使用.html":{"url":"Python/Python语言基础/05-函数和模块的使用.html","title":"函数和模块的使用","keywords":"","body":"datetime:2019/5/14 9:54 author:nzb 函数和模块的使用 在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。 $$x_1 + x_2 + x_3 + x_4 = 8$$ 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。 $$C_M^N =\\frac{M!}{N!(M-N)!}, \\text{(M=7, N=3)} $$ 可以用Python的程序来计算出这个值，代码如下所示。 \"\"\" 输入M和N计算C(M,N) \"\"\" m = int(input('m = ')) n = int(input('n = ')) fm = 1 for num in range(1, m + 1): fm *= num fn = 1 for num in range(1, n + 1): fn *= num fmn = 1 for num in range(1, m - n + 1): fmn *= num print(fm // fn // fmn) 函数的作用 不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数 在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。 def factorial(num): \"\"\" 求阶乘 :param num: 非负整数 :return: num的阶乘 \"\"\" result = 1 for n in range(1, num + 1): result *= n return result m = int(input('m = ')) n = int(input('n = ')) # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数 print(factorial(m) // factorial(n) // factorial(m - n)) 说明：Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。 函数的参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 from random import randint def roll_dice(n=2): \"\"\" 摇色子 :param n: 色子的个数 :return: n颗色子点数之和 \"\"\" total = 0 for _ in range(n): total += randint(1, 6) return total def add(a=0, b=0, c=0): return a + b + c # 如果没有指定参数那么使用默认值摇两颗色子 print(roll_dice()) # 摇三颗色子 print(roll_dice(3)) print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) # 传递参数时可以不按照设定的顺序进行传递 print(add(c=50, a=100, b=200)) 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 # 在参数名前面的*表示args是一个可变参数 # 即在调用add函数时可以传入0个或多个参数 def add(*args): total = 0 for val in args: total += val return total print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) print(add(1, 3, 5, 7, 9)) 用模块管理函数 对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 def foo(): print('hello, world!') def foo(): print('goodbye, world!') # 下面的代码会输出什么呢？ foo() 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。 module1.py def foo(): print('hello, world!') module2.py def foo(): print('goodbye, world!') test.py from module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py import module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py from module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py from module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。 module3.py def foo(): pass def bar(): pass # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py import module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习 练习1：实现计算求最大公约数和最小公倍数的函数。 def gcd(x, y): (x, y) = (y, x) if x > y else (x, y) for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: return factor def lcm(x, y): return x * y // gcd(x, y) 练习2：实现判断一个数是不是回文数的函数。 def is_palindrome(num): temp = num total = 0 while temp > 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数。 def is_prime(num): for factor in range(2, num): if num % factor == 0: return False return True if num != 1 else False 练习4：写一个程序判断输入的正整数是不是回文素数。 if __name__ == '__main__': num = int(input('请输入正整数: ')) if is_palindrome(num) and is_prime(num): print('%d是回文素数' % num) 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题。 def foo(): b = 'hello' def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not defined if __name__ == '__main__': a = 100 # print(b) # NameError: name 'b' is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 def foo(): a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 def foo(): global a a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收)。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包)，这个我们在后续的内容中进行讲解。 说明：很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基百科或者知乎上对这个概念的讨论。 说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。 def main(): # Todo: Add your code here pass if __name__ == '__main__': main() "},"Python/Python语言基础/06-字符串和常用数据结构.html":{"url":"Python/Python语言基础/06-字符串和常用数据结构.html","title":"字符串和常用数据结构","keywords":"","body":"datetime:2019/5/14 9:57 author:nzb 字符串和常用数据结构 使用字符串 第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，一般记为$${\\displaystyle s=a{1}a{2}\\dots a_{n}(0\\leq n \\leq \\infty)}$$。 我们可以通过下面的代码来了解字符串的使用。 def main(): str1 = 'hello, world!' # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find('or')) # 8 print(str1.find('shit')) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index('or')) # print(str1.index('shit')) # 检查字符串是否以指定的字符串开头 print(str1.startswith('He')) # False print(str1.startswith('hel')) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith('!')) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, ' ')) str2 = 'abc123456' # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = ' jackfrued@126.com ' print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip()) if __name__ == '__main__': main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。 使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。 def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。 def main(): fruits = ['grape', 'apple', 'strawberry', 'waxberry'] fruits += ['pitaya', 'pear', 'mango'] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=' ') print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5) if __name__ == '__main__': main() 下面的代码实现了对列表的排序操作。 def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == '__main__': main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。 import sys def main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： $${\\displaystyle F_{0}=0}$$ $${\\displaystyle F_{1}=1}$$ $${\\displaystyle F{n}=F{n-1}+F_{n-2} }({n}\\geq{2})$$ def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == '__main__': main() 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 def main(): # 定义元组 t = ('骆昊', 38, True, '四川成都') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。 使用集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 def main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 & set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 = set2) # print(set1.issuperset(set2)) print(set1 >= set3) # print(set1.issuperset(set3)) if __name__ == '__main__': main() 说明：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典 字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 def main(): scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82} # 通过键可以获取字典中对应的值 print(scores['骆昊']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\\t--->\\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('骆昊', 100)) # 清空字典 scores.clear() print(scores) if __name__ == '__main__': main() 练习 练习1：在屏幕上显示跑马灯文字 import os import time def main(): content = '北京欢迎你为你开天辟地…………' while True: # 清理屏幕上的输出 os.system('cls') # os.system('clear') print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0] if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。 import random def generate_code(code_len=4): \"\"\" 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 \"\"\" all_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' last_pos = len(all_chars) - 1 code = '' for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。 def get_suffix(filename, has_dot=False): \"\"\" 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 \"\"\" pos = filename.rfind('.') if 0 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。 def max2(x): m1, m2 = (x[0], x[1]) if x[0] > x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] > m1: m2 = m1 m1 = x[index] elif x[index] > m2: m2 = x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天 def is_leap_year(year): \"\"\" 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False \"\"\" return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): \"\"\" 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 \"\"\" days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + date def main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1)) if __name__ == '__main__': main() 练习6：打印杨辉三角。 def main(): num = int(input('Number of rows: ')) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end='\\t') print() if __name__ == '__main__': main() 综合案例 案例1：双色球选号 from random import randrange, randint, sample def display(balls): \"\"\" 输出列表中的双色球号码 \"\"\" for index, ball in enumerate(balls): if index == len(balls) - 1: print('|', end=' ') print('%02d' % ball, end=' ') print() def random_select(): \"\"\" 随机选择一组号码 \"\"\" red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_balls def main(): n = int(input('机选几注: ')) for _ in range(n): display(random_select()) if __name__ == '__main__': main() 说明：上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。 综合案例2：约瑟夫环问题 \"\"\" 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 \"\"\" def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter 综合案例3：井字棋游戏 import os def print_board(board): print(board['TL'] + '|' + board['TM'] + '|' + board['TR']) print('-+-+-') print(board['ML'] + '|' + board['MM'] + '|' + board['MR']) print('-+-+-') print(board['BL'] + '|' + board['BM'] + '|' + board['BR']) def main(): init_board = { 'TL': ' ', 'TM': ' ', 'TR': ' ', 'ML': ' ', 'MM': ' ', 'MR': ' ', 'BL': ' ', 'BM': ' ', 'BR': ' ' } begin = True while begin: curr_board = init_board.copy() begin = False turn = 'x' counter = 0 os.system('clear') print_board(curr_board) while counter 说明：最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。 "},"Python/Python语言基础/07-面向对象编程基础.html":{"url":"Python/Python语言基础/07-面向对象编程基础.html","title":"面向对象编程基础","keywords":"","body":"datetime:2019/5/14 10:11 author:nzb 面向对象编程基础 活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是“面向对象编程”，我们先来看看比较正式的说法。 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。 这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于知乎。 说明：以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。 之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，“软件危机”、“软件工程”等一系列的概念开始在行业中出现。 当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“银弹”，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。 说明：当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。 类和对象 简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。 定义类 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_av(self): if self.age 说明：写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象 当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。 def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student('骆昊', 38) # 给对象发study消息 stu1.study('Python程序设计') # 给对象发watch_av消息 stu1.watch_av() stu2 = Student('王大锤', 15) stu2.study('思想品德') stu2.watch_av() if __name__ == '__main__': main() 访问可见性问题 对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo) if __name__ == \"__main__\": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Test('hello') test._Test__bar() print(test._Test__foo) if __name__ == \"__main__\": main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解。 面向对象的支柱 面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习 练习1：定义一个类描述数字时钟 class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): \"\"\"初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 \"\"\" self._hour = hour self._minute = minute self._second = second def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 from math import sqrt class Point(object): def __init__(self, x=0, y=0): \"\"\"初始化方法 :param x: 横坐标 :param y: 纵坐标 \"\"\" self.x = x self.y = y def move_to(self, x, y): \"\"\"移动到指定位置 :param x: 新的横坐标 \"param y: 新的纵坐标 \"\"\" self.x = x self.y = y def move_by(self, dx, dy): \"\"\"移动指定的增量 :param dx: 横坐标的增量 \"param dy: 纵坐标的增量 \"\"\" self.x += dx self.y += dy def distance_to(self, other): \"\"\"计算与另一个点的距离 :param other: 另一个点 \"\"\" dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y)) def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) if __name__ == '__main__': main() 说明：本章中的插图来自于Grady Booch等著作的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。 "},"Python/Python语言基础/08-面向对象编程进阶.html":{"url":"Python/Python语言基础/08-面向对象编程进阶.html","title":"面向对象编程进阶","keywords":"","body":"datetime:2019/5/14 10:30 author:nzb 面向对象进阶 在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器 之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 class Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age __slots__魔法 我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age 静态方法和类方法 之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 from math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b > c and b + c > a and a + c > b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.') if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 from time import time, localtime, sleep class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态 刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age >= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name) class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course)) class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course)) def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av() if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 from abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" pass class Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname) class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname) def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice() if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 综合案例 案例1：奥特曼打小怪兽 from abc import ABCMeta, abstractmethod from random import randint, randrange class Fighter(object, metaclass=ABCMeta): \"\"\"战斗者\"\"\" # 通过__slots__魔法限定对象可以绑定的成员变量 __slots__ = ('_name', '_hp') def __init__(self, name, hp): \"\"\"初始化方法 :param name: 名字 :param hp: 生命值 \"\"\" self._name = name self._hp = hp @property def name(self): return self._name @property def hp(self): return self._hp @hp.setter def hp(self, hp): self._hp = hp if hp >= 0 else 0 @property def alive(self): return self._hp > 0 @abstractmethod def attack(self, other): \"\"\"攻击 :param other: 被攻击的对象 \"\"\" pass class Ultraman(Fighter): \"\"\"奥特曼\"\"\" __slots__ = ('_name', '_hp', '_mp') def __init__(self, name, hp, mp): \"\"\"初始化方法 :param name: 名字 :param hp: 生命值 :param mp: 魔法值 \"\"\" super().__init__(name, hp) self._mp = mp def attack(self, other): other.hp -= randint(15, 25) def huge_attack(self, other): \"\"\"究极必杀技(打掉对方至少50点或四分之三的血) :param other: 被攻击的对象 :return: 使用成功返回True否则返回False \"\"\" if self._mp >= 50: self._mp -= 50 injury = other.hp * 3 // 4 injury = injury if injury >= 50 else 50 other.hp -= injury return True else: self.attack(other) return False def magic_attack(self, others): \"\"\"魔法攻击 :param others: 被攻击的群体 :return: 使用魔法成功返回True否则返回False \"\"\" if self._mp >= 20: self._mp -= 20 for temp in others: if temp.alive: temp.hp -= randint(10, 15) return True else: return False def resume(self): \"\"\"恢复魔法值\"\"\" incr_point = randint(1, 10) self._mp += incr_point return incr_point def __str__(self): return '~~~%s奥特曼~~~\\n' % self._name + \\ '生命值: %d\\n' % self._hp + \\ '魔法值: %d\\n' % self._mp class Monster(Fighter): \"\"\"小怪兽\"\"\" __slots__ = ('_name', '_hp') def attack(self, other): other.hp -= randint(10, 20) def __str__(self): return '~~~%s小怪兽~~~\\n' % self._name + \\ '生命值: %d\\n' % self._hp def is_any_alive(monsters): \"\"\"判断有没有小怪兽是活着的\"\"\" for monster in monsters: if monster.alive > 0: return True return False def select_alive_one(monsters): \"\"\"选中一只活着的小怪兽\"\"\" monsters_len = len(monsters) while True: index = randrange(monsters_len) monster = monsters[index] if monster.alive > 0: return monster def display_info(ultraman, monsters): \"\"\"显示奥特曼和小怪兽的信息\"\"\" print(ultraman) for monster in monsters: print(monster, end='') def main(): u = Ultraman('骆昊', 1000, 120) m1 = Monster('狄仁杰', 250) m2 = Monster('白元芳', 500) m3 = Monster('王大锤', 750) ms = [m1, m2, m3] fight_round = 1 while u.alive and is_any_alive(ms): print('========第%02d回合========' % fight_round) m = select_alive_one(ms) # 选中一只小怪兽 skill = randint(1, 10) # 通过随机数选择使用哪种技能 if skill 0: # 如果选中的小怪兽没有死就回击奥特曼 print('%s回击了%s.' % (m.name, u.name)) m.attack(u) display_info(u, ms) # 每个回合结束后显示奥特曼和小怪兽的信息 fight_round += 1 print('\\n========战斗结束!========\\n') if u.alive > 0: print('%s奥特曼胜利!' % u.name) else: print('小怪兽胜利!') if __name__ == '__main__': main() 案例2：扑克游戏 import random class Card(object): \"\"\"一张牌\"\"\" def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face == 1: face_str = 'A' elif self._face == 11: face_str = 'J' elif self._face == 12: face_str = 'Q' elif self._face == 13: face_str = 'K' else: face_str = str(self._face) return '%s%s' % (self._suite, face_str) def __repr__(self): return self.__str__() class Poker(object): \"\"\"一副牌\"\"\" def __init__(self): self._cards = [Card(suite, face) for suite in '♠♥♣♦' for face in range(1, 14)] self._current = 0 @property def cards(self): return self._cards def shuffle(self): \"\"\"洗牌(随机乱序)\"\"\" self._current = 0 random.shuffle(self._cards) @property def next(self): \"\"\"发牌\"\"\" card = self._cards[self._current] self._current += 1 return card @property def has_next(self): \"\"\"还有没有牌\"\"\" return self._current 说明：大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。 案例3：工资结算系统 \"\"\" 某公司有三种类型的员工 分别是部门经理、程序员和销售员 需要设计一个工资结算系统 根据提供的员工信息来计算月薪 部门经理的月薪是每月固定15000元 程序员的月薪按本月工作时间计算 每小时150元 销售员的月薪是1200元的底薪加上销售额5%的提成 \"\"\" from abc import ABCMeta, abstractmethod class Employee(object, metaclass=ABCMeta): \"\"\"员工\"\"\" def __init__(self, name): \"\"\" 初始化方法 :param name: 姓名 \"\"\" self._name = name @property def name(self): return self._name @abstractmethod def get_salary(self): \"\"\" 获得月薪 :return: 月薪 \"\"\" pass class Manager(Employee): \"\"\"部门经理\"\"\" def get_salary(self): return 15000.0 class Programmer(Employee): \"\"\"程序员\"\"\" def __init__(self, name, working_hour=0): super().__init__(name) self._working_hour = working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour > 0 else 0 def get_salary(self): return 150.0 * self._working_hour class Salesman(Employee): \"\"\"销售员\"\"\" def __init__(self, name, sales=0): super().__init__(name) self._sales = sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales if sales > 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05 def main(): emps = [ Manager('刘备'), Programmer('诸葛亮'), Manager('曹操'), Salesman('荀彧'), Salesman('吕布'), Programmer('张辽'), Programmer('赵云') ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name)) elif isinstance(emp, Salesman): emp.sales = float(input('请输入%s本月销售额: ' % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print('%s本月工资为: ￥%s元' % (emp.name, emp.get_salary())) if __name__ == '__main__': main() "},"Python/Python语言基础/09-图形用户界面和游戏开发.html":{"url":"Python/Python语言基础/09-图形用户界面和游戏开发.html","title":"图形用户界面和游戏开发","keywords":"","body":"datetime:2019/5/14 11:44 author:nzb 图形用户界面和游戏开发 基于tkinter模块的GUI GUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。 下面的代码演示了如何使用tkinter做一个简单的GUI应用。 import tkinter import tkinter.messagebox def main(): flag = True # 修改标签上的文字 def change_label_text(): nonlocal flag flag = not flag color, msg = ('red', 'Hello, world!')\\ if flag else ('blue', 'Goodbye, world!') label.config(text=msg, fg=color) # 确认退出 def confirm_to_quit(): if tkinter.messagebox.askokcancel('温馨提示', '确定要退出吗?'): top.quit() # 创建顶层窗口 top = tkinter.Tk() # 设置窗口大小 top.geometry('240x160') # 设置窗口标题 top.title('小游戏') # 创建标签对象并添加到顶层窗口 label = tkinter.Label(top, text='Hello, world!', font='Arial -32', fg='red') label.pack(expand=1) # 创建一个装按钮的容器 panel = tkinter.Frame(top) # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数 button1 = tkinter.Button(panel, text='修改', command=change_label_text) button1.pack(side='left') button2 = tkinter.Button(panel, text='退出', command=confirm_to_quit) button2.pack(side='right') panel.pack(side='bottom') # 开启主事件循环 tkinter.mainloop() if __name__ == '__main__': main() 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。 使用Pygame进行游戏开发 Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。 下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。 制作游戏窗口 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 在窗口中绘图 可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((242, 242, 242)) # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆) pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 加载图像 如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((255, 255, 255)) # 通过指定的文件名加载图像 ball_image = pygame.image.load('./res/ball.png') # 在窗口上渲染图像 screen.blit(ball_image, (50, 50)) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 实现动画效果 说到动画这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 定义变量来表示小球在屏幕上的位置 x, y = 50, 50 running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False screen.fill((255, 255, 255)) pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0) pygame.display.flip() # 每隔50毫秒就改变小球的位置再刷新窗口 pygame.time.delay(50) x, y = x + 5, y + 5 if __name__ == '__main__': main() 碰撞检测 通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。 from enum import Enum, unique from math import sqrt from random import randint import pygame @unique class Color(Enum): \"\"\"颜色\"\"\" RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0) WHITE = (255, 255, 255) GRAY = (242, 242, 242) @staticmethod def random_color(): \"\"\"获得随机颜色\"\"\" r = randint(0, 255) g = randint(0, 255) b = randint(0, 255) return (r, g, b) class Ball(object): \"\"\"球\"\"\" def __init__(self, x, y, radius, sx, sy, color=Color.RED): \"\"\"初始化方法\"\"\" self.x = x self.y = y self.radius = radius self.sx = sx self.sy = sy self.color = color self.alive = True def move(self, screen): \"\"\"移动\"\"\" self.x += self.sx self.y += self.sy if self.x - self.radius = screen.get_width(): self.sx = -self.sx if self.y - self.radius = screen.get_height(): self.sy = -self.sy def eat(self, other): \"\"\"吃其他球\"\"\" if self.alive and other.alive and self != other: dx, dy = self.x - other.x, self.y - other.y distance = sqrt(dx ** 2 + dy ** 2) if distance other.radius: other.alive = False self.radius = self.radius + int(other.radius * 0.146) def draw(self, screen): \"\"\"在窗口上绘制球\"\"\" pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius, 0) 事件处理 可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。 def main(): # 定义用来装所有球的容器 balls = [] # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # 处理鼠标事件的代码 if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: # 获得点击鼠标的位置 x, y = event.pos radius = randint(10, 100) sx, sy = randint(-10, 10), randint(-10, 10) color = Color.random_color() # 在点击鼠标的位置创建一个球(大小、速度和颜色随机) ball = Ball(x, y, radius, sx, sy, color) # 将球添加到列表容器中 balls.append(ball) screen.fill((255, 255, 255)) # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除 for ball in balls: if ball.alive: ball.draw(screen) else: balls.remove(ball) pygame.display.flip() # 每隔50毫秒就改变球的位置再刷新窗口 pygame.time.delay(50) for ball in balls: ball.move(screen) # 检查球有没有吃到其他的球 for other in balls: ball.eat(other) if __name__ == '__main__': main() 上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是pygame的官方网站，如果英语没毛病就可以赶紧去看看啦。 如果想开发3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看Panda3D。 "},"Python/Python语言基础/10-文件和异常.html":{"url":"Python/Python语言基础/10-文件和异常.html","title":"文件和异常","keywords":"","body":"datetime:2019/5/14 13:49 author:nzb 文件和异常 在实际开发中，常常需要对程序中的数据进行持久化操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 'r' 读取 （默认） 'w' 写入（会先截断之前的内容） 'x' 写入，如果文件已经存在会产生异常 'a' 追加，将内容写入到已有文件的末尾 'b' 二进制模式 't' 文本模式（默认） '+' 更新（既可以读又可以写） 下面这张图来自于菜鸟教程网站，它展示了如果根据应用程序的需要来设置操作模式。 读写文本文件 读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 def main(): f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) f.close() if __name__ == '__main__': main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 def main(): f = None try: f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close() if __name__ == '__main__': main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。 def main(): try: with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') if __name__ == '__main__': main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示。 import time def main(): # 一次性读取整个文件内容 with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('致橡树.txt', mode='r') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('致橡树.txt') as f: lines = f.readlines() print(lines) if __name__ == '__main__': main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为'w'即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为'a'。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999直接的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。 from math import sqrt def is_prime(n): \"\"\"判断素数的函数\"\"\" assert n > 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else False def main(): filenames = ('a.txt', 'b.txt', 'c.txt') fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number 读写二进制文件 知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.') if __name__ == '__main__': main() 读写JSON文件 通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 { 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ {'brand': 'BYD', 'max_speed': 180}, {'brand': 'Audi', 'max_speed': 280}, {'brand': 'Benz', 'max_speed': 320} ] } 可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。 JSON Python object dict array list string str number (int / real) int / float true / false True / False null None Python JSON dict object list, tuple array str string int, float, int- & float-derived Enums number True / False true / false None null 我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。 import json def main(): mydict = { 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ {'brand': 'BYD', 'max_speed': 180}, {'brand': 'Audi', 'max_speed': 280}, {'brand': 'Benz', 'max_speed': 320} ] } try: with open('data.json', 'w', encoding='utf-8') as fs: json.dump(mydict, fs) except IOError as e: print(e) print('保存数据完成!') if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了天行数据提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。 import requests import json def main(): resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&num=10') data_model = json.loads(resp.text) for news in data_model['newslist']: print(news['title']) if __name__ == '__main__': main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。 "},"Python/Python语言基础/11-字符串和正则表达式.html":{"url":"Python/Python语言基础/11-字符串和正则表达式.html","title":"字符串和正则表达式","keywords":"","body":"datetime:2019/5/14 14:14 author:nzb 使用正则表达式 正则表达式相关知识 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 匹配不在字符集中的任意单一字符 aeiou 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I'm dancing中的danc (? 匹配exp后面的位置 (? 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明：如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 \"\"\" 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 \"\"\" import re def main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!') if __name__ == '__main__': main() 提示：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。 下面这张图是截止到2017年底，国内三家运营商推出的手机号段。 import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(? 说明：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容 import re def main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == '__main__': main() 说明：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串 import re def main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡'] if __name__ == '__main__': main() 后话 如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。 "},"Python/Python语言基础/12-进程和线程.html":{"url":"Python/Python语言基础/12-进程和线程.html","title":"进程和线程","keywords":"","body":"datetime:2019/5/14 16:42 author:nzb 进程和线程 今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程 进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。 Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 from random import randint from time import time, sleep def download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 开始下载Python从入门到住院.pdf... Python从入门到住院.pdf下载完成! 耗费了6秒 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 from multiprocessing import Process from os import getpid from random import randint from time import time, sleep def download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 启动下载进程，进程号[1530]. 开始下载Python从入门到住院.pdf... 启动下载进程，进程号[1531]. 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 Python从入门到住院.pdf下载完成! 耗费了10秒 总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 from multiprocessing import Process from time import sleep counter = 0 def sub_task(string): global counter while counter 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 父进程和子进程 注意：进程间不共享全局变量 进程之间的通信-Queue 在初始化Queue()对象时（例如 q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头） Queue.qsize()：返回当前队列包含的消息数量 Queue.empty()：如果队列为空，返回True，反之False Queue.full()：如果队列满了，返回True,反之False Queue.get([block[,timeout]])：获取队列中的一条消息，然后将其从队列中移除， block默认值为True。如果block使用默认值，且没有设置 timeout（单位秒）,消息队列如果为空， 此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了 timeout，则会等待 timeout 秒， 若还没读取到任何消息，则抛出 Queue.Empty 异常： Queue.get_nowait() 相当于 Queue.get(False) Queue.put(item,[block[,timeout]])：将 item 消息写入队列，block 默认值为 True; 如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态）， 直到从消息队列腾出空间为止，如果设置了 timeout，则会等待 timeout 秒，若还没空间，则抛出 Queue.Full 异常 如果block值为 False，消息队列如果没有空间可写入，则会立刻抛出 Queue.Full 异常; Queue.put_nowait(item)：相当 Queue.put(item,False) from multiprocessing import Process, Queue import os, time, random # 写数据进程执行的代码： def write(q): for value in ['A', 'B', 'C']: print(\"Put {} to queue...\".format(value)) q.put(value) time.sleep(0.5) # 读数据进程执行的代码 def read(q): while True: if not q.empty(): value = q.get(True) print(\"Get {} from queue.\".format(value)) time.sleep(0.5) else: break if __name__ == '__main__': # 父进程创建Queue，并传给各个子进程 q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw ，写入： pw.start() # 等待pw结束 pw.join() # 启动子进程pr，读取： pr.start() pr.join() # pr 进程里是死循环，无法等待其结束，只能强行终止: print('') print(os.getpid()) print('所有数据都写入并且读完') 进程池 ```python from multiprocessing import Pool import os import time import random def worker(msg): t_start = time.time() print(\"%s开始执行,进程号为%d\" % (msg, os.getpid())) # random.random()随机生成0~1之间的浮点数 time.sleep(random.random() * 2) t_stop = time.time() print(msg, \"执行完毕，耗时%0.2f\" % (t_stop - t_start)) if name == \"main\": po = Pool(3) # 定义一个进程池，最大进程数3 for i in range(0, 8): # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(worker, (i,)) print(\"----start----\") # 关闭进程池，关闭后po不再接收新的请求 po.close() # 等待po中所有子进程执行完成，必须放在close语句之后 po.join() print(\"-----end-----\") - 进程池中使用 Queue 如果要使用 Pool 创建进程，就需要使用 multiprocessing.Manager() 中的 Queue() ,而不是 multiprocessing.Queue() ,否则会得到如下的错误信息： `RuntimeError： Queue objects should only be shared between processs through inheritance` ```python from multiprocessing import Manager, Pool import os, time, random def reader(q): print(\"reader 启动(%s),父进程为（%s)\" % (os.getpid(), os.getpid())) for i in range(q.qsize()): print(\"reader 从Queue获取到消息:%s\" % q.get(True)) def writer(q): print(\"writer 启动（%s),父进程为(%s)\" % (os.getpid(), os.getpid())) for i in \"itcast\": q.put(i) if __name__ == \"__main__\": print(\"(%s)start\" % os.getpid()) q = Manager().Queue() # 使用Manager中的Queue po = Pool() po.apply_async(writer, (q,)) time.sleep(1) po.apply_async(reader, (q,)) po.close() po.join() print(\"(%s)End\" % os.getpid()) Python中的多线程 在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 from random import randint from threading import Thread from time import time, sleep def download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start)) if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 from random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download)) def main(): start = time() # 将多个下载任务放到多个线程中执行 # 通过自定义的线程类创建线程对象 线程启动后会回调执行run方法 t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 from time import sleep from threading import Thread class Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance) if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 from time import sleep from threading import Thread, Lock class Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance) if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明：上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O 现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 import time import tkinter import tkinter.messagebox def download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') def main(): top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop() if __name__ == '__main__': main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 import time import tkinter import tkinter.messagebox from threading import Thread def main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop() if __name__ == '__main__': main() 例子2：使用多进程对复杂任务进行“分而治之”。 我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 from time import time def main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start)) if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 from multiprocessing import Process, Queue from random import randint from time import time def task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total) def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='') if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 示例代码： 异步I/O操作 - asyncio模块 import asyncio import threading # import time @asyncio.coroutine def hello(): print('%s: hello, world!' % threading.current_thread()) # 休眠不会阻塞主线程因为使用了异步I/O操作 # 注意有yield from才会等待休眠操作执行完成 yield from asyncio.sleep(2) # asyncio.sleep(1) # time.sleep(1) print('%s: goodbye, world!' % threading.current_thread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] # 等待两个异步I/O操作执行结束 loop.run_until_complete(asyncio.wait(tasks)) print('game over!') loop.close() 异步I/O操作 - async和await import asyncio import threading # 通过async修饰的函数不再是普通函数而是一个协程 # 注意async和await将在Python 3.7中作为关键字出现 async def hello(): print('%s: hello, world!' % threading.current_thread()) await asyncio.sleep(2) print('%s: goodbye, world!' % threading.current_thread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] # 等待两个异步I/O操作执行结束 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 异步I/O操作 - asyncio模块 import asyncio async def wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) # 异步方式等待连接结果 reader, writer = await connect header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host writer.write(header.encode('utf-8')) # 异步I/O方式执行写操作 await writer.drain() while True: # 异步I/O方式执行读操作 line = await reader.readline() if line == b'\\r\\n': break print('%s header > %s' % (host, line.decode('utf-8').rstrip())) writer.close() loop = asyncio.get_event_loop() # 通过生成式语法创建一个装了三个协程的列表 hosts_list = ['www.sina.com.cn', 'www.sohu.com', 'www.163.com'] tasks = [wget(host) for host in hosts_list] # 下面的方法将异步I/O操作放入EventLoop直到执行完毕 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 使用协程 - 模拟快递中心派发快递 from time import sleep from random import random def build_deliver_man(man_id): total = 0 while True: total += 1 print('%d号快递员准备接今天的第%d单.' % (man_id, total)) pkg = yield print('%d号快递员收到编号为%s的包裹.' % (man_id, pkg)) sleep(random() * 3) def package_center(deliver_man, max_per_day): num = 1 deliver_man.send(None) # next(deliver_man) while num 使用协程 - 查看协程的状态 from time import sleep from inspect import getgeneratorstate def build_deliver_man(man_id): total = 0 while True: total += 1 print('%d号快递员准备接今天的第%d单.' % (man_id, total)) pkg = yield print('%d号快递员收到编号为%s的包裹.' % (man_id, pkg)) sleep(0.5) def package_center(deliver_man, max_per_day): num = 1 # 创建状态(GEN_CREATED) - 等待开始执行 print(getgeneratorstate(deliver_man)) deliver_man.send(None) # 挂起状态(GEN_SUSPENDED) - 在yield表达式处暂停 print(getgeneratorstate(deliver_man)) # next(deliver_man) while num 使用Process类创建多个进程 # 通过下面程序的执行结果可以证实 父进程在创建子进程时复制了进程及其数据结构 # 每个进程都有自己独立的内存空间 所以进程之间共享数据只能通过IPC的方式 from multiprocessing import Process, Queue from time import sleep def sub_task(string, q): number = q.get() while number: print('%d: %s' % (number, string)) sleep(0.001) number = q.get() def main(): q = Queue(10) for number in range(1, 11): q.put(number) Process(target=sub_task, args=('Ping', q)).start() Process(target=sub_task, args=('Pong', q)).start() if __name__ == '__main__': main() 实现进程间的通信 import multiprocessing import os def sub_task(queue): print('子进程进程号:', os.getpid()) counter = 0 while counter 创建进程调用其他程序 import subprocess import sys def main(): # 通过sys.argv获取命令行参数 if len(sys.argv) > 1: # 第一个命令行参数是程序本身所以从第二个开始取 for index in range(1, len(sys.argv)): try: # 通过subprocess模块的call函数启动子进程 status = subprocess.call(sys.argv[index]) except FileNotFoundError: print('不能执行%s命令' % sys.argv[index]) else: print('请使用命令行参数指定要执行的进程') if __name__ == '__main__': main() 使用多线程的情况 - 模拟多个下载任务 from random import randint from time import time, sleep import atexit import _thread def download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) print('剩余时间%d秒.' % time_to_download) sleep(time_to_download) print('%s下载完成!' % filename) def shutdown_hook(start): end = time() print('总共耗费了%.3f秒.' % (end - start)) def main(): start = time() # 将多个下载任务放到多个线程中执行 thread1 = _thread.start_new_thread(download_task, ('Python从入门到住院.pdf',)) thread2 = _thread.start_new_thread(download_task, ('Peking Hot.avi',)) # 注册关机钩子在程序执行结束前计算执行时间 atexit.register(shutdown_hook, start) if __name__ == '__main__': main() # 执行这里的代码会引发致命错误(不要被这个词吓到) 因为主线程结束后下载线程再想执行就会出问题 # 需要说明一下 由于_thread模块属于比较底层的线程操作而且不支持守护线程的概念 # 在实际开发中会有诸多不便 因此我们推荐使用threading模块提供的高级操作进行多线程编程 "},"Python/Python语言基础/13-网络编程入门.html":{"url":"Python/Python语言基础/13-网络编程入门.html","title":"网络编程入门","keywords":"","body":"datetime:2019/5/14 17:35 author:nzb 网络编程入门 计算机网络基础 计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。 计算机网络发展史 1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。 1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。 1990s - 英国人蒂姆·伯纳斯-李发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。 在没有浏览器的年代，上网是这样的。 有了浏览器以后，上网是这样的。 TCP/IP模型 实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问 HTTP（超文本传输协议） HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式 JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： Alice Bob Will you marry me? JSON的例子： { 'from': 'Alice', 'to': 'Bob', 'content': 'Will you marry me?' } requests库 requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。 我们可以先通过pip安装requests及其依赖库。 pip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。 from time import time from threading import Thread import requests # 继承Thread类创建自定义的线程类 class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url = url def run(self): filename = self.url[self.url.rfind('/') + 1:] resp = requests.get(self.url) with open('/Users/Hao/' + filename, 'wb') as f: f.write(resp.content) def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp = requests.get( 'http://api.tianapi.com/meinv/?key=APIKey&num=10') # 将服务器返回的JSON格式的数据解析为字典 data_model = resp.json() for mm_dict in data_model['newslist']: url = mm_dict['picUrl'] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start() if __name__ == '__main__': main() 基于传输层协议的套接字编程 套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字 所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 from socket import socket, SOCK_STREAM, AF_INET from datetime import datetime def main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close() if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 from socket import socket def main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close() if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： from socket import socket, SOCK_STREAM, AF_INET from base64 import b64encode from json import dumps from threading import Thread def main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start() if __name__ == '__main__': main() 客户端代码： from socket import socket from json import loads from base64 import b64decode def main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.') if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明：上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字 传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 "},"Python/Python语言基础/14-网络应用开发.html":{"url":"Python/Python语言基础/14-网络应用开发.html","title":"网络应用开发","keywords":"","body":"datetime:2019/5/14 17:51 author:nzb 网络应用开发 发送电子邮件 在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText def main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!') if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart import urllib def main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!') if __name__ == '__main__': main() 发送短信 发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 import urllib.parse import http.client import json def main(): host = \"106.ihuyi.com\" sms_send_uri = \"/webservice/sms.php?method=Submit\" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' }) print(params) headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close() if __name__ == '__main__': main() "},"Python/Python语言基础/15-图像和办公文档处理.html":{"url":"Python/Python语言基础/15-图像和办公文档处理.html","title":"图像和文档处理","keywords":"","body":"datetime:2019/5/14 17:55 author:nzb 图像和办公文档处理 用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。 操作图像 计算机图像相关知识 颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 | 名称 | RGBA值 | 名称 | RGBA值 | | :---: | :------------------: | :----: | :----------------: | | White | (255, 255, 255, 255) | Red | (255, 0, 0, 255) | | Green | (0, 255, 0, 255) | Blue | (0, 0, 255, 255) | | Gray | (128, 128, 128, 255) | Yellow | (255, 255, 0, 255) | | Black | (0, 0, 0, 255) | Purple | (128, 0, 128, 255) | 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 用Pillow操作图像 Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。 pip install pillow Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。 >>> from PIL import Image >>> >>> image = Image.open('./res/guido.jpg') >>> image.format, image.size, image.mode ('JPEG', (500, 750), 'RGB') >>> image.show() 剪裁图像 >>> image = Image.open('./res/guido.jpg') >>> rect = 80, 20, 310, 360 >>> image.crop(rect).show() 生成缩略图 >>> image = Image.open('./res/guido.jpg') >>> size = 128, 128 >>> image.thumbnail(size) >>> image.show() 缩放和黏贴图像 >>> image1 = Image.open('./res/luohao.png') >>> image2 = Image.open('./res/guido.jpg') >>> rect = 80, 20, 310, 360 >>> guido_head = image2.crop(rect) >>> width, height = guido_head.size >>> image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40)) 旋转和翻转 >>> image = Image.open('./res/guido.png') >>> image.rotata(180).show() >>> image.transpose(Image.FLIP_LEFT_RIGHT).show() 操作像素 >>> image = Image.open('./res/guido.jpg') >>> for x in range(80, 310): ... for y in range(20, 360): ... image.putpixel((x, y), (128, 128, 128)) ... >>> image.show() 滤镜效果 >>> from PIL import Image, ImageFilter >>> >>> image = Image.open('./res/guido.jpg') >>> image.filter(ImageFilter.CONTOUR).show() 处理Excel电子表格 Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，当然实际工作中，我们可能会用LibreOffice Calc和OpenOffice Calc来处理Excel的电子表格文件，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。关于openpyxl的使用手册和使用文档可以查看它的官方文档。 处理Word文档 利用python-docx模块，Pytho 可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。 处理PDF文档 PDF是Portable Document Format的缩写，使用.pdf作为文件扩展名。接下来我们就研究一下如何通过Python实现从PDF读取文本内容和从已有的文档生成新的PDF文件。 "},"Python/Python语言基础/16-logging日志模块.html":{"url":"Python/Python语言基础/16-logging日志模块.html","title":"logging日志模块","keywords":"","body":"datetime:2021/11/14 17:55 author:nzb logging 模块 基于 logging 实现日志，每天的日志记录到一个文件中。 例如：开发一个网站，4CPU 开 4个 进程(或 8个) 假设： 启动网站，创建 4个 进程，每个进程中都打开文件 a1.log， 每个进程中都有 # 每个进程都有各自文件对象 file_object = open(\"a1.log\", 'a', encoding='utf-8') 用户访问 # 其中 1个 进程接收并加以处理，执行自己的 write file_object.write('日志...') 同时来 4个 # 其中 4个 进程接收并处理，执行自己的 write file_object.write('日志...') logging 模块实现机制(自动切割日志的功能) 启动网站，创建 4个 进程，每个进程中都打开文件 a1.log， 每个进程中都有 # 每个进程都有各自文件对象 file_object = open(\"a1.log\", 'a', encoding='utf-8') 用户访问 # 其中 1个 进程接收并加以处理，执行自己的 write file_object.write('日志...') 同时来 4个 # 其中 4个 进程接收并处理，执行自己的 write file_object.write('日志...') 问题1：多进程写日志会导致删除 例如 11-18日 默认都会记录到 a1.log 文件中 到了 11-19日 判断 a1-11-19.log 文件是否存在，如果存在，就删除(导致多进程会一直删除文件)(优化，文件不存在，可以重命名；文件存在，继续在 a1.log 中写入日志) a1.log -> a1-11-19.log # 到 11.19 后 a1.log 重命名为 a1-11-19.log 然后再写入 a1.log 源码找原因 ```python import time import os from logging.handlers import BaseRotatingHandler class TimedRotatingFileHandler(BaseRotatingHandler): \"\"\" Handler for logging to a file, rotating the log file at certain timed intervals. If backupCount is > 0, when rollover is done, no more than backupCount files are kept - the oldest ones are deleted. \"\"\" def doRollover(self): \"\"\" do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. \"\"\" if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) # # 新文件名，a1-11-19.log # dfn = self.rotation_filename(self.baseFilename + \".\" + # time.strftime(self.suffix, timeTuple)) # # 判断是否存在，存在删除，问题就出在这，多进程时会删除其他进程创建备份的 # if os.path.exists(dfn): # os.remove(dfn) # # 重命名 # self.rotate(self.baseFilename, dfn) # 修复 dfn = self.rotation_filename(self.baseFilename + \".\" + time.strftime(self.suffix, timeTuple)) # 判断是否存在，不存在重命名 if not os.path.exists(dfn): self.rotate(self.baseFilename, dfn) if self.backupCount > 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt 问题2：日志文件不能做相关操作(比如：删除或修改日志文件，日志就不创建文件继续打印了，需要重新执行该程序，才会重新创建文件写入日志) # 类比 WatchedFileHandler 提供解决思路 import os import time from stat import ST_INO, ST_DEV file_obj = open('xxx.log', 'a', encoding='utf-8') sres = os.fstat(file_obj.fileno()) dev, ino = sres[ST_DEV], sres[ST_INO] while True: # WatchedFileHandler 处理 handler 的处理机制 # 删除文件之后报错 try: # stat the file by path, checking for existence new_sres = os.stat(\"xxx.log\") except FileNotFoundError: sres = None if not new_sres or new_sres[ST_DEV] != dev or new_sres[ST_INO] != ino: print(\"文件被删除或修改了\") # 重新打开，获取标志数据 file_obj = open('xxx.log', 'a', encoding='utf-8') sres = os.fstat(file_obj.fileno()) dev, ino = sres[ST_DEV], sres[ST_INO] file_obj.write(\"111\\n\") file_obj.flush() time.sleep(1) 多进程和文件修改(删除)后 2 个结合重写 handler logging Handler 源码解析(TimedRotatingFileHandler为例) import os import time from _stat import ST_INO from logging.handlers import TimedRotatingFileHandler import logging from stat import ST_DEV LOGGING_CONFIG = { \"version\": 1, \"disable_existing_loggers\": True, \"formatters\": { \"standard\": { \"format\": '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s', \"style\": \"%\" } }, \"handlers\": { \"error_file\": { \"class\": \"logging.handlers.CustomizeHandler\", # 自定义处理类 \"formatter\": \"standard\", \"filename\": \"a1.log\", \"when\": \"S\", # 根据天拆分日志, \"interval\": 10, # 1天 \"backupCount\": 2, # 备份数 \"encoding\": \"utf-8\" } }, \"loggers\": { \"\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True }, \"error\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True } } } \"\"\" 继承从下往上 1、实例化 CustomizeHandler 对象 logging.Filterer.__init__() logging.Handler.__init__() logging.StreamHandler.__init__() logging.FileHandler.__init__() BaseRotatingHandler.__init__() TimedRotatingFileHandler.__init__() # 接受了很多关键字参数，这些都是配置字典里面 handlers 里面的值 CustomizeHandler.__init__() # 看2、3点，发现关键点在于 self.baseFilename # 日志文件的绝对路径 self.stream = stream # 打开的文件对象 # 看第 4 点，需要写日志时 handler对象.emit(\"日志内容\") 把检测文件标识的代码移植到 emit 里面 2、FileHandler.__init__() class FileHandler(StreamHandler): def __init__(self, filename, mode='a', encoding=None, delay=False, errors=None): filename = os.fspath(filename) #keep the absolute path, otherwise derived classes which use this #may come a cropper when the current directory changes # 日志文件的绝对路径 self.baseFilename = os.path.abspath(filename) self.mode = mode self.encoding = encoding self.errors = errors self.delay = delay if delay: #We don't open the stream, but we still need to call the #Handler constructor to set level, formatter, lock etc. Handler.__init__(self) self.stream = None else: # self._open() 是打开文件对象返回的句柄 StreamHandler.__init__(self, self._open()) def _open(self): return open(self.baseFilename, self.mode, encoding=self.encoding, errors=self.errors) 3、StreamHandler.__init__() class StreamHandler(Handler): terminator = '\\n' def __init__(self, stream=None): Handler.__init__(self) if stream is None: stream = sys.stderr self.stream = stream # 关键点，这里赋值了 self.stream = 文件句柄 4、开始写日志：handler对象.emit(\"日志内容\") class BaseRotatingHandler(logging.FileHandler): def emit(self, record): try: # 判断是否已经过了设置的时间(比如第二天)，就重命名 if self.shouldRollover(record): self.doRollover() # 执行父类的写日志 logging.FileHandler.emit(self, record) except Exception: self.handleError(record) class FileHandler(StreamHandler): def emit(self, record): # 如果文件句柄为空，重新打开文件赋值 self.stream if self.stream is None: self.stream = self._open() # 执行父类的写日志 StreamHandler.emit(self, record) class StreamHandler(Handler): def emit(self, record): try: msg = self.format(record) # 按你设置的 formatter 格式化日志 stream = self.stream stream.write(msg + self.terminator) # 文件写入日志 self.flush() except RecursionError: # See issue 36272 raise except Exception: self.handleError(record) \"\"\" class CustomizeHandler(TimedRotatingFileHandler): def __init__(self, *args, **kwargs): \"\"\" 借鉴 WatchedFileHandler 的机制检测文件 :param args: :param kwargs: \"\"\" super().__init__(*args, **kwargs) self.dev, self.ino = -1, -1 self._statstream() # WatchedFileHandler 方法 def _statstream(self): if self.stream: sres = os.fstat(self.stream.fileno()) self.dev, self.ino = sres[ST_DEV], sres[ST_INO] # WatchedFileHandler 方法 def reopenIfNeeded(self): \"\"\" Reopen log file if needed. Checks if the underlying file has changed, and if it has, close the old stream and reopen the file to get the current stream. \"\"\" # Reduce the chance of race conditions by stat'ing by path only # once and then fstat'ing our new fd if we opened a new log stream. # See issue #14632: Thanks to John Mulligan for the problem report # and patch. try: # stat the file by path, checking for existence sres = os.stat(self.baseFilename) except FileNotFoundError: sres = None # compare file system stat with that of our stream file handle if not sres or sres[ST_DEV] != self.dev or sres[ST_INO] != self.ino: if self.stream is not None: # we have an open file handle, clean it up self.stream.flush() self.stream.close() self.stream = None # See Issue #21742: _open () might fail. # open a new file handle and get new stat info from that fd self.stream = self._open() self._statstream() def doRollover(self): \"\"\" do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. \"\"\" if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) dfn = self.rotation_filename(self.baseFilename + \".\" + time.strftime(self.suffix, timeTuple)) if not os.path.exists(dfn): # 修复多进程删除日志文件，只有不存在再重命名 self.rotate(self.baseFilename, dfn) if self.backupCount > 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt 思考：上面重写的 handler 类，会不会出现问题？ 答案：会的，比如多进程，第二天的时候所有的进程卡在时间特别短的时候，一起重命名，就会出现问题 解决：为什么不每天得日志都写入一个当天的日志，而不是重命名 每天写入当天日志 \"\"\" 继承从下往上 1、实例化 CustomizeHandler 对象 logging.Filterer.__init__() logging.Handler.__init__() logging.StreamHandler.__init__() logging.FileHandler.__init__() WatchedFileHandler.__init__() # 检测文件是否修改，删除的处理类 CustomizeOneDayOneLogHandler.__init__() \"\"\" from logging.handlers import WatchedFileHandler LOGGING_CONFIG = { \"version\": 1, \"disable_existing_loggers\": True, \"formatters\": { \"standard\": { \"format\": '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s', \"style\": \"%\" } }, \"handlers\": { \"error_file\": { \"class\": \"logging.handlers.TimedRotatingFileHandler\", \"formatter\": \"standard\", \"filepath\": \"logs\", \"encoding\": \"utf-8\" } }, \"loggers\": { \"\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True }, \"error\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True } } } class CustomizeOneDayOneLogHandler(WatchedFileHandler): \"\"\" 每天创建一个日志，每天的日志都打入当天的日志文件 文件名：a-2021-10-20.log, 不会出现 a-2021-10-20.log.2021-10-21 这样的 \"\"\" def __init__(self, file_path, file_name_prefix, mode='a', encoding=None, delay=False, errors=None): \"\"\" :param file_path: 日志文件路径 :param file_name_prefix: 日志文件前缀，就是 logging.getLogger(__name__) 获取，只是重下了 log 类继承 Logger，详细看下面 :param mode: :param encoding: :param delay: :param errors: \"\"\" if not os.path.exists(file_path): os.makedirs(file_path) self.file_path = file_path self.file_name_prefix = file_name_prefix self.file_name = self.get_file_name() filename = os.path.join(file_path, self.file_name) # errors py3.9 有这个参数，3.8、3.7没有(更早版本也可能是) # super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay, errors=errors) super(CustomizeOneDayOneLogHandler, self).__init__(filename=filename, mode=mode, encoding=encoding, delay=delay) def get_file_name(self): \"\"\" TODO 怎么切分可以这里实现，做成那个时间切分的参数配置 :return: 日志名称 \"\"\" # 一天分一次 return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime(\"%Y-%m-%d\")) # 一分钟分一次 # return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime('%Y-%m-%d-%H-%M')) def emit(self, record): \"\"\" Emit a record. If underlying file has changed, reopen the file before emitting the record to it. \"\"\" current_file_name = self.get_file_name() # 文件不一致，新建文件 + 重新打开 + 重新获取 os.stat if current_file_name != self.file_name: self.file_name = current_file_name # 重新赋值，当前的文件名应该是最新的日期 self.baseFilename = os.path.abspath(os.path.join(self.file_path, current_file_name)) if self.stream: self.stream.flush() self.stream.close() self.stream = self._open() self._statstream() super(CustomizeOneDayOneLogHandler, self).emit(record) 项目中使用 #!/usr/bin/env python # -*- coding:utf8 -*- __date__ = \"2021/10/20 11:20\" __doc__ = \"\"\"\"\"\" # 定义三种日志输出格式 开始 import datetime import glob import os import sys import time import traceback from logging import Logger from logging.handlers import WatchedFileHandler import logging.config standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' '[%(levelname)s][%(message)s]' # 其中 name 为 getlogger 指定的名字 simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s' # 第一种：每天一个日志文件 class CustomizeOneDayOneLogHandler(WatchedFileHandler): \"\"\" 每天创建一个日志，每天的日志都打入当天的日志文件 文件名：a-2021-10-20.log, 不会出现 a-2021-10-20.log.2021-10-21 这样的 \"\"\" def __init__(self, file_path, file_name_prefix, backup_count: int = 5, mode='a', encoding=None, delay=False, errors=None): \"\"\" :param file_path: 日志文件路径 :param file_name_prefix: 日志文件前缀 :param backup_count: 日志备份数量 :param mode: :param encoding: :param delay: :param errors: \"\"\" if not os.path.exists(file_path): os.makedirs(file_path) self.file_path = file_path self.file_name_prefix = file_name_prefix self.backup_count = backup_count self.file_name = self.get_file_name() filename = os.path.join(file_path, self.file_name) # errors py3.9 有这个参数，3.8、3.7没有(更早版本也可能是) # super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay, errors=errors) super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay) # 初始化的时候清理下，防止创建了文件不写入，导致空日志文件过多 self.auto_clear() def get_file_name(self) -> str: \"\"\" TODO 怎么切分可以这里实现，做成那个时间切分的参数配置 :return: 日志名称 \"\"\" # 一天分一次 return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime(\"%F\")) # 一分钟分一次 # return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime('%F-%H-%M')) def emit(self, record): \"\"\" Emit a record. If underlying file has changed, reopen the file before emitting the record to it. \"\"\" current_file_name = self.get_file_name() if current_file_name != self.file_name: self.file_name = current_file_name self.baseFilename = os.path.abspath(os.path.join(self.file_path, current_file_name)) if self.stream: self.stream.flush() self.stream.close() self.stream = self._open() self._statstream() self.auto_clear() super().emit(record) def auto_clear(self): \"\"\" 自动清理 log 文件 :return: \"\"\" file_list = sorted(glob.glob(os.path.join(self.file_path, self.file_name_prefix + '*')), key=lambda x: time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(os.path.getctime(x))), reverse=True) for file_ in file_list[self.backup_count:]: os.remove(file_) class MyLog(Logger): def error(self, msg, exc_info=True, extra=None, *args): \"\"\" 重写父类方法,exc_info默认为True \"\"\" if self.isEnabledFor(level=40): # 父类抄来,使用默认值 self._log(40, msg, args, exc_info=True, extra=None) def info(self, msg, *args, **kwargs): \"\"\" 防止在 exception里写 log.info(error) 抓取一切报错堆栈 Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) \"\"\" error_msg = traceback.format_exc() # Windows 和 Linux 不一样？ # if not error_msg == 'None\\n': if not error_msg == 'NoneType: None\\n': error_msg = str(msg) + error_msg self._log(20, error_msg, args, **kwargs) if self.isEnabledFor(20): # 父类抄来,使用默认值 self._log(20, msg, args, **kwargs) class LogUtil(object): def __init__(self, file_name_prefix, backup_count: int = 5, console_out: bool = False): \"\"\" :param file_name_prefix: 日志名称前缀 :param backup_count: 备份数量 :param console_out: 是否在控制台输出 \"\"\" self.file_name_prefix = file_name_prefix if sys.platform.startswith(\"linux\"): self.base_dir = '/app/logs' else: self.base_dir = './logs' # 本地调试 formatter = logging.Formatter('[%(levelname)s] [%(asctime)s] [%(filename)s-line:%(lineno)d] %(message)s') # 按天存放 同类型log最多保留5个 self.log_file_handler = CustomizeOneDayOneLogHandler(self.base_dir, self.file_name_prefix, backup_count=backup_count, encoding='utf-8') self.log_file_handler.setFormatter(formatter) self.logger = MyLog(name=self.log_file_handler.file_name) self.logger.setLevel(logging.DEBUG) self.logger.addHandler(self.log_file_handler) # 输出到文件 if console_out: # 往屏幕上输出 console_handler = logging.StreamHandler() console_handler.setFormatter(formatter) # 设置屏幕上显示的格式 self.logger.addHandler(console_handler) # 输出到控制台 log_test1 = LogUtil(\"test1\", console_out=True).logger log_test2 = LogUtil(\"test2\", console_out=True).logger if __name__ == '__main__': while True: time.sleep(5) log_test1.info(\"aaaaaaaaaaa\") # time.sleep(0.1) # log_test2.info(\"bbbbbbbbbbb\") # try: # a = 1/ 0 # except Exception as e: # # log_test1.error(\"error\") # log_test1.info(\"info\") "},"Python/Python语言基础/unittest/01-单元测试unittest基础.html":{"url":"Python/Python语言基础/unittest/01-单元测试unittest基础.html","title":"单元测试unittest基础","keywords":"","body":"datetime:2022/04/12 14:47 author:nzb 单元测试：unittest 框架基础 一、框架详解 什么是框架？ 开发者封装好的一个半成品，它已经对基础的代码进行了封装并提供了相应的接口，其他的开发者只需要去调用封装之后的接口即可。 例如：Selenium 框架 unittest 单元测试框架 单元测试框架：在编程当中，针对程序的最小单元（函数、方法、类）进行正确性的测试框架。 自动化测试框架针对软件封装的系统框架，这个代码框架就是自动化测试框架 作用 提高测试效率，降低维护成本 提高测试准确性，增加代码的重用性和可靠性 单元测试框架它是自动化测试框架的其中的组成部分，主要用于管理和运行测试用例 二、单元测试框架对比 python(市场使用占比80%) unittest(市场使用占比30%) pytest java(市场使用占比20%) junit testing unittest与pytest差异 用例编写差异 unittest用例规则(耦合，一台unittest) 测试文件必须导包：import unittest 测试类必须继承 unittest.Testcase 测试方法必须以test_开头 pytest 用例规则(非耦合) 测试文件必须以 test_开头或者_test结尾 测试类名必须以Test开头 测试方法必须test_开头 测试用例的夹具(钩子函数、前后置) unittest setUp/tearDown：在测试用例之前和之后执行 setUpClass/tearDownClass：在测试用例类之前和之后执行 setUpModule/teardownModule：在测试模块之前和之后执行 pytest setup/teardown：在测试用例之前和之后执行 setup_class/teardown_class：在测试用例类之前和之后执行 setup_module/teardown_module：在测试模块之前和之后执行 其他夹具 pytest 独有：@pytest.fixtrue() 断言差异 unittest：self.assertEqual()、self.assertIn() pytest：python 自带的 assert 报告 unittest：HtmlTestrunner.py pytest：pytest-html、allure插件 失败重跑 unittest：没有 pytest：pytest-rerunfailures 参数化 unittest：ddt pytest：@pytest.mark.parametrize() 三、单元测试框架作用 发现测试用例 执行测试用例 判断测试用例 生成测试报告 四、unittest 重要组件 TestCase 测试用例：最小单元，业务逻辑 TestSuite 测试套件：一组测试用例的集合，或者测试套件的集合 TestFixtrue 测试夹具：执行测试用例之前和之后的操作 TestLoader 测试加载器：加载测试用例 TestRunner 测试运行器：运行指定的测试用例 五、unittest 实例 单元测试：测试函数 光标放置某一函数后面，右键运行，可单独运行该用例 光标放置某一测试类后面，右键运行，可单独运行该测试类的所有用例 为什么没有 main 方法也可以运行呢？ import unittest class TestUnittest(unittest.TestCase): def test_01(self): print(\"测试test_01\") def test_02(self): print(\"测试test_02\") if __name__ == '__main__': print(\"___________________________main___________________________\") # 未打印 unittest.main() 输出 C:\\Users\\lenovo\\PycharmProjects\\demo\\venv\\Scripts\\python.exe \"D:\\Program\\PyCharm 2020.3.4\\plugins\\python\\helpers\\pycharm\\_jb_unittest_runner.py\" --target test_unittest.TestUnittest Testing started at 15:49 ... Launching unittests with arguments python -m unittest test_unittest.TestUnittest in C:\\Users\\lenovo\\PycharmProjects\\demo\\study\\unittest_demo Ran 2 tests in 0.002s OK 测试test_01 测试test_02 Process finished with exit code 0 unittest 运行方式有两种 命令行的运行方式(右键运行即为默认的测试用例的运行方式，也就是为什么不写 main 也可以运行的原因) 方式1： python -m unittest 模块名.py 例：python -m unittest test_unittest.py 方式2：python -m unittest 模块名.类名.方法名 方式3：python -m unittest -v 模块名.py -v：详细(verbose), 上面简介运行后的 . 变成了 ok 方式4：python -m unittest -v 模块名.py -k *_01 -k：通过通配符匹配方法名 python -m：以脚本(命令行)的方式来运行(测试用例) 通过 main 运行 if __name__ == \"__main__\": unittest.main() 六、unittest 的测试用例运行结果 .：成功 F：失败 E：异常 s：跳过 以上不能通过 -v 的方式运行。因为这是详细的报错方式，不是简洁的报错方式 __date__ = \"2022/4/12 15:18\" import unittest class TestUnittest(unittest.TestCase): def test_01(self): print(\"测试 test_01\") def test_02(self): print(\"测试 test_02\") self.assertEqual(1, 2) def test_03(self): print(\"测试 test_03\") raise Exception(\"报错了\") @unittest.skip(\"直接跳过\") def test_04(self): print(\"测试 test_04\") if __name__ == '__main__': print(\"___________________________main___________________________\") unittest.main() C:\\Users\\lenovo\\PycharmProjects\\demo\\venv\\Scripts\\python.exe C:/Users/lenovo/PycharmProjects/demo/study/unittest_demo/test_unittest.py ___________________________main___________________________ 测试 test_01 测试 test_02 测试 test_03 .FEs ====================================================================== ERROR: test_03 (__main__.TestUnittest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"C:\\Users\\lenovo\\PycharmProjects\\demo\\study\\unittest_demo\\test_unittest.py\", line 20, in test_03 raise Exception(\"报错了\") Exception: 报错了 ====================================================================== FAIL: test_02 (__main__.TestUnittest) ---------------------------------------------------------------------- Traceback (most recent call last): File \"C:\\Users\\lenovo\\PycharmProjects\\demo\\study\\unittest_demo\\test_unittest.py\", line 16, in test_02 self.assertEqual(1, 2) AssertionError: 1 != 2 ---------------------------------------------------------------------- Ran 4 tests in 0.001s FAILED (failures=1, errors=1, skipped=1) Process finished with exit code 1 七、多种 unittest 的加载和运行测试用例的方式 main 方法 通过测试套件来加载和运行 __date__ = \"2022/4/12 16:21\" import unittest from unittest_demo.test_unittest import TestUnittest if __name__ == '__main__': # 创建一个测试套件 suite = unittest.TestSuite() # 通过测试套件加载测试用例 # suite.addTest(TestUnittest(\"test_01\")) # suite.addTest(TestUnittest(\"test_02\")) test_cases = [TestUnittest(\"test_01\"), TestUnittest(\"test_02\")] suite.addTests(test_cases) # 运行 unittest.main(defaultTest='suite') 加载一个目录下所有的用例 __date__ = \"2022/4/12 16:21\" import unittest if __name__ == '__main__': suite = unittest.defaultTestLoader.discover('.', pattern=\"*.py\") # suite = unittest.defaultTestLoader.discover('.', pattern=\"test_unittest.py\") unittest.main(defaultTest='suite') 为什么调用 unittest.main() 就可以执行测试用例？？？ class TestProgram(object): \"\"\"A command-line program that runs a set of tests; this is primarily for making test modules conveniently executable. \"\"\" # defaults for testing module=None verbosity = 1 failfast = catchbreak = buffer = progName = warnings = testNamePatterns = None _discovery_parser = None def __init__(self, module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=loader.defaultTestLoader, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None, *, tb_locals=False): \"\"\" :param module: 测试用例所在的路径，__main__：默认当前 :param defaultTest: 默认的待测试的测试用例的名称，默认执行所有用例 :param argv: 接收外部传递给程序的参数 :param testRunner: 测试运行器 :param testLoader: 测试加载器 :param exit: 是否在测试完成结束之后退出程序 :param verbosity: 显示信息的详细程度，verbose -v = 2: 显示用例总数和全局结果，并输出每个用例的详解 :param failfast: 是否在测试用例失败时终止测试 :param catchbreak: :param buffer: :param warnings: :param tb_locals: \"\"\" TestCase 测试用例：最小单元，业务逻辑 TestSuite 测试套件：一组测试用例的集合，或者测试套件的集合 # 解析测试用例和测试套件 elif self.testNames is None: self.test = self.testLoader.loadTestsFromModule(self.module) else: self.test = self.testLoader.loadTestsFromNames(self.testNames, self.module) TestFixtrue 测试夹具：执行测试用例之前和之后的操作 TestLoader 测试加载器：加载测试用例： __init__时已经给了默认的加载器 TestRunner 测试运行器：运行指定的测试用例 if self.testRunner is None: self.testRunner = runner.TextTestRunner # !/usr/bin/env python # -*- coding:utf8 -*- __date__ = \"2022/4/12 16:21\" import unittest if __name__ == '__main__': suite = unittest.defaultTestLoader.discover('.', pattern=\"*.py\") unittest.main(defaultTest='suite') # 一连串的加载相关组件后运行相当于以下运行 suite = unittest.defaultTestLoader.discover('.', pattern=\"*.py\") unittest.TextTestRunner().run(suite) "},"Python/Python语言基础/unittest/02-单元测试unittest进阶.html":{"url":"Python/Python语言基础/unittest/02-单元测试unittest进阶.html","title":"单元测试unittest进阶","keywords":"","body":"datetime:2022/04/12 17:48 author:nzb 单元测试：unittest 框架进阶 一、测试夹具（固件、钩子函数、前后置）TestFixtrue详解 setUp/tearDown：在测试用例之前和之后执行 setUpClass/tearDownClass：在测试用例类之前和之后执行（必须加 @classmethod 的装饰器） setUpModule/teardownModule：在测试模块之前和之后执行 __date__ = \"2022/4/12 15:18\" import unittest class TestUnittest(unittest.TestCase): @classmethod def setUpClass(cls) -> None: print(\"测试类之前的准备工作：连接数据库，创建日志对象等\") @classmethod def tearDownClass(cls) -> None: print(\"测试类之后的扫尾工作：销毁数据库连接，销毁日志对象等\") def setUp(self) -> None: print(\"测试用例之前的准备工作：打开浏览器，加载网页\") def tearDown(self) -> None: print(\"测试用例之后的扫尾工作：关闭浏览器\") def test_01(self): print(\"测试 test_01\") def test_02(self): print(\"测试 test_02\") # self.assertEqual(1, 2) if __name__ == '__main__': print(\"___________________________main___________________________\") suite = unittest.defaultTestLoader.discover('.', pattern=\"test_unittest.py\") unittest.main(defaultTest='suite') C:\\Users\\lenovo\\PycharmProjects\\demo\\venv\\Scripts\\python.exe C:/Users/lenovo/PycharmProjects/demo/study/unittest_demo/test_unittest.py .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK ___________________________main___________________________ 测试类之前的准备工作：连接数据库，创建日志对象等 测试用例之前的准备工作：打开浏览器，加载网页 测试 test_01 测试用例之后的扫尾工作：关闭浏览器 测试用例之前的准备工作：打开浏览器，加载网页 测试 test_02 测试用例之后的扫尾工作：关闭浏览器 测试类之后的扫尾工作：销毁数据库连接，销毁日志对象等 Process finished with exit code 0 夹具封装 自动化测试框架必备的思想 二、忽略测试用例 import unittest class TestUnittest(unittest.TestCase): a = 18 @unittest.skip(\"无条件忽略\") def test_04(self): print(\"测试 test_04\") @unittest.skipIf(a >= 15, \"条件为 True 忽略\") def test_05(self): print(\"测试 test_05\") @unittest.skipUnless(a >= 20, \"条件为 False 忽略\") def test_06(self): print(\"测试 test_06\") 三、断言(判断我们用例是否执行成功) 方法 检查对象 引入版本 assertEqual(a, b) a == b assertEqual(a, b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIs(a, b) a is b 3.1 assertIsNot(a, b) a is not b 3.1 assertIsNone(x) x is None 3.1 assertIsNotNone(x) x is not None 3.1 assertIn(a, b) a in b 3.1 assertNotIn(a, b) a not in b 3.1 assertIsInstance(a, b) isinstance(a, b) 3.2 assertNotIsInstance(a, b) not isinstance(a, b) 3.2 常用 assertEqual(a, b) assertTrue(x) assertIn(a, b) 四、批量生产自动化的测试报告 txt 文本格式的测试报告 html格式的测试报告 第一步：下载一个 HTMLTestRunner.py (官方上的不行，仅支持py2.7) \"\"\" A TestRunner for use with the Python unit testing framework. It generates a HTML report to show the result at a glance. The simplest way to use this is to invoke its main method. E.g. import unittest import HTMLTestRunner ... define your tests ... if __name__ == '__main__': HTMLTestRunner.main() For more customization options, instantiates a HTMLTestRunner object. HTMLTestRunner is a counterpart to unittest's TextTestRunner. E.g. # output to a file fp = file('my_report.html', 'wb') runner = HTMLTestRunner.HTMLTestRunner( stream=fp, title='My unit test', description='This demonstrates the report output by HTMLTestRunner.' ) # Use an external stylesheet. # See the Template_mixin class for more customizable options runner.STYLESHEET_TMPL = '' # run the test runner.run(my_test_suite) ------------------------------------------------------------------------ Copyright (c) 2004-2007, Wai Yip Tung All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name Wai Yip Tung nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \"\"\" # URL: http://tungwaiyip.info/software/HTMLTestRunner.html __author__ = \"Wai Yip Tung\" __version__ = \"0.8.2\" \"\"\" Change History Version 0.8.2 * Show output inline instead of popup window (Viorel Lupu). Version in 0.8.1 * Validated XHTML (Wolfgang Borgert). * Added description of test classes and test cases. Version in 0.8.0 * Define Template_mixin class for customization. * Workaround a IE 6 bug that it does not treat block as CDATA. Version in 0.7.1 * Back port to Python 2.3 (Frank Horowitz). * Fix missing scroll bars in detail log (Podi). \"\"\" # TODO: color stderr # TODO: simplify javascript using ,ore than 1 class in the class attribute? import datetime import io import sys import time import unittest from xml.sax import saxutils # ------------------------------------------------------------------------ # The redirectors below are used to capture output during testing. Output # sent to sys.stdout and sys.stderr are automatically captured. However # in some cases sys.stdout is already cached before HTMLTestRunner is # invoked (e.g. calling logging.basicConfig). In order to capture those # output, use the redirectors for the cached stream. # # e.g. # >>> logging.basicConfig(stream=HTMLTestRunner.stdout_redirector) # >>> class OutputRedirector(object): \"\"\" Wrapper to redirect stdout or stderr \"\"\" def __init__(self, fp): self.fp = fp def write(self, s): self.fp.write(bytes(s, 'UTF-8')) def writelines(self, lines): self.fp.writelines(lines) def flush(self): self.fp.flush() stdout_redirector = OutputRedirector(sys.stdout) stderr_redirector = OutputRedirector(sys.stderr) # ---------------------------------------------------------------------- # Template class Template_mixin(object): \"\"\" Define a HTML template for report customerization and generation. Overall structure of an HTML report HTML +------------------------+ | | | | | | | STYLESHEET | | +----------------+ | | | | | | +----------------+ | | | | | | | | | | | | HEADING | | +----------------+ | | | | | | +----------------+ | | | | REPORT | | +----------------+ | | | | | | +----------------+ | | | | ENDING | | +----------------+ | | | | | | +----------------+ | | | | | | | +------------------------+ \"\"\" STATUS = { 0: 'pass', 1: 'fail', 2: 'error', } DEFAULT_TITLE = 'Unit Test Report' DEFAULT_DESCRIPTION = '' # ------------------------------------------------------------------------ # HTML Template HTML_TMPL = r\"\"\" %(title)s %(stylesheet)s 1) { tr.className = ''; } else { tr.className = 'hiddenRow'; } } } } function showClassDetail(cid, count) { var id_list = Array(count); var toHide = 1; for (var i = 0; i /g,'&gt;'); return s; } /* obsoleted by detail in function showOutput(id, name) { var w = window.open(\"\", //url name, \"resizable,scrollbars,status,width=800,height=450\"); d = w.document; d.write(\"\"); d.write(html_escape(output_list[id])); d.write(\"\\n\"); d.write(\"close\\n\"); d.write(\"\\n\"); d.close(); } */ --> %(heading)s %(report)s %(ending)s \"\"\" # variables: (title, generator, stylesheet, heading, report, ending) # ------------------------------------------------------------------------ # Stylesheet # # alternatively use a for external style sheet, e.g. # STYLESHEET_TMPL = \"\"\" body { font-family: verdana, arial, helvetica, sans-serif; font-size: 80%; } table { font-size: 100%; } pre { } /* -- heading ---------------------------------------------------------------------- */ h1 { font-size: 16pt; color: gray; } .heading { margin-top: 0ex; margin-bottom: 1ex; } .heading .attribute { margin-top: 1ex; margin-bottom: 0; } .heading .description { margin-top: 4ex; margin-bottom: 6ex; } /* -- css div popup ------------------------------------------------------------------------ */ a.popup_link { } a.popup_link:hover { color: red; } .popup_window { display: none; position: relative; left: 0px; top: 0px; /*border: solid #627173 1px; */ padding: 10px; background-color: #E6E6D6; font-family: \"Lucida Console\", \"Courier New\", Courier, monospace; text-align: left; font-size: 8pt; width: 500px; } } /* -- report ------------------------------------------------------------------------ */ #show_detail_line { margin-top: 3ex; margin-bottom: 1ex; } #result_table { width: 80%; border-collapse: collapse; border: 1px solid #777; } #header_row { font-weight: bold; color: white; background-color: #777; } #result_table td { border: 1px solid #777; padding: 2px; } #total_row { font-weight: bold; } .passClass { background-color: #6c6; } .failClass { background-color: #c60; } .errorClass { background-color: #c00; } .passCase { color: #6c6; } .failCase { color: #c60; font-weight: bold; } .errorCase { color: #c00; font-weight: bold; } .hiddenRow { display: none; } .testcase { margin-left: 2em; } /* -- ending ---------------------------------------------------------------------- */ #ending { } \"\"\" # ------------------------------------------------------------------------ # Heading # HEADING_TMPL = \"\"\" %(title)s %(parameters)s %(description)s \"\"\" # variables: (title, parameters, description) HEADING_ATTRIBUTE_TMPL = \"\"\"%(name)s: %(value)s \"\"\" # variables: (name, value) # ------------------------------------------------------------------------ # Report # REPORT_TMPL = \"\"\" Show Summary Failed All Test Group/Test case Count Pass Fail Error View %(test_list)s Total %(count)s %(Pass)s %(fail)s %(error)s &nbsp; \"\"\" # variables: (test_list, count, Pass, fail, error) REPORT_CLASS_TMPL = r\"\"\" %(desc)s %(count)s %(Pass)s %(fail)s %(error)s Detail \"\"\" # variables: (style, desc, count, Pass, fail, error, cid) REPORT_TEST_WITH_OUTPUT_TMPL = r\"\"\" %(desc)s %(status)s [x] %(script)s \"\"\" # variables: (tid, Class, style, desc, status) REPORT_TEST_NO_OUTPUT_TMPL = r\"\"\" %(desc)s %(status)s \"\"\" # variables: (tid, Class, style, desc, status) REPORT_TEST_OUTPUT_TMPL = r\"\"\" %(id)s: %(output)s \"\"\" # variables: (id, output) # ------------------------------------------------------------------------ # ENDING # ENDING_TMPL = \"\"\"&nbsp;\"\"\" # -------------------- The end of the Template class ------------------- TestResult = unittest.TestResult class _TestResult(TestResult): # note: _TestResult is a pure representation of results. # It lacks the output and reporting ability compares to unittest._TextTestResult. def __init__(self, verbosity=1): TestResult.__init__(self) self.stdout0 = None self.stderr0 = None self.success_count = 0 self.failure_count = 0 self.error_count = 0 self.verbosity = verbosity # result is a list of result in 4 tuple # ( # result code (0: success; 1: fail; 2: error), # TestCase object, # Test output (byte string), # stack trace, # ) self.result = [] def startTest(self, test): TestResult.startTest(self, test) # just one buffer for both stdout and stderr self.outputBuffer = io.BytesIO() stdout_redirector.fp = self.outputBuffer stderr_redirector.fp = self.outputBuffer self.stdout0 = sys.stdout self.stderr0 = sys.stderr sys.stdout = stdout_redirector sys.stderr = stderr_redirector def complete_output(self): \"\"\" Disconnect output redirection and return buffer. Safe to call multiple times. \"\"\" if self.stdout0: sys.stdout = self.stdout0 sys.stderr = self.stderr0 self.stdout0 = None self.stderr0 = None return self.outputBuffer.getvalue() def stopTest(self, test): # Usually one of addSuccess, addError or addFailure would have been called. # But there are some path in unittest that would bypass this. # We must disconnect stdout in stopTest(), which is guaranteed to be called. self.complete_output() def addSuccess(self, test): self.success_count += 1 TestResult.addSuccess(self, test) output = self.complete_output() self.result.append((0, test, output, '')) if self.verbosity > 1: sys.stderr.write('ok ') sys.stderr.write(str(test)) sys.stderr.write('\\n') else: sys.stderr.write('.') def addError(self, test, err): self.error_count += 1 TestResult.addError(self, test, err) _, _exc_str = self.errors[-1] output = self.complete_output() self.result.append((2, test, output, _exc_str)) if self.verbosity > 1: sys.stderr.write('E ') sys.stderr.write(str(test)) sys.stderr.write('\\n') else: sys.stderr.write('E') def addFailure(self, test, err): self.failure_count += 1 TestResult.addFailure(self, test, err) _, _exc_str = self.failures[-1] output = self.complete_output() self.result.append((1, test, output, _exc_str)) if self.verbosity > 1: sys.stderr.write('F ') sys.stderr.write(str(test)) sys.stderr.write('\\n') else: sys.stderr.write('F') class HTMLTestRunner(Template_mixin): \"\"\" \"\"\" def __init__(self, stream=sys.stdout, verbosity=1, title=None, description=None): self.stream = stream self.verbosity = verbosity if title is None: self.title = self.DEFAULT_TITLE else: self.title = title if description is None: self.description = self.DEFAULT_DESCRIPTION else: self.description = description self.startTime = datetime.datetime.now() def run(self, test): \"Run the given test case or test suite.\" result = _TestResult(self.verbosity) test(result) self.stopTime = datetime.datetime.now() self.generateReport(test, result) print('\\nTime Elapsed: %s' % (self.stopTime - self.startTime), file=sys.stderr) return result def sortResult(self, result_list): # unittest does not seems to run in any particular order. # Here at least we want to group them together by class. rmap = {} classes = [] for n, t, o, e in result_list: cls = t.__class__ if not cls in rmap: rmap[cls] = [] classes.append(cls) rmap[cls].append((n, t, o, e)) r = [(cls, rmap[cls]) for cls in classes] return r def getReportAttributes(self, result): \"\"\" Return report attributes as a list of (name, value). Override this to add custom attributes. \"\"\" startTime = str(self.startTime)[:19] duration = str(self.stopTime - self.startTime) status = [] if result.success_count: status.append('Pass %s' % result.success_count) if result.failure_count: status.append('Failure %s' % result.failure_count) if result.error_count: status.append('Error %s' % result.error_count) if status: status = ' '.join(status) else: status = 'none' return [ ('Start Time', startTime), ('Duration', duration), ('Status', status), ] def generateReport(self, test, result): report_attrs = self.getReportAttributes(result) generator = 'HTMLTestRunner %s' % __version__ stylesheet = self._generate_stylesheet() heading = self._generate_heading(report_attrs) report = self._generate_report(result) ending = self._generate_ending() output = self.HTML_TMPL % dict( title=saxutils.escape(self.title), generator=generator, stylesheet=stylesheet, heading=heading, report=report, ending=ending, ) self.stream.write(output.encode('utf8')) def _generate_stylesheet(self): return self.STYLESHEET_TMPL def _generate_heading(self, report_attrs): a_lines = [] for name, value in report_attrs: line = self.HEADING_ATTRIBUTE_TMPL % dict( name=saxutils.escape(name), value=saxutils.escape(value), ) a_lines.append(line) heading = self.HEADING_TMPL % dict( title=saxutils.escape(self.title), parameters=''.join(a_lines), description=saxutils.escape(self.description), ) return heading def _generate_report(self, result): rows = [] sortedResult = self.sortResult(result.result) for cid, (cls, cls_results) in enumerate(sortedResult): # subtotal for a class np = nf = ne = 0 for n, t, o, e in cls_results: if n == 0: np += 1 elif n == 1: nf += 1 else: ne += 1 # format class description if cls.__module__ == \"__main__\": name = cls.__name__ else: name = \"%s.%s\" % (cls.__module__, cls.__name__) doc = cls.__doc__ and cls.__doc__.split(\"\\n\")[0] or \"\" desc = doc and '%s: %s' % (name, doc) or name row = self.REPORT_CLASS_TMPL % dict( style=ne > 0 and 'errorClass' or nf > 0 and 'failClass' or 'passClass', desc=desc, count=np + nf + ne, Pass=np, fail=nf, error=ne, cid='c%s' % (cid + 1), ) rows.append(row) for tid, (n, t, o, e) in enumerate(cls_results): self._generate_report_test(rows, cid, tid, n, t, o, e) report = self.REPORT_TMPL % dict( test_list=''.join(rows), count=str(result.success_count + result.failure_count + result.error_count), Pass=str(result.success_count), fail=str(result.failure_count), error=str(result.error_count), ) return report def _generate_report_test(self, rows, cid, tid, n, t, o, e): # e.g. 'pt1.1', 'ft1.1', etc has_output = bool(o or e) tid = (n == 0 and 'p' or 'f') + 't%s.%s' % (cid + 1, tid + 1) name = t.id().split('.')[-1] doc = t.shortDescription() or \"\" desc = doc and ('%s: %s' % (name, doc)) or name tmpl = has_output and self.REPORT_TEST_WITH_OUTPUT_TMPL or self.REPORT_TEST_NO_OUTPUT_TMPL # o and e should be byte string because they are collected from stdout and stderr? if isinstance(o, str): # TODO: some problem with 'string_escape': it escape \\n and mess up formating # uo = unicode(o.encode('string_escape')) uo = o else: uo = o.decode('utf-8') if isinstance(e, str): # TODO: some problem with 'string_escape': it escape \\n and mess up formating # ue = unicode(e.encode('string_escape')) ue = e else: ue = e.decode('utf-8') script = self.REPORT_TEST_OUTPUT_TMPL % dict( id=tid, output=saxutils.escape(uo + ue), ) row = tmpl % dict( tid=tid, Class=(n == 0 and 'hiddenRow' or 'none'), style=n == 2 and 'errorCase' or (n == 1 and 'failCase' or 'none'), desc=desc, script=script, status=self.STATUS[n], ) rows.append(row) if not has_output: return def _generate_ending(self): return self.ENDING_TMPL ############################################################################## # Facilities for running tests from the command line ############################################################################## # Note: Reuse unittest.TestProgram to launch test. In the future we may # build our own launcher to support more specific command line # parameters like test title, CSS, etc. class TestProgram(unittest.TestProgram): \"\"\" A variation of the unittest.TestProgram. Please refer to the base class for command line parameters. \"\"\" def runTests(self): # Pick HTMLTestRunner as the default test runner. # base class's testRunner parameter is not useful because it means # we have to instantiate HTMLTestRunner before we know self.verbosity. if self.testRunner is None: self.testRunner = HTMLTestRunner(verbosity=self.verbosity) unittest.TestProgram.runTests(self) main = TestProgram ############################################################################## # Executing this module from the command line ############################################################################## if __name__ == \"__main__\": main(module=None) ```python import datetime import unittest from unittest_demo.HTMLTestRunner import HTMLTestRunner if __name__ == '__main__': suite = unittest.defaultTestLoader.discover('.', pattern=\"test_unittest.py\") time_str = datetime.datetime.now().strftime('%Y%m%d%H%M%S') with open(f\"./report_{time_str}.html\", 'wb') as f: runner = HTMLTestRunner(f, title=\"测试报告\", description=\"测试报告详情\") runner.run(suite) ``` 测试报告中的测试用例的中文说明是测试用例函数的注释 "},"Python/Python语言基础/unittest/03-单元测试unittest集成篇.html":{"url":"Python/Python语言基础/unittest/03-单元测试unittest集成篇.html","title":"单元测试unittest集成篇","keywords":"","body":"datetime:2022/04/14 15:17 author:nzb 单元测试：unittest 集成篇 一、数据驱动简介 为什么需要数据驱动？正例、反例登录：同一个业务逻辑，代码逻辑是不变的，数据有很多组，业务逻辑和数据分离。 二、自动化主流的驱动模式介绍 数据驱动数据驱动把数据保存excel、csv、yaml、数据库，然后通过改变数据驱动我们的业务逻辑执行，并且得到不同的结果 关键字驱动关键字驱动其实是从面向对象的思想触发，它把一些业务逻辑代码封装成一个函数，方法作为一个关键字，然后调用不同的函数组成不同的复杂的业务逻辑 数据驱动+关键字驱动 三、unittest 的 ddt 数据驱动 什么是 ddt ？data driver test, 它可以完美的应用于 unittest 框架实现数据驱动 ddt 详解它是通过装饰器的方式来调用的 分为类装饰器和函数装饰器 @ddt：类装饰器，申明当前类使用 DDT 框架 @data：函数装饰器，用不给测试用例传递数据 @unpack：函数装饰器，降数据解包，一般用于元组和列表 @file_data：函数装饰器，用于读取json或yaml文件 用法 __date__ = \"2022/4/14 15:30\" import unittest from ddt import ddt, data, unpack @ddt class TestDdt(unittest.TestCase): \"\"\" @data(\"data1\") . ---------------------------------------------------------------------- Ran 1 test in 0.000s OK ('data1',) {} @data(\"data1\", \"data2\") ('data1',) {} ('data2',) {} .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK @data((\"data1\", \"data3\"), (\"data2\", \"data4\")) .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK (('data1', 'data3'),) {} (('data2', 'data4'),) {} @data((\"data1\", \"data3\"), (\"data2\", \"data4\")) @unpack ('data1', 'data3') {} ('data2', 'data4') {} .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK @data({\"a\": \"data1\", \"b\": \"data3\"}, {\"a\": \"data2\", \"b\": \"data4\"}) @unpack () {'a': 'data1', 'b': 'data3'} () {'a': 'data2', 'b': 'data4'} .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK @data({\"a\": \"data1\", \"b\": \"data3\"}, (\"data2\", \"data4\")) @unpack () {'a': 'data1', 'b': 'data3'} ('data2', 'data4') {} .. ---------------------------------------------------------------------- Ran 2 tests in 0.000s OK \"\"\" # @data(\"data1\") # @data(\"data1\", \"data2\") # @data((\"data1\", \"data3\"), (\"data2\", \"data4\")) # @data({\"a\": \"data1\", \"b\": \"data3\"}, {\"a\": \"data2\", \"b\": \"data4\"}) @data({\"a\": \"data1\", \"b\": \"data3\"}, (\"data2\", \"data4\")) @unpack def test_01(self, *args, **kwargs): \"\"\" 测试 test_01 :return: \"\"\" print(args) print(kwargs) if __name__ == '__main__': unittest.main() 总结 ddt 数据驱动中，测试用例的执行次数是有 @data() 传参的个数决定。传一个值用例执行一次，传多个值，用例执行多次 如果传的是元组(或列表)，那么可以使用 @unpack 解包元组和列表，但是需要注意的是，元组和列表中有多少个值，那么就必须用多少个变量来接收值，或者使用可变长度关键字和关键字参数接收 如果传的是多个字典，那么可以使用 @unpack 解包，但是需要注意的是：用例中的参数的名称和个数必须和字典的 key 保持一致，或者使用可变长度关键字和关键字参数接收 "},"Python/Python语言进阶/01-常用数据结构和算法.html":{"url":"Python/Python语言进阶/01-常用数据结构和算法.html","title":"常用数据结构","keywords":"","body":"datetime:2019/5/15 17:46 author:nzb 数据结构和算法 十大经典算法 算法：解决问题的方法和步骤 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。 渐近时间复杂度的大O标记： - 常量时间复杂度 - 布隆过滤器 / 哈希存储 - 对数时间复杂度 - 折半查找（二分查找） - 线性时间复杂度 - 顺序查找 / 桶排序 - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序） - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序） - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算 - 几何级数时间复杂度 - 汉诺塔 - 阶乘时间复杂度 - 旅行经销商问题 - NP 排序算法（选择、冒泡和归并）和查找算法（顺序和折半） def select_sort(origin_items, comp=lambda x, y: x # 第一种 def bubble_sort(origin_items, comp=lambda x, y: x > y): \"\"\"高质量冒泡排序(搅拌排序)\"\"\" items = origin_items[:] for i in range(len(items) - 1): swapped = False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if swapped: swapped = False for j in range(len(items) - 2 - i, i, -1): if comp(items[j - 1], items[j]): items[j], items[j - 1] = items[j - 1], items[j] swapped = True if not swapped: break return items # 第二种 def bubble_sort(origin_items, comp=lambda x, y: x > y): \"\"\"高质量冒泡排序(搅拌排序)\"\"\" items = origin_items[:] for i in range(1, len(items)): # 循环次数 for j in range(0, len(items) - i): # 循环索引 if comp(items[j], items[j + 1]): items[j], items[j+1] = items[j+1], items[j] return items ```Python 第一种 def merge_sort(items, comp=lambda x, y: x \"\"\"归并排序(分治法)\"\"\" if len(items) def merge(items1, items2, comp): \"\"\"合并(将两个有序的列表合并成一个有序的列表)\"\"\" items = [] index, index2 = 0, 0 while index1 tmp] return self.quick_sort(less) + [tmp] + self.quick_sort(more) ``` ```Python def seq_search(items, key): \"\"\"顺序查找\"\"\" for index, item in enumerate(items): if item == key: return index return -1 ``` ```Python def bin_search(items, key): \"\"\"折半查找\"\"\" start, end = 0, len(items) - 1 while start items[mid]: start = mid + 1 elif key 使用生成式（推导式）语法 prices = { 'AAPL': 191.88, 'GOOG': 1186.96, 'IBM': 149.24, 'ORCL': 48.44, 'ACN': 166.89, 'FB': 208.09, 'SYMC': 21.29 } # 用股票价格大于100元的股票构造一个新的字典 prices2 = {key: value for key, value in prices.items() if value > 100} print(prices2) 说明：生成式（推导式）可以用来生成列表、集合和字典。 嵌套的列表 names = ['关羽', '张飞', '赵云', '马超', '黄忠'] courses = ['语文', '数学', '英语'] # 录入五个学生三门课程的成绩 # 错误 - 参考http://pythontutor.com/visualize.html#mode=edit # scores = [[None] * len(courses)] * len(names) scores = [[None] * len(courses) for _ in range(len(names))] for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] = float(input(f'请输入{name}的{course}成绩: ')) print(scores) Python Tutor - VISUALIZE CODE AND GET LIVE HELP heapq、itertools等的用法 \"\"\" 从列表中找出最大的或最小的N个元素 堆结构(大根堆/小根堆) \"\"\" import heapq list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92] list2 = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] print(heapq.nlargest(3, list1)) print(heapq.nsmallest(3, list1)) print(heapq.nlargest(2, list2, key=lambda x: x['price'])) print(heapq.nlargest(2, list2, key=lambda x: x['shares'])) \"\"\" 迭代工具 - 排列 / 组合 / 笛卡尔积 \"\"\" import itertools itertools.permutations('ABCD') itertools.combinations('ABCDE', 3) itertools.product('ABCD', '123') collections模块下的工具类 \"\"\" 找出序列中出现次数最多的元素 \"\"\" from collections import Counter words = [ 'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes', 'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the', 'eyes', \"don't\", 'look', 'around', 'the', 'eyes', 'look', 'into', 'my', 'eyes', \"you're\", 'under' ] counter = Counter(words) print(counter.most_common(3)) 常用算法： 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。 穷举法例子：百钱百鸡和五人分鱼。 # 公鸡5元一只 母鸡3元一只 小鸡1元三只 # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只 for x in range(20): for y in range(33): z = 100 - x - y if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0: print(x, y, z) # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉 # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份 # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份 # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼 fish = 1 while True: total = fish enough = True for _ in range(5): if (total - 1) % 5 == 0: total = (total - 1) // 5 * 4 else: enough = False break if enough: print(fish) break fish += 1 贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。 | 名称 | 价格（美元） | 重量（kg） | | :----: | :----------: | :--------: | | 电脑 | 200 | 20 | | 收音机 | 20 | 4 | | 钟 | 175 | 10 | | 花瓶 | 50 | 2 | | 书 | 10 | 1 | | 油画 | 90 | 9 | ```Python \"\"\" 贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 输入： 20 6 电脑 200 20 收音机 20 4 钟 175 10 花瓶 50 2 书 10 1 油画 90 9 \"\"\" class Thing(object): \"\"\"物品\"\"\" def __init__(self, name, price, weight): self.name = name self.price = price self.weight = weight @property def value(self): \"\"\"价格重量比\"\"\" return self.price / self.weight def input_thing(): \"\"\"输入物品信息\"\"\" name_str, price_str, weight_str = input().split() return name_str, int(price_str), int(weight_str) def main(): \"\"\"主函数\"\"\" max_weight, num_of_things = map(int, input().split()) all_things = [] for _ in range(num_of_things): all_things.append(Thing(*input_thing())) all_things.sort(key=lambda x: x.value, reverse=True) total_weight = 0 total_price = 0 for thing in all_things: if total_weight + thing.weight = 0 and row = 0 and col 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如： > > 输入：1 -2 3 5 -3 2 > > 输出：8 > > 输入：0 -2 3 5 -1 2 > > 输出：9 > > 输入：-9 -2 -3 -5 -3 > > 输出：-2 ```Python def main(): items = list(map(int, input().split())) size = len(items) overall, partial = {}, {} overall[size - 1] = partial[size - 1] = items[size - 1] for i in range(size - 2, -1, -1): partial[i] = max(items[i], partial[i + 1] + items[i]) overall[i] = max(partial[i], overall[i + 1]) print(overall[0]) if __name__ == '__main__': main() ``` "},"Python/Python语言进阶/02-函数的高级用法.html":{"url":"Python/Python语言进阶/02-函数的高级用法.html","title":"函数的高级用法","keywords":"","body":"datetime:2019/5/16 13:23 author:nzb 函数的使用方式 将函数视为“一等公民” 函数可以赋值给变量 函数可以作为函数的参数 函数可以作为函数的返回值 高阶函数的用法（filter、map以及它们的替代品） items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10)))) items2 = [x ** 2 for x in range(1, 10) if x % 2] 位置参数、可变参数、关键字参数、命名关键字参数 参数的元信息（代码可读性问题） 匿名函数和内联函数的用法（lambda函数） 闭包和作用域问题 闭包 函数内的属性，都是有生命周期，都是在函数执行期间 内部函数对外部函数作用域里变量的引用 闭包内的闭包函数私有化了变量，完成了数据的封装，类似面向对象 作用域 Python搜索变量的LEGB顺序（Local --> Embedded --> Global --> Built-in） global和nonlocal关键字的作用 global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。 nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。 装饰器函数（使用装饰器和取消装饰器）语法糖 @ 最简单的例子： def func1(func): # 外部闭包函数的参数是被装饰的函数对象 def func2(): print('aaabbb') return func() # 返回了外部函数接收的被装饰函数的调用 return func2 # return func # 返回了函数对象 # return func() # 返回的是一个函数调用 # func1(myfunc)() # 接收别装饰的函数作为参数，而且还要继续调用一次 # func2() -> print('aaabbb') -> return myfunc() @func1 def myfunc(): print('你好') # 不影响原有函数的功能，还能添加新的功能 myfunc() # func1(myfunc)() 装饰器函数带参数（与下面一样）多一层包装来接收装饰器的参数 def arg_func(sex): def func1(b_func): def func2(): if sex == 'man': print('你是男士') if sex == 'woman': print('你是女士') return b_func() return func2 return func1 @arg_func(sex='man') def man(): print('好好上班') @arg_func(sex='woman') def woman(): print('好好上班') man() woman() 例子：输出函数执行时间的装饰器。 def record_time(func): \"\"\"自定义装饰函数的装饰器\"\"\" @wraps(func) def wrapper(*args, **kwargs): # 被装饰的函数带参数（最常见） start = time() result = func(*args, **kwargs) # 被装饰的函数带参数（最常见） print(f'{func.__name__}: {time() - start}秒') return result return wrapper 如果装饰器不希望跟print函数耦合，可以编写带参数的装饰器。 ```Python from functools import wraps from time import time def record(output): \"\"\"自定义带参数的装饰器\"\"\" def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decorate ``` ```Python from functools import wraps from time import time class Record(): \"\"\"自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用)\"\"\" def __init__(self, output): self.output = output def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) self.output(func.__name__, time() - start) return result return wrapper ``` > 说明：由于对带装饰功能的函数添加了@wraps装饰器，可以通过`func.__wrapped__`方式获得被装饰之前的函数或类来取消装饰器的作用。 例子：用装饰器来实现单例模式。 ```Python from functools import wraps def singleton(cls): \"\"\"装饰类的装饰器\"\"\" instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President(): \"\"\"总统(单例类)\"\"\" pass ``` > 说明：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？ ```Python from functools import wraps def singleton(cls): \"\"\"线程安全的单例装饰器\"\"\" instances = {} locker = Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with locker: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper ``` "},"Python/Python语言进阶/03-面向对象高级知识.html":{"url":"Python/Python语言进阶/03-面向对象高级知识.html","title":"面向对象高级知识","keywords":"","body":"datetime:2019/5/16 15:26 author:nzb 面向对象相关知识 三大支柱：封装、继承、多态 例子：工资结算系统。 \"\"\" 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成 \"\"\" from abc import ABCMeta, abstractmethod class Employee(metaclass=ABCMeta): \"\"\"员工(抽象类)\"\"\" def __init__(self, name): self.name = name @abstractmethod def get_salary(self): \"\"\"结算月薪(抽象方法)\"\"\" pass class Manager(Employee): \"\"\"部门经理\"\"\" def get_salary(self): return 15000.0 class Programmer(Employee): \"\"\"程序员\"\"\" def __init__(self, name, working_hour=0): self.working_hour = working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hour class Salesman(Employee): \"\"\"销售员\"\"\" def __init__(self, name, sales=0.0): self.sales = sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05 class EmployeeFactory(): \"\"\"创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）\"\"\" @staticmethod def create(emp_type, *args, **kwargs): \"\"\"创建员工\"\"\" emp_type = emp_type.upper() emp = None if emp_type == 'M': emp = Manager(*args, **kwargs) elif emp_type == 'P': emp = Programmer(*args, **kwargs) elif emp_type == 'S': emp = Salesman(*args, **kwargs) return emp def main(): \"\"\"主函数\"\"\" emps = [ EmployeeFactory.create('M', '曹操'), EmployeeFactory.create('P', '荀彧', 120), EmployeeFactory.create('P', '郭嘉', 85), EmployeeFactory.create('S', '典韦', 123000), ] for emp in emps: print('%s: %.2f元' % (emp.name, emp.get_salary())) if __name__ == '__main__': main() 类与类之间的关系 is-a关系：继承 has-a关系：关联 / 聚合 / 合成 use-a关系：依赖 例子：扑克游戏。 \"\"\" 经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择 \"\"\" from enum import Enum, unique import random @unique class Suite(Enum): \"\"\"花色\"\"\" SPADE, HEART, CLUB, DIAMOND = range(4) def __lt__(self, other): return self.value 对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆） 垃圾回收和循环引用以及弱引用 Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。 typedef struct_object { /* 引用计数 */ int ob_refcnt; /* 对象指针 */ struct_typeobject *ob_type; } PyObject; /* 增加引用计数的宏定义 */ #define Py_INCREF(op) ((op)->ob_refcnt++) /* 减少引用计数的宏定义 */ #define Py_DECREF(op) \\ //减少计数 if (--(op)->ob_refcnt != 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 导致引用计数+1的情况： 对象被创建，例如a = 23 对象被引用，例如b = a 对象被作为参数，传入到一个函数中，例如f(a) 对象作为一个元素，存储在容器中，例如list1 = [a, a] 导致引用计数-1的情况： 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a = 24 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象 引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。 # 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收 # 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效 # 如果不想造成循环引用可以使用弱引用 list1 = [] list2 = [] list1.append(list2) list2.append(list1) 以下情况会导致垃圾回收： 调用gc.collect() gc模块的计数器达到阀值 程序退出 如果循环引用中两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，这个问题在Python 3.6中得到了解决。 也可以通过weakref模块构造弱引用的方式来解决循环引用的问题。 Python的内存管理机制及调优手段？ 内存管理机制: 引用计数、垃圾回收、内存池 引用计数：引用计数是一种非常高效的内存管理手段，当一个Python对象被引用时其引用计数增加1, def DisplayItems(self): print \"show all items---\" for item in self.__list: print item if hasattr(Parent, 'x'): print(getattr(Parent, 'x')) setattr(Parent, 'x',3) print(getattr(Parent,'x')) 当其不再被一个变量引用时则计数减1,当引用计数等于0时对象被删除。弱引用不会增加引用计数 垃圾回收：Python的垃圾回收机制采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。 1.引用计数 引用计数也是一种垃圾收集机制，而且也是一种最直观、最简单的垃圾收集技术。当Python的某个对象 的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建 对象，它被分配给某个引用，对象的引用计数变为1，如果引用被删除，对象的引用计数为0,那么该对 象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。 2.标记清除 3.分代回收 内存池 当创建大量消耗小内存的对象时，频繁调用 new/malloc 会导致大量的内存碎片，致使效率降低。内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。 调优手段 1.手动垃圾回收 2.调高垃圾回收阈值 3.避免循环引用 内存泄露是什么？如何避免？ 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消 失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控 制，从而造成了内存的浪费。 有 del() 函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来 删除一个对象的引用计数就可以有效防止内存泄露问题。 通过Python扩展模块gc 来查看不能回收的对象的详细信息。 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露 魔法属性和方法（请参考《Python魔法方法指南》） 有几个小问题请大家思考： 自定义的对象能不能使用运算符做运算？ 自定义的对象能不能放到set中？能去重吗？ 自定义的对象能不能作为dict的键？ 自定义的对象能不能使用上下文语法？ 混入（Mixin） 例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。 class SetOnceMappingMixin(): \"\"\"自定义混入类\"\"\" __slots__ = () def __setitem__(self, key, value): if key in self: raise KeyError(str(key) + ' already set') return super().__setitem__(key, value) class SetOnceDict(SetOnceMappingMixin, dict): \"\"\"自定义字典\"\"\" pass my_dict= SetOnceDict() try: my_dict['username'] = 'jackfrued' my_dict['username'] = 'hellokitty' except KeyError: pass print(my_dict) 元编程和元类 例子：用元类实现单例模式。 import threading class SingletonMeta(type): \"\"\"自定义元类\"\"\" def __init__(cls, *args, **kwargs): cls.__instance = None cls.__lock = threading.Lock() super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: with cls.__lock: if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): \"\"\"总统(单例类)\"\"\" pass 面向对象设计原则 单一职责原则 （SRP）- 一个类只做该做的事情（类的设计要高内聚） 开闭原则 （OCP）- 软件实体应该对扩展开发对修改关闭 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化） 里氏替换原则（LSP） - 任何时候可以用子类对象替换掉父类对象 接口隔离原则（ISP）- 接口要小而专不要大而全（Python中没有接口的概念） 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码 最少知识原则（迪米特法则，LoD）- 不要给没有必然联系的对象发消息 说明：上面加粗的字母放在一起称为面向对象的SOLID原则。 GoF设计模式 创建型模式：单例、工厂、建造者、原型 结构型模式：适配器、门面（外观）、代理 行为型模式：迭代器、观察者、状态、策略 例子：可插拔的哈希算法。 ```Python class StreamHasher(): \"\"\"哈希摘要生成器(策略模式)\"\"\" def init(self, alg='md5', size=4096): self.size = size alg = alg.lower() self.hasher = getattr(__import__('hashlib'), alg.lower())() def call(self, stream): return self.to_digest(stream) def to_digest(self, stream): \"\"\"生成十六进制形式的摘要\"\"\" for buf in iter(lambda: stream.read(self.size), b''): self.hasher.update(buf) return self.hasher.hexdigest() def main(): \"\"\"主函数\"\"\" hasher1 = StreamHasher() with open('Python-3.7.1.tgz', 'rb') as stream: print(hasher1.to_digest(stream)) hasher2 = StreamHasher('sha1') with open('Python-3.7.1.tgz', 'rb') as stream: print(hasher2(stream)) if name == 'main': main() ``` "},"Python/Python语言进阶/04-迭代器和生成器.html":{"url":"Python/Python语言进阶/04-迭代器和生成器.html","title":"迭代器和生成器","keywords":"","body":"datetime:2019/5/16 15:32 author:nzb 迭代器和生成器 和迭代器相关的魔术方法（__iter__和__next__） 两种创建生成器的方式（生成器表达式和yield关键字） ```Python def fib(num): \"\"\"生成器\"\"\" a, b = 0, 1 for _ in range(num): a, b = b, a + b yield a class Fib(object): \"\"\"迭代器\"\"\" def __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx 生成器，迭代器的区别？ 迭代器：遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple,dictionary, set 等）。 另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2） 或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器， 则只要实现 next()（Python 2）或 next ()（Python 3） 生成器（Generator）：只是在需要返回数据的时候使用yield语句。每次 next() 被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值） 区别： 生成器能做到迭代器能做的所有事，而且因为自动创建 iter() 和 next() 方法，生成器显得特别简洁，而且生成器也是高效的， 使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。 列表推导式、字典推导式以及生成器 import random l = [i for i in range(10)] d = {k:random.randint(4,9) for k in ['a', 'c', 'd']} g = (i for i in range(10)) print(\"列表推导式：{}，类型：{}\".format(l, type(l))) print(\"字典推导式：{}，类型：{}\".format(d, type(d))) print(\"生成器：{}，类型：{}\".format(g, type(g))) # 结果 # 列表推导式：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]，类型： # 字典推导式：{'a': 5, 'c': 6, 'd': 9}，类型： # 生成器： at 0x0000023498EF9390>，类型： "},"Python/Python语言进阶/05-并发和异步编程.html":{"url":"Python/Python语言进阶/05-并发和异步编程.html","title":"并发和异步编程","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 并发编程 Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。 ```Python 面试题：进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程 线程 - 操作系统分配CPU的基本单位 并发编程（concurrent programming） 1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行 2. 改善用户体验 - 让耗时间的操作不会造成程序的假死 import glob import os import threading from PIL import Image PREFIX = 'thumbnails' def generate_thumbnail(infile, size, format='PNG'): \"\"\"生成指定图片文件的缩略图\"\"\" file, ext = os.path.splitext(infile) file = file[file.rfind('/') + 1:] outfile = f'{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}' img = Image.open(infile) img.thumbnail(size, Image.ANTIALIAS) img.save(outfile, format) def main(): \"\"\"主函数\"\"\" if not os.path.exists(PREFIX): os.mkdir(PREFIX) for infile in glob.glob('images/*.png'): for size in (32, 64, 128): # 创建并启动线程 threading.Thread( target=generate_thumbnail, args=(infile, (size, size)) ).start() if __name__ == '__main__': main() ``` 多个线程竞争资源的情况 ```Python # 多线程程序如果没有竞争资源处理起来通常也比较简单 # 当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱 # 说明：临界资源就是被多个线程竞争的资源 import time import threading from concurrent.futures import ThreadPoolExecutor class Account(object): \"\"\"银行账户\"\"\" def __init__(self): self.balance = 0.0 self.lock = threading.Lock() def deposit(self, money): # 通过锁保护临界资源 with self.lock: new_balance = self.balance + money time.sleep(0.001) self.balance = new_balance class AddMoneyThread(threading.Thread): \"\"\"自定义线程类\"\"\" def __init__(self, account, money): self.account = account self.money = money # 自定义线程的初始化方法中必须调用父类的初始化方法 super().__init__() def run(self): # 线程启动之后要执行的操作 self.account.deposit(self.money) def main(): \"\"\"主函数\"\"\" account = Account() # 创建线程池 pool = ThreadPoolExecutor(max_workers=10) futures = [] for _ in range(100): # 创建线程的第1种方式 # threading.Thread( # target=account.deposit, args=(1, ) # ).start() # 创建线程的第2种方式 # AddMoneyThread(account, 1).start() # 创建线程的第3种方式 # 调用线程池中的线程来执行特定的任务 future = pool.submit(account.deposit, 1) futures.append(future) # 关闭线程池 pool.shutdown() for future in futures: future.result() print(account.balance) if __name__ == '__main__': main() ``` 修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用`threading`模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示： ```Python # 多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock） # 多个线程竞争多个资源（线程数>资源数） - 信号量（Semaphore） # 多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition from concurrent.futures import ThreadPoolExecutor from random import randint from time import sleep import threading class Account(): \"\"\"银行账户\"\"\" def __init__(self, balance=0): self.balance = balance lock = threading.Lock() self.condition = threading.Condition(lock) def withdraw(self, money): \"\"\"取钱\"\"\" with self.condition: while money > self.balance: self.condition.wait() new_balance = self.balance - money sleep(0.001) self.balance = new_balance def deposit(self, money): \"\"\"存钱\"\"\" with self.condition: new_balance = self.balance + money sleep(0.001) self.balance = new_balance self.condition.notify_all() def add_money(account): while True: money = randint(5, 10) account.deposit(money) print(threading.current_thread().name, ':', money, '====>', account.balance) sleep(0.5) def sub_money(account): while True: money = randint(10, 30) account.withdraw(money) print(threading.current_thread().name, ':', money, ' 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。 ```Python 多进程和进程池的使用 多线程因为GIL的存在不能够发挥CPU的多核特性 对于计算密集型任务应该考虑使用多进程 time python3 example22.py real 0m11.512s user 0m39.319s sys 0m0.169s 使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍 这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU import concurrent.futures import math PRIMES = [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419 ] * 5 def is_prime(n): \"\"\"判断素数\"\"\" if n % 2 == 0: return False sqrt_n = int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False return True def main(): \"\"\"主函数\"\"\" with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print('%d is prime: %s' % (number, prime)) if __name__ == '__main__': main() ``` > 说明：**多线程和多进程的比较**。 > > 以下情况需要使用多线程： > > 1. 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 > 2. 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。 > > 以下情况需要使用多进程： > > 1. 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 > 2. 程序的输入可以并行的分成块，并且可以将运算结果合并。 > 3. 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者future对象来获取任务执行的结果。Python 3通过asyncio模块和await和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。 ```Python 异步I/O - async / await import asyncio def num_generator(m, n): \"\"\"指定范围的数字生成器\"\"\" yield from range(m, n + 1) async def prime_filter(m, n): \"\"\"素数过滤器\"\"\" primes = [] for i in num_generator(m, n): flag = True for j in range(2, int(i ** 0.5 + 1)): if i % j == 0: flag = False break if flag: print('Prime =>', i) primes.append(i) await asyncio.sleep(0.001) return tuple(primes) async def square_mapper(m, n): \"\"\"平方映射器\"\"\" squares = [] for i in num_generator(m, n): print('Square =>', i * i) squares.append(i * i) await asyncio.sleep(0.001) return squares def main(): \"\"\"主函数\"\"\" loop = asyncio.get_event_loop() future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100)) future.add_done_callback(lambda x: print(x.result())) loop.run_until_complete(future) loop.close() if __name__ == '__main__': main() ``` > 说明：上面的代码使用`get_event_loop`函数获得系统默认的事件循环，通过`gather`函数可以获得一个`future`对象，`future`对象的`add_done_callback`可以添加执行完成时的回调函数，`loop`对象的`run_until_complete`方法可以等待通过`future`对象获得协程执行结果。 Python中有一个名为`aiohttp`的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟`asyncio`模块一起工作，并提供了对`Future`对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。 ```Python import asyncio import re import aiohttp PATTERN = re.compile(r'\\(?P.*)\\') async def fetch_page(session, url): async with session.get(url, ssl=False) as resp: return await resp.text() async def show_title(url): async with aiohttp.ClientSession() as session: html = await fetch_page(session, url) print(PATTERN.search(html).group('title')) def main(): urls = ('https://www.python.org/', 'https://git-scm.com/', 'https://www.jd.com/', 'https://www.taobao.com/', 'https://www.douban.com/') loop = asyncio.get_event_loop() tasks = [show_title(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == '__main__': main() ``` > 说明：**异步I/O与多进程的比较**。 > > 当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。 Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。 要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。 "},"Python/Python语言进阶/06-asyncio异步编程.html":{"url":"Python/Python语言进阶/06-asyncio异步编程.html","title":"asynico异步编程","keywords":"","body":"datetime:2021/11/12 11:00 author:nzb asyncio 异步编程 如今编程都往异步发展，尽可能高效利用系统资源，比如：FastAPI、Tornado、Sanic、Django 3、aiohttp 等。所以，咱怎么能落后呢！！！ 1 协程 想学 asyncio，得先了解协程，协程是根本呀！ 协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如： def func1(): print(1) ... print(2) def func2(): print(3) ... print(4) func1() func2() 上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：1、2、3、4。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：1、3、2、4。 在Python中有多种方式可以实现协程，例如： greenlet：是一个第三方模块，用于实现协程代码（Gevent协程就是基于 greenlet 实现） yield：生成器，借助生成器的特点也可以实现协程代码。 asyncio：在 Python3.4 中引入的模块用于编写协程代码。 async & awiat：在 Python3.5 中引入的两个关键字，结合 asyncio 模块可以更方便的编写协程代码。 1.1 greenlet greentlet 是一个第三方模块，需要提前安装 pip3 install greenlet 才能使用。 from greenlet import greenlet def func1(): print(1) # 第1步：输出 1 gr2.switch() # 第3步：切换到 func2 函数 print(2) # 第6步：输出 2 gr2.switch() # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行 def func2(): print(3) # 第4步：输出 3 gr1.switch() # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行 print(4) # 第8步：输出 4 gr1 = greenlet(func1) gr2 = greenlet(func2) gr1.switch() # 第1步：去执行 func1 函数 注意：switch 中也可以传递参数用于在切换执行时相互传递值。 1.2 yield 基于 Python 的生成器的 yield 和 yield form 关键字实现协程代码。 def func1(): yield 1 yield from func2() yield 2 def func2(): yield 3 yield 4 f1 = func1() for item in f1: print(item) 注意：yield form 关键字是在 Python3.3 中引入的。 1.3 asyncio 在 Python3.4 之前官方未提供协程的类库，一般大家都是使用 greenlet 等其他来实现。在 Python3.4 发布后官方正式支持协程，即：asyncio 模块。 import asyncio @asyncio.coroutine def func1(): print(1) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(2) @asyncio.coroutine def func2(): print(3) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2()) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 注意：基于 asyncio 模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。 1.4 async & awit async & awit 关键字在 Python3.5 版本中正式引入，基于他编写的协程代码其实就是上一示例的加强版，让代码可以更加简便。 Python3.8 之后 @asyncio.coroutine 装饰器就会被移除，推荐使用 async & awit关键字实现协程代码。 import asyncio async def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2()) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 1.5 小结 关于协程有多种实现方式，目前主流使用是 Python 官方推荐的 asyncio 模块和 async & await 关键字的方式，例如：在 tonado、sanic、fastapi、django3 中均已支持。 接下来，也会针对 asyncio模块 + async & await 关键字进行更加详细的讲解。 2 协程的意义 通过上面，已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。 但是，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？） 计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。 IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。 2.1 爬虫案例 例如：用代码实现下载 url_list 中的图片。 方式一：同步编程实现 # 下载图片使用第三方模块requests，请提前安装：pip3 install requests import requests def download_image(url): print(\"开始下载:\", url) # 发送网络请求，下载图片 response = requests.get(url) print(\"下载完成\") # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] for item in url_list: download_image(item) 方式二：基于协程的异步编程实现 # 下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp # !/usr/bin/env python # -*- coding:utf-8 -*- import aiohttp import asyncio async def fetch(session, url): print(\"发送请求：\", url) async with session.get(url, verify_ssl=False) as response: content = await response.content.read() file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(content) async def main(): async with aiohttp.ClientSession() as session: url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(tasks) if __name__ == '__main__': asyncio.run(main()) 上述两种的执行对比之后会发现，基于协程的异步编程要比同步编程的效率高了很多。因为： 同步编程，按照顺序逐一排队执行，如果图片下载时间为 2分钟，那么全部执行完则需要 6分钟。 异步编程，几乎同时发出了 3个下载任务的请求（遇到 IO 请求自动切换去发送其他任务请求），如果图片下载时间为 2分钟，那么全部执行完毕也大概需要 2分钟左右就可以了。 2.2 小结 协程一般应用在有 IO操作的程序中，因为协程可以利用 IO等待的时间去执行一些其他的代码，从而提升代码执行效率。 生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待 30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那 30分钟的时间去做点其他的工作。 3 异步编程 基于 async & await 关键字的协程可以实现异步编程，这也是目前 python 异步相关的主流技术。想要真正的了解 Python 中内置的异步编程，根据下文的顺序一点点来看。 3.1 事件循环 事件循环，可以把他当做是一个 while 循环，这个 while 循环在周期性的运行并执行一些任务，在特定条件下终止循环。 # 伪代码 任务列表 = [ 任务1, 任务2, 任务3,... ] while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将'可执行'和'已完成'的任务返回 for 就绪任务 in 已准备就绪的任务列表: 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表: 在任务列表中移除 已完成的任务 如果 任务列表 中的任务都已完成，则终止循环 在编写程序时候可以通过如下代码来获取和创建事件循环。 import asyncio loop = asyncio.get_event_loop() 3.2 协程和异步编程 协程函数，定义形式为 async def 的函数。 协程对象，调用 协程函数 所返回的对象。 # 定义一个协程函数 async def func(): pass # 调用协程函数，返回一个协程对象 result = func() 注意：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。 3.2.1 基本应用 程序中，如果想要执行协程函数的内部代码，需要 事件循环 和 协程对象 配合才能实现，如： import asyncio async def func(): print(\"协程内部代码\") # 调用协程函数，返回一个协程对象。 result = func() # 方式一 # loop = asyncio.get_event_loop() # 创建一个事件循环 # loop.run_until_complete(result) # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。 # 方式二 # 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。 # asyncio.run 函数在 Python 3.7 中加入 asyncio 模块， asyncio.run(result) 这个过程可以简单理解为：将协程当做任务添加到 事件循环 的任务列表，然后事件循环检测列表中的协程是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。 3.2.2 await await 是一个只能在协程函数中使用的关键字，用于遇到 IO 操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行 await 之后的代码。代码如下： 示例1： import asyncio async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。 # 当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await asyncio.sleep(2) print(\"IO请求结束，结果为：\", response) result = func() asyncio.run(result) 示例2： import asyncio async def others(): print(\"start\") await asyncio.sleep(2) print('end') return '返回值' async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await others() print(\"IO请求结束，结果为：\", response) asyncio.run(func()) 示例3： import asyncio async def others(): print(\"start\") await asyncio.sleep(2) print('end') return '返回值' async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response1 = await others() print(\"IO请求结束，结果为：\", response1) response2 = await others() print(\"IO请求结束，结果为：\", response2) asyncio.run(func()) 上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在 IO 等待时无法演示切换到其他任务效果。 在程序想要创建多个任务对象，需要使用 Task 对象来实现。 3.2.3 Task对象 Tasks are used to schedule coroutines concurrently. When a coroutine is wrapped into a Task with functions like asyncio.create_task() the coroutine is automatically scheduled to run soon。 Tasks用于并发调度协程，通过 asyncio.create_task(协程对象) 的方式创建 Task 对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 asyncio.create_task() 函数以外，还可以用低层级的 loop.create_task() 或 ensure_future() 函数。不建议手动实例化 Task 对象。 本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。 注意：asyncio.create_task() 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 asyncio.ensure_future() 函数。 示例1： import asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \"返回值\" async def main(): print(\"main开始\") # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 task1 = asyncio.create_task(func()) # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 task2 = asyncio.create_task(func()) print(\"main结束\") # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。 # 此处的await是等待相对应的协程全都执行完毕并获取结果 ret1 = await task1 ret2 = await task2 print(ret1, ret2) asyncio.run(main()) 示例2： import asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \"返回值\" async def main(): print(\"main开始\") # 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 # 在调用 task_list = [ asyncio.create_task(func(), name=\"n1\"), asyncio.create_task(func(), name=\"n2\") ] print(\"main结束\") # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。 # 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done # 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。 done, pending = await asyncio.wait(task_list, timeout=None) print(done, pending) asyncio.run(main()) 注意：asyncio.wait 源码内部会对列表中的每个协程执行 ensure_future 从而封装为Task对象，所以在和wait配合使用时task_list的值为[func(),func()] 也是可以的。 示例3： import asyncio async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await asyncio.sleep(2) print(\"IO请求结束，结果为：\", response) coroutine_list = [func(), func()] # 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ] # 此处不能直接 asyncio.create_task，因为将 Task 立即加入到事件循环的任务列表。 # 但此时事件循环还未创建，所以会报错。事件循环创建在 asyncio.run 里面才创建。 # 使用 asyncio.wait 将列表封装为一个协程，并调用 asyncio.run 实现执行两个协程 # asyncio.wait 内部会对列表中的每个协程执行 ensure_future，封装为 Task 对象。 done, pending = asyncio.run(asyncio.wait(coroutine_list)) 3.2.4 asyncio.Future 对象 A Futureis a special low-level awaitable object that represents an eventual result of an asynchronous operation. asyncio中的Future对象是一个相对更偏向底层的可等待对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ） Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。 示例1： async def main(): # 获取当前事件循环 loop = asyncio.get_running_loop() # # 创建一个任务（Future对象），这个任务什么都不干。 fut = loop.create_future() # 等待任务最终结果（Future对象），没有结果则会一直等下去。 await fut asyncio.run(main()) 示例2： import asyncio async def set_after(fut): await asyncio.sleep(2) fut.set_result(\"666\") async def main(): # 获取当前事件循环 loop = asyncio.get_running_loop() # 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。 fut = loop.create_future() # 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。 # 即手动设置future任务的最终结果，那么fut就可以结束了。 await loop.create_task(set_after(fut)) # 等待 Future对象获取 最终结果，否则一直等下去 data = await fut print(data) asyncio.run(main()) Future 对象本身函数进行绑定，所以想要让事件循环获取 Future 的结果，则需要手动设置。而 Task 对象继承了 Future 对象，其实就对 Future 进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行 set_result，从而实现自动结束。 虽然，平时使用的是 Task 对象，但对于结果的处理本质是基于 Future 对象来实现的。 扩展：支持 await 对象语法的对象可成为可等待对象，所以 协程对象、Task 对象、Future 对象 都可以被成为可等待对象。 3.2.5 futures.Future对象 在Python的concurrent.futures模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。 import time from concurrent.futures import Future from concurrent.futures.thread import ThreadPoolExecutor from concurrent.futures.process import ProcessPoolExecutor def func(value): time.sleep(1) print(value) pool = ThreadPoolExecutor(max_workers=5) # 或 pool = ProcessPoolExecutor(max_workers=5) for i in range(10): fut = pool.submit(func, i) print(fut) 两个Future对象是不同的，他们是为不同的应用场景而设计，例如：concurrent.futures.Future 不支持await语法 等。 官方提示两对象之间不同： unlike asyncio Futures, concurrent.futures.Future instances cannot be awaited. asyncio.Future.result() and asyncio.Future.exception() do not accept the timeout argument. asyncio.Future.result() and asyncio.Future.exception() raise an InvalidStateError exception when the Future is not done. Callbacks registered with asyncio.Future.add_done_callback() are not called immediately. They are scheduled with loop.call_soon() instead. asyncio Future is not compatible with the concurrent.futures.wait() and concurrent.futures.as_completed() functions. 在 Python 提供了一个将futures.Future 对象包装成asyncio.Future对象的函数 asynic.wrap_future。 为什么python会提供这种功能？ 其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果协程的异步和进程池/线程池的异步混搭时，那么就会用到此功能了。 import time import asyncio import concurrent.futures def func1(): # 某个耗时操作 time.sleep(2) return \"SB\" async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop's executor ( 默认ThreadPoolExecutor ) # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。 fut = loop.run_in_executor(None, func1) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom thread pool', result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom process pool', result) asyncio.run(main()) 应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如： import asyncio import requests async def download_image(url): # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务） print(\"开始下载:\", url) loop = asyncio.get_event_loop() # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print('下载完成') # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 3.2.6 异步迭代器 什么是异步迭代器 实现了 __aiter__() 和 __anext__() 方法的对象。__anext__ 必须返回一个 awaitable 对象。async for 会处理异步迭代器的__anext__() 方法所返回的可等待对象，直到其引发一个 StopAsyncIteration 异常。由 PEP 492 引入。 什么是异步可迭代对象？ 可在 async for 语句中被使用的对象。必须通过它的 __aiter__() 方法返回一个 asynchronous iterator。由 PEP 492 引入。 import asyncio class Reader(object): \"\"\" 自定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): # 创建异步可迭代对象 async_iter = Reader() # async for 必须要放在async def函数内，否则语法错误。 async for item in async_iter: print(item) asyncio.run(func()) 异步迭代器其实没什么太大的作用，只是支持了async for语法而已。 3.2.6 异步上下文管理器 此种对象通过定义 __aenter__() 和 __aexit__() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。 import asyncio class AsyncContextManager: def __init__(self): self.conn = None async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库链接 await asyncio.sleep(1) async def func(): async with AsyncContextManager() as f: result = await f.do_something() print(result) asyncio.run(func()) 这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。 3.3 小结 在程序中只要看到async和await关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。 以上就是异步编程的常见操作，内容参考官方文档。 中文版 英文版 4 uvloop Python标准库中提供了asyncio模块，用于支持基于协程的异步编程。 uvloop 是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。 安装uvloop pip3 install uvloop 在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。 import asyncio import uvloop asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) # 编写asyncio的代码，与之前写的代码一致。 # 内部的事件循环自动化会变为uvloop asyncio.run(...) 注意：知名的 asgi uvicorn 内部就是使用的 uvloop 的事件循环。 5 实战案例 5.1 异步Redis 当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。 安装Python异步操作redis模块 pip3 install aioredis 示例1：异步操作 Redis #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import aioredis async def execute(address, password): print(\"开始执行\", address) # 网络IO操作：创建redis连接 redis = await aioredis.create_redis(address, password=password) # 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = { car:{key1:1,key2:2,key3:3}} await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 网络IO操作：去redis中获取值 result = await redis.hgetall('car', encoding='utf-8') print(result) redis.close() # 网络IO操作：关闭redis连接 await redis.wait_closed() print(\"结束\", address) asyncio.run(execute('redis://47.93.4.198:6379', \"root!2345\")) 示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。 import asyncio import aioredis async def execute(address, password): print(\"开始执行\", address) # 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379 redis = await aioredis.create_redis_pool(address, password=password) # 网络IO操作：遇到IO会自动切换任务 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 网络IO操作：遇到IO会自动切换任务 result = await redis.hgetall('car', encoding='utf-8') print(result) redis.close() # 网络IO操作：遇到IO会自动切换任务 await redis.wait_closed() print(\"结束\", address) task_list = [ execute('redis://47.93.4.197:6379', \"root!2345\"), execute('redis://47.93.4.198:6379', \"root!2345\") ] asyncio.run(asyncio.wait(task_list)) 更多redis操作参考aioredis官网 5.2 异步 MySQL 当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。 安装Python异步操作redis模块 pip3 install aiomysql 示例1： import asyncio import aiomysql async def execute(): # 网络IO操作：连接MySQL conn = await aiomysql.connect(host='127.0.0.1', port=3306, user='root', password='123', db='mysql', ) # 网络IO操作：创建CURSOR cur = await conn.cursor() # 网络IO操作：执行SQL await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：获取SQL结果 result = await cur.fetchall() print(result) # 网络IO操作：关闭链接 await cur.close() conn.close() asyncio.run(execute()) 示例2： #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import aiomysql async def execute(host, password): print(\"开始\", host) # 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379 conn = await aiomysql.connect(host=host, port=3306, user='root', password=password, db='mysql') # 网络IO操作：遇到IO会自动切换任务 cur = await conn.cursor() # 网络IO操作：遇到IO会自动切换任务 await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：遇到IO会自动切换任务 result = await cur.fetchall() print(result) # 网络IO操作：遇到IO会自动切换任务 await cur.close() conn.close() print(\"结束\", host) task_list = [ execute('47.93.40.197', \"root!2345\"), execute('47.93.40.197', \"root!2345\") ] asyncio.run(asyncio.wait(task_list)) 5.3 FastAPI 框架 FastAPI 是一款用于构建API的高性能web框架，框架基于Python3.6+的 type hints搭建。 接下里的异步示例以FastAPI和uvicorn来讲解（uvicorn是一个支持异步的asgi）。 安装FastAPI web 框架 pip3 install fastapi 安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi） pip3 install uvicorn 示例： # !/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn import aioredis from aioredis import Redis from fastapi import FastAPI app = FastAPI() REDIS_POOL = aioredis.ConnectionsPool('redis://47.193.14.198:6379', password=\"root123\", minsize=1, maxsize=10) @app.get(\"/\") def index(): \"\"\" 普通操作接口 \"\"\" return {\"message\": \"Hello World\"} @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" print(\"请求来了\") await asyncio.sleep(3) # 连接池获取一个连接 conn = await REDIS_POOL.acquire() redis = Redis(conn) # 设置值 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 读取值 result = await redis.hgetall('car', encoding='utf-8') print(result) # 连接归还连接池 REDIS_POOL.release(conn) return result if __name__ == '__main__': uvicorn.run(\"demo:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。 例如：同时有两个用户并发来向接口 http://127.0.0.1:5000/red 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。 异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。 基于上下文管理，来实现自动化管理的案例： 示例1：redis #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn import aioredis from aioredis import Redis from fastapi import FastAPI app = FastAPI() REDIS_POOL = aioredis.ConnectionsPool('redis://47.193.14.198:6379', password=\"root123\", minsize=1, maxsize=10) @app.get(\"/\") def index(): \"\"\" 普通操作接口 \"\"\" return {\"message\": \"Hello World\"} @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" print(\"请求来了\") async with REDIS_POOL.get() as conn: redis = Redis(conn) # 设置值 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 读取值 result = await redis.hgetall('car', encoding='utf-8') print(result) return result if __name__ == '__main__': uvicorn.run(\"fast3:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 示例2：mysql #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn from fastapi import FastAPI import aiomysql app = FastAPI() # 创建数据库连接池 pool = aiomysql.Pool(host='127.0.0.1', port=3306, user='root', password='123', db='mysql', minsize=1, maxsize=10, echo=False, pool_recycle=-1, loop=asyncio.get_event_loop()) @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" # 去数据库连接池申请链接 async with pool.acquire() as conn: async with conn.cursor() as cur: # 网络IO操作：执行SQL await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：获取SQL结果 result = await cur.fetchall() print(result) # 网络IO操作：关闭链接 return {\"result\": \"ok\"} if __name__ == '__main__': uvicorn.run(\"fast2:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 5.4 爬虫 在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。 安装aiohttp模块 pip3 install aiohttp 示例： import aiohttp import asyncio async def fetch(session, url): print(\"发送请求：\", url) async with session.get(url, verify_ssl=False) as response: text = await response.text() print(\"得到结果：\", url, len(text)) async def main(): async with aiohttp.ClientSession() as session: url_list = [ 'https://python.org', 'https://www.baidu.com', 'https://www.pythonav.com' ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(tasks) if __name__ == '__main__': asyncio.run(main()) 总结 为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。 "},"Python/第三方库/Django/01-快速上手.html":{"url":"Python/第三方库/Django/01-快速上手.html","title":"快速上手","keywords":"","body":"datetime:2019/6/10 9:55 author:nzb 快速上手 Web开发的早期阶段，开发者需要手动编写每个页面，例如一个新闻门户网站，每天都要修改它的HTML页面，随着网站规模和体量的增大，这种方式就变得极度糟糕。为了解决这个问题，开发人员想到了用外部程序来为Web服务器生成动态内容，也就是说HTML页面以及页面中的动态内容不再通过手动编写而是通过程序自动生成。最早的时候，这项技术被称为CGI（公共网关接口），当然随着时间的推移，CGI暴露出的问题也越来越多，例如大量重复的样板代码，总体性能较为低下等，因此在时代呼唤新英雄的背景下，PHP、ASP、JSP这类Web应用开发技术在上世纪90年代中后期如雨后春笋般涌现。通常我们说的Web应用是指通过浏览器来访问网络资源的应用程序，因为浏览器的普及性以及易用性，Web应用使用起来方便简单，免除了安装和更新应用程序带来的麻烦，而且也不用关心用户到底用的是什么操作系统，甚至不用区分是PC端还是移动端。 Web应用机制和术语 下图向我们展示了Web应用的工作流程，其中涉及到的术语如下表所示。 说明：相信有经验的读者会发现，这张图中其实还少了很多东西，例如反向代理服务器、数据库服务器、防火墙等，而且图中的每个节点在实际项目部署时可能是一组节点组成的集群。当然，如果你对这些没有什么概念也不要紧，继续下去就行了，后面会给大家一一讲解的。 术语 解释 URL/URI 统一资源定位符/统一资源标识符，网络资源的唯一标识 域名 与Web服务器地址对应的一个易于记忆的字符串名字 DNS 域名解析服务，可以将域名转换成对应的IP地址 IP地址 网络上的主机的身份标识，通过IP地址可以区分不同的主机 HTTP 超文本传输协议，构建在TCP之上的应用级协议，万维网数据通信的基础 反向代理 代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端 Web服务器 接受HTTP请求，然后返回HTML文件、纯文本文件、图像等资源给请求者 Nginx 高性能的Web服务器，也可以用作反向代理，负载均衡 和 HTTP缓存 HTTP协议 这里我们稍微费一些笔墨来谈谈上面提到的HTTP。HTTP（超文本传输协议）是构建于TCP（传输控制协议）之上应用级协议，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解。下图是我于2009年9月10日凌晨4点在四川省网络通信技术重点实验室用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。 HTTP请求（请求行+请求头+空行+[消息体]）： HTTP响应（响应行+响应头+空行+消息体）： 说明：但愿这两张如同泛黄的照片般的截图能帮助你了解HTTP到底是什么样子的。 Django概述 Python的Web框架有上百个，比它的关键字还要多。所谓Web框架，就是用于开发Web服务器端应用的基础设施（通常指封装好的模块和一系列的工具）。事实上，即便没有Web框架，我们仍然可以通过socket或CGI来开发Web服务器端应用，但是这样做的成本和代价在实际开发中通常是不能接受的。通过Web框架，我们可以化繁为简，同时降低创建、更新、扩展应用程序的工作量。Python的Web框架中比较有名的有：Flask、Django、Tornado、Sanic、Pyramid、Bottle、Web2py、web.py等。 在基于Python的Web框架中，Django是所有重量级选手中最有代表性的一位，开发者可以基于Django快速的开发可靠的Web应用程序，因为它减少了Web开发中不必要的开销，对常用的设计和开发模式进行了封装，并对MVC架构提供了支持（MTV）。许多成功的网站和App都是基于Django框架构建的，国内比较有代表性的网站包括：知乎、豆瓣网、果壳网、搜狐闪电邮箱、101围棋网、海报时尚网、背书吧、堆糖、手机搜狐网、咕咚、爱福窝、果库等。 Django诞生于2003年，它是一个在真正的应用中成长起来的项目，由劳伦斯出版集团旗下在线新闻网站的内容管理系统（CMS）研发团队编写（主要是Adrian Holovaty和Simon Willison），以比利时的吉普赛爵士吉他手Django Reinhardt来命名，在2005年夏天作为开源框架发布。使用Django能用很短的时间构建出功能完备的网站，因为它代替程序员完成了所有乏味和重复的劳动，剩下真正有意义的核心业务给程序员，这一点就是对DRY（Don't Repeat Yourself）理念的最好践行。 5分钟快速上手 准备工作 检查Python环境：Django 1.11需要Python 2.7或Python 3.4以上的版本；Django 2.0需要Python 3.4以上的版本；Django 2.1需要Python 3.5以上的版本。 $ python3 --version $ python3 >>> import sys >>> sys.version >>> sys.version_info 创建项目文件夹并切换到该目录，例如我们要实例一个OA（办公自动化）项目。 $ mkdir oa $ cd oa 创建并激活虚拟环境。 $ python3 -m venv venv $ source venv/bin/activate 说明：上面使用了Python自带的venv模块完成了虚拟环境的创建，当然也可以使用其他的工具，例如：virtualenv或pipenv等。要激活虚拟环境，在Windows系统下是通过\"venv/Scripts/activate\"`执行批处理文件来实现。 更新包管理工具pip。 (venv)$ pip install -U pip 或 (venv)$ python -m pip install -U pip 注意：请注意终端提示符发生的变化，前面的(venv)说明我们已经进入虚拟环境，而虚拟环境下的python和pip已经是Python 3的解释器和包管理工具了。 安装Django。 (venv)$ pip install django 或指定版本号来安装对应的Django的版本。 (venv)$ pip install django==1.11 检查Django的版本。 (venv)$ python -m django --version (venv)$ django-admin --version 或 (venv)$ python >>> import django >>> django.get_version() 当然，也可以通过pip来查看安装的依赖库及其版本，如： (venv)$ pip freeze (venv)$ pip list 下图展示了Django版本和Python版本的对应关系，如果在安装时没有指定版本号，将自动选择最新的版本（在写作这段内容时，最新的版本是2.0；目前最新的版本已经更新到2.2）。 | Django版本 | Python版本 | | ---------- | ----------------------- | | 1.8 | 2.7、3.2、3.3、3.4、3.5 | | 1.9、1.10 | 2.7、3.4、3.5 | | 1.11 | 2.7、3.4、3.5、3.6、3.7 | | 2.0 | 3.4、3.5、3.6、3.7 | | 2.1、2.2 | 3.5、3.6、3.7 | 使用django-admin创建项目，项目命名为oa。 (venv)$ django-admin startproject oa . 注意：上面的命令最后的那个点，它表示在当前路径下创建项目。 执行上面的命令后看看生成的文件和文件夹，它们的作用如下所示： manage.py： 一个让你用各种方式管理 Django 项目的命令行工具。 oa/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 oa/settings.py：Django 项目的配置文件。 oa/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。 oa/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。 启动服务器运行项目。 (venv)$ python manage.py runserver 在浏览器中输入http://127.0.0.1:8000访问我们的服务器，效果如下图所示。 说明1：刚刚启动的是Django自带的用于开发和测试的服务器，它是一个用纯Python编写的轻量级Web服务器，但它并不是真正意义上的生产级别的服务器，千万不要将这个服务器用于和生产环境相关的任何地方。 说明2：用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍Python代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。 说明3：可以通过python manage.py help命令查看可用命令列表；在启动服务器时，也可以通过python manage.py runserver 1.2.3.4:5678来指定绑定的IP地址和端口。 说明4：可以通过Ctrl+C来终止服务器的运行。 接下来我们修改项目的配置文件settings.py，Django是一个支持国际化和本地化的框架，因此刚才我们看到的默认首页也是支持国际化的，我们将默认语言修改为中文，时区设置为东八区。 (venv)$ vim oa/settings.py # 此处省略上面的内容 # 设置语言代码 LANGUAGE_CODE = 'zh-hans' # 设置时区 TIME_ZONE = 'Asia/Chongqing' # 此处省略下面的内容 刷新刚才的页面。 动态页面 创建名为hrs（人力资源系统）的应用，一个Django项目可以包含一个或多个应用。 (venv)$ python manage.py startapp hrs 执行上面的命令会在当前路径下创建hrs目录，其目录结构如下所示： __init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 admin.py：可以用来注册模型，用于在Django的管理界面管理模型。 apps.py：当前应用的配置。 migrations：存放与模型有关的数据库迁移信息。 __init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 models.py：存放应用的数据模型，即实体类及其之间的关系（MVC/MVT中的M）。 tests.py：包含测试应用各项功能的测试类和测试函数。 views.py：处理请求并返回响应的函数（MVC中的C，MVT中的V）。 修改应用目录下的视图文件views.py。 (venv)$ vim hrs/views.py ```Python from django.http import HttpResponse def index(request): return HttpResponse('Hello, Django!') 3. 在应用目录创建一个urls.py文件并映射URL。 ```Shell (venv)$ touch hrs/urls.py (venv)$ vim hrs/urls.py from django.urls import path from hrs import views urlpatterns = [ path('', views.index, name='index'), ] 说明：上面使用的path函数是Django 2.x中新添加的函数，除此之外还可以使用支持正则表达式的URL映射函数re_path函数；Django 1.x中是用名为url函数来设定URL映射。 切换到项目目录，修改该目录下的urls.py文件，对应用中设定的URL进行合并。 (venv) $ vim oa/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('hrs/', include('hrs.urls')), ] 重新运行项目，并打开浏览器中访问http://localhost:8000/hrs。 (venv)$ python manage.py runserver 修改views.py生成动态内容。 (venv)$ vim hrs/views.py ```Python from io import StringIO from django.http import HttpResponse depts_list = [ {'no': 10, 'name': '财务部', 'location': '北京'}, {'no': 20, 'name': '研发部', 'location': '成都'}, {'no': 30, 'name': '销售部', 'location': '上海'}, ] def index(request): output = StringIO() output.write('\\n') output.write('\\n') output.write('\\t\\n') output.write('\\t首页') output.write('\\n') output.write('\\n') output.write('\\t部门信息\\n') output.write('\\t\\n') output.write('\\t\\n') output.write('\\t\\t\\n') output.write('\\t\\t\\t部门编号\\n') output.write('\\t\\t\\t部门名称\\n') output.write('\\t\\t\\t所在地\\n') output.write('\\t\\t\\n') for dept in depts_list: output.write('\\t\\t\\n') output.write(f'\\t\\t\\t{dept[\"no\"]}\\n') output.write(f'\\t\\t\\t{dept[\"name\"]}\\n') output.write(f'\\t\\t\\t{dept[\"location\"]}\\n') output.write('\\t\\t\\n') output.write('\\t\\n') output.write('\\n') output.write('\\n') return HttpResponse(output.getvalue()) 7. 刷新页面查看程序的运行结果。 ![](./res/show-depts.png) #### 使用视图模板 上面通过拼接HTML代码的方式生成动态视图的做法在实际开发中是无能接受的，这一点大家一定能够想到。为了解决这个问题，我们可以提前准备一个模板页，所谓模板页就是一个带占位符的HTML页面，当我们将程序中获得的数据替换掉页面中的占位符时，一个动态页面就产生了。 我们可以用Django框架中template模块的Template类创建模板对象，通过模板对象的render方法实现对模板的渲染。所谓的渲染就是用数据替换掉模板页中的占位符，当然这里的渲染称为后端渲染，即在服务器端完成页面的渲染再输出到浏览器中，这种做法的主要坏处是当并发访问量较大时，服务器会承受较大的负担，所以今天有很多的Web应用都使用了前端渲染，即服务器只为浏览器提供所需的数据（通常是JSON格式），在浏览器中通过JavaScript获取这些数据并渲染到页面上，这些内容在后面为大家呈现。 Django框架通过shortcuts模块的快捷函数`render`简化了渲染模板的操作，具体的用法如下所示。 1. 先回到manage.py文件所在的目录创建名为templates文件夹。 ```Shell (venv)$ mkdir templates 创建模板页index.html。 (venv)$ touch templates/index.html (venv)$ vim templates/index.html 首页 部门信息 部门编号 部门名称 所在地 { % for dept in depts_list % } { { dept.no } } { { dept.name } } { { dept.location } } { % endfor % } 在上面的模板页中我们使用了{ { greeting } }这样的模板占位符语法，也使用了{ % for % }这样的模板指令，这些都是Django模板语言（DTL）的一部分。如果对此不熟悉并不要紧，我们会在后续的内容中进一步的讲解，而且我们刚才也说到了，还有更好的选择就是使用前端渲染，当然这是后话。 回到应用目录，修改views.py文件。 (venv)$ vim hrs/views.py ```Python from django.shortcuts import render depts_list = [ {'no': 10, 'name': '财务部', 'location': '北京'}, {'no': 20, 'name': '研发部', 'location': '成都'}, {'no': 30, 'name': '销售部', 'location': '上海'}, ] def index(request): return render(request, 'index.html', {'depts_list': depts_list}) 到此为止，我们还没有办法让views.py中的`render`函数找到模板文件index.html，为此我们需要修改settings.py文件，配置模板文件所在的路径。 4. 切换到项目目录修改settings.py文件。 ```Shell (venv)$ vim oa/settings.py # 此处省略上面的内容 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] # 此处省略下面的内容 重新运行项目或直接刷新页面查看结果。 (venv)$ python manage.py runserver 总结 至此，我们已经利用Django框架完成了一个非常小的Web应用，虽然它并没有任何的实际价值，但是可以通过这个项目对Django框架有一个感性的认识。当然，实际开发中我们可以用PyCharm来创建项目，如果使用专业版的PyCharm，可以直接创建Django项目。使用PyCharm的好处在于编写代码时可以获得代码提示、错误修复、自动导入等功能，从而提升开发效率，但是专业版的PyCharm需要按年支付相应的费用，社区版的PyCharm中并未包含对Django框架直接的支持，但是我们仍然可以使用它来创建Django项目，只是在使用上没有专业版的方便。关于PyCharm的使用，可以参考《玩转PyCharm》一文。 此外，学习Django最好的资料肯定是它的官方文档，除此之外图灵社区出版的《Django基础教程》也是非常适合初学者的读物。 "},"Python/第三方库/Django/02-深入模型.html":{"url":"Python/第三方库/Django/02-深入模型.html","title":"深入模型","keywords":"","body":"datetime:2019/6/10 10:01 author:nzb 深入模型 在上一个章节中，我们提到了Django是基于MVC架构的Web框架，MVC架构追求的是“模型”和“视图”的解耦合。所谓“模型”说得更直白一些就是数据，所以通常也被称作“数据模型”。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在很长一段时间都是持久化的首选方案，下面我们以MySQL为例来说明如何使用关系型数据库来实现持久化操作。 配置关系型数据库MySQL 我们继续来完善上一个章节中的OA项目，首先从配置项目使用的数据库开始。 修改项目的settings.py文件，首先将我们之前创建的应用hrs添加已安装的项目中，然后配置MySQL作为持久化方案。 (venv)$ cd oa/settings.py # 此处省略上面的代码 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'hrs', ] DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'oa', 'HOST': 'localhost', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', } } # 此处省略下面的代码 在配置ENGINE属性时，常用的可选值包括： 'django.db.backends.sqlite3'：SQLite嵌入式数据库。 'django.db.backends.postgresql'：BSD许可证下发行的开源关系型数据库产品。 'django.db.backends.mysql'：转手多次目前属于甲骨文公司的经济高效的数据库产品。 'django.db.backends.oracle'：甲骨文公司的关系型数据库旗舰产品。 其他的配置可以参考官方文档中数据库配置的部分。 NAME属性代表数据库的名称，如果使用SQLite它对应着一个文件，在这种情况下NAME的属性值应该是一个绝对路径；使用其他关系型数据库，则要配置对应的HOST（主机）、PORT（端口）、USER（用户名）、PASSWORD（口令）等属性。 安装MySQL客户端工具，Python 3中使用PyMySQL，Python 2中用MySQLdb。 (venv)$ pip install pymysql 如果使用Python 3需要修改项目的__init__.py文件并加入如下所示的代码，这段代码的作用是将PyMySQL视为MySQLdb来使用，从而避免Django找不到连接MySQL的客户端工具而询问你：“Did you install mysqlclient? ”（你安装了mysqlclient吗？）。 import pymysql pymysql.install_as_MySQLdb() 运行manage.py并指定migrate参数实现数据库迁移，为应用程序创建对应的数据表，当然在此之前需要先启动MySQL数据库服务器并创建名为oa的数据库，在MySQL中创建数据库的语句如下所示。 drop database if exists oa; create database oa default charset utf8; (venv)$ cd .. (venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK 可以看到，Django帮助我们创建了10张表，这些都是使用Django框架需要的东西，稍后我们就会用到这些表。除此之外，我们还应该为我们自己的应用创建数据模型。如果要在hrs应用中实现对部门和员工的管理，我们可以创建如下所示的数据模型。 (venv)$ vim hrs/models.py ```Python from django.db import models class Dept(models.Model): \"\"\"部门类\"\"\" no = models.IntegerField(primary_key=True, db_column='dno', verbose_name='部门编号') name = models.CharField(max_length=20, db_column='dname', verbose_name='部门名称') location = models.CharField(max_length=10, db_column='dloc', verbose_name='部门所在地') class Meta: db_table = 'tb_dept' class Emp(models.Model): \"\"\"员工类\"\"\" no = models.IntegerField(primary_key=True, db_column='eno', verbose_name='员工编号') name = models.CharField(max_length=20, db_column='ename', verbose_name='员工姓名') job = models.CharField(max_length=10, verbose_name='职位') # 自参照完整性多对一外键关联 mgr = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='主管编号') sal = models.DecimalField(max_digits=7, decimal_places=2, verbose_name='月薪') comm = models.DecimalField(max_digits=7, decimal_places=2, null=True, blank=True, verbose_name='补贴') # 多对一外键关联 dept = models.ForeignKey(Dept, db_column='dno', on_delete=models.PROTECT, verbose_name='所在部门') class Meta: db_table = 'tb_emp' > 说明：上面定义模型时使用了字段类及其属性，其中IntegerField对应数据库中的integer类型，CharField对应数据库的varchar类型，DecimalField对应数据库的decimal类型，ForeignKey用来建立多对一外键关联。字段属性primary_key用于设置主键，max_length用来设置字段的最大长度，db_column用来设置数据库中与字段对应的列，verbose_name则设置了Django后台管理系统中该字段显示的名称。如果对这些东西感到很困惑也不要紧，文末提供了字段类、字段属性、元数据选项等设置的相关说明，不清楚的读者可以稍后查看对应的参考指南。 5. 通过模型创建数据表。 ```Shell (venv)$ python manage.py makemigrations hrs Migrations for 'hrs': hrs/migrations/0001_initial.py - Create model Dept - Create model Emp (venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, hrs, sessions Running migrations: Applying hrs.0001_initial... OK 执行完数据模型迁移操作之后，可以在通过图形化的MySQL客户端工具查看到E-R图（实体关系图）。 在后台管理模型 创建超级管理员账号。 (venv)$ python manage.py createsuperuser Username (leave blank to use 'hao'): jackfrued Email address: jackfrued@126.com Password: Password (again): Superuser created successfully. 启动Web服务器，登录后台管理系统。 (venv)$ python manage.py runserver 访问http://127.0.0.1:8000/admin，会来到如下图所示的登录界面。 登录后进入管理员操作平台。 至此我们还没有看到之前创建的模型类，需要在应用的admin.py文件中模型进行注册。 注册模型类。 (venv)$ vim hrs/admin.py from django.contrib import admin from hrs.models import Emp, Dept admin.site.register(Dept) admin.site.register(Emp) 注册模型类后，就可以在后台管理系统中看到它们。 对模型进行CRUD操作。 可以在管理员平台对模型进行C（新增）R（查看）U（更新）D（删除）操作，如下图所示。 添加新的部门。 查看所有部门。 更新和删除部门。 注册模型管理类。 再次修改admin.py文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。 ```Python from django.contrib import admin from hrs.models import Emp, Dept class DeptAdmin(admin.ModelAdmin): list_display = ('no', 'name', 'location') ordering = ('no', ) class EmpAdmin(admin.ModelAdmin): list_display = ('no', 'name', 'job', 'mgr', 'sal', 'comm', 'dept') search_fields = ('name', 'job') admin.site.register(Dept, DeptAdmin) admin.site.register(Emp, EmpAdmin) ![](./res/admin-model-depts.png) ![](./res/admin-model-emps.png) 为了更好的查看模型数据，可以为Dept和Emp两个模型类添加`__str__`魔法方法。 ```Python from django.db import models class Dept(models.Model): \"\"\"部门类\"\"\" # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 class Emp(models.Model): \"\"\"员工类\"\"\" # 此处省略上面的代码 mgr = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='直接主管') # 此处省略下面的代码 # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 修改代码后刷新查看Emp模型的页面，效果如下图所示。 模型管理类详细配置 models.py # _*_ encoding:utf-8 _*_ from datetime import datetime from DjangoUeditor.models import UEditorField from django.db import models from organization.models import CourseOrg, Teacher # Create your models here. class Course(models.Model): course_org = models.ForeignKey(CourseOrg, verbose_name=u'课程机构', null=True, blank=True, on_delete=models.CASCADE) name = models.CharField(max_length=50, verbose_name=u'课程名称') desc = models.CharField(max_length=300, verbose_name=u'课程描述') # 使用富文本编辑器插件, ueditor的上传路径固定在ueditor目录下。文件名查看官方文档的变量设置 detail = UEditorField(verbose_name=u'课程详情', width=600, height=300, imagePath=\"courses/ueditor/\", filePath=\"courses/ueditor/\", default=u'') is_banner = models.BooleanField(default=False, verbose_name=u'是否轮播') teacher = models.ForeignKey(Teacher, verbose_name=u'讲师', null=True, blank=True, on_delete=models.CASCADE) degree = models.CharField(verbose_name=u'难度', choices=(('cj', u'初级'), ('zj', u'中级'), ('gj', u'高级')), max_length=2) learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') students = models.IntegerField(default=0, verbose_name=u'学习人数') fav_nums = models.IntegerField(default=0, verbose_name=u'收藏人数') image = models.ImageField(upload_to='courses/%Y/%m', verbose_name=u'封面图', max_length=100, null=True, blank=True) click_nums = models.IntegerField(default=0, verbose_name=u'点击数') category = models.CharField(default=u'后端开发', max_length=20, verbose_name=u'课程类别') tag = models.CharField(default='', verbose_name=u'课程标签', max_length=10,) youneed_know = models.CharField(max_length=300, verbose_name=u'课程须知', default='') what_you_learn = models.CharField(default='', max_length=300, verbose_name=u'老师告诉你能学到什么') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程' verbose_name_plural = verbose_name # # def __unicode__(self): # return self.name def get_lesson_nums(self): \"\"\" 获取章节数 :return: 章节数 \"\"\" return self.lesson_set.all().count() # 给个显示名字 get_lesson_nums.short_description = u'章节数' # 跳转函数 def go_to(self): from django.utils.safestring import mark_safe return mark_safe(\"跳转\") go_to.short_description = u'跳转' def get_learn_users(self): \"\"\" 获取学习用户 :return: 学习用户 \"\"\" return self.usercourse_set.all()[:5] def get_lesson(self): \"\"\" 获取课程所有章节 :return: \"\"\" return self.lesson_set.all() # def get_user(self): # \"\"\" # 获取课程所有章节 # :return: # \"\"\" # return self.lesson_set.all() def __str__(self): return self.name class BannerCourse(Course): \"\"\"轮播课程model继承于Course,拥有Course所有方法和属性\"\"\" class Meta: verbose_name = u'轮播课程' verbose_name_plural = verbose_name # proxy必须设置为True,就不会另外生产一张表而是和Course同一张表 proxy = True class Lesson(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'章节名') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'章节' verbose_name_plural = verbose_name def get_lesson_video(self): \"\"\" 获取章节视频信息 \"\"\" return self.video_set.all() def __str__(self): return self.name class Video(models.Model): lesson = models.ForeignKey(Lesson, verbose_name=u'章节', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'视频名') url = models.CharField(default='', max_length=200, verbose_name=u'访问地址') learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'视频' verbose_name_plural = verbose_name def __str__(self): return self.name class CourseResource(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'名称') download = models.FileField(upload_to='course/%Y/%m', verbose_name=u'资源文件', max_length=100) add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程资源' verbose_name_plural = verbose_name def __str__(self): return self.name adminx.py import xadmin from .models import Course, Lesson, Video, CourseResource, BannerCourse #配置主题功能 class BaseSetting(object): enable_themes = True use_bootswatch = True #全局头部脚步配置 class GlobalSettings(object): site_title = '慕课网' site_footer = '慕课在线网' menu_style = 'accordion' # inline模式，只能一层嵌套，不能多层嵌套，但可以多个 class LessonInline(object): model = Lesson extra = 0 class CourseResourceInline(object): model = CourseResource extra = 0 class CourseAdmin(object): \"\"\" 课程管理器 \"\"\" # 显示的字段，还可以显示函数，可以加入model中定义的函数如获取章节数：get_lesson_nums,go_to list_display = ['name', 'course_org', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time', 'get_lesson_nums', 'go_to'] # 搜索功能 search_fields = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums'] # 过滤器 list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] # ico图标 model_icon = 'fa fa-file' # 当有一个model有一个外键指向它时，它是ajax加载方式完成，数据量过大时很有用，可进行搜索而不是下拉式 relfield_style = 'fk-ajax' # 排序规则 ordering = ['-click_nums'] # 设置某些字段为只读 readonly_fields = ['click_nums'] # 设置某些字段不显示,和上面的设置会冲突，所以某个字段只能设置其中一个 exclude = ['fav_nums'] # 展示页面中直接修改功能 list_editable = ['degree','desc'] # inlines 设置 inlines = [LessonInline, CourseResourceInline] # 自定义刷新时间,配置多个页面中可选 refresh_times = [3, 5] # 插件配置 # 1、指明某个字段用的是什么样式，下面就是指明detail是ueditor样式 style_fields = {\"detail\": \"ueditor\"} # 2、Excel导入导出功能,True为开启 list_export = ['xls', 'xml', 'json'] import_excel = True # 重载方法过滤课程 def queryset(self): qs = super(CourseAdmin, self).queryset() qs = qs.filter(is_banner=False) return qs def save_models(self): # 在保存课程的时候统计机构的课程数 obj = self.new_obj # 查询前先保存才能增加新增的数量 obj.save() if obj.course_org is not None: course_org = obj.course_org course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save() def post(self, request, *args, **kwargs): # 导入逻辑 if 'excel' in request.FILES: pass return super(CourseAdmin, self).post(request, args, kwargs) class BannerCourseAdmin(object): \"\"\" 轮播课程管理器，和上面的课程管理器管理的是同一张表 \"\"\" list_display = ['name', 'course_org', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] search_fields = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] model_icon = 'fa fa-file' # 排序规则 ordering = ['-click_nums'] # 设置某些字段为只读 readonly_fields = ['click_nums'] # 设置某些字段不显示,和上面的设置会冲突，所以某个字段只能设置其中一个 exclude = ['fav_nums'] # inlines 设置 inlines = [LessonInline, CourseResourceInline] # 重载方法过滤课程 def queryset(self): qs = super(BannerCourseAdmin, self).queryset() qs = qs.filter(is_banner=True) return qs class LessonAdmin(object): list_display = ['course', 'name', 'add_time'] search_fields = ['course', 'name'] list_filter = ['course__name', 'name', 'add_time'] #course__name外键设置 model_icon = 'fa fa-file-o' class VideoAdmin(object): list_display = ['lesson', 'name', 'add_time'] search_fields = ['lesson', 'name'] list_filter = ['lesson__name', 'name', 'add_time']#course__name外键设置 model_icon = 'fa fa-file-video-o' class CourseResourceAdmin(object): list_display = ['course', 'name', 'download', 'add_time'] search_fields = ['course', 'name', 'download'] list_filter = ['course__name', 'name', 'download', 'add_time'] model_icon = 'fa fa-file-archive-o' xadmin.site.register(Course, CourseAdmin) xadmin.site.register(BannerCourse, BannerCourseAdmin) xadmin.site.register(Lesson, LessonAdmin) xadmin.site.register(Video, VideoAdmin) xadmin.site.register(CourseResource, CourseResourceAdmin) xadmin.site.register(views.BaseAdminView, BaseSetting) xadmin.site.register(views.CommAdminView, GlobalSettings) Django_xadmin开启excel导入功能 # 文件路径：xadmin/plugins/execl.py from xadmin.sites import site from xadmin.views import BaseAdminPlugin, ListAdminView from django.template import loader from xadmin.plugins.utils import get_context_dict #excel 导入 class ListImportExcelPlugin(BaseAdminPlugin): import_excel = False def init_request(self, *args, **kwargs): return bool(self.import_excel) def block_top_toolbar(self, context, nodes): nodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html', context=get_context_dict(context))) xadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView) ```html # 模板文件：xadmin/templates/xadmin/excel/model_list.top_toolbar.import.html { % load i18n % } 导入1 导入 Excel function fileChange(target){ //检测上传文件的类型 var imgName = document.all.submit_upload.value; var ext,idx; if (imgName == ''){ document.all.submit_upload_b.disabled=true; alert(\"请选择需要上传的 xls 文件!\"); return; } else { idx = imgName.lastIndexOf(\".\"); if (idx != -1){ ext = imgName.substr(idx+1).toUpperCase(); ext = ext.toLowerCase( ); {# alert(\"ext=\"+ext);#} if (ext != 'xls' && ext != 'xlsx'){ document.all.submit_upload_b.disabled=true; alert(\"只能上传 .xls 类型的文件!\"); return; } } else { document.all.submit_upload_b.disabled=true; alert(\"只能上传 .xls 类型的文件!\"); return; } } } { % csrf_token % } &times; 导入 Excel { % trans \"Close\" % } 导入 ``` ```python # adminx.py文件 class maintenanceRecordListAdmin(object): list_display = [...] search_fields = [...] list_filter = [...] list_editable = [...] readonly_fields = [...] #excel导入导出功能 list_export = ['xls', 'xml', 'json'] import_excel = True def post(self, request, *args, **kwargs): # 导入逻辑 if 'excel' in request.FILES: pass return super(maintenanceRecordListAdmin, self).post(request, args, kwargs) ### 使用ORM完成模型的CRUD操作 在了解了Django提供的模型管理平台之后，我们来看看如何从代码层面完成对模型的CRUD（Create / Read / Update / Delete）操作。我们可以通过manage.py开启Shell交互式环境，然后使用Django内置的ORM框架对模型进行CRUD操作。 ```Shell (venv)$ python manage.py shell Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. (InteractiveConsole) >>> 新增 >>> from hrs.models import Dept, Emp >>> dept = Dept(40, '研发2部', '深圳') >>> dept.save() 更新 >>> dept.name = '研发3部' >>> dept.save() 查询 查询所有对象。 >>> Dept.objects.all() , , , ]> 过滤数据。 >>> Dept.objects.filter(name='研发3部') # 查询部门名称为“研发3部”的部门 ]> >>> >>> Dept.objects.filter(name__contains='研发') # 查询部门名称包含“研发”的部门(模糊查询) , ]> >>> >>> Dept.objects.filter(no__gt=10).filter(no__lt=40) # 查询部门编号大于10小于40的部门 , ]> >>> >>> Dept.objects.filter(no__range=(10, 30)) # 查询部门编号在10到30之间的部门 , , ]> 查询单个对象。 >>> Dept.objects.get(pk=10) >>> >>> Dept.objects.get(no=20) >>> >>> Dept.objects.get(no__exact=30) >>> >>> Dept.objects.filter(no=10).first() 排序数据。 >>> Dept.objects.order_by('no') # 查询所有部门按部门编号升序排列 , , , ]> >>> >>> Dept.objects.order_by('-no') # 查询所有部门按部门编号降序排列 , , , ]> 切片数据。 >>> Dept.objects.order_by('no')[0:2] # 按部门编号排序查询1~2部门 , ]> >>> >>> Dept.objects.order_by('no')[2:4] # 按部门编号排序查询3~4部门 , ]> 高级查询。 >>> Emp.objects.filter(dept__no=10) # 根据部门编号查询该部门的员工 , , ]> >>> >>> Emp.objects.filter(dept__name__contains='销售') # 查询名字包含“销售”的部门的员工 ]> >>> >>> Dept.objects.get(pk=10).emp_set.all() # 通过部门反查部门所有的员工 , , ]> 说明1：由于员工与部门之间存在多对一外键关联，所以也能通过部门反向查询该部门的员工（从一对多关系中“一”的一方查询“多”的一方），反向查询属性默认的名字是类名小写_set（如上面例子中的emp_set），当然也可以在创建模型时通过ForeingKey的related_name属性指定反向查询属性的名字。如果不希望执行反向查询可以将related_name属性设置为'+'或以'+'开头的字符串。 说明2：查询多个对象的时候返回的是QuerySet对象，QuerySet使用了惰性查询，即在创建QuerySet对象的过程中不涉及任何数据库活动，等真正用到对象时（求值QuerySet）才向数据库发送SQL语句并获取对应的结果，这一点在实际开发中需要引起注意！ 说明3：可以在QuerySet上使用update()方法一次更新多个对象。 删除 >>> Dept.objects.get(pk=40).delete() (1, {'hrs.Dept': 1}) Django模型最佳实践 正确的为模型和关系字段命名。 设置适当的related_name属性。 用OneToOneField代替ForeignKeyField(unique=True)。 通过“迁移操作”（migrate）来添加模型。 用NoSQL来应对需要降低范式级别的场景。 如果布尔类型可以为空要使用NullBooleanField。 在模型中放置业务逻辑。 用.DoesNotExists取代ObjectDoesNotExists。 在数据库中不要出现无效数据。 不要对QuerySet调用len()函数。 将QuerySet的exists()方法的返回值用于if条件。 用DecimalField来存储货币相关数据而不是FloatField。 定义__str__方法。 不要将数据文件放在同一个目录中。 说明：以上内容来自于STEELKIWI网站的Best Practice working with Django models in Python，有兴趣的小伙伴可以阅读原文。 模型定义参考 字段 对字段名称的限制 字段名不能是Python的保留字，否则会导致语法错误 字段名不能有多个连续下划线，否则影响ORM查询操作 Django模型字段类 字段类 说明 AutoField 自增ID字段 BigIntegerField 64位有符号整数 BinaryField 存储二进制数据的字段，对应Python的bytes类型 BooleanField 存储True或False CharField 长度较小的字符串 DateField 存储日期，有auto_now和auto_now_add属性 DateTimeField 存储日期和日期，两个附加属性同上 DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数 DurationField 存储时间跨度 EmailField 与CharField相同，可以用EmailValidator验证 FileField 文件上传字段 FloatField 存储浮点数 ImageField 其他同FileFiled，要验证上传的是不是有效图像 IntegerField 存储32位有符号整数。 GenericIPAddressField 存储IPv4或IPv6地址 NullBooleanField 存储True、False或null值 PositiveIntegerField 存储无符号整数（只能存储正数） SlugField 存储slug（简短标注） SmallIntegerField 存储16位有符号整数 TextField 存储数据量较大的文本 TimeField 存储时间 URLField 存储URL的CharField UUIDField 存储全局唯一标识符 自定义字段（了解为主） class UnsignedIntegerField(models.IntegerField): def db_type(self, connection): return 'integer UNSIGNED' 自定义char类型字段： class FixedCharField(models.Field): \"\"\" 自定义的char类型的字段类 \"\"\" def __init__(self, max_length, *args, **kwargs): super().__init__(max_length=max_length, *args, **kwargs) self.length = max_length def db_type(self, connection): \"\"\" 限定生成数据库表的字段类型为char，长度为length指定的值 \"\"\" return 'char(%s)' % self.length class Class(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=25) # 使用上面自定义的char类型的字段 cname = FixedCharField(max_length=25) 字段属性 通用字段属性 选项 说明 null 数据库中对应的字段是否允许为NULL，默认为False blank 后台模型管理验证数据时，是否允许为NULL，默认为False choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值 db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称 db_index 设置为True时将在该字段创建索引 db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE default 字段的默认值 editable 字段在后台模型管理或ModelForm中是否显示，默认为True error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date help_text 表单小组件旁边显示的额外的帮助文本。 primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。 unique 设置为True时，表中字段的值必须是唯一的 verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称 ForeignKey属性 1. limit_choices_to：值是一个Q对象或返回一个Q对象，用于限制后台显示哪些对象。 2. related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为`'+'`，或者以`'+'`结尾。 3. to_field：指定关联的字段，默认关联对象的主键字段。 4. db_constraint：是否为外键创建约束，默认值为True。 5. on_delete：外键关联的对象被删除时对应的动作，可取的值包括django.db.models中定义的： - CASCADE：级联删除。 - PROTECT：抛出ProtectedError异常，阻止删除引用的对象。 - SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。 - SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。 ManyToManyField属性 1. symmetrical：是否建立对称的多对多关系。 2. through：指定维持多对多关系的中间表的Django模型。 3. throughfields：定义了中间模型时可以指定建立多对多关系的字段。 4. db_table：指定维持多对多关系的中间表的表名。 模型元数据选项 选项 说明 abstract 设置为True时模型是抽象父类 app_label 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定 db_table 模型使用的数据表名称 db_tablespace 模型使用的数据表空间 default_related_name 关联对象回指这个模型时默认使用的名称，默认为_set get_latest_by 模型中可排序字段的名称。 managed 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除 order_with_respect_to 标记对象为可排序的 ordering 对象的默认排序 permissions 创建对象时写入权限表的额外权限 default_permissions 默认为('add', 'change', 'delete') unique_together 设定组合在一起时必须独一无二的字段名(联合唯一索引) index_together 设定一起建立索引的多个字段名(联合索引) verbose_name 为对象设定人类可读的名称 verbose_name_plural 设定对象的复数名称 查询参考 按字段查找可以用的条件： 1. exact / iexact：精确匹配/忽略大小写的精确匹配查询 2. contains / icontains / startswith / istartswith / endswith / iendswith：基于`like`的模糊查询 3. in：集合运算 4. gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算 5. range：指定范围查询（SQL中的`between…and…`） 6. year / month / day / week_day / hour / minute / second：查询时间日期 7. isnull：查询空值（True）或非空值（False） 8. search：基于全文索引的全文检索 9. regex / iregex：基于正则表达式的模糊匹配查询 Q对象（用于执行复杂查询）的使用： >>> from django.db.models import Q >>> Emp.objects.filter( ... Q(name__startswith='张'), ... Q(sal__gte=5000) | Q(comm__gte=1000) ... ) # 查询名字以“张”开头且工资大于等于5000或补贴大于等于1000的员工 ]> 模型定义例子 from datetime import datetime from DjangoUeditor.models import UEditorField from django.db import models from organization.models import CourseOrg, Teacher # Create your models here. class Course(models.Model): course_org = models.ForeignKey(CourseOrg, verbose_name=u'课程机构', null=True, blank=True, on_delete=models.CASCADE) name = models.CharField(max_length=50, verbose_name=u'课程名称') desc = models.CharField(max_length=300, verbose_name=u'课程描述') # 使用富文本编辑器插件, ueditor的上传路径固定在ueditor目录下。文件名查看官方文档的变量设置 detail = UEditorField(verbose_name=u'课程详情', width=600, height=300, imagePath=\"courses/ueditor/\", filePath=\"courses/ueditor/\", default=u'') is_banner = models.BooleanField(default=False, verbose_name=u'是否轮播') teacher = models.ForeignKey(Teacher, verbose_name=u'讲师', null=True, blank=True, on_delete=models.CASCADE) degree = models.CharField(verbose_name=u'难度', choices=(('cj', u'初级'), ('zj', u'中级'), ('gj', u'高级')), max_length=2) learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') students = models.IntegerField(default=0, verbose_name=u'学习人数') fav_nums = models.IntegerField(default=0, verbose_name=u'收藏人数') image = models.ImageField(upload_to='courses/%Y/%m', verbose_name=u'封面图', max_length=100, null=True, blank=True) click_nums = models.IntegerField(default=0, verbose_name=u'点击数') category = models.CharField(default=u'后端开发', max_length=20, verbose_name=u'课程类别') tag = models.CharField(default='', verbose_name=u'课程标签', max_length=10,) youneed_know = models.CharField(max_length=300, verbose_name=u'课程须知', default='') what_you_learn = models.CharField(default='', max_length=300, verbose_name=u'老师告诉你能学到什么') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程' verbose_name_plural = verbose_name def get_lesson_nums(self): \"\"\" 获取章节数 :return: 章节数 \"\"\" return self.lesson_set.all().count() # 给个显示名字 get_lesson_nums.short_description = u'章节数' # 跳转函数 def go_to(self): from django.utils.safestring import mark_safe return mark_safe(\"跳转\") go_to.short_description = u'跳转' def get_learn_users(self): \"\"\" 获取学习用户 :return: 学习用户 \"\"\" return self.usercourse_set.all()[:5] def get_lesson(self): \"\"\" 获取课程所有章节 :return: \"\"\" return self.lesson_set.all() def __str__(self): return self.name class BannerCourse(Course): \"\"\"轮播课程model继承于Course,拥有Course所有方法和属性\"\"\" class Meta: verbose_name = u'轮播课程' verbose_name_plural = verbose_name # proxy必须设置为True,就不会另外生产一张表而是和Course同一张表 proxy = True class Lesson(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'章节名') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'章节' verbose_name_plural = verbose_name def get_lesson_video(self): \"\"\" 获取章节视频信息 \"\"\" return self.video_set.all() def __str__(self): return self.name class Video(models.Model): lesson = models.ForeignKey(Lesson, verbose_name=u'章节', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'视频名') url = models.CharField(default='', max_length=200, verbose_name=u'访问地址') learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'视频' verbose_name_plural = verbose_name def __str__(self): return self.name class CourseResource(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'名称') download = models.FileField(upload_to='course/%Y/%m', verbose_name=u'资源文件', max_length=100) add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程资源' verbose_name_plural = verbose_name def __str__(self): return self.name "},"Python/第三方库/Django/03-静态资源和Ajax请求.html":{"url":"Python/第三方库/Django/03-静态资源和Ajax请求.html","title":"静态资源和Ajax请求","keywords":"","body":"datetime:2019/6/10 11:32 author:nzb AJAX AJAX准备知识：JSON 什么是JSON? JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 *JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 啥都别多说了，上图吧！ 合格的json对象： [\"one\", \"two\", \"three\"] { \"one\": 1, \"two\": 2, \"three\": 3 } {\"names\": [\"张三\", \"李四\"] } [ { \"name\": \"张三\"}, {\"name\": \"李四\"} ]　 不合格的json对象： { name: \"张三\", 'age': 32 } // 属性名必须使用双引号 [32, 64, 128, 0xFFF] // 不能使用十六进制值 { \"name\": \"张三\", \"age\": undefined } // 不能使用undefined { \"name\": \"张三\", \"birthday\": new Date('Fri, 26 Aug 2011 07:13:10 GMT'), \"getName\": function() {return this.name;} // 不能使用函数和日期对象 } stringify与parse方法 JavaScript中关于JSON对象和字符串转换的两个方法： JSON.parse(): 用于将一个 JSON 字符串转换为 JavaScript 对象　 JSON.parse('{\"name\":\"Q1mi\"}'); JSON.parse('{name:\"Q1mi\"}') ; // 错误 JSON.parse('[18,undefined]') ; // 错误 JSON.stringify(): 用于将 JavaScript 值转换为 JSON 字符串。　 JSON.stringify({\"name\":\"Q1mi\"}) 和XML的比较 JSON 格式于2001年由 Douglas Crockford 提出，目的就是取代繁琐笨重的 XML 格式。 JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON迅速被接受，已经成为各大网站交换数据的标准格式，并被写入ECMAScript 5，成为标准的一部分。 XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。 用XML表示中国部分省市数据如下： 中国 黑龙江 哈尔滨 大庆 广东 广州 深圳 珠海 台湾 台北 高雄 新疆 乌鲁木齐 用JSON表示如下： { \"name\": \"中国\", \"province\": [{ \"name\": \"黑龙江\", \"cities\": { \"city\": [\"哈尔滨\", \"大庆\"] } }, { \"name\": \"广东\", \"cities\": { \"city\": [\"广州\", \"深圳\", \"珠海\"] } }, { \"name\": \"台湾\", \"cities\": { \"city\": [\"台北\", \"高雄\"] } }, { \"name\": \"新疆\", \"cities\": { \"city\": [\"乌鲁木齐\"] } }] } 由上面的两端代码可以看出，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。 AJAX简介 发送请求的方式： 直接在地址栏输入URL回车 GET请求 a标签 GET请求 form表单 GET/POST请求 AJAX GET/POST请求 AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。（这一特点给用户的感受是在不知不觉中完成请求和响应过程） AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求； 异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。 示例 页面输入两个整数，通过AJAX传输到后端计算出结果并返回。 AJAX局部刷新实例 + = $(\"#b1\").on(\"click\", function () { $.ajax({ url:\"/ajax_add/\", type:\"GET\", data:{\"i1\":$(\"#i1\").val(),\"i2\":$(\"#i2\").val()}, success:function (data) { $(\"#i3\").val(data); } }) }) def ajax_demo1(request): return render(request, \"ajax_demo1.html\") def ajax_add(request): i1 = int(request.GET.get(\"i1\")) i2 = int(request.GET.get(\"i2\")) ret = i1 + i2 return JsonResponse(ret, safe=False) urlpatterns = [ ... url(r'^ajax_add/', views.ajax_add), url(r'^ajax_demo1/', views.ajax_demo1), ... ] AJAX常见应用场景 搜索引擎根据用户输入的关键字，自动提示检索关键字。 还有一个很重要的应用场景就是注册时候的用户名的查重。 其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。 整个过程中页面没有刷新，只是刷新页面中的局部位置而已！ 当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！ 当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。 整个过程中页面没有刷新，只是局部刷新了； 在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作； AJAX的优缺点 优点： AJAX使用JavaScript技术向服务器发送异步请求； AJAX请求无须刷新整个页面； 因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高； jQuery实现的AJAX 最基本的jQuery发送AJAX请求示例： ajax test AJAX 测试 $(\"#ajaxTest\").click(function () { $.ajax({ url: \"/ajax_test/\", type: \"POST\", data: {username: \"Q1mi\", password: 123456}, success: function (data) { alert(data) } }) }) views.py def ajax_test(request): user_name = request.POST.get(\"username\") password = request.POST.get(\"password\") print(user_name, password) return HttpResponse(\"OK\") $.ajax参数 data参数中的键值对，如果值值不为字符串，需要将其转换成字符串类型。 $(\"#b1\").on(\"click\", function () { $.ajax({ url:\"/ajax_add/\", type:\"GET\", data:{\"i1\":$(\"#i1\").val(),\"i2\":$(\"#i2\").val(),\"hehe\": JSON.stringify([1, 2, 3])}, success:function (data) { $(\"#i3\").val(data); } }) }) $.ajax参数data ajax有三种传递传递data的方式： 1、json格式 2、标准参数模式 3、json字符串格式 1.json对象格式： {“username”:”chen”,”nickname”:”alien”} $.ajax({ type:\"post\", url:\"/test/saveUser\", data:{\"username\":\"chen\",\"nickname\":\"alien\"}, dataType:\"json\", //指定响应的data数据类型为JSON对象。 success: function(data){ console.log(data); } }); - 如：当前的Ajax请求是一个POST请求，对请求体中的数据 使用默认的数据编码，格式如：key1 = value2&key2 = value2 a中的数据变成这样的格式：key1 = value2&key2 = value2 ，包装在Http请求体中传送给后台。 - dataType:\"json\" - dataType:“json” ：用来指定服务器返回的data数据类型必须是JSON类型。然后jQuery就会把后端返回的json字符串尝试通过JSON.parse()解析为js对象。 - 如果不指定dataType，jQuery 将自动根据 HTTP 包的 MIME 信息来智能判断，若MIME信息的值为JSON，则jQuery会自动的把data数据转换成JS对象的json，接着Script把data传递给回调函数进行JS的脚本操作。 2、标准参数模式 “username=Liudehua & age=50” $.ajax({ type:\"post\", url:\"/test/saveUser\", data:\"username=chen&nickname=alien\", dataType:\"json\", success: function(data){ console.log(data); } }); - $(“#form1”).serialize() 就是把表单的数据拼成这个格式（key1 = value2&key2 = value2）的字符串，然后放在Http请求体中传给后台！ 3.json字符串 ————>只用于post请求 “{“username”:”chen”,”nickname”:”alien”}”————>JSON对象格式的字符串 JSON.stringify({“username”:”chen”,”nickname”:”alien”})————>把JSON对象转成JSON格式的字符串。 $.ajax({ type:\"post\", url:\"/test/saveUser\", data:JSON.stringify({\"username\":\"chen\",\"nickname\":\"alien\"}), contentType:\"json/application\" dataType:\"json\", success: function(data){ console.log(data); } }); ** 第三种这种方式不能用于 Get请求。 原因： 1、因为此种方式发送的请求，后端必须得用@RequestBody进行接收，且接收的是Http请求体中的数据，Get请求没有请求体。 2、而且此方式的Ajax 必须要添加 contentType:”json/application”这个字段信息。 ** 注意： 1、若为GET请求，则会把data的数据 附加在 URL 后， 格式如：localhost://findAll ? key1=value1&key2=value2 若为POST请求，则就会把data的数据 放在请求体中。 格式如：key1 = value2&key2 = value2 2、dataType：指定服务器端返回的数据类型。 若不指定，且后端返回的是Json，前端就会自动识别返回的数据是JSON。 JS实现AJAX var b2 = document.getElementById(\"b2\"); b2.onclick = function () { // 原生JS var xmlHttp = new XMLHttpRequest(); xmlHttp.open(\"POST\", \"/ajax_test/\", true); xmlHttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xmlHttp.send(\"username=q1mi&password=123456\"); xmlHttp.onreadystatechange = function () { if (xmlHttp.readyState === 4 && xmlHttp.status === 200) { alert(xmlHttp.responseText); } }; }; AJAX请求如何设置csrf_token 方式1 通过获取隐藏的input标签中的csrfmiddlewaretoken值，放置在data中发送。 $.ajax({ url: \"/cookie_ajax/\", type: \"POST\", data: { \"username\": \"Q1mi\", \"password\": 123456, \"csrfmiddlewaretoken\": $(\"[name = 'csrfmiddlewaretoken']\").val() // 使用jQuery取出csrfmiddlewaretoken的值，拼接到data中 }, success: function (data) { console.log(data); } }) 方式2 通过获取返回的cookie中的字符串 放置在请求头中发送。 注意：需要引入一个jquery.cookie.js插件。 $.ajax({ url: \"/cookie_ajax/\", type: \"POST\", headers: {\"X-CSRFToken\": $.cookie('csrftoken')}, // 从Cookie取csrftoken，并设置到请求头中 data: {\"username\": \"Q1mi\", \"password\": 123456}, success: function (data) { console.log(data); } }) 或者用自己写一个getCookie方法： function getCookie(name) { var cookieValue = null; if (document.cookie && document.cookie !== '') { var cookies = document.cookie.split(';'); for (var i = 0; i 每一次都这么写太麻烦了，可以使用$.ajaxSetup()方法为ajax请求统一设置。 function csrfSafeMethod(method) { // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function (xhr, settings) { if (!csrfSafeMethod(settings.type) && !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", csrftoken); } } }); 注意： 如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。 如果你的视图渲染的HTML文件中没有包含 { % csrf_token % }，Django可能不会设置CSRFtoken的cookie。 这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。 django.views.decorators.csrf import ensure_csrf_cookie @ensure_csrf_cookie def login(request): pass 更多细节详见：Djagno官方文档中关于CSRF的内容 AJAX上传文件 XMLHttpRequest 是一个浏览器接口，通过它，我们可以使得 Javascript 进行 HTTP (S) 通信。XMLHttpRequest 在现在浏览器中是一种常用的前后台交互数据的方式。2008年 2 月，XMLHttpRequest Level 2 草案提出来了，相对于上一代，它有一些新的特性，其中 FormData 就是 XMLHttpRequest Level 2 新增的一个对象，利用它来提交表单、模拟表单提交，当然最大的优势就是可以上传二进制文件。下面就具体 首先看一下formData的基本用法：FormData对象，可以把所有表单元素的name与value组成一个queryString，提交到后台。只需要把 form 表单作为参数传入 FormData 构造函数即可： 介绍一下如何利用 FormData 来上传文件。 // 上传文件示例 $(\"#b3\").click(function () { var formData = new FormData(); formData.append(\"csrfmiddlewaretoken\", $(\"[name='csrfmiddlewaretoken']\").val()); formData.append(\"f1\", $(\"#f1\")[0].files[0]); $.ajax({ url: \"/upload/\", type: \"POST\", processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 data: formData, success:function (data) { console.log(data) } }) }) 或者使用 var form = document.getElementById(\"form1\"); var fd = new FormData(form); 这样也可以直接通过ajax 的 send() 方法将 fd 发送到后台。 注意：由于 FormData 是 XMLHttpRequest Level 2 新增的接口，现在 低于IE10 的IE浏览器不支持 FormData。 练习（用户名是否已被注册） 功能介绍 在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回这个用户名是否已经被注册过。 案例分析 页面中给出注册表单； 在username input标签中绑定onblur事件处理函数。 当input标签失去焦点后获取 username表单字段的值，向服务端发送AJAX请求； django的视图函数中处理该请求，获取username值，判断该用户在数据库中是否被注册，如果被注册了就返回“该用户已被注册”，否则响应“该用户名可以注册”。 ajax中参数traditional的作用 　　 在使用ajax向后台传值的时候，有的时候一个字段需要传多个值，这种情况下会想到用数组形式来传，比如： $.ajax({ type: \"post\", async: true, data: { \"records\": [\"123\",\"456\",\"789\"] }, url: \"xxxxx\", error: function(request) {}, success: function(data) {} }); 但是通过测试很快就会发现java后台无法取到参数，因为jQuery需要调用jQuery.param序列化参数，jQuery.param(obj, traditional )默认情况下traditional为false， 即jquery会深度序列化参数对象，以适应如PHP和Ruby on Rails框架，但servelt api无法处理，我们可以通过设置traditional 为true阻止深度序列化，然后序列化结果如下： records: [\"123\", \"456\", \"789\"] => records=123&p=456&p=789 随即，我们就可以在后台通过request.getParameterValues()来获取参数的值数组了，如下： $.ajax({ type: \"post\", async: true, traditional: true, data: { \"records\": [\"123\",\"456\",\"789\"] }, url: \"xxxxx\", error: function(request) {}, success: function(data) {} }); 序列化 Django内置的serializers def books_json(request): book_list = models.Book.objects.all()[0:10] from django.core import serializers ret = serializers.serialize(\"json\", book_list) return HttpResponse(ret) 补充一个SweetAlert插件示例 点击下载Bootstrap-sweetalert项目。 $(\".btn-danger\").on(\"click\", function () { swal({ title: \"你确定要删除吗？\", text: \"删除可就找不回来了哦！\", type: \"warning\", showCancelButton: true, confirmButtonClass: \"btn-danger\", confirmButtonText: \"删除\", cancelButtonText: \"取消\", closeOnConfirm: false }, function () { var deleteId = $(this).parent().parent().attr(\"data_id\"); $.ajax({ url: \"/delete_book/\", type: \"post\", data: {\"id\": deleteId}, success: function (data) { if (data.status === 1) { swal(\"删除成功!\", \"你可以准备跑路了！\", \"success\"); } else { swal(\"删除失败\", \"你可以再尝试一下！\", \"error\") } } }) }); }) 静态资源和Ajax请求(100天) 基于前面两个章节讲解的知识，我们已经可以使用Django框架来实现Web应用的开发了。接下来我们就尝试实现一个投票应用，具体的需求是用户进入应用首先查看到“学科介绍”页面，该页面显示了一个学校所开设的所有学科；通过点击某个学科，可以进入“老师介绍”页面，该页面展示了该学科所有老师的详细情况，可以在该页面上给老师点击“好评”或“差评”，但是会先跳转到“登录页”要求用户登录，登录成功才能投票；对于未注册的用户，可以在“登录页”点击“新用户注册”进入“注册页”完成用户注册，注册成功后会跳转到“登录页”，注册失败会获得相应的提示信息。 准备工作 由于之前已经详细的讲解了如何创建Django项目以及项目的相关配置，因此我们略过这部分内容，唯一需要说明的是，从上面对投票应用需求的描述中我们可以分析出三个业务实体：学科、老师和用户。学科和老师之间通常是一对多关联关系（一个学科有多个老师，一个老师通常只属于一个学科），用户因为要给老师投票，所以跟老师之间是多对多关联关系（一个用户可以给多个老师投票，一个老师也可以收到多个用户的投票）。首先修改应用下的models.py文件来定义数据模型，先给出学科和老师的模型。 from django.db import models class Subject(models.Model): \"\"\"学科\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') name = models.CharField(max_length=31, verbose_name='名称') intro = models.CharField(max_length=511, verbose_name='介绍') def __str__(self): return self.name class Meta: db_table = 'tb_subject' verbose_name_plural = '学科' class Teacher(models.Model): \"\"\"老师\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') name = models.CharField(max_length=15, verbose_name='姓名') gender = models.BooleanField(default=True, choices=((True, '男'), (False, '女')), verbose_name='性别') birth = models.DateField(null=True, verbose_name='出生日期') intro = models.CharField(max_length=511, default='', verbose_name='') good_count = models.IntegerField(default=0, verbose_name='好评数') bad_count = models.IntegerField(default=0, verbose_name='差评数') photo = models.CharField(max_length=255, verbose_name='照片') subject = models.ForeignKey(to=Subject, on_delete=models.PROTECT, db_column='sno', verbose_name='所属学科') def __str__(self): return self.name class Meta: db_table = 'tb_teacher' verbose_name_plural = '老师' 模型定义完成后，可以通过“生成迁移”和“执行迁移”来完成关系型数据库中二维表的创建，当然这需要提前启动数据库服务器并创建好对应的数据库，同时我们在项目中已经安装了PyMySQL而且完成了相应的配置，这些内容此处不再赘述。 (venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ... 注意：为了给vote应用生成迁移，需要先修改Django项目的配置文件settings.py，在INSTALLED_APPS中添加vote应用。 完成模型迁移之后，我们可以通过下面的SQL语句来添加学科和老师测试的数据。 INSERT INTO `tb_subject` (`no`,`name`,`intro`) VALUES (1, 'Python全栈+人工智能', 'Python是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。'), (2, 'JavaEE+分布式服务', 'Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。'), (3, 'HTML5大前端', 'HTML5 将成为 HTML、XHTML 以及 HTML DOM 的新标准。'), (4, '全栈软件测试', '在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程'), (5, '全链路UI/UE', '全链路要求设计师关注整个业务链中的每一个环节，将设计的价值融入每一个和用户的接触点中，让整个业务的用户体验质量得到几何级数的增长。'); INSERT INTO `tb_teacher` (`no`,`name`,`gender`,`birth`,`intro`,`good_count`,`bad_count`,`photo`,`sno`) VALUES (1, '骆昊', 1, '1980-11-28', '10年以上软硬件产品设计、研发、架构和管理经验，2003年毕业于四川大学，四川大学Java技术俱乐部创始人，四川省优秀大学毕业生，在四川省网络通信技术重点实验室工作期间，参与了2项国家自然科学基金项目、1项中国科学院中长期研究项目和多项四川省科技攻关项目，在国际会议和国内顶级期刊上发表多篇论文（1篇被SCI收录，3篇被EI收录），大规模网络性能测量系统DMC-TS的设计者和开发者，perf-TTCN语言的发明者。国内最大程序员社区CSDN的博客专家，在Github上参与和维护了多个高质量开源项目，精通C/C++、Java、Python、R、Swift、JavaScript等编程语言，擅长OOAD、系统架构、算法设计、协议分析和网络测量，主持和参与过电子政务系统、KPI考核系统、P2P借贷平台等产品的研发，一直践行“用知识创造快乐”的教学理念，善于总结，乐于分享。', 0, 0, 'images/luohao.png', 1), (2, '王海飞', 1, '1993-05-24', '5年以上Python开发经验，先后参与了O2O商城、CRM系统、CMS平台、ERP系统等项目的设计与研发，曾在全国最大最专业的汽车领域相关服务网站担任Python高级研发工程师、项目经理等职务，擅长基于Python、Java、PHP等开发语言的企业级应用开发，全程参与了多个企业级应用从需求到上线所涉及的各种工作，精通Django、Flask等框架，熟悉基于微服务的企业级项目开发，拥有丰富的项目实战经验。善于用浅显易懂的方式在课堂上传授知识点，在授课过程中经常穿插企业开发的实际案例并分析其中的重点和难点，通过这种互动性极强的教学模式帮助学员找到解决问题的办法并提升学员的综合素质。', 0, 0, 'images/wangdachui.png', 1), (3, '余婷', 0, '1992-03-12', '5年以上移动互联网项目开发经验和教学经验，曾担任上市游戏公司高级软件研发工程师和移动端（iOS）技术负责人，参了多个企业级应用和游戏类应用的移动端开发和后台服务器开发，拥有丰富的开发经验和项目管理经验，以个人开发者和协作开发者的身份在苹果的AppStore上发布过多款App。精通Python、C、Objective-C、Swift等开发语言，熟悉iOS原生App开发、RESTful接口设计以及基于Cocos2d-x的游戏开发。授课条理清晰、细致入微，性格活泼开朗、有较强的亲和力，教学过程注重理论和实践的结合，在学员中有良好的口碑。', 0, 0, 'images/yuting.png', 1), (4, '肖世荣', 1, '1977-07-02', '10年以上互联网和移动互联网产品设计、研发、技术架构和项目管理经验，曾在中国移动、symbio、ajinga.com、万达信息等公司担任架构师、项目经理、技术总监等职务，长期为苹果、保时捷、耐克、沃尔玛等国际客户以及国内的政府机构提供信息化服务，主导的项目曾获得“世界科技先锋”称号，个人作品“许愿吧”曾在腾讯应用市场生活类App排名前3，拥有百万级用户群体，运营的公众号“卵石坊”是国内知名的智能穿戴设备平台。精通Python、C++、Java、Ruby、JavaScript等开发语言，主导和参与了20多个企业级项目（含国家级重大项目和互联网创新项目），涉及的领域包括政务、社交、电信、卫生和金融，有极为丰富的项目实战经验。授课深入浅出、条理清晰，善于调动学员的学习热情并帮助学员理清思路和方法。', 0, 0, 'images/xiaoshirong.png', 1), (5, '张无忌', 1, '1987-07-07', '出生起便在冰火岛过着原始生活，踏入中土后因中玄冥神掌命危而带病习医，忍受寒毒煎熬七年最后因福缘际会练成“九阳神功”更在之后又练成了“乾坤大挪移”等盖世武功，几乎无敌于天下。 生性随和，宅心仁厚，精通医术和药理。20岁时便凭着盖世神功当上明教教主，率领百万教众及武林群雄反抗蒙古政权元朝的高压统治，最后推翻了元朝。由于擅长乾坤大挪移神功，上课遇到问题就转移话题，属于拉不出屎怪地球没有引力的类型。', 0, 0, 'images/zhangwuji.png', 5), (6, '韦一笑', 1, '1975-12-15', '外号“青翼蝠王”，为明教四大护教法王之一。 身披青条子白色长袍，轻功十分了得。由于在修炼至阴至寒的“寒冰绵掌”时出了差错，经脉中郁积了至寒阴毒，只要运上内力，寒毒就会发作，如果不吸人血解毒，全身血脉就会凝结成冰，后得张无忌相助，以其高明医术配以“九阳神功”，终将寒毒驱去，摆脱了吸吮人血这一命运。由于轻功绝顶，学生一问问题就跑了。', 0, 0, 'images/weiyixiao.png', 3); 当然也可以直接使用Django提供的后台管理应用来添加学科和老师信息，这需要先注册模型类和模型管理类。 from django.contrib import admin from django.contrib.admin import ModelAdmin from vote.models import Teacher, Subject class SubjectModelAdmin(ModelAdmin): \"\"\"学科模型管理\"\"\" list_display = ('no', 'name') ordering = ('no', ) class TeacherModelAdmin(ModelAdmin): \"\"\"老师模型管理\"\"\" list_display = ('no', 'name', 'gender', 'birth', 'good_count', 'bad_count', 'subject') ordering = ('no', ) search_fields = ('name', ) admin.site.register(Subject, SubjectModelAdmin) admin.site.register(Teacher, TeacherModelAdmin) 接下来，我们就可以修改views.py文件，通过编写视图函数先实现“学科介绍”页面。 def show_subjects(request): \"\"\"查看所有学科\"\"\" subjects = Subject.objects.all() return render(request, 'subject.html', {'subjects': subjects}) 至此，我们还需要一个模板页，模板的配置以及模板页中模板语言的用法在之前已经进行过简要的介绍，如果不熟悉可以看看下面的代码，相信这并不是一件困难的事情。 学科信息 /* 此处略去了层叠样式表的选择器 */ 千锋互联所有学科信息 { % for subject in subjects % } { { subject.name } } { { subject.intro } } { % endfor % } 在上面的模板中，我们为每个学科添加了一个超链接，点击超链接可以查看该学科的讲师信息，为此需要再编写一个视图函数来处理查看指定学科老师信息。 def show_teachers(request): \"\"\"查看指定学科的老师\"\"\" try: sno = int(request.GET['sno']) subject = Subject.objects.get(no=sno) teachers = Teacher.objects.filter(subject__no=sno) context = {'subject': subject, 'teachers': teachers} return render(request, 'teacher.html', context) except (KeyError, ValueError, Subject.DoesNotExist): return redirect('/') 显示老师信息的模板页。 { % load static % } 老师信息 /* 此处略去了层叠样式表的选择器 */ { { subject.name } }学科老师信息 { % if teachers % } { % for teacher in teachers % } 姓名：{ { teacher.name } } 性别：{ { teacher.gender | yesno:'男,女' } } 出生日期：{ { teacher.birth } } { { teacher.intro } } 好评（{ { teacher.good_count } }） 差评（{ { teacher.bad_count } }） { % endfor % } { % else % } 暂时没有该学科的老师信息 { % endif % } &lt;&lt;&nbsp;返回学科 加载静态资源 在上面的模板页面中，我们使用了标签来加载老师的照片，其中使用了引用静态资源的模板指令{ % static % }，要使用该指令，首先要使用{ % load static % }指令来加载静态资源，我们将这段代码放在了页码开始的位置。在上面的项目中，我们将静态资源置于名为static的文件夹中，在该文件夹下又创建了三个文件夹：css、js和images，分别用来保存外部层叠样式表、外部JavaScript文件和图片资源。为了能够找到保存静态资源的文件夹，我们还需要修改Django项目的配置文件settings.py，如下所示： # 此处省略上面的代码 STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ] STATIC_URL = '/static/' # 此处省略下面的代码 接下来修改urls.py文件，配置用户请求的URL和视图函数的对应关系。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path('', views.show_subjects), path('teachers/', views.show_teachers), path('admin/', admin.site.urls), ] 启动服务器运行项目，进入首页查看学科信息。 点击学科查看老师信息。 Ajax请求 接下来就可以实现“好评”和“差评”的功能了，很明显如果能够在不刷新页面的情况下实现这两个功能会带来更好的用户体验，因此我们考虑使用Ajax技术来实现“好评”和“差评”，Ajax技术我们在之前的章节中已经介绍过了，此处不再赘述。 首先修改项目的urls.py文件，为“好评”和“差评”功能映射对应的URL。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path('', views.show_subjects), path('teachers/', views.show_teachers), path('praise/', views.prise_or_criticize), path('criticize/', views.prise_or_criticize), path('admin/', admin.site.urls), ] 设计视图函数praise_or_criticize来支持“好评”和“差评”功能，该视图函数通过Django封装的JsonResponse类将字典序列化成JSON字符串作为返回给浏览器的响应内容。 def praise_or_criticize(request): \"\"\"好评\"\"\" try: tno = int(request.GET['tno']) teacher = Teacher.objects.get(no=tno) if request.path.startswith('/prise'): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {'code': 200, 'hint': '操作成功'} except (KeyError, ValueError, Teacher.DoseNotExist): data = {'code': 404, 'hint': '操作失败'} return JsonResponse(data) 修改显示老师信息的模板页，引入jQuery库来实现事件处理、Ajax请求和DOM操作。 $(() => { $('.comment>a').on('click', (evt) => { evt.preventDefault(); let a = $(evt.target) let span = a.next() $.getJSON(a.attr('href'), (json) => { if (json.code == 200) { span.text(parseInt(span.text()) + 1) } else { alert(json.hint) } }) }) }) 小结 到此为止，这个投票项目的核心功能已然完成，在下面的章节中我们会要求用户必须登录才能投票，没有账号的用户可以通过注册功能注册一个账号。 "},"Python/第三方库/Django/04-Django模板系统.html":{"url":"Python/第三方库/Django/04-Django模板系统.html","title":"Django模板系统","keywords":"","body":"datetime:2019/6/10 15:35 author:nzb Django模板系统 官方文档 常见语法 只需要记两种特殊符号： { { } }和 { % % } 变量相关的用{ {} }，逻辑相关的用{ %% }。 变量 在Django的模板语言中按此语法使用：{ { 变量名 } }。 当模版引擎遇到一个变量，它将计算这个变量，然后用结果替换掉它本身。 变量的命名包括任何字母数字以及下划线 (\"_\")的组合。 变量名称中不能有空格或标点符号。 点（.）在模板语言中有特殊的含义。当模版系统遇到点(\".\")，它将以这样的顺序查询： 字典查询（Dictionary lookup） 属性或方法查询（Attribute or method lookup） 数字索引查询（Numeric index lookup） 注意事项： 如果计算结果的值是可调用的，它将被无参数的调用。 调用的结果将成为模版的值。 如果使用的变量不存在， 模版系统将插入 string_if_invalid 选项的值， 它被默认设置为'' (空字符串) 。 # 几个例子： # view中代码： def template_test(request): l = [11, 22, 33] d = {\"name\": \"alex\"} class Person(object): def __init__(self, name, age): self.name = name self.age = age def dream(self): return \"{} is dream...\".format(self.name) Alex = Person(name=\"Alex\", age=34) Egon = Person(name=\"Egon\", age=9000) Eva_J = Person(name=\"Eva_J\", age=18) person_list = [Alex, Egon, Eva_J] return render(request, \"template_test.html\", {\"l\": l, \"d\": d, \"person_list\": person_list}) # 模板中支持的写法： {# 取l中的第一个参数 #} { { l.0 } } {# 取字典中key的值 #} { { d.name } } {# 取对象的name属性 #} { { person_list.0.name } } {# .操作只能调用不带参数的方法 #} { { person_list.0.dream } } Filters(过滤器) 在Django的模板语言中，通过使用 过滤器 来改变变量的显示。 过滤器的语法： { { value|filter_name:参数 } } 使用管道符\"|\"来应用过滤器。 例如：{ { name|lower } }会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 注意事项： 过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。 过滤器可以接受参数，例如：{ { sss|truncatewords:30 } }，这将显示sss的前30个词。 过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：{ { list|join:', ' } } '|'左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器。 default 如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值。 { { value|default:\"nothing\"} } length 返回值的长度，作用于字符串和列表。 { { value|length } } 返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 '13 KB', '4.1 MB', '102 bytes', 等等）。例如： { { value|filesizeformat } } 如果 value 是 123456789，输出将会是 117.7 MB。 slice 切片 { {value|slice:\"2:-1\"} } date 格式化 { { value|date:\"Y-m-d H:i:s\"} } 可用的参数： 格式化字符 描述 示例输出 a 'a.m.'或'p.m.'（请注意，这与PHP的输出略有不同，因为这包括符合Associated Press风格的期间） 'a.m.' A 'AM'或'PM'。 'AM' b 月，文字，3个字母，小写。 'jan' B 未实现。 c ISO 8601格式。 （注意：与其他格式化程序不同，例如“Z”，“O”或“r”，如果值为naive datetime，则“c”格式化程序不会添加时区偏移量（请参阅datetime.tzinfo） 。 2008-01-02T10:30:00.000123+02:00或2008-01-02T10:30:00.000123如果datetime是天真的 d 月的日子，带前导零的2位数字。 '01'到'31' D 一周中的文字，3个字母。 “星期五” e 时区名称 可能是任何格式，或者可能返回一个空字符串，具体取决于datetime。 ''、'GMT'、'-500'、'US/Eastern'等 E 月份，特定地区的替代表示通常用于长日期表示。 'listopada'（对于波兰语区域，而不是'Listopad'） f 时间，在12小时的小时和分钟内，如果它们为零，则分钟停留。 专有扩展。 '1'，'1:30' F 月，文，长。 '一月' g 小时，12小时格式，无前导零。 '1'到'12' G 小时，24小时格式，无前导零。 '0'到'23' h 小时，12小时格式。 '01'到'12' H 小时，24小时格式。 '00'到'23' i 分钟。 '00'到'59' I 夏令时间，无论是否生效。 '1'或'0' j 没有前导零的月份的日子。 '1'到'31' l 星期几，文字长。 '星期五' L 布尔值是否是一个闰年。 True或False m 月，2位数字带前导零。 '01'到'12' M 月，文字，3个字母。 “扬” n 月无前导零。 '1'到'12' N 美联社风格的月份缩写。 专有扩展。 'Jan.'，'Feb.'，'March'，'May' o ISO-8601周编号，对应于使用闰年的ISO-8601周数（W）。 对于更常见的年份格式，请参见Y。 '1999年' O 与格林威治时间的差异在几小时内。 '+0200' P 时间为12小时，分钟和'a.m。'/'p.m。'，如果为零，分钟停留，特殊情况下的字符串“午夜”和“中午”。 专有扩展。 '1 am'，'1:30 pm' / t3>，'midnight'，'noon'，'12：30 pm' / T10> r RFC 5322格式化日期。 'Thu, 21 Dec 2000 16:01:07 +0200' s 秒，带前导零的2位数字。 '00'到'59' S 一个月的英文序数后缀，2个字符。 'st'，'nd'，'rd'或'th' t 给定月份的天数。 28 to 31 T 本机的时区。 'EST'，'MDT' u 微秒。 000000 to 999999 U 自Unix Epoch以来的二分之一（1970年1月1日00:00:00 UTC）。 w 星期几，数字无前导零。 '0'（星期日）至'6'（星期六） W ISO-8601周数，周数从星期一开始。 1，53 y 年份，2位数字。 '99' Y 年，4位数。 '1999年' z 一年中的日子 0到365 Z 时区偏移量，单位为秒。 UTC以西时区的偏移量总是为负数，对于UTC以东时，它们总是为正。 -43200到43200 safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 比如： value = \"点我\" { { value|safe} } truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾。 参数：截断的字符数 { { value|truncatechars:9} } truncatewords 在一定数量的字后截断字符串。 { { value|truncatewords:9} } cut 移除value中所有的与给出的变量相同的字符串 { { value|cut:' ' } } 如果value为'i love you'，那么将输出'iloveyou'. join 使用字符串连接列表，例如Python的str.join(list) timesince 将日期格式设为自该日期起的时间（例如，“4天，6小时”）。 采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在）。 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”： { { blog_date|timesince:comment_date } } 分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。 timeuntil 似于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则{ { conference_date | timeuntil } }将返回“4周”。 使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”： { { conference_date|timeuntil:from_date } } 自定义filter 自定义过滤器只是带有一个或两个参数的Python函数: 变量（输入）的值 - -不一定是一个字符串 参数的值 - 这可以有一个默认值，或完全省略 例如，在过滤器{ {var | foo:'bar'} }中，过滤器foo将传递变量var和参数“bar”。 自定义filter代码文件摆放位置： app01/ __init__.py models.py templatetags/ # 在app01下面新建一个package package __init__.py app01_filters.py # 建一个存放自定义filter的文件 views.py 编写自定义filter: from django import template register = template.Library() @register.filter(name=\"cut\") def cut(value, arg): return value.replace(arg, \"\") @register.filter(name=\"addSB\") def add_sb(value): return \"{} SB\".format(value) 使用自定义filter: {# 先导入我们自定义filter那个文件 #} { % load app01_filters % } {# 使用我们自定义的filter #} { { somevariable|cut:\"0\" } } { { d.name|addSB } } Tags for循环 普通for循环 { % for user in user_list % } { { user.name } } { % endfor % } for循环可用的一些参数： Variable Description forloop.counter 当前循环的索引值（从1开始） forloop.counter0 当前循环的索引值（从0开始） forloop.revcounter 当前循环的倒序索引值（从1开始） forloop.revcounter0 当前循环的倒序索引值（从0开始） forloop.first 当前循环是不是第一次循环（布尔值） forloop.last 当前循环是不是最后一次循环（布尔值） forloop.parentloop 本层循环的外层循环 for ... empty { % for user in user_list % } { { user.name } } { % empty % } 空空如也 { % endfor % } if判断 if,elif和else { % if user_list % } 用户人数：{ { user_list|length } } { % elif black_list % } 黑名单数：{ { black_list|length } } { % else % } 没有用户 { % endif % } 当然也可以只有if和else { % if user_list|length > 5 % } 七座豪华SUV { % else % } 黄包车 { % endif % } if语句支持 and 、or、==、>、=、in、not in、is、is not判断。 with 定义一个中间变量，多用于给一个复杂的变量起别名。 注意等号左右不要加空格。 { % with total=business.employees.count % } { { total } } employee{ { total|pluralize } } { % endwith % } 或 { % with business.employees.count as total % } { { total } } employee{ { total|pluralize } } { % endwith % } csrf_token 这个标签用于跨站请求伪造保护。 在页面的form表单里面写上{ % csrf_token % } 注释 {# ... #} 注意事项 Django的模板语言不支持连续判断，即不支持以下写法： { % if a > b > c % } ... { % endif % } Django的模板语言中属性的优先级大于方法 def xx(request): d = {\"a\": 1, \"b\": 2, \"c\": 3, \"items\": \"100\"} return render(request, \"xx.html\", {\"data\": d}) 如上，我们在使用render方法渲染一个页面的时候，传的字典d有一个key是items并且还有默认的 d.items() 方法，此时在模板语言中: { { data.items } } 默认会取d的items key的值。 母版 Title { % block page-css % } { % endblock % } 这是母板的标题 { % block page-main % } { % endblock % } 母板底部内容 { % block page-js % } { % endblock % } 继承母版 在子页面中在页面最上方使用下面的语法来继承母板。 { % extends 'layouts.html' % } 块(block) 通过在母板中使用{ % block xxx % }来定义\"块\"。 在子页面中通过定义母板中的block名来对应替换母板中相应的内容。 { % block page-main % } 世情薄 人情恶 雨送黄昏花易落 { % endblock % } 组件 可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方按如下语法导入即可。 { % include 'navbar.html' % } 静态文件相关 { % static % } { % load static % } 引用JS文件时使用： { % load static % } 某个文件多处被用到可以存为一个变量 { % load static % } { % static \"images/hi.jpg\" as myphoto % } { % get_static_prefix % } { % load static % } 或者 { % load static % } { % get_static_prefix as STATIC_PREFIX % } simple_tag 和自定义filter类似，只不过接收更灵活的参数。 定义注册simple tag @register.simple_tag(name=\"plus\") def plus(a, b, c): return \"{} + {} + {}\".format(a, b, c) 使用自定义simple tag { % load app01_demo % } {# simple tag #} { % plus \"1\" \"2\" \"abc\" % } inclusion_tag 多用于返回html代码片段 示例： templatetags/my_inclusion.py from django import template register = template.Library() @register.inclusion_tag('result.html') def show_results(n): n = 1 if n templates/snippets/result.html { % for choice in data % } { { choice } } { % endfor % } templates/index.html inclusion_tag test { % load inclusion_tag_test % } { % show_results 10 % } 模板中或序列化中choice类型字段的值 模板中 { { obj.get_column_display } } 序列化中 column = serializers.CharField(source='get_column_display') "},"Python/第三方库/Django/05-Django的View.html":{"url":"Python/第三方库/Django/05-Django的View.html","title":"Django的View(视图)","keywords":"","body":"datetime:2019/6/11 11:10 author:nzb Django的View(视图) 一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。 响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片。 无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你当前项目目录下面。 除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为views.py的文件中。 一个简单的视图 # 下面是一个以HTML文档的形式返回当前日期和时间的视图： from django.http import HttpResponse import datetime def current_datetime(request): now = datetime.datetime.now() html = \"It is now %s.\" % now return HttpResponse(html) 让我们来逐行解释下上面的代码： 首先，我们从 django.http模块导入了HttpResponse类，以及Python的datetime库。 接着，我们定义了current_datetime函数。它就是视图函数。每个视图函数都使用HttpRequest对象作为第一个参数，并且通常称之为request。 注意，视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为current_datetime，是因为这个名称能够比较准确地反映出它实现的功能。 这个视图会返回一个HttpResponse对象，其中包含生成的响应。每个视图函数都负责返回一个HttpResponse对象。 Django使用请求和响应对象来通过系统传递状态。 当浏览器向服务端请求一个页面时，Django创建一个HttpRequest对象，该对象包含关于请求的元数据。然后，Django加载相应的视图，将这个HttpRequest对象作为第一个参数传递给视图函数。 每个视图负责返回一个HttpResponse对象。 CBV和FBV 我们之前写过的都是基于函数的view，就叫FBV。还可以把view写成基于类的。 就拿我们之前写过的添加班级为例： FBV版 # FBV版添加班级 def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") CBV版 # CBV版添加班级 from django.views import View class AddClass(View): def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") # 注意： # 使用CBV时，urls.py中也做对应的修改： # urls.py中 url(r'^add_class/$', views.AddClass.as_view()), 给视图加装饰器 使用装饰器装饰FBV # FBV本身就是一个函数，所以和给普通的函数加装饰器无差： def wrapper(func): def inner(*args, **kwargs): start_time = time.time() ret = func(*args, **kwargs) end_time = time.time() print(\"used:\", end_time-start_time) return ret return inner # FBV版添加班级 @wrapper def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") 使用装饰器装饰CBV # 类中的方法与独立函数不完全相同，因此不能直接将函数装饰器应用于类中的方法 ，我们需要先将其转换为方法装饰器。 # Django中提供了method_decorator装饰器用于将函数装饰器转换为方法装饰器。 # CBV版添加班级 from django.views import View from django.utils.decorators import method_decorator class AddClass(View): @method_decorator(wrapper) def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") # 使用CBV时要注意，请求过来后会先执行dispatch()这个方法，如果需要批量对具体的请求处理方法，如get，post等做一些操作的时候，这里我们可以手动改写dispatch方法，这个dispatch方法就和在FBV上加装饰器的效果一样。 class Login(View): def dispatch(self, request, *args, **kwargs): print('before') obj = super(Login,self).dispatch(request, *args, **kwargs) print('after') return obj def get(self,request): return render(request,'login.html') def post(self,request): print(request.POST.get('user')) return HttpResponse('Login.post') Request对象和Response对象 request对象 当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。 Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 官方文档 请求相关的常用值 path_info 返回用户访问url，不包括域名 method 请求中使用的HTTP方法的字符串表示，全大写表示。 GET 包含所有HTTP GET参数的类字典对象 POST 包含所有HTTP POST参数的类字典对象 body 请求体，byte类型 request.POST的数据就是从body里面提取到的 属性 所有的属性应该被认为是只读的，除非另有说明。 属性： 　　django将请求报文中的请求行、头部信息、内容主体封装成 HttpRequest 类中的属性。 除了特殊说明的之外，其他均为只读的。 0. HttpRequest.scheme 表示请求方案的字符串（通常为http或https） 1. HttpRequest.body 　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。 　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。 　　另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。 2. HttpRequest.path 　　一个字符串，表示请求的路径组件（不含域名）。 　　例如：\"/music/bands/the_beatles/\" 3. HttpRequest.method 　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。 　　例如：\"GET\"、\"POST\" 4. HttpRequest.encoding 　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。 这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。 接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。 如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。 5. HttpRequest.GET 　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。 6. HttpRequest.POST 　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。 　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。 因此，不应该使用 if request.POST 来检查使用的是否是POST 方法；应该使用 if request.method == \"POST\" 　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 7. HttpRequest.COOKIES 　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。 8. HttpRequest.FILES 　　一个类似于字典的对象，包含所有的上传文件信息。 FILES 中的每个键为 中的name，值则为对应的数据。 　　注意，FILES 只有在请求的方法为POST 且提交的 带有enctype=\"multipart/form-data\" 的情况下才会 包含数据。否则，FILES 将为一个空的类似于字典的对象。 9. HttpRequest.META 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如\"GET\" 或\"POST\"。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时， 都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_ 前缀。 所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。 10. HttpRequest.user 　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。 例如： if request.user.is_authenticated(): # Do something for logged-in users. else: # Do something for anonymous users. 　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。 ------------------------------------------------------------------------------------- 匿名用户 class models.AnonymousUser django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点： id 永远为None。 username 永远为空字符串。 get_username() 永远返回空字符串。 is_staff 和 is_superuser 永远为False。 is_active 永远为 False。 groups 和 user_permissions 永远为空。 is_anonymous() 返回True 而不是False。 is_authenticated() 返回False 而不是True。 set_password()、check_password()、save() 和delete() 引发 NotImplementedError。 New in Django 1.8: 新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。 11. HttpRequest.session 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。 完整的细节参见会话的文档。 request属性相关 上传文件示例 def upload(request): \"\"\" 保存上传文件前，数据需要存放在某个位置。默认当上传文件小于2.5M时，django会将上传文件的全部内容读进内存。从内存读取一次，写磁盘一次。 但当上传文件很大时，django会把上传文件写到临时文件中，然后存放到系统临时文件夹中。 :param request: :return: \"\"\" if request.method == \"POST\": # 从请求的FILES中获取上传文件的文件名，file为页面上type=files类型input的name属性值 filename = request.FILES[\"file\"].name # 在项目目录下新建一个文件 with open(filename, \"wb\") as f: # 从上传的文件对象中一点一点读 for chunk in request.FILES[\"file\"].chunks(): # 写入本地文件 f.write(chunk) return HttpResponse(\"上传OK\") 方法 1.HttpRequest.get_host() 　　根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。 如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。 　　USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。 　　例如：\"127.0.0.1:8000\" 　　注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。 2.HttpRequest.get_full_path() 　　返回 path，如果可以将加上查询字符串。 　　例如：\"/music/bands/the_beatles/?print=true\" 3.HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 　　返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。 　　如果提供 default 参数，将不会引发异常并返回 default 的值。 　　可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。 复制代码 >>> request.get_signed_cookie('name') 'Tony' >>> request.get_signed_cookie('name', salt='name-salt') 'Tony' # 假设在设置cookie的时候使用的是相同的salt >>> request.get_signed_cookie('non-existing-cookie') ... KeyError: 'non-existing-cookie' # 没有相应的键时触发异常 >>> request.get_signed_cookie('non-existing-cookie', False) False >>> request.get_signed_cookie('cookie-that-was-tampered-with') ... BadSignature: ... >>> request.get_signed_cookie('name', max_age=60) ... SignatureExpired: Signature age 1677.3839159 > 60 seconds >>> request.get_signed_cookie('name', False, max_age=60) False 复制代码 4.HttpRequest.is_secure() 　　如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。 5.HttpRequest.is_ajax() 　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。 　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。 注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： request.POST.getlist(\"hobby\") Response对象 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 使用 传递字符串 from django.http import HttpResponse response = HttpResponse(\"Here's the text of the Web page.\") response = HttpResponse(\"Text only, please.\", content_type=\"text/plain\") 设置或删除响应头信息 response = HttpResponse() response['Content-Type'] = 'text/html; charset=UTF-8' del response['Content-Type'] 属性 HttpResponse.content：响应内容 HttpResponse.charset：响应内容的编码 HttpResponse.status_code：响应的状态码 JsonResponse对象 JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。 from django.http import JsonResponse response = JsonResponse({'foo': 'bar'}) print(response.content) b'{\"foo\": \"bar\"}' 默认只能传递字典类型，如果要传递非字典类型需要设置一下safe关键字参数。 response = JsonResponse([1, 2, 3], safe=False) Django shortcut functions 官方文档 render() 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。 参数： request： 用于生成响应的请求对象。 template_name：要使用的模板的完整名称，可选的参数 context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。 content_type：生成的文档要使用的MIME类型。默认为 DEFAULT_CONTENT_TYPE 设置的值。默认为'text/html' status：响应的状态码。默认为200。 　　　useing: 用于加载模板的模板引擎的名称。 一个简单的例子： from django.shortcuts import render def my_view(request): # 视图的代码写在这里 return render(request, 'myapp/index.html', {'foo': 'bar'}) 上面的代码等于： from django.http import HttpResponse from django.template import loader def my_view(request): # 视图代码写在这里 t = loader.get_template('myapp/index.html') c = {'foo': 'bar'} return HttpResponse(t.render(c, request)) redirect() 参数可以是： 一个模型：将调用模型的get_absolute_url() 函数 一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称 一个绝对的或相对的URL，将原封不动的作为重定向的位置。 默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。 示例: 你可以用多种方式使用redirect() 函数。 传递一个具体的ORM对象（了解即可） 将调用具体ORM对象的get_absolute_url() 方法来获取重定向的URL： from django.shortcuts import redirect def my_view(request): ... object = MyModel.objects.get(...) return redirect(object) 传递一个视图的名称 def my_view(request): ... return redirect('some-view-name', foo='bar') 传递要重定向到的一个具体的网址 def my_view(request): ... return redirect('/some/url/') 当然也可以是一个完整的网址 def my_view(request): ... return redirect('http://example.com/') 默认情况下，redirect() 返回一个临时重定向。以上所有的形式都接收一个permanent 参数；如果设置为True，将返回一个永久的重定向： def my_view(request): ... object = MyModel.objects.get(...) return redirect(object, permanent=True) 扩展阅读： 临时重定向（响应状态码：302）和永久重定向（响应状态码：301）对普通用户来说是没什么区别的，它主要面向的是搜索引擎的机器人。 A页面临时重定向到B页面，那搜索引擎收录的就是A页面。 A页面永久重定向到B页面，那搜索引擎收录的就是B页面。 "},"Python/第三方库/Django/06-Django的路由系统.html":{"url":"Python/第三方库/Django/06-Django的路由系统.html","title":"Django的路由系统","keywords":"","body":"datetime:2019/6/11 16:27 author:nzb Django的路由系统 Django 1.11版本 URLConf官方文档 URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表。 你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 URLconfs配置 基本格式 from django.conf.urls import url urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 注意： Django 2.0版本中的路由系统已经替换成下面的写法(官方文档)： from django.urls import path urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles//', views.year_archive), path('articles///', views.month_archive), path('articles////', views.article_detail), ] 参数说明 正则表达式：一个正则表达式字符串 views视图函数：一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 参数：可选的要传递给视图函数的默认参数（字典形式） 别名：一个可选的name参数 正则表达式详解 基本配置 from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/([0-9]{4})/$', views.year_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] 注意事项 urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。 若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。 每个正则表达式前面的'r' 是可选的但是建议加上。 补充说明 是否开启URL访问地址后面不为/跳转至带有/的路径的配置项 APPEND_SLASH=True Django settings.py配置文件中默认没有 APPEND_SLASH 这个参数，但 Django 默认这个参数为 APPEND_SLASH = True。 其作用就是自动在网址结尾加'/'。 其效果就是： 我们定义了urls.py： from django.conf.urls import url from app01 import views urlpatterns = [ url(r'^blog/$', views.blog), ] 访问 http://www.example.com/blog 时，默认将网址自动转换为 http://www.example/com/blog/ 。 如果在settings.py中设置了 APPEND_SLASH=False，此时我们再请求 http://www.example.com/blog 时就会提示找不到页面。 分组命名匹配 上面的示例使用简单的正则表达式分组匹配（通过圆括号）来捕获URL中的值并以位置参数形式传递给视图。 在更高级的用法中，可以使用分组命名匹配的正则表达式组来捕获URL中的值并以关键字参数形式传递给视图。 在Python的正则表达式中，分组命名正则表达式组的语法是(?Ppattern)，其中name是组的名称，pattern是要匹配的模式。 下面是以上URLconf 使用命名组的重写： from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。 例如，针对url /articles/2017/12/相当于按以下方式调用视图函数： views.month_archive(request, year=\"2017\", month=\"12\") 区别 分组匹配 --> 相当于给视图函数传递位置参数(*args) 分组命名匹配 --> 相当于给视图函数传递关键字参数(**kwargs) 例子： url(r'^articles/2003/$', views.special_case_2003), 分组匹配 url(r'^articles/(?P[0-9]{4})/$', views.year_archive), 分组命名匹配 在实际应用中，使用分组命名匹配的方式可以让你的URLconf 更加明晰且不容易产生参数顺序问题的错误，但是有些开发人员则认为分组命名组语法太丑陋、繁琐。 至于究竟应该使用哪一种，你可以根据自己的喜好来决定。 URLconf匹配的位置 URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。 例如，http://www.example.com/myapp/ 请求中，URLconf 将查找myapp/。 在http://www.example.com/myapp/?page=3 请求中，URLconf 仍将查找myapp/。 URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的POST、GET、HEAD等等 —— 都将路由到相同的函数。 捕获的参数永远都是字符串 每个在URLconf中捕获的参数都作为一个普通的Python字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中： url(r'^articles/(?P[0-9]{4})/$', views.year_archive), 传递到视图函数views.year_archive() 中的year 参数永远是一个字符串类型。 视图函数中指定默认值 urls.py中: from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P[0-9]+)/$', views.page), ] # views.py中，可以为num指定默认值 def page(request, num=\"1\"): pass 在上面的例子中，两个URL模式指向相同的view - views.page - 但是第一个模式并没有从URL中捕获任何东西。 如果第一个模式匹配上了，page()函数将使用其默认参数num=“1”,如果第二个模式匹配，page()将使用正则表达式捕获到的num值。 include其他的URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This #essentially “roots” a set of URLs below other ones. #For example, here’s an excerpt of the URLconf for the Django website itself. #It includes a number of other URLconfs: from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), # 可以包含其他的URLconfs文件 ] 传递额外的参数给视图函数（了解） URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。 django.conf.urls.url() 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。 例如： from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/(?P[0-9]{4})/$', views.year_archive, {'foo': 'bar'}), ] 在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year='2005', foo='bar')。 这个技术在Syndication 框架中使用，来传递元数据和选项给视图。 命名URL和URL反向解析 本质就是给url匹配模式起别名，然后用别名通过reverse函数反向生成url，在HTML和视图函数中使用，就不会因为后期url的改变而出现404。 在使用Django 项目时，一个常见的需求是获得URL的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。 人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。 换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。 获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。 Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它： 根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。 根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。 第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。 在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查： 在模板中：使用url模板标签。 在Python 代码中：使用django.core.urlresolvers.reverse() 函数。 在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。 上面说了一大堆，你可能并没有看懂。（那是官方文档的生硬翻译）。 咱们简单来说就是可以给我们的URL匹配规则起个名字，一个URL匹配模式起一个名字。 这样我们以后就不需要写死URL代码了，只需要通过名字来调用当前的URL。 举个简单的例子： url(r'^home', views.home, name='home'), # 给我的url匹配模式起名为 home url(r'^index/(\\d*)', views.index, name='index'), # 给我的url匹配模式起名为index 这样： 在模板里面可以这样引用： { % url 'home' % } 在views函数中可以这样引用： from django.urls import reverse reverse(\"index\", args=(\"2018\", )) 例子： 考虑下面的URLconf： from django.conf.urls import url from . import views urlpatterns = [ # ... url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'), # ... ] 根据这里的设计，某一年nnnn对应的归档的URL是/articles/nnnn/。 你可以在模板的代码中使用下面的方法获得它们： 2012 Archive { % for yearvar in year_list % } { { yearvar } } Archive { % endfor % } 在Python 代码中，这样使用： from django.urls import reverse from django.shortcuts import redirect def redirect_to_year(request): # ... year = 2006 # ... return redirect(reverse('news-year-archive', args=(year,))) 如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要修改URLconf 中的内容。 在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。 注意： 为了完成上面例子中的URL 反查，你将需要使用命名的URL 模式。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的Python 名称。 当命名你的URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的URL 模式叫做comment，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个URL。 在URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用myapp-comment 而不是comment。 命名空间模式 即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 举个例子： project中的urls.py from django.conf.urls import url, include urlpatterns = [ url(r'^app01/', include('app01.urls', namespace='app01')), url(r'^app02/', include('app02.urls', namespace='app02')), ] app01中的urls.py from django.conf.urls import url from app01 import views app_name = 'app01' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] app02中的urls.py from django.conf.urls import url from app02 import views app_name = 'app02' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] 现在，我的两个app中 url名称重复了，我反转URL的时候就可以通过命名空间的名称得到我当前的URL。 语法： '命名空间名称:URL名称' 模板中使用： { % url 'app01:detail' pk=12 pp=99 % } views中的函数中使用 v = reverse('app01:detail', kwargs={'pk':11}) 这样即使app中URL的命名相同，我也可以反转得到正确的URL了。 "},"Python/第三方库/Django/07-Django-ORM相关操作.html":{"url":"Python/第三方库/Django/07-Django-ORM相关操作.html","title":"Django ORM相关操作","keywords":"","body":"datetime:2019/6/12 16:47 author:nzb Django ORM相关操作 一般操作 官方文档 必知必会13条 all(): 查询所有结果 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列，需要哪些字段就写进去。 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 order_by(*field): 对查询结果排序 reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。 distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。) count(): 返回数据库中匹配查询(QuerySet)的对象数量。 first(): 返回第一条记录 last(): 返回最后一条记录 exists(): 如果QuerySet包含数据，就返回True，否则返回False values()方法例子： 返回QuerySet对象的方法有 all() filter() exclude() order_by() reverse() distinct() 特殊QuerySet values() 返回一个可迭代的字典序列 values_list() 返回一个可迭代的元祖序列 返回具体对象的 get() first() last() 返回布尔值的方法有 exists() 返回数字的方法有 count() 单表查询之神奇的双下划线 models.Tb1.objects.filter(id__lt=10, id__gt=1) # 获取id大于1 且 小于10的值 models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据 models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in models.Tb1.objects.filter(name__contains=\"ven\") # 获取name字段包含\"ven\"的 models.Tb1.objects.filter(name__icontains=\"ven\") # icontains大小写不敏感 models.Tb1.objects.filter(id__range=[1, 3]) # id范围是1到3的，等价于SQL的bettwen and 类似的还有：startswith，istartswith, endswith, iendswith　 date字段还可以： models.Class.objects.filter(first_day__year=2017) ForeignKey操作 正向查找 对象查找(跨表) 这是对对象进行操作，不能values()和values_list() 语法： 对象.关联字段.字段 示例： book_obj = models.Book.objects.first() # 第一本书对象 print(book_obj.publisher) # 得到这本书关联的出版社对象 print(book_obj.publisher.name) # 得到出版社对象的名称 字段查找(跨表) 这是对QuerySet进行操作，可以 values()和values_list() 语法： 关联字段__字段 示例： print(models.Book.objects.values_list(\"publisher__name\")) # 双下划线表示跨表 反向操作 对象查找 语法： obj.表名_set 示例： publisher_obj = models.Publisher.objects.first() # 找到第一个出版社对象 books = publisher_obj.book_set.all() # 找到第一个出版社出版的所有书 titles = books.values_list(\"title\") # 找到第一个出版社出版的所有书的书名 如果外键字段设置了：related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为'+'，或者以'+'结尾。 例子： course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE, related_name='course') 语法： 未设置： **obj.表名_set** 设置： **obj.course** 字段查找 语法： 表名__字段 示例： titles = models.Publisher.objects.values_list(\"book__title\") OneToOneField 当一张表的某些字段查询的比较繁琐，另外一些字段查询的不是特别繁琐，把不怎么常用的字段单独拿出来做成一张表，然后用一对一关联起来。 优势： 既保证数据能完整的保存下来，有能保证大部分的检索更快。 用法： OneToOneField(to=\"\") 例子： 作者 class Author(models.Model): name = models.CharField(max_length=12) age = models.IntegerField() phone = models.IntegerField() detail = models.OneToOneField(to=\"AuthorDetail\") def __str__(self): return self.name 作者详情 class AuthorDetail(models.Model): 爱好 hobby = models.CharField(max_length=32) 地址 addr = models.CharField(max_length=128) ManyToManyField class RelatedManager \"关联管理器\"是在一对多或者多对多的关联上下文中使用的管理器。 它存在于下面两种情况： 外键关系的反向查询 多对多关联关系 简单来说就是当 点后面的对象 可能存在多个的时候就可以使用以下的方法。 方法 create() 创建一个新的对象，保存对象，并将它添加到关联对象集之中，返回新创建的对象。 >>> import datetime >>> models.Author.objects.first().book_set.create(title=\"番茄物语\", publish_date=datetime.date.today()) add() 把指定的model对象添加到关联对象集中。 添加对象 >>> author_objs = models.Author.objects.filter(id__lt=3) >>> models.Book.objects.first().authors.add(*author_objs) 添加id >>> models.Book.objects.first().authors.add(*[1, 2]) set() 更新model对象的关联对象。 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.set([2, 3]) remove() 从关联对象集中移除执行的model对象 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.remove(3) clear() 从关联对象集中移除一切对象。 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.clear() 注意： 对于ForeignKey对象，clear()和remove()方法仅在null=True时存在。 举个例子： ForeignKey字段没设置null=True时， class Book(models.Model): title = models.CharField(max_length=32) publisher = models.ForeignKey(to=Publisher) 没有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() Traceback (most recent call last): File \"\", line 1, in AttributeError: 'RelatedManager' object has no attribute 'clear' 当ForeignKey字段设置null=True时， class Book(models.Model): name = models.CharField(max_length=32) publisher = models.ForeignKey(to=Class, null=True) 此时就有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() 注意： 对于所有类型的关联字段，add()、create()、remove()和clear(),set()都会马上更新数据库。换句话说，在关联的任何一端，都不需要再调用save()方法。 自己创建第三张表 多对多的方式 ORM自动创建第三种表 自己创建第三张表，利用外键分别关联作者和书 关联查询比较麻烦，因为没办法使用ORM提供的便利方法 自己创建第三张表，使用ORM 的ManyToManyField() 使用此种方式创建多对多表的时候，没有add()、remove()等方法 而是直接操作第三张表 使用方法(依情况而定)： 如果你第三张表没有额外的字段，就用第一种 如果你第三张表有额外的字段，就用第三种或第一种 # 作者 class Author(models.Model): name = models.CharField(max_length=12) age = models.IntegerField() phone = models.IntegerField() # 通过through=\"AuthorBook\",through_fields=(\"author\", \"book\") 来指定使用我创建的第三张表来构建多对多的关系，而不是django自动创建的 book = models.ManyToManyField(to=\"Book\", through=\"AuthorBook\", through_fields=(\"author\", \"book\")) # through_field中，第一个字段，多对多设置在哪一张表里，第三张表通过什么字段找到这张表，就把这个字段写在前面，有关联关系的才要写进去 detail = models.OneToOneField(to=\"AuthorDetail\") def __str__(self): return self.name # 书 class Book(models.Model): name = models.CharField(max_length=50) # 自己创建作者和书关联的第三张表 # 此时，在ORM层面 作者和书就没有多对多的关系了 class AuthorBook(models.Model): # 作者id author = models.ForeignKey(to=\"Author\") # 书id book = models.ForeignKey(to=\"Book\") # 其他字段 info = models.CharField(max_length=12) class Meta: # 作者id和书id联合唯一 unique_together = ('author', 'book') 聚合查询和分组查询 聚合 aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。 键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 用到的内置函数： from django.db.models import Avg, Sum, Max, Min, Count 示例： >>> from django.db.models import Avg, Sum, Max, Min, Count >>> models.Book.objects.all().aggregate(Avg(\"price\")) {'price__avg': 13.233333} 如果你想要为聚合值指定一个名称，可以向聚合子句提供它。 >>> models.Book.objects.aggregate(average_price=Avg('price')) {'average_price': 13.233333} 如果你希望生成不止一个聚合，你可以向aggregate()子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询： >>> models.Book.objects.all().aggregate(Avg(\"price\"), Max(\"price\"), Min(\"price\")) {'price__avg': 13.233333, 'price__max': Decimal('19.90'), 'price__min': Decimal('9.90')} 分组 我们在这里先复习一下SQL语句的分组。 假设现在有一张公司职员表： 我们使用原生SQL语句，按照部分分组求平均工资： select dept,AVG(salary) from employee group by dept; ORM查询: from django.db.models import Avg Employee.objects.values(\"dept\").annotate(avg=Avg(\"salary\").values(\"dept\", \"avg\") # values()就是取哪些字段，同时具有分组的作用。 连表查询的分组： SQL查询： select dept.name,AVG(salary) from employee inner join dept on (employee.dept_id=dept.id) group by dept_id; ORM查询： from django.db.models import Avg models.Employee.objects.values('dept_id').annotate(avg=Avg('salary')).values('dept__name', 'avg') # 或 models.Dept.objects.annotate(avg=Avg(\"employee__salary\")).values(\"name\", \"avg\") extra()方法分组 extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None) 有些情况下，Django的查询语法难以简单的表达复杂的 WHERE 子句，对于这种情况, Django 提供了 extra() QuerySet修改机制 — 它能在 QuerySet生成的SQL从句中注入新子句 extra可以指定一个或多个 参数,例如 select, where or tables. 这些参数都不是必须的，但是你至少要使用一个!要注意这些额外的方式对不同的数据库引擎可能存在移植性问题.(因为你在显式的书写SQL语句),除非万不得已,尽量避免这样做 参数之select The select 参数可以让你在 SELECT 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。 queryResult=models.Article 　　　　　　　　　　　.objects.extra(select={'is_recent': \"create_time > '2017-09-05'\"}) 结果集中每个 Entry 对象都有一个额外的属性is_recent, 它是一个布尔值，表示 Article对象的create_time 是否晚于2017-09-05. article_obj=models.Article.objects.filter(nid=1).extra(select={\"standard_time\":\"strftime('%%Y-%%m-%%d',create_time)\"}).values(\"standard_time\",\"nid\",\"title\") print(article_obj) # 参数之where / tables 您可以使用where定义显式SQL WHERE子句 - 也许执行非显式连接。您可以使用tables手动将表添加到SQL FROM子句。 where和tables都接受字符串列表。所有where参数均为“与”任何其他搜索条件。 queryResult=models.Article.objects.extra(where=['nid in (1,3) OR title like \"py%\" ','nid>2']) 运用 按日查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y-%%m-%%d')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 按月查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y-%%m')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 按年查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 更多示例 示例1：统计每一本书的作者个数 >>> book_list = models.Book.objects.all().annotate(author_num=Count(\"author\")) >>> for obj in book_list: ... print(obj.author_num) ... 2 1 1 示例2：统计出每个出版社买的最便宜的书的价格 >>> publisher_list = models.Publisher.objects.annotate(min_price=Min(\"book__price\")) >>> for obj in publisher_list: ... print(obj.min_price) ... 9.90 19.90 方法二： >>> models.Book.objects.values(\"publisher__name\").annotate(min_price=Min(\"price\")) 示例3：统计不止一个作者的图书 >>> models.Book.objects.annotate(author_num=Count(\"author\")).filter(author_num__gt=1) ]> 示例4：根据一本图书作者数量的多少对查询集 QuerySet进行排序 >>> models.Book.objects.annotate(author_num=Count(\"author\")).order_by(\"author_num\") , , ]> 示例5：查询各个作者出的书的总价格 >>> models.Author.objects.annotate(sum_price=Sum(\"book__price\")).values(\"name\", \"sum_price\") 示例6：查询动态最多的组织并排序 >>> model.Organization.objects.filter(is_del=False, userdynamic__is_pass=2).annotate(dynamic_nums=Count('userdynamic__org')).order_by('-dynamic_nums').all() F查询和Q查询 F查询 在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？ Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。 示例1： 查询评论数大于收藏数的书籍 from django.db.models import F models.Book.objects.filter(commnet_num__gt=F('keep_num')) Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。 models.Book.objects.filter(commnet_num__lt=F('keep_num')*2) 修改操作也可以使用F函数,比如将每一本书的价格提高30元 models.Book.objects.all().update(price=F(\"price\")+30) 引申： 如果要修改char字段咋办？ 如：把所有书名后面加上：(第一版) >>> from django.db.models.functions import Concat >>> from django.db.models import Value >>> models.Book.objects.all().update(title=Concat(F(\"title\"), Value(\"(\"), Value(\"第一版\"), Value(\")\"))) Q查询 filter() 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。 示例1： 查询作者名是小仙女或小魔女的 models.Book.objects.filter(Q(authors__name=\"小仙女\")|Q(authors__name=\"小魔女\")) 你可以组合& 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。同时，Q 对象可以使用~ 操作符取反，这允许组合正常的查询和取反(NOT) 查询。 示例：查询作者名字是小仙女并且不是2018年出版的书的书名。 >>> models.Book.objects.filter(Q(author__name=\"小仙女\") & ~Q(publish_date__year=2018)).values_list(\"title\") 查询函数可以混合使用Q 对象和关键字参数。所有提供给查询函数的参数（关键字参数或Q 对象）都将\"AND”在一起。但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 例如：查询出版年份是2017或2018，书名中带物语的所有书。 >>> models.Book.objects.filter(Q(publish_date__year=2018) | Q(publish_date__year=2017), title__icontains=\"物语\") , , ]> 锁和事务 锁 select_for_update(nowait=False, skip_locked=False) 返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个 SELECT ... FOR UPDATE 语句。 举个例子： entries = Entry.objects.select_for_update().filter(author=request.user) 所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。 一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。 如果这不想要使查询阻塞的话，使用select_for_update(nowait=True)。 如果其它事务持有冲突的锁, 那么查询将引发 DatabaseError 异常。你也可以使用select_for_update(skip_locked=True)忽略锁定的行。 nowait和skip_locked是互斥的，同时设置会导致ValueError。 目前，postgresql，oracle和mysql数据库后端支持select_for_update()。 但是，MySQL不支持nowait和skip_locked参数。 使用不支持这些选项的数据库后端（如MySQL）将nowait=True或skip_locked=True转换为select_for_update()将导致抛出DatabaseError异常，这可以防止代码意外终止。 事务 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() import datetime from app01 import models try: from django.db import transaction with transaction.atomic(): new_publisher = models.Publisher.objects.create(name=\"火星出版社\") models.Book.objects.create(title=\"橘子物语\", publish_date=datetime.date.today(), publisher_id=10) # 指定一个不存在的出版社id except Exception as e: print(str(e)) 其他鲜为人知的操作(了解为主) Django_ORM执行原生SQL 在模型查询API不够用的情况下，我们还可以使用原始的SQL语句进行查询。 Django 提供两种方法使用原始SQL进行查询：一种是使用raw()方法，进行原始SQL查询并返回模型实例；另一种是完全避开模型层，直接执行自定义的SQL语句。 执行原生查询 raw()管理器方法用于原始的SQL查询，并返回模型的实例： 注意：raw()语法查询必须包含主键。 这个方法执行原始的SQL查询，并返回一个django.db.models.query.RawQuerySet 实例。 这个RawQuerySet 实例可以像一般的QuerySet那样，通过迭代来提供对象实例。 举个例子： class Person(models.Model): first_name = models.CharField(...) last_name = models.CharField(...) birth_date = models.DateField(...) 可以像下面这样执行原生SQL语句 >>> for p in Person.objects.raw('SELECT * FROM myapp_person'): ... print(p) raw()查询可以查询其他表的数据。 举个例子： ret = models.Student.objects.raw('select id, tname as hehe from app02_teacher') for i in ret: print(i.id, i.hehe) raw()方法自动将查询字段映射到模型字段。还可以通过translations参数指定一个把查询的字段名和ORM对象实例的字段名互相对应的字典 d = {'tname': 'haha'} ret = models.Student.objects.raw('select * from app02_teacher', translations=d) for i in ret: print(i.id, i.sname, i.haha) 原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！ d = {'tname': 'haha'} ret = models.Student.objects.raw('select * from app02_teacher where id > %s', translations=d, params=[1,]) for i in ret: print(i.id, i.sname, i.haha) 直接执行自定义SQL 有时候raw()方法并不十分好用，很多情况下我们不需要将查询结果映射成模型，或者我们需要执行DELETE、 INSERT以及UPDATE操作。在这些情况下，我们可以直接访问数据库，完全避开模型层。 我们可以直接从django提供的接口中获取数据库连接，然后像使用pymysql模块一样操作数据库。 from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) ret = cursor.fetchone() QuerySet方法大全 ################################################################## # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET # ################################################################## def all(self) # 获取所有的数据对象 def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def select_related(self, *fields) 性能相关：表之间进行join连表操作，一次性获取关联的数据。 总结： 1. select_related主要针一对一和多对一关系进行优化。 2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。 def prefetch_related(self, *lookups) 性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。 总结： 1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。 2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。 def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重 def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age') def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置） ################################################## # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS # ################################################## def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'} Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using=\"default\") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..) def values(self, *fields): # 获取每行数据为字典格式 def values_list(self, *fields, **kwargs): # 获取每行数据为元祖 def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日） # order只能是：\"ASC\" \"DESC\" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC') def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\" # order只能是：\"ASC\" \"DESC\" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) \"\"\" pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) \"\"\" def none(self): # 空QuerySet对象 #################################### # METHODS THAT DO DATABASE QUERIES # #################################### def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===> {'k': 3, 'n': 4} def count(self): # 获取个数 def get(self, *args, **kwargs): # 获取单个对象 def create(self, **kwargs): # 创建对象 def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10) def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 2}) def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 1}) def first(self): # 获取第一个 def last(self): # 获取最后一个 def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list) def delete(self): # 删除 def update(self, **kwargs): # 更新 def exists(self): # 是否有结果 Django终端打印SQL语句 在Django项目的settings.py文件中，在最后复制粘贴如下代码： LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'console':{ 'level':'DEBUG', 'class':'logging.StreamHandler', }, }, 'loggers': { 'django.db.backends': { 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', }, } } 即为你的Django项目配置上一个名为django.db.backends的logger实例即可查看翻译后的SQL语句。 在Python脚本中调用Django环境 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() from app01 import models books = models.Book.objects.all() print(books) PS: BMS为项目名 "},"Python/第三方库/Django/08-Cookie、Session和分页.html":{"url":"Python/第三方库/Django/08-Cookie、Session和分页.html","title":"Cookie、Session和分页","keywords":"","body":"datetime:2019/6/24 9:46 author:nzb Cookie、Session和分页 Cookie Cookie的由来 大家都知道HTTP协议是无状态的。 无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响， 也不会直接影响后面的请求响应情况。 一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。 状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的， 也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。 什么是Cookie Cookie具体指的是一段小信息，它是服务器发送出来存储在浏览器上的一组组键值对，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。 Cookie的原理 cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。 查看Cookie 我们使用Chrome浏览器，打开开发者工具。 Django中操作Cookie 获取Cookie request.COOKIES['key'] request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 设置Cookie rep = HttpResponse(...) rep ＝ render(request, ...) rep.set_cookie(key,value,...) rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...) 参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 删除Cookie def logout(request): rep = redirect(\"/login/\") rep.delete_cookie(\"user\") # 删除用户浏览器上之前设置的usercookie值 return rep Cookie版登陆校验 def check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.get_signed_cookie(\"login\", salt=\"SSS\", default=None) == \"yes\": # 已经登录的用户... return func(request, *args, **kwargs) else: # 没有登录的用户，跳转刚到登录页面 return redirect(\"/login/?next={}\".format(next_url)) return inner @check_login def login(request): if request.method == \"POST\": username = request.POST.get(\"username\") passwd = request.POST.get(\"password\") if username == \"xxx\" and passwd == \"dashabi\": next_url = request.GET.get(\"next\") if next_url and next_url != \"/logout/\": response = redirect(next_url) else: response = redirect(\"/class_list/\") response.set_signed_cookie(\"login\", \"yes\", salt=\"SSS\") return response return render(request, \"login.html\") Session Session的由来 Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。 另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 Django中Session相关方法 # 获取、设置、删除Session中数据 request.session['k1'] request.session.get('k1',None) request.session['k1'] = 123 request.session.setdefault('k1',123) # 存在则不设置 del request.session['k1'] # 所有 键、值、键值对 request.session.keys() request.session.values() request.session.items() request.session.iterkeys() request.session.itervalues() request.session.iteritems() # 会话session的key request.session.session_key # 将所有Session失效日期小于当前日期的数据删除 request.session.clear_expired() # 检查会话session的key在数据库中是否存在 request.session.exists(\"session_key\") # 删除当前会话的所有Session数据 request.session.delete() 　　 # 删除当前的会话数据并删除会话的Cookie。 request.session.flush() 这用于确保前面的会话数据不可以再次被用户的浏览器访问 例如，django.contrib.auth.logout() 函数中就会调用它。 # 设置会话Session和Cookie的超时时间 request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 Session流程解析 Session版登陆验证 from functools import wraps def check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.session.get(\"user\"): return func(request, *args, **kwargs) else: return redirect(\"/login/?next={}\".format(next_url)) return inner def login(request): if request.method == \"POST\": user = request.POST.get(\"user\") pwd = request.POST.get(\"pwd\") if user == \"alex\" and pwd == \"alex1234\": # 设置session request.session[\"user\"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get(\"next\") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect(\"/index/\") return render(request, \"login.html\") @check_login def logout(request): # 删除所有当前请求相关的session request.session.delete() return redirect(\"/login/\") @check_login def index(request): current_user = request.session.get(\"user\", None) return render(request, \"index.html\", {\"user\": current_user}) Django中的Session配置 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用。 1. 数据库Session SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） 2. 缓存Session SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎 SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 3. 文件Session SESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎 SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库 SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 5. 加密Cookie Session SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎 其他公用设置项： SESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认） SESSION_COOKIE_PATH ＝ \"/\" # Session的cookie保存的路径（默认） SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认） SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认） SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认） SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认） SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） CBV中加装饰器相关 CBV实现的登录视图 class LoginView(View): def get(self, request): \"\"\" 处理GET请求 \"\"\" return render(request, 'login.html') def post(self, request): \"\"\" 处理POST请求 \"\"\" user = request.POST.get('user') pwd = request.POST.get('pwd') if user == 'alex' and pwd == \"alex1234\": next_url = request.GET.get(\"next\") # 生成随机字符串 # 写浏览器cookie -> session_id: 随机字符串 # 写到服务端session： # { # \"随机字符串\": {'user':'alex'} # } request.session['user'] = user if next_url: return redirect(next_url) else: return redirect('/index/') return render(request, 'login.html') 要在CBV视图中使用我们上面的check_login装饰器，有以下三种方式： from django.utils.decorators import method_decorator 1. 加在CBV视图的get或post方法上 from django.utils.decorators import method_decorator class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") @method_decorator(check_login) def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 2. 加在dispatch方法上 from django.utils.decorators import method_decorator class HomeView(View): @method_decorator(check_login) def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 因为CBV中首先执行的就是dispatch方法，所以这么写相当于给get和post方法都加上了登录校验。 3. 直接加在视图类上，但method_decorator必须传 name 关键字参数 如果get方法和post方法都需要登录校验的话就写两个装饰器。 from django.utils.decorators import method_decorator @method_decorator(check_login, name=\"get\") @method_decorator(check_login, name=\"post\") class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 补充 CSRF Token相关装饰器在CBV只能加到dispatch方法上，或者加在视图类上然后name参数指定为dispatch方法。 备注： csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。 csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。 from django.views.decorators.csrf import csrf_exempt, csrf_protect from django.utils.decorators import method_decorator class HomeView(View): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 或者 from django.views.decorators.csrf import csrf_exempt, csrf_protect from django.utils.decorators import method_decorator @method_decorator(csrf_exempt, name='dispatch') class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 分页 当数据库中数据有很多，我们通常会在前端页面做分页展示。 分页的数据可以在前端页面实现，也可以在后端实现分页。 后端实现分页的原理就是每次只请求一页数据。 准备工作 我们使用脚本批量创建一些测试数据（将下面的代码保存到bulk_create.py文件中放到Django项目的根目录，直接执行即可。）： import os if __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"about_orm.settings\") import django django.setup() from app01 import models bulk_obj = (models.Publisher(name='沙河第{}出版社'.format(i)) for i in range(300)) models.Publisher.objects.bulk_create(bulk_obj) 自定义分页 稳扎稳打版 def publisher_list(request): # 从URL中取当前访问的页码数 try: current_page = int(request.GET.get('page')) except Exception as e: # 取不到或者页码数不是数字都默认展示第1页 current_page = 1 # 总数据量 total_count = models.Publisher.objects.count() # 定义每页显示多少条数据 per_page = 10 # 计算出总页码数 total_page, more = divmod(total_count, per_page) if more: total_page += 1 # 定义页面上最多显示多少页码(为了左右对称，一般设为奇数) max_show = 11 half_show = max_show // 2 # 计算一下页面显示的页码范围 if total_page = total_page: # 右边越界 page_end = total_page page_start = total_page - max_show elif current_page - half_show ') # 加首页 first_li = '首页' page_html_list.append(first_li) # 加上一页 if current_page == 1: prev_li = '&laquo;' else: prev_li = '&laquo;'.format(current_page - 1) page_html_list.append(prev_li) for i in range(page_start, page_end + 1): if i == current_page: li_tag = '{0}'.format(i) else: li_tag = '{0}'.format(i) page_html_list.append(li_tag) # 加下一页 if current_page == total_page: next_li = '&raquo;' else: next_li = '&raquo;'.format(current_page + 1) page_html_list.append(next_li) # 加尾页 page_end_li = '尾页'.format(total_page) page_html_list.append(page_end_li) page_html_list.append('') page_html = \"\".join(page_html_list) return render(request, \"publisher_list.html\", {\"publisher_list\": publisher_list, \"page_html\": page_html}) 封装保存版 class Pagination(object): \"\"\"自定义分页（Bootstrap版）\"\"\" def __init__(self, current_page, total_count, base_url, per_page=10, max_show=11): \"\"\" :param current_page: 当前请求的页码 :param total_count: 总数据量 :param base_url: 请求的URL :param per_page: 每页显示的数据量，默认值为10 :param max_show: 页面上最多显示多少个页码，默认值为11 \"\"\" try: self.current_page = int(current_page) except Exception as e: # 取不到或者页码数不是数字都默认展示第1页 self.current_page = 1 # 定义每页显示多少条数据 self.per_page = per_page # 计算出总页码数 total_page, more = divmod(total_count, per_page) if more: total_page += 1 self.total_page = total_page # 定义页面上最多显示多少页码(为了左右对称，一般设为奇数) self.max_show = max_show self.half_show = max_show // 2 self.base_url = base_url @property def start(self): return (self.current_page-1) * self.per_page @property def end(self): return self.current_page * self.per_page def page_html(self): # 计算一下页面显示的页码范围 if self.total_page = self.total_page: # 右边越界 page_end = self.total_page page_start = self.total_page - self.max_show elif self.current_page - self.half_show ') # 加首页 first_li = '首页'.format(self.base_url) page_html_list.append(first_li) # 加上一页 if self.current_page == 1: prev_li = '&laquo;' else: prev_li = '&laquo;'.format( self.base_url, self.current_page - 1) page_html_list.append(prev_li) for i in range(page_start, page_end + 1): if i == self.current_page: li_tag = '{1}'.format(self.base_url, i) else: li_tag = '{1}'.format(self.base_url, i) page_html_list.append(li_tag) # 加下一页 if self.current_page == self.total_page: next_li = '&raquo;' else: next_li = '&raquo;'.format( self.base_url, self.current_page + 1) page_html_list.append(next_li) # 加尾页 page_end_li = '尾页'.format(self.base_url, self.total_page) page_html_list.append(page_end_li) page_html_list.append('') return \"\".join(page_html_list) 封装保存版使用示例 def publisher_list(request): # 从URL中取当前访问的页码数 current_page = int(request.GET.get('page')) # 比len(models.Publisher.objects.all())更高效 total_count = models.Publisher.objects.count() page_obj = Pagination(current_page, total_count, request.path_info) data = models.Publisher.objects.all()[page_obj.start:page_obj.end] page_html = page_obj.page_html() return render(request, \"publisher_list.html\", {\"publisher_list\": data, \"page_html\": page_html}) Django内置分页 内置分页view部分 from django.shortcuts import render from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger L = [] for i in range(999): L.append(i) def index(request): current_page = request.GET.get('p') paginator = Paginator(L, 10) # per_page: 每页显示条目数量 # count: 数据总个数 # num_pages:总页数 # page_range:总页数的索引范围，如: (1,10),(1,200) # page: page对象 try: posts = paginator.page(current_page) # has_next 是否有下一页 # next_page_number 下一页页码 # has_previous 是否有上一页 # previous_page_number 上一页页码 # object_list 分页之后的数据列表 # number 当前页 # paginator paginator对象 except PageNotAnInteger: posts = paginator.page(1) except EmptyPage: posts = paginator.page(paginator.num_pages) return render(request, 'index.html', {'posts': posts}) 内置分页HTML部分 { % for item in posts % } { { item } } { % endfor % } { % if posts.has_previous % } Previous { % endif % } Page { { posts.number } } of { { posts.paginator.num_pages } }. { % if posts.has_next % } Next { % endif % } Cookie和Session(100天) 实现用户跟踪 如今，一个网站如果不通过某种方式记住你是谁以及你之前在网站的活动情况，失去的就是网站的可用性和便利性，继而很有可能导致网站用户的流式，所以记住一个用户（更专业的说法叫用户跟踪）对绝大多数Web应用来说都是必需的功能。 在服务器端，我们想记住一个用户最简单的办法就是创建一个对象，通过这个对象就可以把用户相关的信息都保存起来，这个对象就是我们常说的session（用户会话对象）。那么问题来了，HTTP本身是一个无连接（每次请求和响应的过程中，服务器一旦完成对客户端请求的响应之后就断开连接）、无状态（客户端再次发起对服务器的请求时，服务器无法得知这个客户端之前的任何信息）的协议，即便服务器通过session对象保留了用户数据，还得通过某种方式来确定当前的请求与之前保存过的哪一个session是有关联的。相信很多人都能想到，我们可以给每个session对象分配一个全局唯一的标识符来识别session对象，我们姑且称之为sessionid，每次客户端发起请求时，只要携带上这个sessionid，就有办法找到与之对应的session对象，从而实现在两次请求之间记住该用户的信息，也就是我们之前说的用户跟踪。 要让客户端记住并在每次请求时带上sessionid又有以下几种做法： URL重写。所谓URL重写就是在URL中携带sessionid，例如：http://www.example.com/index.html?sessionid=123456，服务器通过获取sessionid参数的值来取到与之对应的session对象。 隐藏域（隐式表单域）。在提交表单的时候，可以通过在表单中设置隐藏域向服务器发送额外的数据。例如：。 本地存储。现在的浏览器都支持多种本地存储方案，包括：cookie、localStorage、sessionStorage、IndexedDB等。在这些方案中，cookie是历史最为悠久也是被诟病得最多的一种方案，也是我们接下来首先为大家讲解的一种方案。简单的说，cookie是一种以键值对方式保存在浏览器临时文件中的数据，每次请求时，请求头中会携带本站点的cookie到服务器，那么只要将sessionid写入cookie，下次请求时服务器只要读取请求头中的cookie就能够获得这个sessionid，如下图所示。 在HTML5时代要，除了cookie，还可以使用新的本地存储API来保存数据，就是刚才提到的localStorage、sessionStorage、IndexedDB等技术，如下图所示。 Django框架对session的支持 在创建Django项目时，默认的配置文件settings.py文件中已经激活了一个名为SessionMiddleware的中间件（关于中间件的知识我们在下一个章节做详细的讲解，这里只需要知道它的存在即可），因为这个中间件的存在，我们可以直接通过请求对象的session属性来操作会话对象。session属性是一个像字典一样可以读写数据的容器对象，因此我们可以使用“键值对”的方式来保留用户数据。与此同时，SessionMiddleware中间件还封装了对cookie的操作，在cookie中保存了sessionid，就如同我们之前描述的那样。 在默认情况下，Django将session的数据序列化后保存在关系型数据库中，在Django 1.6以后的版本中，默认的序列化数据的方式是JSON序列化，而在此之前一直使用Pickle序列化。JSON序列化和Pickle序列化的差别在于前者将对象序列化为字符串（字符形式），而后者将对象序列化为字节串（二进制形式），因为安全方面的原因，JSON序列化成为了目前Django框架默认序列化数据的方式，这就要求在我们保存在session中的数据必须是能够JSON序列化的，否则就会引发异常。还有一点需要说明的是，使用关系型数据库保存session中的数据在大多数时候并不是最好的选择，因为数据库可能会承受巨大的压力而成为系统性能的瓶颈，在后面的章节中我们会告诉大家如何将session的数据保存到缓存服务中。 我们继续完善之前的投票应用，前一个章节中我们实现了用户的登录和注册，下面我们首先完善登录时对验证码的检查。 def get_captcha(request): \"\"\"验证码\"\"\" captcha_text = random_captcha_text() request.session['captcha'] = captcha_text image_data = Captcha.instance().generate(captcha_text) return HttpResponse(image_data, content_type='image/png') 注意上面代码中的第4行，我们将随机生成的验证码字符串保存到session中，稍后用户登录时，我们要将保存在session中的验证码字符串和用户输入的验证码字符串进行比对，如果用户输入了正确的验证码才能够执行后续的登录流程，代码如下所示。 def login(request: HttpRequest): \"\"\"登录\"\"\" hint = '' if request.method == 'POST': form = LoginForm(request.POST) if form.is_valid(): # 对验证码的正确性进行验证 captcha_from_user = form.cleaned_data['captcha'] captcha_from_sess = request.session.get('captcha', '') if captcha_from_sess.lower() != captcha_from_user.lower(): hint = '请输入正确的验证码' else: username = form.cleaned_data['username'] password = form.cleaned_data['password'] user = User.objects.filter(username=username, password=password).first() if user: # 登录成功后将用户编号和用户名保存在session中 request.session['userid'] = user.no request.session['username'] = user.username return redirect('/') else: hint = '用户名或密码错误' else: hint = '请输入有效的登录信息' return render(request, 'login.html', {'hint': hint}) 上面的代码中，我们设定了登录成功后会在session中保存用户的编号（userid）和用户名（username），页面会重定向到首页。接下来我们可以稍微对首页的代码进行调整，在页面的右上角显示出登录用户的用户名。我们将这段代码单独写成了一个名为header.html的HTML文件，首页中可以通过在标签中添加{ % include 'header.html' % }来包含这个页面，代码如下所示。 { % if request.session.userid % } { { request.session.username } } 注销 { % else % } 登录&nbsp;&nbsp; { % endif % } 注册 如果用户没有登录，页面会显示登录和注册的超链接；而用户登录成功后，页面上会显示用户名和注销的链接，注销链接对应的视图函数如下所示，URL的映射与之前讲过的类似，不再赘述。 def logout(request): \"\"\"注销\"\"\" request.session.flush() return redirect('/') 上面的代码通过session对象flush方法来销毁session，一方面清除了服务器上session对象保存的用户数据，一方面将保存在浏览器cookie中的sessionid删除掉，稍后我们会对如何读写cookie的操作加以说明。 我们可以通过项目使用的数据库中名为django_session 的表来找到所有的session，该表的结构如下所示： session_key session_data expire_date c9g2gt5cxo0k2evykgpejhic5ae7bfpl MmI4YzViYjJhOGMyMDJkY2M5Yzg3... 2019-05-25 23:16:13.898522 其中，第1列就是浏览器cookie中保存的sessionid；第2列是经过BASE64编码后的session中的数据，如果使用Python的base64对其进行解码，解码的过程和结果如下所示。 >>> import base64 >>> base64.b64decode('MmI4YzViYjJhOGMyMDJkY2M5Yzg3ZWIyZGViZmUzYmYxNzdlNDdmZjp7ImNhcHRjaGEiOiJzS3d0Iiwibm8iOjEsInVzZXJuYW1lIjoiamFja2ZydWVkIn0=') '2b8c5bb2a8c202dcc9c87eb2debfe3bf177e47ff:{\"captcha\":\"sKwt\",\"no\":1,\"username\":\"jackfrued\"}' 第3列是session的过期时间，session过期后浏览器保存的cookie中的sessionid就会失效，但是数据库中的这条对应的记录仍然会存在，如果想清除过期的数据，可以使用下面的命令。 python manage.py clearsessions Django框架默认的session过期时间为两周（1209600秒），如果想修改这个时间，可以在项目的配置文件中添加如下所示的代码。 # 配置会话的超时时间为1天（86400秒） SESSION_COOKIE_AGE = 86400 有很多对安全性要求较高的应用都必须在关闭浏览器窗口时让会话过期，不再保留用户的任何信息，如果希望在关闭浏览器窗口时就让会话过期（cookie中的sessionid失效），可以加入如下所示的配置。 # 设置为True在关闭浏览器窗口时session就过期 SESSION_EXPIRE_AT_BROWSER_CLOSE = True 如果不希望将session的数据保存在数据库中，可以将其放入缓存中，对应的配置如下所示，缓存的配置和使用我们在后面讲解。 # 配置将会话对象放到缓存中存储 SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 配置使用哪一组缓存来保存会话 SESSION_CACHE_ALIAS = 'default' 如果要修改session数据默认的序列化方式，可以将默认的JSONSerializer修改为PickleSerializer。 SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer' 在视图函数中读写cookie Django封装的HttpRequest和HttpResponse对象分别提供了读写cookie的操作。 HttpRequest封装的属性和方法： COOKIES属性 - 该属性包含了HTTP请求携带的所有cookie。 get_signed_cookie方法 - 获取带签名的cookie，如果签名验证失败，会产生BadSignature异常。 HttpResponse封装的方法： set_cookie方法 - 该方法可以设置一组键值对并将其最终将写入浏览器。 set_signed_cookie方法 - 跟上面的方法作用相似，但是会对cookie进行签名来达到防篡改的作用。因为如果篡改了cookie中的数据，在不知道密钥和盐>)的情况下是无法生成有效的签名，这样服务器在读取cookie时会发现数据与签名不一致从而产生BadSignature异常。需要说明的是，这里所说的密钥就是我们在Django项目配置文件中指定的SECRET_KEY，而盐是程序中设定的一个字符串，你愿意设定为什么都可以，只要是一个有效的字符串。 上面提到的方法，如果不清楚它们的具体用法，可以自己查阅一下Django的官方文档，没有什么资料比官方文档能够更清楚的告诉你这些方法到底如何使用。 刚才我们说过了，激活SessionMiddleware之后，每个HttpRequest对象都会绑定一个session属性，它是一个类似字典的对象，除了保存用户数据之外还提供了检测浏览器是否支持cookie的方法，包括： set_test_cookie方法 - 设置用于测试的cookie。 test_cookie_worked方法 - 检测测试cookie是否工作。 delete_test_cookie方法 - 删除用于测试的cookie。 set_expiry方法 - 设置会话的过期时间。 get_expire_age/get_expire_date方法 - 获取会话的过期时间。 clear_expired方法 - 清理过期的会话。 下面是在执行登录之前检查浏览器是否支持cookie的代码。 def login(request): if request.method == 'POST': if request.session.test_cookie_worked(): request.session.delete_test_cookie() # Add your code to perform login process here else: return HttpResponse(\"Please enable cookies and try again.\") request.session.set_test_cookie() return render_to_response('login.html') Cookie的替代品 之前我们说过了，cookie的名声一直都不怎么好，当然我们在实际开发中是不会在cookie中保存用户的敏感信息（如用户的密码、信用卡的账号等）的，而且保存在cookie中的数据一般也会做好编码和签名的工作。即便如此，HTML5中还是给出了用于替代cookie的技术方案，其中使用得最为广泛的就是localStorage和sessionStorage，相信从名字上你就能听出二者的差别，存储在localStorage的数据可以长期保留；而存储在sessionStorage的数据会在浏览器关闭时会被清除 。关于这些cookie替代品的用法，建议大家查阅MDN来进行了解。 "},"Python/第三方库/Django/09-Form和ModelForm组件.html":{"url":"Python/第三方库/Django/09-Form和ModelForm组件.html","title":"Form、ModelForm组件","keywords":"","body":"datetime:2019/6/27 10:07 author:nzb Form和ModelForm组件 Form介绍 我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。 与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息.。 Django form组件就实现了上面所述的功能。 总结一下，其实form组件的主要功能如下: 生成页面可用的HTML标签 对用户提交的数据进行校验 保留上次输入内容 普通方式手写注册功能 views.py # 注册 def register(request): error_msg = \"\" if request.method == \"POST\": username = request.POST.get(\"name\") pwd = request.POST.get(\"pwd\") # 对注册信息做校验 if len(username) login.html 注册页面 { % csrf_token % } 用户名: 密码： { { error_msg } } 使用form组件实现注册功能 views.py 先定义好一个RegForm类： from django import forms # 按照Django form组件的要求自己写一个类 class RegForm(forms.Form): name = forms.CharField(label=\"用户名\") pwd = forms.CharField(label=\"密码\") 再写一个视图函数： # 使用form组件实现注册方式 def register2(request): form_obj = RegForm() if request.method == \"POST\": # 实例化form对象的时候，把post提交过来的数据直接传进去 form_obj = RegForm(request.POST) # 调用form_obj校验数据的方法 if form_obj.is_valid(): return HttpResponse(\"注册成功\") return render(request, \"register2.html\", {\"form_obj\": form_obj}) login2.html 注册2 { % csrf_token % } { { form_obj.name.label } } { { form_obj.name } } { { form_obj.name.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } 看网页效果发现 也验证了form的功能： 前端页面是form类的对象生成的 -->生成HTML标签功能 当用户名和密码输入为空或输错之后 页面都会提示 -->用户提交校验功能 当用户输错之后 再次输入 上次的内容还保留在input框 -->保留上次输入内容 Form那些事 常用字段与插件 创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML; initial 初始值，input框里面的初始值。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\" **# 设置默认值** ) pwd = forms.CharField(min_length=6, label=\"密码\") error_messages 重写错误信息。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" }, widget=forms.widgets.TextInput(attrs={'class': 'c1'}, render_value=True) ) pwd = forms.CharField(min_length=6, label=\"密码\") password class LoginForm(forms.Form): ... pwd = forms.CharField( min_length=6, label=\"密码\", widget=forms.widgets.PasswordInput( attrs={'class': 'c1'}, # **标签属性** render_value=True) # **表单值是否返回** ) radioSelect 单radio值为字符串 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ) pwd = forms.CharField(min_length=6, label=\"密码\") gender = forms.ChoiceField( choices=((1, \"男\"), (2, \"女\"), (3, \"保密\")), label=\"性别\", initial=3, widget=forms.widgets.RadioSelect() ) 单选Select class LoginForm(forms.Form): ... hobby = forms.ChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=3, widget=forms.widgets.Select() ) 多选Select class LoginForm(forms.Form): ... hobby = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=[1, 3], widget=forms.widgets.SelectMultiple() ) 单选checkbox class LoginForm(forms.Form): ... keep = forms.ChoiceField( label=\"是否记住密码\", initial=\"checked\", widget=forms.widgets.CheckboxInput() ) 多选checkbox class LoginForm(forms.Form): ... hobby = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=[1, 3], widget=forms.widgets.CheckboxSelectMultiple() ) choice字段注意事项 在使用选择标签时，需要注意choices的选项可以配置从数据库中获取，但是由于是静态字段获取的值无法实时更新，需要重写构造方法从而实现choice实时更新。 方式一： from django.forms import Form from django.forms import widgets from django.forms import fields class MyForm(Form): user = fields.ChoiceField( # choices=((1, '上海'), (2, '北京'),), initial=2, widget=widgets.Select ) def __init__(self, *args, **kwargs): super(MyForm,self).__init__(*args, **kwargs) # self.fields['user'].choices = ((1, '上海'), (2, '北京'),) # 或 self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption') 方式二： from django import forms from django.forms import fields from django.forms import models as form_model class FInfo(forms.Form): authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all()) # 多选 # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all()) # 单选 Django Form所有内置字段 Field required=True, 是否允许为空 widget=None, HTML插件 label=None, 用于生成Label标签或显示内容 initial=None, 初始值 help_text='', 帮助信息(在标签旁边显示) error_messages=None, 错误信息 {'required': '不能为空', 'invalid': '格式错误'} validators=[], 自定义验证规则 localize=False, 是否支持本地化 disabled=False, 是否可以编辑 label_suffix=None Label内容后缀 CharField(Field) max_length=None, 最大长度 min_length=None, 最小长度 strip=True 是否移除用户输入空白 IntegerField(Field) max_value=None, 最大值 min_value=None, 最小值 FloatField(IntegerField) ... DecimalField(IntegerField) max_value=None, 最大值 min_value=None, 最小值 max_digits=None, 总长度 decimal_places=None, 小数位长度 BaseTemporalField(Field) input_formats=None 时间格式化 DateField(BaseTemporalField) 格式：2015-09-01 TimeField(BaseTemporalField) 格式：11:12 DateTimeField(BaseTemporalField)格式：2015-09-01 11:12 DurationField(Field) 时间间隔：%d %H:%M:%S.%f ... RegexField(CharField) regex, 自定制正则表达式 max_length=None, 最大长度 min_length=None, 最小长度 error_message=None, 忽略，错误信息使用 error_messages={'invalid': '...'} EmailField(CharField) ... FileField(Field) allow_empty_file=False 是否允许空文件 ImageField(FileField) ... 注：需要PIL模块，pip3 install Pillow 以上两个字典使用时，需要注意两点： - form表单中 enctype=\"multipart/form-data\" - view函数中 obj = MyForm(request.POST, request.FILES) URLField(Field) ... BooleanField(Field) ... NullBooleanField(BooleanField) ... ChoiceField(Field) ... choices=(), 选项，如：choices = ((0,'上海'),(1,'北京'),) required=True, 是否必填 widget=None, 插件，默认select插件 label=None, Label内容 initial=None, 初始值 help_text='', 帮助提示 ModelChoiceField(ChoiceField) ... django.forms.models.ModelChoiceField queryset, # 查询数据库中的数据 empty_label=\"---------\", # 默认空显示内容 to_field_name=None, # HTML中value的值对应的字段 limit_choices_to=None # ModelForm中对queryset二次筛选 ModelMultipleChoiceField(ModelChoiceField) ... django.forms.models.ModelMultipleChoiceField TypedChoiceField(ChoiceField) coerce = lambda val: val 对选中的值进行一次转换 empty_value= '' 空值的默认值 MultipleChoiceField(ChoiceField) ... TypedMultipleChoiceField(MultipleChoiceField) coerce = lambda val: val 对选中的每一个值进行一次转换 empty_value= '' 空值的默认值 ComboField(Field) fields=() 使用多个验证，如下：即验证最大长度20，又验证邮箱格式 fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),]) MultiValueField(Field) PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用 SplitDateTimeField(MultiValueField) input_date_formats=None, 格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y'] input_time_formats=None 格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M'] FilePathField(ChoiceField) 文件选项，目录下文件显示在页面中 path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 required=True, widget=None, label=None, initial=None, help_text='' GenericIPAddressField protocol='both', both,ipv4,ipv6支持的IP格式 unpack_ipv4=False 解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用 SlugField(CharField) 数字，字母，下划线，减号（连字符） ... UUIDField(CharField) uuid类型 字段校验 RegexValidator验证器 from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.validators import RegexValidator class MyForm(Form): user = fields.CharField( validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')], ) 自定义验证函数 import re from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.exceptions import ValidationError # 自定义验证规则 def mobile_validate(value): mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$') if not mobile_re.match(value): raise ValidationError('手机号码格式错误') class PublishForm(Form): title = fields.CharField(max_length=20, min_length=5, error_messages={'required': '标题不能为空', 'min_length': '标题最少为5个字符', 'max_length': '标题最多为20个字符'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': '标题5-20个字符'})) # 使用自定义验证规则 phone = fields.CharField(validators=[mobile_validate, ], error_messages={'required': '手机不能为空'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'手机号码'})) email = fields.EmailField(required=False, error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'邮箱'})) Hook方法 除了上面两种方式，我们还可以在Form类中定义钩子函数，来实现自定义的验证功能。 局部钩子 我们在Fom类中定义 clean_字段名() 方法，就能够实现对特定字段进行校验。 举个例子： class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" }, widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"}) ) ... # 定义局部钩子，用来校验username字段 def clean_username(self): value = self.cleaned_data.get(\"username\") if \"666\" in value: raise ValidationError(\"光喊666是不行的\") else: return value 全局钩子 我们在Fom类中定义 clean() 方法，就能够实现对字段进行全局校验。 class LoginForm(forms.Form): ... password = forms.CharField( min_length=6, label=\"密码\", widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True) ) re_password = forms.CharField( min_length=6, label=\"确认密码\", widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True) ) ... # 定义全局的钩子，用来校验密码和确认密码字段是否相同 def clean(self): password_value = self.cleaned_data.get('password') re_password_value = self.cleaned_data.get('re_password') if password_value == re_password_value: return self.cleaned_data else: self.add_error('re_password', '两次密码不一致') raise ValidationError('两次密码不一致') 补充进阶 应用Bootstrap样式 login { % csrf_token % } { { form_obj.username.label } } { { form_obj.username } } { { form_obj.username.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } { { form_obj.gender.label } } { % for radio in form_obj.gender % } { { radio.tag } }{ { radio.choice_label } } { % endfor % } 注册 批量添加样式 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ... def __init__(self, *args, **kwargs): super(LoginForm, self).__init__(*args, **kwargs) for field in iter(self.fields): self.fields[field].widget.attrs.update({ 'class': 'form-control' }) ModelForm 通常在Django项目中，我们编写的大部分都是与Django 的模型紧密映射的表单。 举个例子，你也许会有个Book 模型，并且你还想创建一个form表单用来添加和编辑书籍信息到这个模型中。 在这种情况下，在form表单中定义字段将是冗余的，因为我们已经在模型中定义了那些字段。 基于这个原因，Django 提供一个辅助类来让我们可以从Django 的模型创建Form，这就是ModelForm。 ModelForm定义 form与model的终极结合。 class BookForm(forms.ModelForm): class Meta: model = models.Book fields = \"__all__\" labels = { \"title\": \"书名\", \"price\": \"价格\" } widgets = { \"password\": forms.widgets.PasswordInput(attrs={\"class\": \"c1\"}), } class Meta下常用参数 model = models.Book # 对应的Model中的类 fields = \"__all__\" # 字段，如果是__all__,就是表示列出所有的字段 exclude = None # 排除的字段 labels = None # 提示信息 help_texts = None # 帮助提示信息 widgets = None # 自定义插件 error_messages = None # 自定义错误信息 ModelForm的验证 与普通的Form表单验证类型类似，ModelForm表单的验证在调用is_valid() 或访问errors 属性时隐式调用。 我们可以像使用Form类一样自定义局部钩子方法和全局钩子方法来实现自定义的校验规则。 如果我们不重写具体字段并设置validators属性的话，ModelForm是按照模型中字段的validators来校验的。 save()方法 每个ModelForm还具有一个save()方法。 这个方法根据表单绑定的数据创建并保存数据库对象。 ModelForm的子类可以接受现有的模型实例作为关键字参数instance；如果提供此功能，则save()将更新该实例。 如果没有提供，save() 将创建模型的一个新实例： >>> from myapp.models import Book >>> from myapp.forms import BookForm # 根据POST数据创建一个新的form对象 >>> form_obj = BookForm(request.POST) # 创建书籍对象 >>> new_ book = form_obj.save() # 基于一个书籍对象创建form对象 >>> edit_obj = Book.objects.get(id=1) # 使用POST提交的数据更新书籍对象 >>> form_obj = BookForm(request.POST, instance=edit_obj) >>> form_obj.save() 表单的应用(100天) 我们继续来完成上一章节中的项目，实现“用户注册”和“用户登录”的功能，并限制只有登录的用户才能为老师投票。Django框架中提供了对表单的封装，而且提供了多种不同的使用方式。 首先添加用户模型。 class User(models.Model): \"\"\"用户\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') username = models.CharField(max_length=20, unique=True, verbose_name='用户名') password = models.CharField(max_length=32, verbose_name='密码') regdate = models.DateTimeField(auto_now_add=True, verbose_name='注册时间') class Meta: db_table = 'tb_user' verbose_name_plural = '用户' 通过生成迁移和执行迁移操作，在数据库中创建对应的用户表。 (venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ... 定制一个非常简单的注册模板页面。 用户注册 /* 此处省略层叠样式表选择器 */ 用户注册 { { hint } } { % csrf_token % } 用户名： 密码： 确认密码： 返回登录 注意，在上面的表单中，我们使用了模板指令{ % csrf_token % }为表单添加一个隐藏域（type属性值为hidden的input标签），它的作用是在表单中生成一个随机令牌（token）来防范跨站请求伪造（通常简称为CSRF），这也是Django在提交表单时的硬性要求，除非我们设置了免除CSRF令牌。下图是一个关于CSRF简单生动的例子，它来自于维基百科。 用户在提交注册表单时，我们还需要对用户的输入进行验证，例如我们的网站要求用户名必须由字母、数字、下划线构成且长度在4-20个字符之间，密码的长度为8-20个字符，确认密码必须跟密码保持一致。这些验证操作首先可以通过浏览器中的JavaScript代码来完成，但是即便如此，在服务器端仍然要对用户输入再次进行验证来避免将无效的数据库交给数据库，因为用户可能会禁用浏览器的JavaScript功能，也有可能绕过浏览器的输入检查将注册数据提交给服务器，所以服务器端的用户输入检查仍然是必要的。 我们可以利用Django框架封装的表单功能来对用户输入的有效性进行检查，虽然Django封装的表单还能帮助我们定制出页面上的表单元素，但这显然是一种灵活性很差的设计，这样的功能在实际开发中基本不考虑，所以表单主要的作用就在于数据验证，具体的做法如下所示。 USERNAME_PATTERN = re.compile(r'\\w{4,20}') class RegisterForm(forms.ModelForm): repassword = forms.CharField(min_length=8, max_length=20) def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('用户名由字母、数字和下划线构成且长度为4-20个字符') return username def clean_password(self): password = self.cleaned_data['password'] if len(password) 20: raise ValidationError('无效的密码，密码长度为8-20个字符') return to_md5_hex(self.cleaned_data['password']) def clean_repassword(self): repassword = to_md5_hex(self.cleaned_data['repassword']) if repassword != self.cleaned_data['password']: raise ValidationError('密码和确认密码不一致') return repassword class Meta: model = User exclude = ('no', 'regdate') 上面，我们定义了一个与User模型绑定的表单（继承自ModelForm），我们排除了用户编号（no）和注册日期（regdate）这两个属性，并添加了一个repassword属性用来接收从用户表单传给服务器的确认密码。我们在定义User模型时已经对用户名的最大长度进行了限制，上面我们又对确认密码的最小和最大长度进行了限制，但是这些都不足以完成我们对用户输入的验证。上面以clean_打头的方法就是我们自定义的验证规则。很明显，clean_username是对用户名的检查，而clean_password是对密码的检查。由于数据库二维表中不应该保存密码的原文，所以对密码做了一个简单的MD5摘要处理，实际开发中如果只做出这样的处理还不太够，因为即便使用了摘要，仍然有利用彩虹表反向查询破解用户密码的风险，如何做得更好我们会在后续的内容中讲到。为字符串生成MD5摘要的代码如下所示。 def to_md5_hex(message): return hashlib.md5(message.encode()).hexdigest() 新增一个视图函数实现用户注册的功能。 def register(request): page, hint = 'register.html', '' if request.method == 'POST': form = RegisterForm(request.POST) if form.is_valid(): form.save() page = 'login.html' hint = '注册成功，请登录' else: hint = '请输入有效的注册信息' return render(request, page, {'hint': hint}) 如果用户发起GET请求，将直接跳转到注册的页面；如果用户以POST方式提交注册表单，则创建自定义的注册表单对象并获取用户输入。可以通过表单对象的is_valid方法对表单进行验证，如果用户输入没有问题，该方法返回True，否则返回False；由于我们定义的RegisterForm继承自ModelForm，因此也可以直接使用表单对象的save方法来保存模型。下面是注册请求的URL配置。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path('register/', views.register, name='register'), # 此处省略下面的代码 ] 说明：path函数可以通过name参数给URL绑定一个逆向解析的名字，也就是说，如果需要可以从后面给的名字逆向解析出对应的URL。 我们再来定制一个非常简单的登录页。 用户登录 /* 此处省略层叠样式表选择器 */ 用户登录 { { hint } } { % csrf_token % } 用户名： 密码： 验证码： 注册新用户 上面的登录页中，我们要求用户提供验证码，验证码全称是全自动区分计算机和人类的公开图灵测试，它是一种用来区分系统的使用者是计算机还是人类的程序。简单的说就是程序出一个只有人类能够回答的问题，由系统使用者来解答，由于计算机理论上无法解答程序提出的问题，所以回答出问题的用户就可以被认为是人类。大多数的网站都使用了不同类型的验证码技术来防范用程序自动注册用户或模拟用户登录（暴力破解用户密码），因为验证码具有一次消费性，而没有通过图灵测试的程序是不能够完成注册或登录的。 在Python程序中生成验证码并不算特别复杂，但需要三方库Pillow的支持（PIL的分支），因为要对验证码图片进行旋转、扭曲、拉伸以及加入干扰信息来防范那些用OCR（光学文字识别）破解验证码的程序。下面的代码封装了生成验证码图片的功能，大家可以直接用这些代码来生成图片验证码，不要“重复发明轮子”。 \"\"\" 图片验证码 \"\"\" import os import random from io import BytesIO from PIL import Image from PIL import ImageFilter from PIL.ImageDraw import Draw from PIL.ImageFont import truetype class Bezier(object): \"\"\"贝塞尔曲线\"\"\" def __init__(self): self.tsequence = tuple([t / 20.0 for t in range(21)]) self.beziers = {} def make_bezier(self, n): \"\"\"绘制贝塞尔曲线\"\"\" try: return self.beziers[n] except KeyError: combinations = pascal_row(n - 1) result = [] for t in self.tsequence: tpowers = (t ** i for i in range(n)) upowers = ((1 - t) ** i for i in range(n - 1, -1, -1)) coefs = [c * a * b for c, a, b in zip(combinations, tpowers, upowers)] result.append(coefs) self.beziers[n] = result return result class Captcha(object): \"\"\"验证码\"\"\" def __init__(self, width, height, fonts=None, color=None): self._image = None self._fonts = fonts if fonts else \\ [os.path.join(os.path.dirname(__file__), 'fonts', font) for font in ['ArialRB.ttf', 'ArialNI.ttf', 'Georgia.ttf', 'Kongxin.ttf']] self._color = color if color else random_color(0, 200, random.randint(220, 255)) self._width, self._height = width, height @classmethod def instance(cls, width=200, height=75): prop_name = f'_instance_{width}_{height}' if not hasattr(cls, prop_name): setattr(cls, prop_name, cls(width, height)) return getattr(cls, prop_name) def background(self): \"\"\"绘制背景\"\"\" Draw(self._image).rectangle([(0, 0), self._image.size], fill=random_color(230, 255)) def smooth(self): \"\"\"平滑图像\"\"\" return self._image.filter(ImageFilter.SMOOTH) def curve(self, width=4, number=6, color=None): \"\"\"绘制曲线\"\"\" dx, height = self._image.size dx /= number path = [(dx * i, random.randint(0, height)) for i in range(1, number)] bcoefs = Bezier().make_bezier(number - 1) points = [] for coefs in bcoefs: points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)]) for ps in zip(*path))) Draw(self._image).line(points, fill=color if color else self._color, width=width) def noise(self, number=50, level=2, color=None): \"\"\"绘制扰码\"\"\" width, height = self._image.size dx, dy = width / 10, height / 10 width, height = width - dx, height - dy draw = Draw(self._image) for i in range(number): x = int(random.uniform(dx, width)) y = int(random.uniform(dy, height)) draw.line(((x, y), (x + level, y)), fill=color if color else self._color, width=level) def text(self, captcha_text, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None): \"\"\"绘制文本\"\"\" color = color if color else self._color fonts = tuple([truetype(name, size) for name in fonts for size in font_sizes or (65, 70, 75)]) draw = Draw(self._image) char_images = [] for c in captcha_text: font = random.choice(fonts) c_width, c_height = draw.textsize(c, font=font) char_image = Image.new('RGB', (c_width, c_height), (0, 0, 0)) char_draw = Draw(char_image) char_draw.text((0, 0), c, font=font, fill=color) char_image = char_image.crop(char_image.getbbox()) for drawing in drawings: d = getattr(self, drawing) char_image = d(char_image) char_images.append(char_image) width, height = self._image.size offset = int((width - sum(int(i.size[0] * squeeze_factor) for i in char_images[:-1]) - char_images[-1].size[0]) / 2) for char_image in char_images: c_width, c_height = char_image.size mask = char_image.convert('L').point(lambda i: i * 1.97) self._image.paste(char_image, (offset, int((height - c_height) / 2)), mask) offset += int(c_width * squeeze_factor) @staticmethod def warp(image, dx_factor=0.3, dy_factor=0.3): \"\"\"图像扭曲\"\"\" width, height = image.size dx = width * dx_factor dy = height * dy_factor x1 = int(random.uniform(-dx, dx)) y1 = int(random.uniform(-dy, dy)) x2 = int(random.uniform(-dx, dx)) y2 = int(random.uniform(-dy, dy)) warp_image = Image.new( 'RGB', (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2))) warp_image.paste(image, (abs(x1), abs(y1))) width2, height2 = warp_image.size return warp_image.transform( (width, height), Image.QUAD, (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1)) @staticmethod def offset(image, dx_factor=0.1, dy_factor=0.2): \"\"\"图像偏移\"\"\" width, height = image.size dx = int(random.random() * width * dx_factor) dy = int(random.random() * height * dy_factor) offset_image = Image.new('RGB', (width + dx, height + dy)) offset_image.paste(image, (dx, dy)) return offset_image @staticmethod def rotate(image, angle=25): \"\"\"图像旋转\"\"\" return image.rotate(random.uniform(-angle, angle), Image.BILINEAR, expand=1) def generate(self, captcha_text='', fmt='PNG'): \"\"\"生成验证码(文字和图片)\"\"\" self._image = Image.new('RGB', (self._width, self._height), (255, 255, 255)) self.background() self.text(captcha_text, self._fonts, drawings=['warp', 'rotate', 'offset']) self.curve() self.noise() self.smooth() image_bytes = BytesIO() self._image.save(image_bytes, format=fmt) return image_bytes.getvalue() def pascal_row(n=0): \"\"\"生成Pascal三角第n行\"\"\" result = [1] x, numerator = 1, n for denominator in range(1, n // 2 + 1): x *= numerator x /= denominator result.append(x) numerator -= 1 if n & 1 == 0: result.extend(reversed(result[:-1])) else: result.extend(reversed(result)) return result def random_color(start=0, end=255, opacity=255): \"\"\"获得随机颜色\"\"\" red = random.randint(start, end) green = random.randint(start, end) blue = random.randint(start, end) if opacity is None: return red, green, blue return red, green, blue, opacity 说明：上面的代码在生成验证码图片时用到了三种字体文件，使用上面的代码时需要添加字体文件到应用目录下的fonts目录中。 下面的视图函数用来生成验证码并通过HttpResponse对象输出到用户浏览器中。 ALL_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' def get_captcha_text(length=4): selected_chars = random.choices(ALL_CHARS, k=length) return ''.join(selected_chars) def get_captcha(request): \"\"\"获得验证码\"\"\" captcha_text = get_captcha_text() image = Captcha.instance().generate(captcha_text) return HttpResponse(image, content_type='image/png') 生成的验证码如下图所示。 为了验证用户提交的登录表单，我们再定义个表单类。 class LoginForm(forms.Form): username = forms.CharField(min_length=4, max_length=20) password = forms.CharField(min_length=8, max_length=20) captcha = forms.CharField(min_length=4, max_length=4) def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('无效的用户名') return username def clean_password(self): return to_md5_hex(self.cleaned_data['password']) 跟之前我们定义的注册表单类略有区别，登录表单类直接继承自Form没有跟模型绑定，定义了三个字段分别对应登录表单中的用户名、密码和验证码。接下来是处理用户登录的视图函数。 def login(request): hint = '' if request.method == 'POST': form = LoginForm(request.POST) if form.is_valid(): username = form.cleaned_data['username'] password = form.cleaned_data['password'] user = User.objects.filter(username=username, password=password).first() if user: return redirect('/') else: hint = '用户名或密码错误' else: hint = '请输入有效的登录信息' return render(request, 'login.html', {'hint': hint}) 映射URL。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path('login/', views.login, name='login'), # 此处省略下面的代码 ] 需要指出，上面我们设定用户登录成功时直接返回首页，而且在用户登录时并没有验证用户输入的验证码是否正确，这些我们留到下一个单元再为大家讲解。另外，如果要在Django自带的管理后台中进行表单验证，可以在admin.py的模型管理类中指定form属性为自定义的表单即可，例如： class UserForm(forms.ModelForm): password = forms.CharField(min_length=8, max_length=20, widget=forms.PasswordInput, label='密码') def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('用户名由字母、数字和下划线构成且长度为4-20个字符') return username def clean_password(self): password = self.cleaned_data['password'] return to_md5_hex(self.cleaned_data['password']) class Meta: model = User exclude = ('no', ) class UserAdmin(admin.ModelAdmin): list_display = ('no', 'username', 'password', 'email', 'tel') ordering = ('no', ) form = UserForm list_per_page = 10 admin.site.register(User, UserAdmin) "},"Python/第三方库/Django/10-中间件.html":{"url":"Python/第三方库/Django/10-中间件.html","title":"中间件","keywords":"","body":"datetime:2019/6/28 14:13 author:nzb Django中间件 前戏 我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。 我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。 学完今天的内容之后呢，我们就可以用更适宜的方式来实现类似给所有请求都做相同操作的功能了 中间件 中间件介绍 什么是中间件? 官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。 每个中间件组件都负责做一些特定的功能。 但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。 说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法， Django框架会在请求的特定的时间去执行这些方法。 我们一直都在使用中间件，只是没有注意到而已，打开Django项目的Settings.py文件，看到下图的MIDDLEWARE配置项。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。 我们之前已经接触过一个csrf相关的中间件了？我们一开始让大家把他注释掉，再提交post请求的时候，就不会被forbidden了， 后来学会使用csrf_token之后就不再注释这个中间件了。 那接下来就学习中间件中的方法以及这些方法什么时候被执行。 自定义中间件 中间件可以定义五个方法，分别是：（主要的是process_request和process_response） process_request(self,request) process_view(self, request, view_func, view_args, view_kwargs) process_template_response(self,request,response) process_exception(self, request, exception) process_response(self, request, response) 以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象， 则直接将该对象返回给用户。 自定义一个中间件 from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response process_request process_request有一个参数，就是request，这个request和视图函数中的request是一样的。 它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象， Django将不执行视图函数，而将相应对象返回给浏览器。 我们来看看多个中间件时，Django是如何执行其中的process_request方法的。 from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass 在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件： MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'middlewares.MD1', # 自定义中间件MD1 'middlewares.MD2' # 自定义中间件MD2 ] 此时，我们访问一个视图，会发现终端中打印如下内容： MD1里面的 process_request MD2里面的 process_request app01 中的 index视图 把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下： MD2里面的 process_request MD1里面的 process_request app01 中的 index视图 看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。 在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。 由此总结一下： 1、中间件的process_request方法是在执行视图函数之前执行的。 2、当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。 3、不同中间件之间传递的request都是同一个对象 多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行， 而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。 process_response 它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。 该方法的返回值也必须是HttpResponse对象。 给上述的M1和M2加上process_response方法： from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response 访问一个视图，看一下终端的输出： MD2里面的 process_request MD1里面的 process_request app01 中的 index视图 MD1里面的 process_response MD2里面的 process_response 看结果可知： process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册) 多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行， 而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。 process_view process_view(self, request, view_func, view_args, view_kwargs) 该方法有四个参数 request是HttpRequest对象。 view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。） view_args是将传递给视图的位置参数的列表. view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。 Django会在调用视图函数之前调用process_view方法。 它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。 给MD1和MD2添加process_view方法: from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) 访问index视图函数，看一下输出结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 MD1里面的 process_response MD2里面的 process_response process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序从前到后顺序执行的 process_exception process_exception(self, request, exception) 该方法两个参数: 一个HttpRequest对象 一个exception是视图函数异常产生的Exception对象。 这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。 给MD1和MD2添加上这个方法： from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD2 中的process_exception\") 如果视图函数中无异常，process_exception方法不执行。 想办法，在视图函数中抛出一个异常： def index(request): print(\"app01 中的 index视图\") raise ValueError(\"呵呵\") return HttpResponse(\"O98K\") 在MD1的process_exception中返回一个响应对象： class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") return HttpResponse(str(exception)) # 返回一个响应对象 看输出结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 呵呵 MD1 中的process_exception MD1里面的 process_response MD2里面的 process_response 注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。 proc process_template_response(用的比较少) process_template_response(self, request, response) 它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。 process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法 （或者表明该对象是一个TemplateResponse对象或等价方法）。 class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") return HttpResponse(str(exception)) def process_template_response(self, request, response): print(\"MD1 中的process_template_response\") return response class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD2 中的process_exception\") def process_template_response(self, request, response): print(\"MD2 中的process_template_response\") return response views.py中： def index(request): print(\"app01 中的 index视图\") def render(): print(\"in index/render\") return HttpResponse(\"O98K\") rep = HttpResponse(\"OK\") rep.render = render return rep 访问index视图，终端输出的结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 MD1 中的process_template_response MD2 中的process_template_response in index/render MD1里面的 process_response MD2里面的 process_response 从结果看出： 视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的， 接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。 中间件的执行流程 上一部分，我们了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。 请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行， 如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法， 将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象， 那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。 process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法， process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。 加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件， 也就是中间件6的process_response方法开始倒序执行。 process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下： 中间件版登陆验证 中间件版的登录验证需要依靠session，所以数据库中要有django_session表。 urls.py from django.conf.urls import url from app01 import views urlpatterns = [ url(r'^index/$', views.index), url(r'^login/$', views.login, name='login'), ] views.py from django.shortcuts import render, HttpResponse, redirect def index(request): return HttpResponse('this is index') def home(request): return HttpResponse('this is home') def login(request): if request.method == \"POST\": user = request.POST.get(\"user\") pwd = request.POST.get(\"pwd\") if user == \"Q1mi\" and pwd == \"123456\": # 设置session request.session[\"user\"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get(\"next\") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect(\"/index/\") return render(request, \"login.html\") login.html 登录页面 用户名： 密 码： middlewares.py class AuthMD(MiddlewareMixin): white_list = ['/login/', ] # 白名单 balck_list = ['/black/', ] # 黑名单 def process_request(self, request): from django.shortcuts import redirect, HttpResponse next_url = request.path_info print(request.path_info, request.get_full_path()) if next_url in self.white_list or request.session.get(\"user\"): return elif next_url in self.balck_list: return HttpResponse('This is an illegal URL') else: return redirect(\"/login/?next={}\".format(next_url)) 在settings.py中注册 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'middlewares.AuthMD', ] AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。 访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程； 如果URL在黑名单中，则返回This is an illegal URL的字符串； 正常的URL但是需要登录后访问，让浏览器跳转到登录页面。 注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。 附：Django请求流程图 中间件的应用(100天) 实现登录验证 我们继续来完善投票应用。在上一个章节中，我们在用户登录成功后通过session保留了用户信息，接下来我们可以应用做一些调整，要求在为老师投票时必须要先登录，登录过的用户可以投票，否则就将用户引导到登录页面，为此我们可以这样修改视图函数。 def praise_or_criticize(request: HttpRequest): \"\"\"投票\"\"\" if 'username' in request.session: try: tno = int(request.GET.get('tno', '0')) teacher = Teacher.objects.get(no=tno) if request.path.startswith('/praise'): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {'code': 200, 'message': '操作成功'} except (ValueError, Teacher.DoesNotExist): data = {'code': 404, 'message': '操作失败'} else: data = {'code': 401, 'message': '请先登录'} return JsonResponse(data) 前端页面在收到{'code': 401, 'message': '请先登录'}后，可以将用户引导到登录页面，修改后的teacher.html页面的JavaScript代码部门如下所示。 $(() => { $('.comment > a').on('click', (evt) => { evt.preventDefault() let a = $(evt.target) $.getJSON(a.attr('href'), (json) => { if (json.code == 200) { let span = a.next() span.text(parseInt(span.text()) + 1) } else if (json.code == 401) { location.href = '/login/?backurl=' + location.href } else { alert(json.message) } }) }) }) 注意：为了在登录成功之后能够回到刚才投票的页面，我们在跳转登录时设置了一个backurl参数，把当前浏览器中的URL作为返回的页面地址。 这样我们已经实现了用户必须登录才能投票的限制，但是一个新的问题来了。如果我们的应用中有很多功能都需要用户先登录才能执行，例如将前面导出Excel报表和查看统计图表的功能都加以登录限制，那么我们是不是需要在每个视图函数中添加代码来检查session中是否包含了登录用户的信息呢？答案是否定的，如果这样做了，我们的视图函数中必然会充斥着大量的重复代码。编程大师Martin Fowler曾经说过：代码有很多种坏味道，重复是最坏的一种。在Django项目中，我们可以把验证用户是否登录这样的重复性代码放到中间件中。 Django中间件概述 中间件是安插在Web应用请求和响应过程之间的组件，它在整个Web应用中扮演了拦截过滤器的角色，通过中间件可以拦截请求和响应，并对请求和响应进行过滤（简单的说就是执行额外的处理）。通常，一个中间件组件只专注于完成一件特定的事，例如：Django框架通过SessionMiddleware中间件实现了对session的支持，又通过AuthenticationMiddleware中间件实现了基于session的请求认证。通过把多个中间件组合在一起，我们可以完成更为复杂的任务，Django框架就是这么做的。 Django项目的配置文件中就包含了对中间件的配置，代码如下所示。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 我们稍微为大家解释一下这些中间件的作用： CommonMiddleware - 基础设置中间件，可以处理以下一些配置参数。 DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器） APPEND_SLASH - 是否追加/ USE_ETAG - 浏览器缓存相关 SecurityMiddleware - 安全相关中间件，可以处理和安全相关的配置项。 SECURE_HSTS_SECONDS - 强制使用HTTPS的时间 SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆盖子域名 SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型 SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器 SECURE_SSL_REDIRECT - 是否重定向到HTTPS连接 SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS SessionMiddleware - 会话中间件。 CsrfViewMiddleware - 通过生成令牌，防范跨请求份伪的造中间件。 XFrameOptionsMiddleware - 通过设置请求头参数，防范点击劫持攻击的中间件。 在请求的过程中，上面的中间件会按照书写的顺序从上到下执行，然后是URL解析，最后请求才会来到视图函数；在响应的过程中，上面的中间件会按照书写的顺序从下到上执行，与请求时中间件执行的顺序正好相反。 自定义中间件 Django中的中间件有两种实现方式：基于类的实现方式和基于函数的实现方式，后者更接近于装饰器的写法。装饰器实际上是代理模式的应用，将横切关注功能（与正常业务逻辑没有必然联系的功能，例如：身份认证、日志记录、编码转换之类的功能）置于代理中，由代理对象来完成被代理对象的行为并添加额外的功能。中间件对用户请求和响应进行拦截过滤并增加额外的处理，在这一点上它跟装饰器是完全一致的，所以基于函数的写法来实现中间件就跟装饰器的写法几乎一模一样。下面我们用自定义的中间件来实现用户登录验证的功能。 \"\"\" middlewares.py \"\"\" from django.http import JsonResponse from django.shortcuts import redirect # 需要登录才能访问的资源路径 LOGIN_REQUIRED_URLS = { '/praise/', '/criticize/', '/excel/', '/teachers_data/', } def check_login_middleware(get_resp): def wrapper(request, *args, **kwargs): # 请求的资源路径在上面的集合中 if request.path in LOGIN_REQUIRED_URLS: # 会话中包含userid则视为已经登录 if 'userid' not in request.session: # 判断是不是Ajax请求 if request.is_ajax(): # Ajax请求返回JSON数据提示用户登录 return JsonResponse({'code': 10003, 'hint': '请先登录'}) else: backurl = request.get_full_path() # 非Ajax请求直接重定向到登录页 return redirect(f'/login/?backurl={backurl}') return get_resp(request, *args, **kwargs) return wrapper 修改配置文件，激活中间件使其生效。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'debug_toolbar.middleware.DebugToolbarMiddleware', 'vote.middlewares.check_login_middleware', ] 注意上面这个中间件列表中元素的顺序，当收到来自用户的请求时，中间件按照从上到下的顺序依次执行，这行完这些中间件以后，请求才会最终到达视图函数。当然，在这个过程中，用户的请求可以被拦截，就像上面我们自定义的中间件那样，如果用户在没有登录的情况下访问了受保护的资源，中间件会将请求直接重定向到登录页，后面的中间件和视图函数将不再执行。在响应用户请求的过程中，上面的中间件会按照从下到上的顺序依次执行，这样的话我们还可以对响应做进一步的处理。 中间件执行的顺序是非常重要的，对于有依赖关系的中间件必须保证被依赖的中间件要置于依赖它的中间件的前面，就好比我们刚才自定义的中间件要放到SessionMiddleware的后面，因为我们要依赖这个中间件为请求绑定的session对象才能判定用户是否登录。 小结 至此，除了对用户投票数量加以限制的功能外，这个投票应用就算基本完成了，整个项目的完整代码请参考https://github.com/jackfrued/django1902，其中用户注册时使用的手机验证码功能请大家使用自己注册的短信平台替代它。如果需要投票应用完整的视频讲解，可以在首页扫码打赏后留言联系作者获取视频下载地址，谢谢大家的理解和支持。 "},"Python/第三方库/Django/Django-REST-framework.html":{"url":"Python/第三方库/Django/Django-REST-framework.html","title":"Django-REST-framework","keywords":"","body":"Django生命周期 a、wsgi wsgi：协议：web server getway interface web服务网关接口 wsgiref:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(django) werkzeug:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架) tornado:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架) uwsgi:是实现了wsgi协议的一个模块，模块本质：一个socket服务器 Django生命周期:(rest_framework) CBV,基于反射实现根据请求方式不同，执行不同的方法。 原理： 1、路由 url -> as_view()里的view方法 -> dispath方法（反射执行其他：GET/POST/DELETE/PUT） 2、流程 class StudentView(View): def dispath(self, request, *args, **kwargs): print('before') # 自己添加需求 ret = super(Student, self).dispath(request, *args, **kwargs) print('after') def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') Django的rest_framework： 中间件 1、最多几个方法： process_request； process_view； process_response； process_exception； process_render_template； 执行流程： 首先进来执行所有的process_request然后路由匹配（找到函数不执行跳回去），然后再执行所有的process_view，然后再执行 视图函数，然后再执行process_response，如果报错执行process_exception，如果返回render则执行process_render_template。 2、用中间件做过什么： --利用它实现csrf_token，利用process_view中处理或装饰器 2.1、为什么用process_view而不用process_request? 因为用process_request的话如果用的是装饰器这需要到达路由匹配到函数才能知道是否加了装饰器， 而process_view已经路由匹配到函数，知道函数是否加了装饰器 --基于角色的权限控制 --用户认证 --csrf(说原理） --session(说原理） --黑名单 --日志记录 3、csrf --检查视图函数是否被 @csrf_exempt(免除csrf认证) --去请求体或cookie中获取token FBV: 情况一：FBV中，全局配置 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] from django.views.decorators.csrf import csrf_exempt @csrf_exempt # 该函数无需认证 def users(request): return HttpResponse('...') 情况二：全局注释，FBV中某些函数需要 from django.views.decorators.csrf import csrf_protect @csrf_protect # 该函数需认证 def users(request): return HttpResponse('...') CBV: # 单独在get，post。。。等中无效 方式一： from django.views.decorators.csrf import csrf_exempt,csrf_protect from django.utils.decorates import method_decorator class StudentView(View): @method_decorator(csrf_exempt) def dispath(self, request, *args, **kwargs): ret = super(Student, self).dispath(request, *args, **kwargs) def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') 方式二： from django.views.decorators.csrf import csrf_exempt,csrf_protect from django.utils.decorates import method_decorator @method_decorator(csrf_exempt, name='dispath') class StudentView(View): def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') 4、CBV 5、restful 3.1、10条规范 3.2、自己的认识 6、djangorestframework 5.1、如何验证（基于数据库实现用户认证） 5.2、源码流程（面向对象回顾流程） Django-Rest-framework组件 一、认证 1、使用 1.1、创建类：继承BaseAuthentication：实现：authenticate这个方法 1.2、返回值： 1.2.1、None，下一个认证类执行，全部都返回None，则返回匿名用户。 1.2.3、抛出异常，raise exceptions.AuthenticationFailed('用户认证失败') 1.2.3、返回元组，（元素1，元素2） 分别赋值给request.user，request.auth 1.3、局部使用： 需要认证的View:加上authentication_classes = [Authentication,] 1.4、全局使用：（使用路径） REST_FRAMEWORK = { # 全局使用的认证类 \"authentication_classes\": ['app01.utils.auth.Authentication',], # 匿名用户设置 # \"UNAUTHENTICATED_USER\": lambda :\"匿名用户\" \"UNAUTHENTICATED_USER\": None, # 推荐使用，匿名，因为request.user = None \"UNAUTHENTICATED_TOKEN\": None, # 匿名，因为request.auth = None } 2、源码流程 dispath -> 封装request -> 获取定义的认证类（全局/局部）,通过列表生成器创建对象 -> initial -> perform_authentication -> request.user -> Request里的user方法 -> _authenticate -> 最后执行自定义的认证类里的authenticate方法 3、示例 # 认证 # 访问进来第一步执行as_view()里面的view()里面的dispath,当前类没有找父类 class MyAuthentication(object): \"\"\" 认证源码流程 1.访问进来第一步执行dispath,当前类没有找父类 2.封装Request： initialize_request(request, *args, **kwargs) 3. initial(request, *args, **kwargs) # 这当中我们设置的raise异常都会在当前函数的下面捕获 4. perform_authentication(request) 5. request.user ————>去封装request的类里面找user()方法 6.user方法里面: _authenticate() 7._authenticate()里面循环认证类的所有对象 调用每个对象的authenticate()方法就是我们自己定义的 MyAuthentication里面的 authenticate() 8.最后反射到我们定义的View的get,post等等方法执行里面逻辑。 \"\"\" def authenticate(self, request): token = request._request.GET.get('token') # 获取用户名和密码，去数据库校验 if not token: raise exceptions.AuthenticationFailed('用户认证失败') # 返回元组（校验后的数据） return (\"nzb\", None) def authenticate_header(self, val): \"\"\" 认证失败给浏览器返回的响应头 :param val: :return: \"\"\" pass 二、权限 问题：不同的视图不同的权限 1、使用 class MyPermission(object): def has_permission(self, request, view): print(request.user) if request.user.user_type != 1: return False return True class OrderView(APIView): permission_classes = [MyPermission,] def get(self, request, *args, **kwargs): ret = {'code': 10000,'msg': None, 'data':None} try: ret['data'] = {'msg':'test'} except Exception as e: pass return JsonResponse(ret) 2、权限梳理 3.1、基本使用 3.1.1、类，必须继承rest-framework提供的类：BasePermission，必须实现：has_permission方法 from rest_framework.permissions import BasePermission class SvipPermission(BasePermission): # 定义错误信息 message = \"必须是SVIP才能访问\" def has_permission(self, request, view): # print(request.user) if request.user.user_type != 3: return False return True 3.1.2、返回值，True,有权访问，False,无权访问 3.1.3、局部使用： 需要认证的View:加上permission_classes = [SvipPermission,] 3.1.4、全局使用：（使用路径） REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\":['app01.utils.permission.SvipPermission',], } 3、源码流程 跟认证相似，执行完认证执行权限，类里面的has_permission方法。 三、频率控制(节流) 1、使用 -类，继承：BaseThrottle，实现：allow_request、wait方法 -类，继承：SimpleRateThrottle，实现：get_cache_key、scope = \"Lufei\" (配置文件中的key) 1.1、局部使用 class AuthView(APIView): \"\"\"用户认证\"\"\" # 因为全局配置了，但当前View认证，所以设置为空 authentication_classes = [] permission_classes = [] throttle_classes = [VisitThorttle, ] def post(self, request, *args, **kwargs): 1.2、全局使用 REST_FRAMEWORK = { # 访问频率控制 'DEFAULT_THROTTLE_CLASSES': ['app01.utils.throttle.UserThorttle', ], 'DEFAULT_THROTTLE_RATES': { 'Lufei': '3/m', # 匿名用户配置 一分钟三次 'LufeiUser': '3/m', # 用户配置 一分钟三次 } } import time VISIT_RECORD = {} # 放入缓存里 class VisitThorttle(object): def __init__(self): self.history = None def allow_request(self, request, view): \"\"\"60s内只能访问3次\"\"\" # 1、获取用户ip remote_addr = request._request.META.get('REMOTE_ADDR') ctime = time.time() if remote_addr not in VISIT_RECORD: VISIT_RECORD[remote_addr] = [ctime, ] return True self.history = VISIT_RECORD.get(remote_addr) # 把超出时间外的时间数据pop掉 while self.history and self.history[-1] 四、版本(全局配置就行) 1、URL中通过GET传参数 class ParamVersion(object): def determine_version(self, request, *args, **kwargs): version = request.query_params.get('version') return version class OrderView(APIView): versioning_class = ParamVersion ... 2、在URL中传参（推荐使用,正则表达式） # 版本配置类 \"DEFAULT_VERSIONING_CLASS\": 'rest_framework.versioning.URLPathVersioning', \"DEFAULT_VERSION\": 'v1', # 默认版本 \"ALLOWED_VERSIONS\": ['v1', 'v2'], # 允许版本 \"VERSION_PARAM\": 'version', # 版本参数 例：re_path('(?P[v1|v2]+)/', include(router.urls)) # 获取版本 # print(request.version) # 获取处理版本的对象 # print(request.versioning_scheme) # request.versioning_scheme # 反向生成url # print(request.versioning_scheme.reverse(viewname='order', request=request)) 五、解析器(全局配置就行) 1、前戏：django:request.POST/ request.body request.POST要有值需要满足以下2个要求： 1.1、请求头要求： Content-Type:application/x-www-form-urlencoded PS：如果请求头中的Content-Type:application/x-www-form-urlencoded，request.POST中才有值（去request.body中解析数据） 1.2、数据格式要求： name=alex&age=18&gender=男 如： a.form表单提交：默认带的是Content-Type:application/x-www-form-urlencoded b.ajax提交： $.ajax({ url:... type:POST data:{'name':'alex','age':18} # 内部转化成name=alex&age=18&gender=男，携带Content-Type:application/x-www-form-urlencoded提交 ... }) 情况一： $.ajax({ url:... type:POST headres:{'Content-Type':'application/json'} data:{'name':'alex','age':18} # 内部转化成name=alex&age=18&gender=男 ... # body有值，POST没有 }) 情况二： $.ajax({ url:... type:POST headres:{'Content-Type':'application/json'} data:JSON.stringfy({'name':'alex','age':18}) # {'name':'alex','age':18} ... # body有值，POST没有，但是可以用json.loads(request.body)得到 }) 2、rest-framework解析器，对请求体进行解析 2.1、全局配置 2.2、使用 class ParserView(APIView): \"\"\" JSONParser:表示只能解析content-type:application/json头,(最常用) FormParser:表示只能解析content-type:application/x-www-form-urlencoded头 \"\"\" def post(self, request, *args, **kwargs): \"\"\" 允许用户发送JSON格式数据 a.content-type:application/json b.{'name':'alex','age':18} :param request: :param args: :param kwargs: :return: \"\"\" # 获取解析后的结果，用了request.data才去解析 \"\"\" 1.获取用户请求 2.获取用户请求体 3.根据用户请求体和parser_classes = [JSONParser,]中支持的请求头进行比较 4.JSONParser对象处理请求体 5.request.data来触发的 \"\"\" print(request.data) return HttpResponse('ParserView') 2.3、想实现上传功能的话，局部视图配置 parser_classes = [FileUploadParser] 然后取文件： request.FILES 3、源码流程&本质： 3.1、本质 请求体 状态码 请求方法 3.2、源码流程 --dispath:request封装 --request.data 六、序列化 1、序列化： 1.1、写类，继承于Serializer(自定义生成字段)、ModelSerializer(自动生成字段，也是继承于Serializer) 1.2、字段： 1.2.1、name=serializers.CharField(source=\"xxx.xx.xx\") 1.2.2、roles = serializers.SerializerMethodField() # 自定义显示 class UserInfoSerializer(serializers.ModelSerializer): roles = serializers.SerializerMethodField() # 字段自定义显示 class Meta: model = UserInfo # fields = \"__all__\" fields = ['id', 'username', 'password', 'xxx', 'roles', 'group'] def get_roles(self, row): role_obj_list = row.roles.all() ret = [] for item in role_obj_list: ret.append({'id':item.id, 'name':item.name}) return ret 1.2.3、自定义字段类不常用 1.3、自动化序列化连表 class UserInfoSerializer(serializers.ModelSerializer): class Meta: model = UserInfo fields = \"__all__\" # fields = ['id', 'username', 'password', 'xxx', 'roles', 'group'] depth = 1 # 官方建议0~10，尽量不要超过3层 1.4、生成链接 class UserInfoSerializer(serializers.ModelSerializer): group = serializers.HyperlinkedIdentityField(view_name='group', lookup_field='group_id', lookup_url_kwarg='pk') class Meta: model = UserInfo fields = \"__all__\" fields = ['id', 'username', 'password', 'roles', 'group'] depth = 0 # 官方建议0~10，尽量不要超过3层 class UserInfoView(APIView): \"\"\"用户中心（普通用户，vip）\"\"\" # authentication_classes = [Authentication, ] # 当前permission_classes存在就不会去取配置文件里的设置 permission_classes = [VipPermission, ] def get(self, request, *args, **kwargs): users = UserInfo.objects.all() ser = UserInfoSerializer(instance=users, many=True, context={'request': request}) # print(ser.data) ret = json.dumps(ser.data, ensure_ascii=False) return HttpResponse(ret) 1.5、源码流程 单个结果，对象使用Serializer类处理 多个结果，QuerySet，ListSerializer类处理 # ser.data是入口 2、请求数据校验 class XXXValidator(object): def __init__(self, base): self.base = base def __call__(self, value): if not value.startswith(self.base): message = '名称必须以 %s 开头' % self.base raise serializers.ValidationError(message) class UserGroupSerializer(serializers.Serializer): name = serializers.CharField(error_messages={'required': '姓名不能为空'}, validators=[XXXValidator('nzb'),]) class UserGroupView(APIView): authentication_classes = [] permission_classes = [] def post(self, request, *args, **kwargs): # print(request.data) ser = UserGroupSerializer(data=request.data) if ser.is_valid(): # 取数据 print(ser.validated_data) # 单独取某些 print(ser.validated_data['name']) else: print(ser.errors) return HttpResponse('提交数据') 七、分页 数据量大时，怎么规避，1、只显示200页，2、只有上一页和下一页 1、分页，看第几页，每页显示n条数据； 2、分页，在n个位置，向后查看n条数据； 3、加密分页，只能看上一页和下一页。(记住id的最大值和最小值) 第一种分页 class MyPagination(PageNumberPagination): # 自定义分页类 page_size = 2 page_query_param = 'page' page_size_query_param = 'size' max_page_size = 5 第二种分页 class MyPagination(LimitOffsetPagination): # 自定义分页类 page_size = 2 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 5 第三种分页 class MyPagination(CursorPagination): # 自定义分页类 page_size = 2 cursor_query_param = 'cursor' max_limit = 5 ordering = 'id' page_size_query_param = None max_page_size = None class Pager1View(APIView): authentication_classes = [] permission_classes = [] def get(self, request, *args, **kwargs): # 获取所以数据 roles = Role.objects.all() # ret = json.dumps(ser.data, ensure_ascii=False) # return HttpResponse(ret) # rest_framework 渲染 # 创建分页对象 pg = MyPagination() # 在数据中获取分页的数据 pager_roles = pg.paginate_queryset(queryset=roles, request=request, view=self) # 对数据进行序列化 ser = PagerSerializer(instance=pager_roles, many=True) # return Response(ser.data) # 生成上一页下一页链接(加密分页很有用) return pg.get_paginated_response(ser.data) 总结： 1、数据量大，如何做分页？ 1.1、数据库性能相关转到rest_framework是怎么处理 1.2、 八、视图 1、过去 class XxxView(View)： pass 2、现在 class XxxView(APIView): APIView继承于VIew pass 3、没什么用的类：GenericAPIView（不使用） from app01.utils.serializers.pager import PagerSerializer from rest_framework.generics import GenericAPIView class View1View(GenericAPIView): # 继承GenericAPIView需要queryset相当于上面的roles queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] def get(self, request, *args, **kwargs): # 获取数据 roles = self.get_queryset() # Role.objects.all() # 分页 [1,100] pager_roles = self.paginate_queryset(roles) # 序列化 ser = self.get_serializer(instance=pager_roles, many=True) return Response(ser.data) 4、GenericViewSet(ViewSetMixin, generics.GenericAPIView): 路由： re_path('(?P[v1|v2]+)/v1/', views.View1View.as_view({'get': 'list'}), name='view1'), 视图： from app01.utils.serializers.pager import PagerSerializer from rest_framework.viewsets import GenericViewSet class View1View(GenericViewSet): queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] def list(self, request, *args, **kwargs): # 获取数据 roles = self.get_queryset() # Role.objects.all() # 分页 [1,100] pager_roles = self.paginate_queryset(roles) # 序列化 ser = self.get_serializer(instance=pager_roles, many=True) return Response(ser.data) 5、ModelViewSet(最强大) 路由： re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put': 'update','patch': 'partial_update'}), name='view1'), 视图： from app01.utils.serializers.pager import PagerSerializer from rest_framework.viewsets import GenericViewSet, ModelViewSet from rest_framework.mixins import ListModelMixin, CreateModelMixin # class View1View(ListModelMixin,GenericViewSet,CreateModelMixin): class View1View(ModelViewSet): queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] PS:class View1View(CreateModelMixin): 6、总结： 6.1、增删改查：ModelViewSet 6.2、增删：CreateModelMixin，DestroyModelMixin，GenericViewSet 6.4、复杂逻辑：GenericViewSet 或 APIView PS：权限： GenericAPIView.get_object check_object_permissions has_object_permission 九、路由 1、 re_path('(?P[v1|v2]+)/auth/', views.AuthView.as_view(), name='auth'), 2、 re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), 3、 # http://127.0.0.1:8000/api01/v1/v1/ re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), # http://127.0.0.1:8000/api01/v1/v1.json re_path('(?P[v1|v2]+)/v1\\.(?P\\w+)$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)$', views.View1View.as_view({'get': 'retrieve', 'delete':'destroy', 'put': 'update', 'patch': 'partial_update'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)\\.(?P\\w+)', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put': 'update','patch': 'partial_update'}), name='view1'), 4、自动生成路由 from app01 import views from rest_framework import routers # rest_framework路由 router = routers.DefaultRouter() router.register(r'xxx', views.View1View) router.register(r'rt', views.View1View) urlpatterns = [ # rest_framework路由 re_path('(?P[v1|v2]+)/', include(router.urls)) ] 十、渲染器 from rest_framework.renderers import JSONRenderer, BrowsableAPIRenderer, AdminRenderer, HTMLFormRenderer # class View1View(ListModelMixin,GenericViewSet,CreateModelMixin): class View1View(ModelViewSet): # 渲染器,使用JSONRenderer就行，BrowsableAPIRenderer只是界面好看 # renderer_classes = [JSONRenderer, BrowsableAPIRenderer] authentication_classes = [] permission_classes = [] queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination 全局配置： 'DEFAULT_RENDERER_CLASSES':['rest_framework.renderers.JSONRenderer','rest_framework.renderers.BrowsableAPIRenderer'] 十一、django组件content_type Django内置的一个组件，帮助开发者做连表操作。【混搭】 models里定义的时候，实现一表对多表操作 例： # 利用content-type实现一表对应多表 # models.py from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation from django.db import models from django.contrib.contenttypes.models import ContentType class Course(models.Model): \"\"\" 普通课程 \"\"\" name = models.CharField(max_length=32) # 仅用于反向查找 price_policy_list = GenericRelation('PricePolicy') class DegreeCourse(models.Model): \"\"\" 学位课程 \"\"\" name = models.CharField(max_length=32) # 仅用于反向查找 price_policy_list = GenericRelation('PricePolicy') class PricePolicy(models.Model): \"\"\"价格策略\"\"\" price = models.IntegerField() period = models.IntegerField() # 自定义 # table_name = models.CharField(verbose_name=u'关联的表名称') # object_id = models.CharField(verbose_name=u'关联表中的数据id') # 使用Django的组件content-type content_type = models.ForeignKey(ContentType, verbose_name=u'关联普通课或学位课表', on_delete=models.CASCADE) # 11、12就是上面两个表 object_id = models.IntegerField(verbose_name=u'关联表中的数据id') # 帮助你快速实现content-type操作 content_object = GenericForeignKey('content_type', 'object_id') # 视图view里面的逻辑, views.py: # 插入一条价格策略,为学位课“Python”添加一个价格策略：一个月9.9 # 1、加一个字段后，使用content-type # obj = DegreeCourse.objects.filter(name='Python').first() # PricePolicy.objects.create(price=9.9, period=30, content_object=obj) # 2、根据课程ID找到课程，并获取所有的价格策略 # course = DegreeCourse.objects.filter(id=1).first() # price_policy = course.price_policy_list.all() 十二、小知识点 1、前后端分离如何解决跨域 --jsonp --cors -响应头放在中间件 2、__init__和__new__的区别： __new__：是返回对象 __init__：是__new__返回的对象的构造方法 例： class Foo(object): def __init__(self, a1): print(a1) self.a = a1 def __new__(cls, *args, **kwargs): \"\"\" 1.根据类创建对象，并返回 2.执行返回值的__init__ \"\"\" # 如果返回的是nzb字符串，则执行字符串的构造方法__init__,上面__init__里面的输出a1为nzb(因为字符串没有构造方法) return 'nzb' # 默认,实例化当前类的对象返回, 然后去执行构造方法 return object.__new__(cls) obj = Foo(123) print(obj) "},"Python/第三方库/Django/Django开发经验/02-Django-restframework登录相关.html":{"url":"Python/第三方库/Django/Django开发经验/02-Django-restframework登录相关.html","title":"登录相关","keywords":"","body":"datetime:2020/5/13 10:33 author:nzb 登录相关（基于jwt token登录；单个用户表或多个用户表） urls.py path(\"login/\", CustomLoginJSONWebToken.as_view()), settings.py # 验证中间件 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', # 'corsheaders.middleware.CorsPostCsrfMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'middlewares.ValidTokenMiddleware', # 换台设备需重新登录 ] # drf框架的配置信息 REST_FRAMEWORK = { # 默认分页 'DEFAULT_PAGINATION_CLASS': 'utils.PagePagination', 'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S', # 自定义token内含值 'JWT_PAYLOAD_HANDLER': 'utils.custom_payload_handler', # 异常处理 'EXCEPTION_HANDLER': 'utils.exception_handler.exception_handler', # 见01-重写异常处理手柄 # 用户登陆认证方式 'DEFAULT_AUTHENTICATION_CLASSES': ( #单个用户表配置 # 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', # 'rest_framework.authentication.SessionAuthentication', # 'rest_framework.authentication.BasicAuthentication', # 多个用户表配置 'authentication.CustomAuthenticate', # 自定义 JSON Token Authentication ), # 获取用户的secret_key # 没用，需要也是放到下面的 JWT_AUTH 中，不设置是获取上面的 SECRET_KEY 用于签名加密（不能泄露） # 'JWT_GET_USER_SECRET_KEY': 'utils.jwt_get_user_secret', } # jwt载荷中的有效期设置(from rest_framework_jwt) token_time = datetime.timedelta(days=365) JWT_AUTH = { 'JWT_EXPIRATION_DELTA': token_time, # 有效期设置 'JWT_REFRESH_EXPIRATION_DELTA': token_time, # 刷新有效期 'JWT_RESPONSE_PAYLOAD_HANDLER': '.utils.custom_jwt_response_payload_handler', # 自定义返回认证通过后的数据 } utils.py from django.contrib.auth import authenticate, get_user_model from rest_framework_jwt.utils import jwt_encode_handler from rest_framework_jwt.settings import api_settings def custom_payload_handler(user): '''自定义token内含值 :param user: user auth model :return: 计算token的基本信息 ''' # jwt token payload的基本信息： user_id 用户主键id, 用户first_name, 用户电话号码 phone payload = { 'user_id': user.pk, 'username': user.username, 'exp': datetime.datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA, # 'phone': user.phone 'user_secret': str(uuid.uuid4()) #　uuid } if api_settings.JWT_ALLOW_REFRESH: payload['orig_iat'] = timegm( datetime.datetime.utcnow().utctimetuple() ) if api_settings.JWT_AUDIENCE is not None: payload['aud'] = api_settings.JWT_AUDIENCE if api_settings.JWT_ISSUER is not None: payload['iss'] = api_settings.JWT_ISSUER return payload def generate_user_token(user): \"\"\"生成用户token\"\"\" user_model = get_user_model() payload = custom_payload_handler(user) token = jwt_encode_handler(payload) return token def custom_jwt_response_payload_handler(token, user=None): \"\"\" 自定义jwt认证成功返回的数据 :token 返回的jwt :user 当前登录的用户信息[对象] :request 当前本次客户端提交过来的数据 Example: return { 'token': token, 'user': UserSerializer(user, context={'request': request}).data } \"\"\" data = { 'code': 10000, 'results': { 'token': token, 'id': user.id, 'username': user.username, ．．．． } } return data def jwt_get_secret_key(payload=None): \"\"\"获取用户的secret_key（例如uuid） For enhanced security you may want to use a secret key based on user. This way you have an option to logout only this user if: - token is compromised - password is changed - etc. \"\"\" return user.user_secret # 分页 class PagePagination(LimitOffsetPagination): \"\"\"分页\"\"\" # page_size = 1 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 20 def get_paginated_response(self, data): ret = dict([ ('code', 10000, ('errMsg', ''), ('count', self.count), ('previous', self.get_previous_link()), ('next', self.get_next_link()), ]) if isinstance(data, dict): ret.update(**data) else: ret.update({ 'results': data }) return Response(OrderedDict(ret)) views.py from rest_framework_jwt.views import JSONWebTokenAPIView from rest_framework_jwt.settings import api_settings from utils import custom_jwt_response_payload_handler class CustomLoginJSONWebToken(JSONWebTokenAPIView): \"\"\" 自定义登录 \"\"\" serializer_class = CustomJSONWebTokenSerializer def post(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) if serializer.is_valid(): user = serializer.object.get('user') or request.user token = serializer.object.get('token') #　可自定义返回认证成功后的数据,settings中的JWT_AUTH中的JWT_RESPONSE_PAYLOAD_HANDLER设置 # 这里还可以写需要的相应逻辑 response_data = custom_jwt_response_payload_handler(token, user, request) response = Response(response_data) if api_settings.JWT_AUTH_COOKIE: expiration = (datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA) response.set_cookie(api_settings.JWT_AUTH_COOKIE, token, expires=expiration, httponly=True) return response return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) serializers.py from rest_framework_jwt.serializers import JSONWebTokenSerializer from django.contrib.auth import authenticate, get_user_model from utils import generate_user_token class CustomJSONWebTokenSerializer(JSONWebTokenSerializer): \"\"\"自定义账号密码登录序列号\"\"\" def validate(self, attrs): # 密码账户验证 username = attrs.get(self.username_field) password = attrs.get('password', None) credentials = { self.username_field: username, 'password': password } if all(credentials.values()): user = authenticate(**credentials) if user: if not user.is_active: msg = {'code': 10996, 'errMsg': '用户被冻结'} raise serializers.ValidationError(msg) # payload = jwt_payload_handler(user) return { # 'token': jwt_encode_handler(payload), 'token': generate_user_token(user), 'user': user } else: # 若认证失败 msg = {'code': 10991, 'errMsg': '用户名和密码错误'} raise serializers.ValidationError(msg) else: msg = {'code': 10997, 'errMsg': 'username和password为必填字段'} raise serializers.ValidationError(msg) from rest_framework_jwt.serializers import VerifyJSONWebTokenSerializer class CustomVerifyJSONWebTokenSerializer(VerifyJSONWebTokenSerializer): \"\"\" 多个用户表时自定义验证 中间件中使用 \"\"\" def _check_user(self, payload): # print(\"-------自定义验证的payload：\", payload) username = jwt_get_username_from_payload(payload) if not username: msg = _('Invalid payload.') raise serializers.ValidationError(msg) # Make sure user exists token_type = payload.get(\"type\", None) if token_type == \"manager\": try: # 表1 user = UserManager.objects.get_by_natural_key(username) except UserManager.DoesNotExist: msg = _(\"User doesn't exist.\") raise serializers.ValidationError(msg) if not user.is_active: msg = _('User account is disabled.') raise serializers.ValidationError(msg) else: try: # 表2 user = UserStuInfo.objects.filter(id=payload.get(\"user_id\", None), sno=payload.get(\"sno\", None), is_del=False).first() except UserStuInfo.DoesNotExist: msg = _(\"User doesn't exist.\") raise serializers.ValidationError(msg) return user authentication.py（多个用户表时的登录验证） from rest_framework_jwt.authentication import JSONWebTokenAuthentication, jwt_get_username_from_payload class CustomAuthenticate(JSONWebTokenAuthentication): \"\"\"多个用户表自定义设置登录选项\"\"\" def authenticate_credentials(self, payload): \"\"\" Returns an active user that matches the payload's user id and email. \"\"\" # User = get_user_model() username = jwt_get_username_from_payload(payload) # if if not username: msg = _('Invalid payload.') raise exceptions.AuthenticationFailed(msg) token_type = payload.get(\"type\", None) if token_type == \"manager\": try: # 举例用户表1 user = UserManager.objects.get_by_natural_key(username) except user.DoesNotExist: msg = _('Invalid signature.') raise exceptions.AuthenticationFailed(msg) if not user.is_active: msg = _('User account is disabled.') raise exceptions.AuthenticationFailed(msg) else: try: # 举例用户表2 user = UserStuInfo.objects.filter(id=payload.get(\"user_id\", None), sno=payload.get(\"sno\", None), is_del=False).first() except user.DoesNotExist: msg = _('Invalid signature.') raise exceptions.AuthenticationFailed(msg) return user middleware.py from uuid import uuid4 import json from django.http import HttpResponse from jwt import InvalidSignatureError from rest_framework.exceptions import ValidationError from django.utils.deprecation import MiddlewareMixin from rest_framework_jwt.utils import jwt_decode_handler from authentication import CustomVerifyJSONWebTokenSerializer # 1.每次登录 response 处理 记录 jwt # 2.每次请求判断 jwt是否与表中相等(相当于用户异设备登录获取了新的jwt) 不等 就修改uuid class ValidTokenMiddleware(MiddlewareMixin): def process_request(self, request): # 用于处理 所有带 jwt 的请求 jwt_token = request.META.get('HTTP_AUTHORIZATION', None) if jwt_token is not None and jwt_token != '': data = { 'token': request.META['HTTP_AUTHORIZATION'].split(' ')[1], } try: # valid_data = VerifyJSONWebTokenSerializer().validate(data) # 原来的 valid_data = CustomVerifyJSONWebTokenSerializer().validate(data) # 多用户自定义后的 user = valid_data['user'] # if user: # print(\"------------请求时用户的uuid:{0}\".format(user.user_secret)) except (InvalidSignatureError, ValidationError): # 找不到用户 data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) # if user.user_jwt != data['token']: # 解析token，这里面就有获取用户的user_secret，~~所以需要重写jwt_get_secret_key（不需要）~~ decode_token = jwt_decode_handler(data['token']) # print(\"------------请求时带的token：{0}\".format(decode_token)) if not user: data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) elif str(user.user_secret) != decode_token.get(\"user_secret\"): user.user_secret = uuid4() user.save() data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) def process_response(self, request, response): # 仅用于处理 login请求 # print(\"----------\", request.META['PATH_INFO']) MANAGER_LOGIN_PATH = \"/api/teacher/login/\" STUDENT_LOGIN_PATH = \"/api/student/login/\" if request.META['PATH_INFO'] in (MANAGER_LOGIN_PATH, STUDENT_LOGIN_PATH): try: rep_data = response.data except AttributeError as e: print(\"报错信息：\", e.args) results = rep_data.get('results', None) if results: # valid_data = VerifyJSONWebTokenSerializer().validate(results) # 原来的 valid_data = CustomVerifyJSONWebTokenSerializer().validate(results) # 多用户自定义后的 user = valid_data['user'] # user.user_jwt = rep_data['results']['token'] decode_token = jwt_decode_handler(rep_data['results']['token']) # print(\"--------登录后的token:\", decode_token) user.user_secret = decode_token.get(\"user_secret\") user.save() return response else: return response else: return response "},"Python/第三方库/Django/Django开发经验/01-Django-restframework重写异常处理手柄.html":{"url":"Python/第三方库/Django/Django开发经验/01-Django-restframework重写异常处理手柄.html","title":"异常处理手柄","keywords":"","body":"datetime:2020/1/8 16:02 author:nzb 重写异常处理返回 例如： 正常返回 { \"detail\": \"方法 “GET” 不被允许。\" } 重写返回 { \"code\": 10001, \"errMsg\": \"方法 “GET” 不被允许。\" } 源码流程 dispath() 分发 def dispatch(self, request, *args, **kwargs): \"\"\" `.dispatch()` is pretty much the same as Django's regular dispatch, but with extra hooks for startup, finalize, and exception handling. \"\"\" self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 活动到某个视图的某个方法，例如create() # 视图函数里的serializer.is_valid(raise_exception=True), # 会去验证序列化里面自带的验证规则和自定义的验证规则（并抛出异常） response = handler(request, *args, **kwargs) except Exception as exc: # 捕获异常 response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response handle_exception() # 捕获异常后执行 def handle_exception(self, exc): \"\"\" Handle any exception that occurs, by returning an appropriate response, or re-raising the error. \"\"\" if isinstance(exc, (exceptions.NotAuthenticated, exceptions.AuthenticationFailed)): # WWW-Authenticate header for 401 responses, else coerce to 403 auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN # 获取重写的异常返回函数 exception_handler = self.get_exception_handler() context = self.get_exception_handler_context() response = exception_handler(exc, context) if response is None: self.raise_uncaught_exception(exc) response.exception = True return response # 获取配置文件 def get_exception_handler(self): \"\"\" Returns the exception handler that this view uses. \"\"\" return self.settings.EXCEPTION_HANDLER 重写函数custom_exception_handler() from rest_framework.views import exception_handler def custom_exception_handler(exc,context): \"\"\" 框架自带错误码(常见已知的) ( (400, \"invalid\"), (401, \"authentication_failed\"), (401, \"not_authenticated\"), (403, \"permission_denied\"), (404, \"not_found\"), (405, \"method_not_allowed\"), ) 不常见的 ( (400, \"parse_error\"), (406, \"not_acceptable\"), (415, \"unsupported_media_type\"), (429, \"throttled\") ) \"\"\" response = exception_handler(exc, context) # 获取本来应该返回的exception的response request = context.get(\"request\", None) ... if response is not None: if response.status_code == 403: # 权限 pass elif response.status_code == 401: # 是否登录 pass elif response.status_code == 404: # 资源未找到 response.data['code'] = org_status_code.NOTFOUNDERROR_CODE.get(\"code\", None) response.data['errMsg'] = org_status_code.NOTFOUNDERROR_CODE.get(\"detail\", None) del response.data['detail'] elif response.status_code == 405: # 方法不允许 pass elif response.status_code == 400: # 重写django自带的序列化错误以及自定义的序列化错误 response = process_400_BAD_REQUEST(response) else: pass return response def process_400_BAD_REQUEST(response): \"\"\"映射自带错误和返回自定义错误\"\"\" old_data = response.data for k, v in old_data.items(): new_data = {} # 框架自带错误码(常见已知的) if v[0].code == \"required\": new_data['code'] = org_status_code.NOTNULL_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.NOTNULL_CODE.get(\"detail\", None).format(k) elif v[0].code == \"invalid\": new_data['code'] = org_status_code.TYPEERROR_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.TYPEERROR_CODE.get(\"detail\", None).format(k, v[0]) elif v[0].code == \"incorrect_type\": # 类型错误 new_data['code'] = org_status_code.TYPEERROR_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.TYPEERROR_CODE.get(\"detail\", None).format(k, v[ 0]) # \"{0}字段{1}\".format(k, v[0]) elif v[0].code == \"does_not_exist\": # 外键对象不存在 new_data['code'] = org_status_code.FOREIGNKEYNOEXISTED_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.FOREIGNKEYNOEXISTED_CODE.get(\"detail\", None).format(k, v[ 0]) # \"{0}字段{1}\".format(k, v[0]) elif v[0].code == \"unique\": # 已存在 new_data['code'] = org_status_code.EXISTED_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.EXISTED_CODE.get(\"detail\", None) elif v[0].code == \"max_length\": # 最大长度 new_data['code'] = org_status_code.MAXLENGTHERROR_CODE.get(\"code\", None) new_data['errMsg'] = v[0].replace(\"这个\", k) elif v[0].code == \"min_length\": # 最小长度 new_data['code'] = org_status_code.MINLENGTHERROR_CODE.get(\"code\", None) new_data['errMsg'] = v[0].replace(\"这个\", k) # 自定义错误码以及未知的错误码 else: if isinstance(v[0].code, int): # 自定义的错误 new_data['code'] = v[0].code new_data['errMsg'] = v[0] else: response.data = old_data return response response.data = new_data return response settings.py配置 REST_FRAMEWORK = { 'DATETIME_FORMAT': '%Y/%m/%d %H:%M:%S', 'JWT_ALLOW_REFRESH': True, 'DEFAULT_AUTHENTICATION_CLASSES': ( \"rest_framework_jwt.authentication.JSONWebTokenAuthentication\", # 'utils.authentication.CustomAuthenticate', # 自定义 JSON Token Authentication # 'rest_framework.authentication.BasicAuthentication', # 'rest_framework.authentication.SessionAuthentication', ), 'EXCEPTION_HANDLER': 'utils.exceptions.custom_exception_handler', # 自定义重写的异常处理返回 'SEARCH_PARAM': 'kw', } "},"Python/第三方库/Django/Django开发经验/03-Django-restframework过滤类相关.html":{"url":"Python/第三方库/Django/Django开发经验/03-Django-restframework过滤类相关.html","title":"过滤相关","keywords":"","body":"datetime:2020/5/13 13:45 author:nzb 过滤类相关 class NumberInFilter(django_filters.BaseInFilter, django_filters.NumberFilter): pass class MyFilter(django_filters.rest_framework.FilterSet): id_list = NumberInFilter(field_name=\"id\", label=\"xxx\", lookup_expr=\"in\") class Meta: model = TestModel fields = ['id_list'] "},"Python/第三方库/Django/Django开发经验/04-Django-Fastdfs重写存储类.html":{"url":"Python/第三方库/Django/Django开发经验/04-Django-Fastdfs重写存储类.html","title":"存储类重写","keywords":"","body":"datetime:2020/5/14 16:17 author:nzb Django-Fastdfs重写存储类 csnd文章 源码解析 本地存储类 重写存储类 client.conf # connect timeout in seconds # default value is 30s connect_timeout=30 # network timeout in seconds # default value is 30s network_timeout=60 # the base path to store log files # base_path=C:\\Users\\Admin\\PycharmProjects\\alumnus_circle\\venv # FastDFS客户端存放日志文件的目录 base_path = /data/log/fastdfs/fastdfs.log # tracker_server can ocur more than once, and tracker_server format is # \"host:port\", host can be hostname or ip address # 运行tracker服务的机器ip tracker_server = 172.26.6.129:22122 #standard log level as syslog, case insensitive, value list: ### emerg for emergency ### alert ### crit for critical ### error ### warn for warning ### notice ### info ### debug log_level=info # if use connection pool # default value is false # since V4.05 use_connection_pool = false # connections whose the idle time exceeds this time will be closed # unit: second # default value is 3600 # since V4.05 connection_pool_max_idle_time = 3600 # if load FastDFS parameters from tracker server # since V4.05 # default value is false load_fdfs_parameters_from_tracker=false # if use storage ID instead of IP address # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # default value is false # since V4.05 use_storage_id = false # specify storage ids filename, can use relative or absolute path # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # since V4.05 storage_ids_filename = storage_ids.conf #HTTP settings http.tracker_server_port=80 #use \"#include\" directive to include HTTP other settiongs ##include http.conf fdfs-storage.py # _*_ encoding:utf-8 _*_ __author__ = 'nzb' __datetime__ = '2020/1/3 15:18' from django.conf import settings from django.core.files.storage import Storage from django.utils.deconstruct import deconstructible from fdfs_client.client import Fdfs_client @deconstructible class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): \"\"\" 初始化 :param base_url: 用于构造图片完整路径使用，图片服务器的域名 :param client_conf: FastDFS客户端配置文件的路径 \"\"\" if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf def _open(self, name, mode='rb'): \"\"\" 用不到打开文件，所以省略 \"\"\" pass def _save(self, name, content): \"\"\" 在FastDFS中保存文件 :param name: 传入的文件名 :param content: 文件内容 :return: 保存到数据库中的FastDFS的文件名 \"\"\" client = Fdfs_client(self.client_conf) filename = content.name filename_ext = filename.split('.') if len(filename_ext) settings.py # FastDFS # django文件存储 DEFAULT_FILE_STORAGE = 'utils.fastdfs.fdfs_storage.FastDFSStorage' FDFS_URL = 'http://img.example.com/' FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf') 本地存储重命名 helper.py # 文件重命名 @deconstructible class RenameFile(object): def __init__(self, upload_to): self.upload_to = upload_to def __call__(self, instance, filename: str, *args, **kwargs) -> str: filename_ext = filename.split('.') if len(filename_ext) models.py class FeedBackFile(models.Model): file = models.FileField(verbose_name=\"意见反馈举报附件\", upload_to=RenameFile(\"upload/feedback/\")) create_time = models.DateTimeField(auto_now_add=True, verbose_name=\"创建时间\") class Meta: verbose_name = \"意见反馈附件\" verbose_name_plural = verbose_name 头部判断 import struct # 常见文件格式的文件头 ALLOW_FILETYPE = { \"FFD8FF\": \"JPEG (jpg)\", \"89504E47\": \"PNG (png)\", \"47494638\": \"GIF (gif)\", \"49492A00\": \"TIFF (tif)\", \"41433130\": \"CAD (dwg)\", \"D0CF11E0\": \"MS Word/Excel (xls.or.doc)\", \"255044462D312E\": \"Adobe Acrobat (pdf)\", \"504B0304\": \"ZIP Archive (zip)\", \"52617221\": \"RAR Archive (rar)\", \"41564920\": \"AVI (avi)\" } # 字节码转16进制字符串 def bytes2hex(bytes): num = len(bytes) hexstr = u\"\" for i in range(num): t = u\"%x\" % bytes[i] if len(t) % 2: hexstr += u\"0\" hexstr += t return hexstr.upper() def validate_file(file): \"\"\" 根据文件头判断文件类型 文件后缀不可信，并且后缀在linux系统下是没有这个概念的，所以通过文件中的头部标识来判断 :param file:IO文件 :return: xxx：文件类型，unknown：未知文件（不支持） \"\"\" # binfile = open(file, 'rb') # 必需二制字读取 tl = ALLOW_FILETYPE ftype = 'unknown' for hcode in tl.keys(): numOfBytes = len(hcode) / 2 # 需要读多少字节 file.seek(0) # 每次读取都要回到文件头，不然会一直往后读取 # hbytes = struct.unpack_from(\"B\" * numOfBytes, binfile.read(numOfBytes)) # 一个 \"B\"表示一个字节 hbytes = struct.unpack_from(\"B\" * int(numOfBytes), file.read(int(numOfBytes))) # 一个 \"B\"表示一个字节 f_hcode = bytes2hex(hbytes) if f_hcode == hcode: ftype = tl[hcode] break file.seek(0) # 回到文件头 return ftype if __name__ == '__main__': pass ret = validate_file('./test.jpg') print(ret) "},"Python/第三方库/Django/Django开发经验/05-Django-restframework序列化相关.html":{"url":"Python/第三方库/Django/Django开发经验/05-Django-restframework序列化相关.html","title":"序列化相关","keywords":"","body":"datetime:2020/6/28 14:34 author:nzb 唯一验证 # serialiezers.py from rest_framework import serializers from rest_framework.validators import UniqueTogetherValidator class ExampleSerializer(serializers.ModelSerializer): args1 = serializers.CharField(label=\"参数1\", required=False) class Meta: model = Example exclude = ['create_time'] validators = [UniqueTogetherValidator(queryset=Example.objects.filter(), fields=('project_id', 'project_type', 'user_id'), message='已存在')] def validate(self, attrs): file = attrs.get(\"file\", None) # 文件类型验证 if validate_file(file) == \"unknown\": raise serializers.ValidationError(code=40000, detail=\"不支持的文件类型\") return attrs 文件类型验证 # helper.py import struct # 常见文件格式的文件头 ALLOW_FILETYPE = { \"FFD8FF\": \"JPEG (jpg)\", \"89504E47\": \"PNG (png)\", \"47494638\": \"GIF (gif)\", \"49492A00\": \"TIFF (tif)\", \"41433130\": \"CAD (dwg)\", \"D0CF11E0\": \"MS Word/Excel (xls.or.doc)\", \"255044462D312E\": \"Adobe Acrobat (pdf)\", \"504B0304\": \"ZIP Archive (zip)\", \"52617221\": \"RAR Archive (rar)\", \"41564920\": \"AVI (avi)\" } # 字节码转16进制字符串 def bytes2hex(bytes): num = len(bytes) hexstr = u\"\" for i in range(num): t = u\"%x\" % bytes[i] if len(t) % 2: hexstr += u\"0\" hexstr += t return hexstr.upper() def validate_file(file): \"\"\" 根据文件头判断文件类型 文件后缀不可信，并且后缀在linux系统下是没有这个概念的，所以通过文件中的头部标识来判断 :param file:IO文件 :return: xxx：文件类型，unknown：未知文件（不支持） \"\"\" # binfile = open(file, 'rb') # 必需二制字读取 tl = ALLOW_FILETYPE ftype = 'unknown' for hcode in tl.keys(): numOfBytes = len(hcode) / 2 # 需要读多少字节 file.seek(0) # 每次读取都要回到文件头，不然会一直往后读取 # hbytes = struct.unpack_from(\"B\" * numOfBytes, binfile.read(numOfBytes)) # 一个 \"B\"表示一个字节 hbytes = struct.unpack_from(\"B\" * int(numOfBytes), file.read(int(numOfBytes))) # 一个 \"B\"表示一个字节 f_hcode = bytes2hex(hbytes) if f_hcode == hcode: ftype = tl[hcode] break file.seek(0) # 回到文件头 return ftype "},"Python/第三方库/Django/Django开发经验/06-api接口自动化测试.html":{"url":"Python/第三方库/Django/Django开发经验/06-api接口自动化测试.html","title":"自动化测试","keywords":"","body":"datetime:2020/9/17 14:35 author:nzb api接口自动化测试 配置文件数据库配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'sign_server', 'USER': 'root', 'PASSWORD':'123456', 'PORT': 3306, 'HOST': '127.0.0.1', 'TEST':{ # 测试数据库，每次测试都会自动创建，测试完后会自动删除 'NAME': 'test_sign_server', 'CHARSET': 'utf8mb4', 'COLLATION': 'utf8mb4_general_ci' }, 'OPTIONS': { 'charset': 'utf8mb4' } } } 测试示例 from django.test import TestCase import json from pprint import pprint from django.urls import reverse from rest_framework import status from rest_framework.test import APITestCase from sign.models import SignInfo class SignTests(APITestCase): def test_sign(self): \"\"\"签到\"\"\" print(\"开始测试\") url = reverse('sign-list') # url：/api/sign/ for user_id in range(1, 21): data = {'pro_id': 1, \"obj_id\": 1, \"obj_type\": 0, \"user_id\": user_id, \"sign_type\": 0} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) # 用户1第二条记录 data = {'pro_id': 1, \"obj_id\": 2, \"obj_type\": 0, \"user_id\": 1, \"sign_type\": 0} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) ins_id = response.data.get(\"results\", {}).get(\"id\") # 详情 url = reverse('sign-detail', args=[ins_id]) # url：/api/sign/21/ response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"results\", {}).get(\"status\", None), 0, \"用户签到状态错误\") # 修改处理状态 url = reverse('sign-detail', args=[ins_id]) # url：/api/sign/21/ data = {\"status\": 2} response = self.client.put(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(SignInfo.objects.get(id=ins_id).status, 2, \"修改处理状态出错\") # 补签(用户2在补签一个， obj_id=2) url = reverse('sign-list') # url：/api/sign/ data = {'pro_id': 1, \"obj_id\": 2, \"obj_type\": 0, \"user_id\": 2, \"sign_type\": 1, \"extra4\": \"我要补签\", \"extra_explain\": json.dumps({\"extra1\": \"扩展1说明\", \"extra2\": None, \"extra3\": None, \"extra4\": \"补签说明\", \"extra5\": None, \"extra6\": None})} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"results\", {}).get(\"sign_type\", None), 1, \"补签失败\") self.assertEqual(response.data.get(\"results\", {}).get(\"extra4\", None), \"我要补签\", \"补签的额外字段错误\") self.assertEqual(SignInfo.objects.filter().count(), 22, \"总数量不对\") # 用户1的签到历史 url = reverse('sign-list') + \"?offset=0&limit=1&user_id=1\" # url：/api/sign/?offset=0&limit=1&user_id=1 response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"count\"), 2, \"用户1的数量不对\") # 签到扩展字段说明 url = reverse('sign-detail', args=['extra_explain']) + \"?pro_id=1&obj_id=2&obj_type=0\" # url：/api/sign/extra_explain/?pro_id=1&obj_id=2&obj_type=0 response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(len(response.data.get(\"results\", [])), 1, \"额外参数说明错误\") 路由的反向解析 其中用drf注册的路由系统，反向解析如下 源码 routes = [ # List route. Route( url=r'^{prefix}{trailing_slash}$', mapping={ 'get': 'list', # 列表 'post': 'create' # 创建 }, name='{basename}-list', # 本例中：sign-list， basename：url中的别名 detail=False, initkwargs={'suffix': 'List'} ), # Dynamically generated list routes. Generated using # @action(detail=False) decorator on methods of the viewset. DynamicRoute( url=r'^{prefix}/{url_path}{trailing_slash}$', name='{basename}-{url_name}', # 装饰器的接口：detail=False detail=False, initkwargs={} ), # Detail route. Route( url=r'^{prefix}/{lookup}{trailing_slash}$', mapping={ 'get': 'retrieve', # 详情 'put': 'update', # 更新 'patch': 'partial_update', # 更新 'delete': 'destroy' # 删除 }, name='{basename}-detail', # 本例中：sign-detail， basename：url中的别名 detail=True, initkwargs={'suffix': 'Instance'} ), # Dynamically generated detail routes. Generated using # @action(detail=True) decorator on methods of the viewset. DynamicRoute( url=r'^{prefix}/{lookup}/{url_path}{trailing_slash}$', name='{basename}-{url_name}', # 装饰器的接口：detail=False detail=True, initkwargs={} ), ] 注意 被action修饰的接口尽量不用下划线连接，否则reverse不能反向解析，如果使用了下划线，只能这样url = reverse('sign-detail', args=['extra_explain']) + \"?pro_id=1&obj_id=2&obj_type=0\" detail=True：reverse(\"sign-extra\", args=[1]) 结果：/api/sign/extra/ detail=False：reverse(\"sign-extra\") 结果：/api/sign/1/extra/ 如果测试的接口有用到其他表信息：比如用户表可以直接用表创建用户 "},"Python/第三方库/Django/Django开发经验/07-为接口加速加缓存.html":{"url":"Python/第三方库/Django/Django开发经验/07-为接口加速加缓存.html","title":"接口加速缓存","keywords":"","body":"datetime:2020/9/17 15:22 author:nzb 为接口提速，加缓存 1、为什么要使用缓存 目前，用户对于接口的操作基本都需要查询数据库。获取文章列表需要从数据库查询，获取单篇文章需要从数据库查询，获取评论列表也需要查询数据。但是，对于博客中的很多资源来说，在某个时间段内，他们的内容几乎都不会发生更新。例如文章详情，文章发表后，除非对其内容做了修改，否则内容就不会变化。还有评论列表，如果没人发布新评论，评论列表也不会变化。 要知道查询数据库的操作相对而言是比较缓慢的，而直接从内存中直接读取数据就会快很多，因此缓存系统应运而生。将那些变化不那么频繁的数据缓存到内存中，内存中的数据相当于数据库中的一个副本，用户查询数据时，不从数据库查询而是直接从缓存中读取，数据库的数据发生了变化时再更新缓存，这样，数据查询的性能就大大提升了。 当然数据库性能也没有说的那么不堪，对于大部分访问量不大的个人博客而言，任何关系型数据库都足以应付。但是我们学习 django-rest-framework 不仅仅是为了写博客，也许你在工作中，面对的是流量非常大的系统，这时候缓存就不可或缺。 2、确定需缓存的接口 先来整理一下我们已有的接口，看看哪些接口是需要缓存的： 接口名 URL 需缓存 文章列表 /api/posts/ 是 文章详情 /api/posts/:id/ 是 分类列表 /categories/ 是 标签列表 /tags/ 是 归档日期列表 /posts/archive/dates/ 是 评论列表 /api/posts/:id/comments/ 是 文章搜索结果 /api/search/ 否 补充说明 文章列表：需要缓存，但如果有文章修改、新增或者删除时应使缓存失效。 文章详情：需要缓存，但如果文章内容修改或者删除了应使缓存失效。 分类、标签、归档日期：可以缓存，但同样要注意在相应的数据变化时使缓存失效。 评论列表：可以缓存，新增或者删除评论时应使缓存失效。 搜索接口：因为搜索的关键词是多种多样的，可以缓存常见搜索关键词的搜索结果，但如何确定常见搜索关键词是一个复杂的优化问题，这里我们不做任何缓存处理。 3、配置缓存 django 为我们提供了一套开箱即用的缓存框架，缓存框架对缓存的操作做了抽象，提供了统一的读写缓存的接口。无论底层使用什么样的缓存服务（例如常用的 Redis、Memcached、文件系统等），对上层应用来说，操作逻辑和调用的接口都是一样的。 配置 django 缓存，最重要的就是选择一个缓存服务，即缓存结果存储和读取的地方。本项目中我们决定开发环境使用本地内存（Local Memory）缓存服务，线上环境使用 Redis 缓存。 3.1、开发环境配置 在开发环境的配置文件 settings/local.py 中加入以下的配置项即开启本地内存缓存服务。 CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.locmem.LocMemCache', } } 3.2、线上环境配置 线上环境使用到 Redis 缓存服务，django 并未内置 Redis 缓存服务的支持，不过对于 Redis 来说当然不缺乏第三方库的支持，我们选择 django-redis-cache，先来安装它： pipenv install django-redis-cache 然后在项目的线上环境配置文件 settings/production.py 中加入以下配置： CACHES = { \"default\": { \"BACKEND\": \"redis_cache.RedisCache\", \"LOCATION\": \"redis://:UJaoRZlNrH40BDaWU6fi@redis:6379/0\", \"OPTIONS\": { \"CONNECTION_POOL_CLASS\": \"redis.BlockingConnectionPool\", \"CONNECTION_POOL_CLASS_KWARGS\": {\"max_connections\": 50, \"timeout\": 20}, \"MAX_CONNECTIONS\": 1000, \"PICKLE_VERSION\": -1, }, }, } 这样，django 的缓存功能就启用了。至于如何启动 Redis 服务，请参考教程最后的 Redis 服务部分。 3.3、drf-extensions Cache django 的缓存框架比较底层，drf-extensions 在 django 缓存框架的基础上，针对 django-rest-framework 封装了更多缓存相关的辅助函数和类，我们将借助这个第三方库来大大简化缓存逻辑的实现。 首先安装它： pipenv install drf-extensions 那么 drf-extensions 对缓存提供了哪些辅助函数和类呢？我们需要用到的主要有这些： KeyConstructor 可以理解为缓存键生成类。我们先来看看 API 接口缓存的逻辑，伪代码是这样的： 给定一个 URL, 尝试从缓存中查找这个 URL 接口的响应结果 if 结果在缓存中: return 缓存中的结果 else: 生成响应结果 将响应结果存入缓存 (以便下一次查询) return 生成的响应结果 缓存结果是以 key-value 的键值对形式存储的，这里关键的地方在于存储或者查询缓存结果时，需要生成相应的 key。例如我们可以把 API 请求的 URL 作为缓存的 key，这样同一个接口请求将返回相同的缓存内容。但是在更为复杂的场景下，不能简单使用 URL 作为 key，比如即使是同一个 API 请求，已认证和未认证的用户调用接口得到的结果是不一样的，所以 drf-extensions 使用 KeyConstructor 辅助基类来提供灵活的 key 生成方式。 KeyBit 可以理解为 KeyConstructor 定义的 key 生成规则中的某一项规则定义。例如，同一个 API 请求，已认证和未认证的用户将得到不同的响应结果，我们可以定义 key 的生成规则为请求的 URL + 用户的认证 id。那么 URL 可以看成一个 KeyBit，用户 id 是另一个 KeyBit。 cache_response 装饰器 这个装饰器用来装饰 django-rest-framework 的视图（单个视图函数、视图集中的 action 等），被装饰的视图将具备缓存功能。 4、缓存博客文章 我们首先来使用 cache_response 装饰器缓存文章列表接口，代码如下： blog/views.py from rest_framework_extensions.cache.decorators import cache_response class PostViewSet( mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet ): # ... @cache_response(timeout=5 * 60, key_func=PostListKeyConstructor()) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) @cache_response(timeout=5 * 60, key_func=PostObjectKeyConstructor()) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) 这里我们分别装饰了 list（获取文章列表的 action）和 retrieve（获取单篇文章），timeout 参数用于指定缓存失效时间， key_func 指定缓存 key 的生成类（即 KeyConstructor），当然 PostListKeyConstructor、和 PostObjectKeyConstructor 还未定义，接下来我们就来定义这两个缓存 key 生成类： from rest_framework_extensions.key_constructor.bits import ( ListSqlQueryKeyBit, PaginationKeyBit, RetrieveSqlQueryKeyBit, ) from rest_framework_extensions.key_constructor.constructors import DefaultKeyConstructor class PostListKeyConstructor(DefaultKeyConstructor): list_sql = ListSqlQueryKeyBit() pagination = PaginationKeyBit() updated_at = PostUpdatedAtKeyBit() class PostObjectKeyConstructor(DefaultKeyConstructor): retrieve_sql = RetrieveSqlQueryKeyBit() updated_at = PostUpdatedAtKeyBit() PostListKeyConstructor 用于文章列表接口缓存 key 的生成，它继承自 DefaultKeyConstructor，这个基类中定义了 3 条缓存 key 的 KeyBit： 接口调用的视图方法的 id，例如 blog.views. PostViewSet.list。 客户端请求的接口返回的数据格式，例如 json、xml。 客户端请求的语言类型。 另外我们还添加了 3 条自定义的缓存 key 的 KeyBit： 执行数据库查询的 sql 查询语句 分页请求的查询参数 Post 资源的最新更新时间 以上 6 条分别对应一个 KeyBit，KeyBit 将提供生成缓存键所需要的值，如果任何一个 KeyBit 提供的值发生了变化，生成的缓存 key 就会不同，查询到的缓存结果也就不一样，这个方式为我们提供了一种有效的缓存失效机制。例如 PostUpdatedAtKeyBit 是我们自定义的一个 KeyBit，它提供 Post 资源最近一次的更新时间，如果资源发生了更新，返回的值就会发生变化，生成的缓存 key 就会不同，从而不会让接口读到旧的缓存值。PostUpdatedAtKeyBit的代码如下： blog/views.py from .utils import UpdatedAtKeyBit class PostUpdatedAtKeyBit(UpdatedAtKeyBit): key = \"post_updated_at\" 因为资源更新时间的 KeyBit 是比较通用的（后面我们还会用于评论资源），所以我们定义了一个基类 UpdatedAtKeyBit，代码如下： from datetime import datetime from django.core.cache import cache from rest_framework_extensions.key_constructor.bits import KeyBitBase class UpdatedAtKeyBit(KeyBitBase): key = \"updated_at\" def get_data(self, **kwargs): value = cache.get(self.key, None) if not value: value = datetime.now() # 这边的缓存时间可以和数据的缓存时间一样（或比数据缓存的时间长） # 短了的话（取不到值），获取后生成的数据缓存key跟缓存的key不一样，会重新查询数据库 cache.set(self.key, value=value, timeout=5 * 60) return str(value) get_data 方法返回这个 KeyBit 对应的值，UpdatedAtKeyBit 首先根据设置的 key 从缓存中读取资源最近更新的时间，如果读不到就将资源最近更新的时间设为当前时间，然后返回这个时间。 当然，我们需要自动维护缓存中记录的资源更新时间，这可以通过 django 的 signal 来完成： # 也可以写在blog/signals.py blog/models.py from django.db.models.signals import post_delete, post_save def change_post_updated_at(sender=None, instance=None, *args, **kwargs): cache.set(\"post_updated_at\", datetime.utcnow()) post_save.connect(receiver=change_post_updated_at, sender=Post) post_delete.connect(receiver=change_post_updated_at, sender=Post) 每当有文章（Post）被新增、修改或者删除时，django 会发出 post_save 或者 post_delete 信号，post_save.connect 和 post_delete.connect 设置了这两个信号的接收器为 change_post_updated_at，信号发出后该方法将被调用，往缓存中写入文章资源的更新时间。 整理一下请求被缓存的逻辑： 请求文章列表接口 根据 PostListKeyConstructor 生成缓存 key，如果使用这个 key 读取到了缓存结果，就直接返回读取到的结果，否则从数据库查询结果，并把查询的结果写入缓存。 再次请求文章列表接口，PostListKeyConstructor 将生成同样的缓存 key，这时就可以直接从缓存中读到结果并返回了。 缓存更新的逻辑： 新增、修改或者删除文章，触发 post_delete, post_save 信号，文章资源的更新时间将被修改。 再次请求文章列表接口，PostListKeyConstructor 将生成不同的缓存 key，这个新的 key 不在缓存中，因此将从数据库查询最新结果，并把查询的结果写入缓存。 再次请求文章列表接口，PostListKeyConstructor 将生成同样的缓存 key，这时就可以直接从缓存中读到结果并返回了。 PostObjectKeyConstructor 用于文章详情接口缓存 key 的生成，逻辑和 PostListKeyConstructor 是完全一样。 5、缓存评论列表 有了文章列表的缓存，评论列表的缓存只需要依葫芦画瓢。 KeyBit 定义： blog/views.py class CommentUpdatedAtKeyBit(UpdatedAtKeyBit): key = \"comment_updated_at\" KeyConstructor 定义： blog/views.py class CommentListKeyConstructor(DefaultKeyConstructor): list_sql = ListSqlQueryKeyBit() pagination = PaginationKeyBit() updated_at = CommentUpdatedAtKeyBit() 视图集： @cache_response(timeout=5 * 60, key_func=CommentListKeyConstructor()) @action( methods=[\"GET\"], detail=True, url_path=\"comments\", url_name=\"comment\", pagination_class=LimitOffsetPagination, serializer_class=CommentSerializer, ) def list_comments(self, request, *args, **kwargs): # ... 6、Redis 服务 本地内存缓存服务配置简单，适合在开发环境使用，但无法适应多线程和多进程适的环境，线上环境我们使用 Redis 做缓存。有了 Docker，启动一个 Redis 服务就是一件非常简单的事。 在线上环境的容器编排文件 production.yml 中加入一个 Redis 服务： version: '3' volumes: static: database: esdata: redis_data: services: hellodjango.rest.framework.tutorial: ... depends_on: - elasticsearch - redis redis: image: 'bitnami/redis:5.0' container_name: hellodjango_rest_framework_tutorial_redis ports: - '6379:6379' volumes: - 'redis_data:/bitnami/redis/data' env_file: - .envs/.production 然后在 .envs/.production 文件中添加如下的环境变量，这个值将作为 redis 连接的密码： REDIS_PASSWORD=055EDy65AAhLgBxMp1u1 然后就可以将服务发布上线了。 "},"Python/第三方库/PyQt5/":{"url":"Python/第三方库/PyQt5/","title":"导航","keywords":"","body":"datetime:2019/5/23 15:28 author:nzb PyQt5关系图 创建窗口 创建按钮 垂直布局和水平布局 栅格布局 布局添加标签 布局添加背景图 单选按钮 复选框 创建提示 行编辑 按钮组 布局组 无边框窗口 创建框架qframe 创建分离器 创建滑动条 创建滚动条 创建刻度盘 spinbox 生成随机数 进度条 工具框 菜单栏和工具栏 文档编辑框 文本框字体的选择 字体颜色 打印 打印预览 打印PDF （带选择的）消息框提示框 右键菜单 选项卡（单选下拉框和多选） stack(堆叠小部件)小部件.md) 可停靠的窗口小部件 日历 单选下拉框 首字符模糊填充（查询） 打开更多的窗口 时间编辑 列表部件 列表部件小示例 "},"Python/第三方库/PyQt5/01-窗口.html":{"url":"Python/第三方库/PyQt5/01-窗口.html","title":"窗口","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 创建窗口 import sys from PyQt5.QtWidgets import QMainWindow, QApplication, QDesktopWidget from PyQt5 import QtGui class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 demo' self.left = 600 self.top = 200 self.width = 800 self.height = 600 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 # self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.resize(800, 600) # 窗口大小 self.center() # 窗口居中 # 展示窗口 self.show() def center(self): \"\"\"窗口居中\"\"\" qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/02-按钮.html":{"url":"Python/第三方库/PyQt5/02-按钮.html","title":"按钮","keywords":"","body":"datetime:2019/5/20 14:04 author:nzb 创建按钮 import sys from PyQt5.QtWidgets import QMainWindow, QApplication, QDesktopWidget, QPushButton from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 demo' self.left = 600 self.top = 200 self.width = 800 self.height = 600 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 按钮 self.button() # 展示窗口 self.show() def button(self): \"\"\"按钮\"\"\" btn = QPushButton('click me', self) # btn.resize(100, 34) # 按钮大小 # btn.move(290, 550) # 移动按钮 # 合并 btn.setGeometry(QtCore.QRect(300, 250, 150, 34)) # 按钮图标 btn.setIcon(QtGui.QIcon('../img/Agt Stop.ico')) btn.setIconSize(QtCore.QSize(40, 40)) # 设置图标大小 # 设置按钮提示 btn.setToolTip('按钮提示') # 触发事件 btn.clicked.connect(self.ClickMe) def ClickMe(self): print('Hello World') # 退出 sys.exit() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/03-垂直布局和水平布局.html":{"url":"Python/第三方库/PyQt5/03-垂直布局和水平布局.html","title":"垂直布局和水平布局","keywords":"","body":"datetime:2019/5/20 14:21 author:nzb 垂直布局和水平布局 import sys from PyQt5.QtWidgets import QApplication, QDesktopWidget, QDialog, QPushButton, QVBoxLayout, QGroupBox, QHBoxLayout from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 300 self.height = 100 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 布局 self.createLayout() vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.setLayout(vbox) # 展示窗口 self.show() def createLayout(self): \"\"\"垂直布局和水平布局\"\"\" self.groupBox = QGroupBox('What is your favorite sport?') hboxlayout = QHBoxLayout() btn = QPushButton('Soccer', self) btn.setIcon(QtGui.QIcon('../img/Soccer.ico')) btn.setIconSize(QtCore.QSize(40, 40)) btn.setMinimumHeight((40)) hboxlayout.addWidget(btn) btn1 = QPushButton('Tennis', self) btn1.setIcon(QtGui.QIcon('../img/Tennis.ico')) btn1.setIconSize(QtCore.QSize(40, 40)) btn1.setMinimumHeight((40)) hboxlayout.addWidget(btn1) btn2 = QPushButton('Basketball', self) btn2.setIcon(QtGui.QIcon('../img/Basketball.ico')) btn2.setIconSize(QtCore.QSize(40, 40)) btn2.setMinimumHeight((40)) hboxlayout.addWidget(btn2) self.groupBox.setLayout(hboxlayout) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/04-栅格布局.html":{"url":"Python/第三方库/PyQt5/04-栅格布局.html","title":"栅格布局","keywords":"","body":"datetime:2019/5/20 14:27 author:nzb 栅格布局 import sys from PyQt5.QtWidgets import QApplication, QDialog, QPushButton, QVBoxLayout, QGroupBox, QGridLayout from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Grid Layout ' self.left = 600 self.top = 200 self.width = 300 self.height = 100 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 栅格布局 self.createLayout() vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.setLayout(vbox) # 展示窗口 self.show() def createLayout(self): \"\"\"栅格布局\"\"\" self.groupBox = QGroupBox('What is your favorite programming language?') gridLayout = QGridLayout() btn = QPushButton('Python', self) btn.setIcon(QtGui.QIcon('../img/python.ico')) btn.setIconSize(QtCore.QSize(40, 40)) btn.setMinimumHeight((40)) gridLayout.addWidget(btn, 0, 0) btn1 = QPushButton('java', self) btn1.setIcon(QtGui.QIcon('../img/java.ico')) btn1.setIconSize(QtCore.QSize(40, 40)) btn1.setMinimumHeight((40)) gridLayout.addWidget(btn1, 0, 1) btn2 = QPushButton('php', self) btn2.setIcon(QtGui.QIcon('../img/php.ico')) btn2.setIconSize(QtCore.QSize(40, 40)) btn2.setMinimumHeight((40)) gridLayout.addWidget(btn2, 1, 0) btn3 = QPushButton('c++', self) btn3.setIcon(QtGui.QIcon('./img/C++.ico')) btn3.setIconSize(QtCore.QSize(40, 40)) btn3.setMinimumHeight((40)) gridLayout.addWidget(btn3, 1, 1) self.groupBox.setLayout(gridLayout) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/05-布局添加标签Label.html":{"url":"Python/第三方库/PyQt5/05-布局添加标签Label.html","title":"布局添加标签Label","keywords":"","body":"datetime:2019/5/20 14:34 author:nzb 布局添加标签 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 标签 label = QLabel('This is PyQt5 Label.') vbox.addWidget(label) label2 = QLabel('This is big Label.') label2.setFont(QtGui.QFont(\"Sanserif\", 20)) # 设置字体和大小 label2.setStyleSheet(\"color:red\") # 设置颜色 vbox.addWidget(label2) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/06-布局添加背景图.html":{"url":"Python/第三方库/PyQt5/06-布局添加背景图.html","title":"布局添加背景图","keywords":"","body":"datetime:2019/5/20 14:41 author:nzb 布局添加背景图 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 背景图 labelImage = QLabel(self) pixmap = QtGui.QPixmap('../img/default.jpg') labelImage.setPixmap(pixmap) vbox.addWidget(labelImage) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/07-单选框.html":{"url":"Python/第三方库/PyQt5/07-单选框.html","title":"单选框","keywords":"","body":"datetime:2019/5/20 15:02 author:nzb 单选按钮 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QRadioButton, QHBoxLayout from PyQt5 import QtGui, QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 单选框 self.radioButton() vbox.addWidget(self.groupBox) self.label = QLabel(self) self.label.setFont(QtGui.QFont(\"Sanserif\", 20)) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def radioButton(self): \"\"\"单选框\"\"\" self.groupBox = QGroupBox(\"What is your favorite sport?\") self.groupBox.setFont(QtGui.QFont(\"Sanserif\", 12)) hboxlayout = QHBoxLayout() self.radiobtn1 = QRadioButton('Soccer') self.radiobtn1.setChecked(True) # 选中状态 self.radiobtn1.setIcon(QtGui.QIcon('../img/Soccer.ico')) self.radiobtn1.setIconSize(QtCore.QSize(40, 40)) self.radiobtn1.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn1.toggled.connect(self.OnRadioBtn) # 选中事件 hboxlayout.addWidget(self.radiobtn1) self.radiobtn2 = QRadioButton('Tennis') self.radiobtn2.setIcon(QtGui.QIcon('../img/Tennis.ico')) self.radiobtn2.setIconSize(QtCore.QSize(40, 40)) self.radiobtn2.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn2.toggled.connect(self.OnRadioBtn) hboxlayout.addWidget(self.radiobtn2) self.radiobtn3 = QRadioButton('Basketball') self.radiobtn3.setIcon(QtGui.QIcon('../img/Basketball.ico')) self.radiobtn3.setIconSize(QtCore.QSize(40, 40)) self.radiobtn3.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn3.toggled.connect(self.OnRadioBtn) hboxlayout.addWidget(self.radiobtn3) self.groupBox.setLayout(hboxlayout) def OnRadioBtn(self): \"\"\"单选框选中事件\"\"\" radioBtn = self.sender() if radioBtn.isChecked(): self.label.setText(\"You have selected \" + radioBtn.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/08-复选框.html":{"url":"Python/第三方库/PyQt5/08-复选框.html","title":"复选框","keywords":"","body":"datetime:2019/5/20 15:45 author:nzb 复选框 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QCheckBox, QHBoxLayout from PyQt5 import QtGui, QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Check Box' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.CreateCheckBox() # 复选按钮 vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) #设置标签字体字号 vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def CreateCheckBox(self): \"\"\"复选框\"\"\" self.groupBox = QGroupBox(\"What is you favorite programming language?\") self.groupBox.setFont(QtGui.QFont(\"Sanserif\", 13)) # 设置字体字号 hboxLayout = QHBoxLayout() self.check1 = QCheckBox(\"python\") self.check1.setIcon(QtGui.QIcon('../img/python.ico')) self.check1.setIconSize(QtCore.QSize(40, 40)) self.check1.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check1.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check1) self.check2 = QCheckBox(\"java\") self.check2.setIcon(QtGui.QIcon('../img/java.ico')) self.check2.setIconSize(QtCore.QSize(40, 40)) self.check2.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check2.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check2) self.check3 = QCheckBox(\"php\") self.check3.setIcon(QtGui.QIcon('../img/php.ico')) self.check3.setIconSize(QtCore.QSize(40, 40)) self.check3.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check3.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check3) self.groupBox.setLayout(hboxLayout) def onCheckBox_Toggled(self): \"\"\"复选框触发事件\"\"\" if self.check1.isChecked(): self.label.setText('you have select:' + self.check1.text()) if self.check2.isChecked(): self.label.setText('you have select:' + self.check2.text()) if self.check3.isChecked(): self.label.setText('you have select:' + self.check3.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/09-键盘提示.html":{"url":"Python/第三方库/PyQt5/09-键盘提示.html","title":"键盘提示","keywords":"","body":"datetime:2019/5/20 15:58 author:nzb 创建提示 import sys from PyQt5.QtWidgets import QApplication, QDialog, QLabel, QHBoxLayout, QPushButton from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 WhaiIsThis Class' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 hbox = QHBoxLayout() label = QLabel(\"Focus and press Shift + F1\") hbox.addWidget(label) button = QPushButton('click me', self) button.setWhatsThis(\"This is a button that you can click on this\") hbox.addWidget(button) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/10-行编辑lineedit.html":{"url":"Python/第三方库/PyQt5/10-行编辑lineedit.html","title":"行编辑Lineedit","keywords":"","body":"datetime:2019/5/20 16:12 author:nzb 行编辑 import sys from PyQt5.QtWidgets import QWidget, QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QLineEdit from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Lineedit' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 行编辑 hbox = QHBoxLayout() self.lineedit = QLineEdit(self) self.lineedit.setFont(QtGui.QFont('Sanserif', 15)) self.lineedit.returnPressed.connect(self.onPressed) hbox.addWidget(self.lineedit) self.lable = QLabel(self) self.lable.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.lable) self.setLayout(hbox) # 展示窗口 self.show() def onPressed(self): \"\"\"输入绑定事件\"\"\" self.lable.setText(self.lineedit.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/11-按钮组.html":{"url":"Python/第三方库/PyQt5/11-按钮组.html","title":"按钮组","keywords":"","body":"datetime:2019/5/20 16:28 author:nzb 按钮组 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 ButtonGroup' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 按钮组 hbox = QHBoxLayout() self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.label) self.buttongroup = QButtonGroup() # 创建按钮组 self.buttongroup.buttonClicked[int].connect(self.on_button_clicked) # 绑定事件 button = QPushButton('python') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/python.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 1) # 添加按钮 hbox.addWidget(button) button = QPushButton('java') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/java.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 2) hbox.addWidget(button) button = QPushButton('php') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/php.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 3) hbox.addWidget(button) self.setLayout(hbox) # 展示窗口 self.show() def on_button_clicked(self, id): \"\"\"按钮事件\"\"\" for button in self.buttongroup.buttons(): if button is self.buttongroup.button(id): self.label.setText(button.text() + \" was clicked\") if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/12-布局组.html":{"url":"Python/第三方库/PyQt5/12-布局组.html","title":"布局组","keywords":"","body":"datetime:2019/5/20 17:03 author:nzb 布局组 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Groupbox' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 布局组 # 水平布局 hbox = QHBoxLayout() groupbox = QGroupBox('select you favorite sport') groupbox.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(groupbox) # 垂直布局 vbox = QVBoxLayout() rad1 = QRadioButton('soccer') vbox.addWidget(rad1) rad2 = QRadioButton('tennis') vbox.addWidget(rad2) groupbox.setLayout(vbox) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/13-无边框窗口.html":{"url":"Python/第三方库/PyQt5/13-无边框窗口.html","title":"无边框窗口","keywords":"","body":"datetime:2019/5/20 17:13 author:nzb 无边框窗口 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup, \\ QSizeGrip from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Frameless Window' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 无边框窗口 flags = QtCore.Qt.WindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint) self.setWindowFlags(flags) vbox = QVBoxLayout() sizegrip = QSizeGrip(self) vbox.addWidget(sizegrip) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/14-框架qframe.html":{"url":"Python/第三方库/PyQt5/14-框架qframe.html","title":"框架Qframe","keywords":"","body":"datetime:2019/5/21 15:13 author:nzb 创建框架qframe import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup, \\ QSizeGrip, QFrame from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Qframe' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 设置背景颜色 # 框架qframe hbox = QHBoxLayout() btn = QPushButton('click me') btn.setStyleSheet('color:white') btn.setStyleSheet('background-color:green') frame = QFrame() frame.setFrameShape(QFrame.StyledPanel) frame.setStyleSheet('background-color:red') hbox.addWidget(frame) hbox.addWidget(btn) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/15-分离器.html":{"url":"Python/第三方库/PyQt5/15-分离器.html","title":"分离器","keywords":"","body":"datetime:2019/5/21 15:16 author:nzb 创建分离器 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QPushButton, QButtonGroup, QSizeGrip, QFrame from PyQt5.QtWidgets import QVBoxLayout, QRadioButton, QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Splitters' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 分离器 hbox = QHBoxLayout() left = QFrame() left.setFrameShape(QFrame.StyledPanel) bottom = QFrame() bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) # 水平分离（默认） splitter1.setStyleSheet('background-color:red') lineedit = QLineEdit() lineedit.setStyleSheet('background-color:green') splitter1.addWidget(left) splitter1.addWidget(lineedit) splitter1.setSizes([200, 200]) splitter2 = QSplitter(Qt.Vertical) # 垂直分离 splitter2.addWidget(splitter1) splitter2.addWidget(bottom) splitter2.setStyleSheet('background-color:blue') hbox.addWidget(splitter2) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/16-滑动条.html":{"url":"Python/第三方库/PyQt5/16-滑动条.html","title":"滑动条","keywords":"","body":"datetime:2019/5/21 15:44 author:nzb 创建滑动条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QPushButton, QButtonGroup, QFrame, QSlider from PyQt5.QtWidgets import QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Slider' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 滑动条 hbox = QHBoxLayout() # 水平布局 self.slider = QSlider() self.slider.setOrientation(Qt.Horizontal) # 水平滑动（默认垂直） self.slider.setTickPosition(QSlider.TicksBelow) # 刻度 self.slider.setTickInterval(10) # 设置刻度数量 self.slider.setMinimum(0) # 滑动条最小值 self.slider.setMaximum(100) # 滑动条最大值 self.slider.valueChanged.connect(self.changedValue) # 绑定事件 self.label = QLabel('0') self.label.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.slider) hbox.addWidget(self.label) self.setLayout(hbox) # 展示窗口 self.show() def changedValue(self): size = self.slider.value() self.label.setText(str(size)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/17-滚动条.html":{"url":"Python/第三方库/PyQt5/17-滚动条.html","title":"滚动条","keywords":"","body":"datetime:2019/5/21 16:00 author:nzb 创建滚动条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QFrame, QScrollArea, QFormLayout, QPushButton, QVBoxLayout from PyQt5.QtWidgets import QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self, val): super().__init__() # 窗口信息 self.title = 'PyQt5 QScroll Area' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.val = val self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 滚动区域 formLayout = QFormLayout() # 表单布局 groupBox = QGroupBox(\"This is group box\") labelList = [] buttonList = [] for i in range(self.val): labelList.append(QLabel(\"Label\")) buttonList.append(QPushButton('click me')) formLayout.addRow(labelList[i], buttonList[i]) groupBox.setLayout(formLayout) scroll = QScrollArea() scroll.setWidget(groupBox) scroll.setWidgetResizable(True) scroll.setFixedHeight(400) layout = QVBoxLayout() layout.addWidget(scroll) self.setLayout(layout) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo(20) sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/18-刻度盘.html":{"url":"Python/第三方库/PyQt5/18-刻度盘.html","title":"刻度盘","keywords":"","body":"datetime:2019/5/21 16:23 author:nzb 创建刻度盘 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QFrame, QScrollArea, QFormLayout, QPushButton, QVBoxLayout from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 QDial' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 刻度盘 vbox = QVBoxLayout() self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) self.dial = QDial() self.dial.setMinimum(0) self.dial.setMaximum(100) self.dial.setValue(30) self.dial.valueChanged.connect(self.dial_changed) vbox.addWidget(self.dial) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def dial_changed(self): getValue = self.dial.value() self.label.setText(\"Dial is changing：\" + str(getValue)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/19-spinbox.html":{"url":"Python/第三方库/PyQt5/19-spinbox.html","title":"Spinbox","keywords":"","body":"datetime:2019/5/21 16:45 author:nzb spinbox import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self, val): super().__init__() # 窗口信息 self.title = 'PyQt5 QSpinbox' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.val = val self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 转动盒子 vbox = QVBoxLayout() self.spinbox = QSpinBox() self.spinbox.valueChanged.connect(self.spin_changed) vbox.addWidget(self.spinbox) self.label = QLabel() self.label.setFont(QtGui.QFont('Sanserif', 15)) self.label.setAlignment(Qt.AlignCenter) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def spin_changed(self): spinValue = self.spinbox.value() self.label.setText(\"current value is :\" + str(spinValue)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo(20) sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/20-生成随机数.html":{"url":"Python/第三方库/PyQt5/20-生成随机数.html","title":"生成随机数","keywords":"","body":"datetime:2019/5/21 16:59 author:nzb 生成随机数 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt from random import randint class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 QLCDNumber' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 随机生成数字 self.initUI() # 展示窗口 self.show() def initUI(self): \"\"\"随机生成数字\"\"\" vbox = QVBoxLayout() self.lcd = QLCDNumber() # self.lcd.display(60) # 显示数字 self.lcd.setStyleSheet('background-color:green') vbox.addWidget(self.lcd) self.button = QPushButton('random number generator') self.button.setStyleSheet('background-color:yellow') self.button.clicked.connect(self.LCDHandler) vbox.addWidget(self.button) self.setLayout(vbox) def LCDHandler(self): \"\"\"随机数字\"\"\" random = randint(1, 200) self.lcd.display(random) # 显示数字 if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/21-进度条.html":{"url":"Python/第三方库/PyQt5/21-进度条.html","title":"进度条","keywords":"","body":"datetime:2019/5/21 17:38 author:nzb 进度条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial, QProgressBar from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt, QThread, pyqtSignal import time class MyThead(QThread): change_value = pyqtSignal(int) def run(self): cnt = 0 while cnt "},"Python/第三方库/PyQt5/22-工具框.html":{"url":"Python/第三方库/PyQt5/22-工具框.html","title":"工具框","keywords":"","body":"datetime:2019/5/21 17:51 author:nzb 工具框 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial, QToolBox from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt, QThread, pyqtSignal class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Toolbox' self.left = 600 self.top = 200 self.width = 440 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 生成工具盒子 self.initUI() # 展示窗口 self.show() def initUI(self): \"\"\"工具盒子\"\"\" vbox = QVBoxLayout() toolbox = QToolBox() toolbox.setStyleSheet('background-color:green') vbox.addWidget(toolbox) label = QLabel() toolbox.addItem(label, \"Python\") label = QLabel() toolbox.addItem(label, \"Java\") label = QLabel() toolbox.addItem(label, \"PHP\") self.setLayout(vbox) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/23-菜单栏工具栏.html":{"url":"Python/第三方库/PyQt5/23-菜单栏工具栏.html","title":"菜单栏工具栏","keywords":"","body":"datetime:2019/5/22 16:57 author:nzb 菜单栏和工具栏 菜单栏 工具栏 import sys from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QAction from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 MenuBar' self.left = 600 self.top = 200 self.width = 440 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") fileMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") fileMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") fileMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/24-文档编辑框.html":{"url":"Python/第三方库/PyQt5/24-文档编辑框.html","title":"文档编辑框","keywords":"","body":"datetime:2019/5/22 17:09 author:nzb 文档编辑框 import sys from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QAction, QTextEdit from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 TextEdit' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") fileMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") fileMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") fileMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/25-字体文本框.html":{"url":"Python/第三方库/PyQt5/25-字体文本框.html","title":"字体文本框","keywords":"","body":"datetime:2019/5/22 17:20 author:nzb 文本框字体的选择 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Font Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/26-颜色文本框.html":{"url":"Python/第三方库/PyQt5/26-颜色文本框.html","title":"颜色文本框","keywords":"","body":"datetime:2019/5/22 17:27 author:nzb 字体颜色 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Color Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/27-打印（文本框）.html":{"url":"Python/第三方库/PyQt5/27-打印（文本框）.html","title":"打印（文本框）","keywords":"","body":"datetime:2019/5/22 17:35 author:nzb 打印 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Print Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) printAction = QAction(QtGui.QIcon(self.iconName), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/28-打印预览.html":{"url":"Python/第三方库/PyQt5/28-打印预览.html","title":"打印预览","keywords":"","body":"datetime:2019/5/22 17:47 author:nzb 打印预览 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 PrintPreview Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) printAction = QAction(QtGui.QIcon(self.iconName), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) printpreviewAction = QAction(QtGui.QIcon(self.iconName), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/29-打印PDF.html":{"url":"Python/第三方库/PyQt5/29-打印PDF.html","title":"打印PDF","keywords":"","body":"datetime:2019/5/23 10:26 author:nzb 打印PDF import sys from PyQt5.QtWidgets import QFileDialog, QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog from PyQt5.QtCore import QFileInfo class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 PDF' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') # 复制 copyAction = QAction(QtGui.QIcon('../img/copy.ico'), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) # 剪切 cutAction = QAction(QtGui.QIcon('../img/cut.png'), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) # 保存 saveAction = QAction(QtGui.QIcon('../img/save.png'), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) # 打印 printAction = QAction(QtGui.QIcon('../img/print.png'), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) # 打印预览 printpreviewAction = QAction(QtGui.QIcon('../img/printpreview.png'), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) # pdf pdfAction = QAction(QtGui.QIcon('../img/pdf.png'), 'PDF', self) pdfAction.triggered.connect(self.pdfExport) fileMenu.addAction(pdfAction) # 退出 exitAction = QAction(QtGui.QIcon('../img/exit.png'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) # 黏贴 pasteAction = QAction(QtGui.QIcon('../img/paste.png'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 字体 fontAction = QAction(QtGui.QIcon('../img/font.png'), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 字体颜色 colorAction = QAction(QtGui.QIcon('../img/color.png'), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) toolbar.addAction(pdfAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) def pdfExport(self): \"\"\"导出PDF\"\"\" fn, _ = QFileDialog.getSaveFileName(self, \"Export PDF\", None, \"PDF files (.pdf);;All Files()\") if fn != '': if QFileInfo(fn).suffix() == \"\": fn += '.pdf' printer = QPrinter(QPrinter.HighResolution) printer.setOutputFormat(QPrinter.PdfFormat) printer.setOutputFileName(fn) self.textEdit.document().print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/30-消息框提示框（带选择的）.html":{"url":"Python/第三方库/PyQt5/30-消息框提示框（带选择的）.html","title":"消息框提示框（带选择的）","keywords":"","body":"datetime:2019/5/23 10:44 author:nzb （带选择的）消息框提示框 import sys from PyQt5.QtWidgets import QFileDialog, QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog, QMessageBox from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog from PyQt5.QtCore import QFileInfo class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Messagebox' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') # 复制 copyAction = QAction(QtGui.QIcon('../img/copy.ico'), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) # 剪切 cutAction = QAction(QtGui.QIcon('../img/cut.png'), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) # 保存 saveAction = QAction(QtGui.QIcon('../img/save.png'), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) # 打印 printAction = QAction(QtGui.QIcon('../img/print.png'), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) # 打印预览 printpreviewAction = QAction(QtGui.QIcon('../img/printpreview.png'), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) # pdf pdfAction = QAction(QtGui.QIcon('../img/pdf.png'), 'PDF', self) pdfAction.triggered.connect(self.pdfExport) fileMenu.addAction(pdfAction) # 退出 exitAction = QAction(QtGui.QIcon('../img/exit.png'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) # 黏贴 pasteAction = QAction(QtGui.QIcon('../img/paste.png'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 字体 fontAction = QAction(QtGui.QIcon('../img/font.png'), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 字体颜色 colorAction = QAction(QtGui.QIcon('../img/color.png'), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 消息框，提示框 helpAction = QAction(QtGui.QIcon('../img/about.ico'), \"About\", self) helpAction.triggered.connect(self.AboutMessageBox) helpMenu.addAction(helpAction) # 带选择的消息框，提示框 choiceAction = QAction(QtGui.QIcon('../img/about.ico'), \"Choice Message\", self) choiceAction.triggered.connect(self.choiceMessageBox) helpMenu.addAction(choiceAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) toolbar.addAction(pdfAction) toolbar.addAction(helpAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) def pdfExport(self): \"\"\"导出PDF\"\"\" fn, _ = QFileDialog.getSaveFileName(self, \"Export PDF\", None, \"PDF files (.pdf);;All Files()\") if fn != '': if QFileInfo(fn).suffix() == \"\": fn += '.pdf' printer = QPrinter(QPrinter.HighResolution) printer.setOutputFormat(QPrinter.PdfFormat) printer.setOutputFileName(fn) self.textEdit.document().print_(printer) def AboutMessageBox(self): \"\"\"消息框提示框\"\"\" message = QMessageBox.about(self, \"About application\", \"this is simple texteditor application\") def choiceMessageBox(self): \"\"\"带选择的消息框和提示框\"\"\" message = QMessageBox.question(self, \"Choice Message\", 'Do you like PyQt5?', QMessageBox.Yes | QMessageBox.No) if message == QMessageBox.Yes: self.textEdit.setText(\"Yes I like PyQt5\") else: self.textEdit.setText(\"No I don't like PyQt5\") if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/31-右键菜单.html":{"url":"Python/第三方库/PyQt5/31-右键菜单.html","title":"右键菜单","keywords":"","body":"datetime:2019/5/23 10:53 author:nzb 右键菜单 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QMenu from PyQt5 import QtGui class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Context Menu' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 展示窗口 self.show() def contextMenuEvent(self, event): \"\"\"右键菜单\"\"\" contextMenu = QMenu(self) newAction = contextMenu.addAction(\"New\") openAction = contextMenu.addAction(\"Open\") quitAction = contextMenu.addAction(\"Quit\") action = contextMenu.exec_(self.mapToGlobal(event.pos())) if action == quitAction: self.close() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/32-选项卡（单选下拉框和多选）.html":{"url":"Python/第三方库/PyQt5/32-选项卡（单选下拉框和多选）.html","title":"选项卡（单选下拉框和多选）","keywords":"","body":"datetime:2019/5/23 11:26 author:nzb 选项卡（单选下拉框和多选） 选项卡 单选和多选 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QGroupBox, QComboBox, QCheckBox, QDialog, QTabWidget, QWidget, QVBoxLayout, QDialogButtonBox, QTabWidget, QLabel, QLineEdit import sys from PyQt5.QtGui import QIcon class Tab(QDialog): \"\"\"选项卡\"\"\" def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Tab Widget\") self.setWindowIcon(QIcon('../img/home.ico')) vbox = QVBoxLayout() tabWidget = QTabWidget() # 按钮 buttonbox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel) buttonbox.accepted.connect(self.accept) buttonbox.accepted.connect(self.reject) # 选项卡 tabWidget.addTab(TabContact(), \"Contact Details\") tabWidget.addTab(TabPersonDetails(), 'Personal Details') vbox.addWidget(tabWidget) vbox.addWidget(buttonbox) self.setLayout(vbox) class TabContact(QWidget): def __init__(self): super().__init__() nameLabel = QLabel(\"Name: \") nameEdit = QLineEdit() phoneLabel = QLabel(\"Phone: \") phoneEdit = QLineEdit() emailLabel = QLabel(\"Email: \") emailEdit = QLineEdit() vbox = QVBoxLayout() vbox.addWidget(nameLabel) vbox.addWidget(nameEdit) vbox.addWidget(phoneLabel) vbox.addWidget(phoneEdit) vbox.addWidget(emailLabel) vbox.addWidget(emailEdit) self.setLayout(vbox) class TabPersonDetails(QWidget): def __init__(self): super().__init__() # 单选下拉框 groupbox = QGroupBox(\"select your gender\") list1 = [\"male\", 'female'] combo = QComboBox() combo.addItems(list1) vbox = QVBoxLayout() vbox.addWidget(combo) groupbox.setLayout(vbox) # 多选 groupbox2 = QGroupBox(\"select your favorite programming language\") python = QCheckBox(\"Python\") cpp = QCheckBox(\"C++\") java = QCheckBox(\"Java\") vbox = QVBoxLayout() vbox.addWidget(python) vbox.addWidget(cpp) vbox.addWidget(java) groupbox2.setLayout(vbox) mainLayout = QVBoxLayout() mainLayout.addWidget(groupbox) mainLayout.addWidget(groupbox2) self.setLayout(mainLayout) if __name__ == \"__main__\": app = QApplication(sys.argv) tabDialog = Tab() tabDialog.show() app.exec_() "},"Python/第三方库/PyQt5/34-可停靠的窗口小部件.html":{"url":"Python/第三方库/PyQt5/34-可停靠的窗口小部件.html","title":"可停靠的窗口小部件","keywords":"","body":"datetime:2019/5/23 13:37 author:nzb 可停靠的窗口小部件 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QPushButton, QStackedWidget, QGroupBox, QComboBox, QDialog, QTabWidget, QWidget, QVBoxLayout, QLabel from PyQt5.QtWidgets import QTextEdit, QDockWidget, QMainWindow, QListWidget import sys from PyQt5.QtGui import QIcon from PyQt5.QtCore import Qt class DockDialog(QMainWindow): \"\"\"可停靠的窗口小部件\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 DockDialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # self.createDockWidget() # 展示窗口 self.show() def createDockWidget(self): menubar = self.menuBar() file = menubar.addMenu(\"File\") file.addAction(\"New\") file.addAction(\"Save\") file.addAction(\"Close\") self.dock = QDockWidget(\"Dockable\", self) self.listwidget = QListWidget() list1 = ['Python', 'C++', 'Java'] self.listwidget.addItems(list1) self.dock.setWidget(self.listwidget) self.setCentralWidget(QTextEdit()) self.addDockWidget(Qt.RightDockWidgetArea, self.dock) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = DockDialog() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/35-日历.html":{"url":"Python/第三方库/PyQt5/35-日历.html","title":"日历","keywords":"","body":"datetime:2019/5/23 13:44 author:nzb 日历 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QDialog, QCalendarWidget, QVBoxLayout, QLabel import sys class Window(QDialog): def __init__(self): super().__init__() self.title = \"PyQt5 QCalender\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.Calender() self.show() def Calender(self): vbox = QVBoxLayout() self.calender = QCalendarWidget() self.calender.selectionChanged.connect(self.onSelectionChanged) self.calender.setGridVisible(True) vbox.addWidget(self.calender) self.label = QLabel() self.label.setFont(QtGui.QFont(\"Sanserif\", 15)) self.label.setStyleSheet('color:green') vbox.addWidget(self.label) self.setLayout(vbox) def onSelectionChanged(self): ca = self.calender.selectedDate() self.label.setText(str(ca)) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) 日历中时间的格式化 from PyQt5.QtCore import QDateTime, QDate,QTime,Qt datetime = QDateTime.currentDateTime() print(datetime.toString()) print(datetime.toString(Qt.ISODate)) print(datetime.toString(Qt.DefaultLocaleLongDate)) # 周四 5月 23 13:46:48 2019 # 2019-05-23T13:46:48 # 2019年5月23日 13:46:48 date = QDate.currentDate() print(date.toString()) print(date.toString(Qt.ISODate)) print(date.toString(Qt.DefaultLocaleLongDate)) # 周四 5月 23 2019 # 2019-05-23 # 2019年5月23日 time = QTime.currentTime() print(time.toString()) print(time.toString(Qt.DefaultLocaleLongDate)) # 13:46:48 # 13:46:48 "},"Python/第三方库/PyQt5/36-单选下拉框.html":{"url":"Python/第三方库/PyQt5/36-单选下拉框.html","title":"单选下拉框","keywords":"","body":"datetime:2019/5/23 14:07 author:nzb 单选下拉框 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys class Window(QDialog): \"\"\"下拉框\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 combobox\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() self.combo = QComboBox() self.combo.addItem(\"Python\") self.combo.addItem(\"Ruby\") self.combo.addItem(\"C++\") self.combo.addItem(\"PHP\") self.combo.currentTextChanged.connect(self.comboChanged) self.label = QLabel() self.label.setFont(QtGui.QFont(\"Sanserif\", 15)) self.label.setStyleSheet(\"color:red\") vbox.addWidget(self.combo) vbox.addWidget(self.label) self.setLayout(vbox) def comboChanged(self): \"\"\"选择事件\"\"\" text = self.combo.currentText() self.label.setText(\"You have selected \" + text) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/37-首字符模糊填充（查询）.html":{"url":"Python/第三方库/PyQt5/37-首字符模糊填充（查询）.html","title":"首字符模糊填充（查询）","keywords":"","body":"datetime:2019/5/23 14:14 author:nzb 首字符模糊填充（查询） from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit class Window(QDialog): \"\"\"模糊查询\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 completer\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() names = ['China', 'USA', 'Pakistan', 'Japan', 'India', 'American', '测试中文'] completer = QCompleter(names) self.lineedit = QLineEdit() self.lineedit.setCompleter(completer) vbox.addWidget(self.lineedit) self.setLayout(vbox) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/38-打开更多的窗口.html":{"url":"Python/第三方库/PyQt5/38-打开更多的窗口.html","title":"打开更多的窗口","keywords":"","body":"datetime:2019/5/23 14:28 author:nzb 打开更多的窗口 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit class Window(QDialog): \"\"\"模糊查询\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QDialog\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() self.btn = QPushButton(\"Open second dialog\") self.btn.setFont(QtGui.QFont(\"Sanserif\", 15)) self.btn.clicked.connect(self.openSecondDialog) vbox.addWidget(self.btn) self.setLayout(vbox) def openSecondDialog(self): \"\"\"打开另一个窗口\"\"\" # 1.只能打开第二个，并且不能移动第一个 # mydialog = QDialog() # mydialog.setModal(True) # mydialog.exec() # 可以无限打开，并且可以在第一个上操作 mydialog = QDialog(self) mydialog.show() App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/39-时间编辑.html":{"url":"Python/第三方库/PyQt5/39-时间编辑.html","title":"时间编辑","keywords":"","body":"datetime:2019/5/23 14:37 author:nzb 时间编辑 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit, QTimeEdit from PyQt5.QtCore import QTime class Window(QWidget): \"\"\"时间编辑\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QDialog\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.MyTime() self.show() def MyTime(self): vbox = QVBoxLayout() time = QTime() time.setHMS(13, 15, 40) timeedit = QTimeEdit() timeedit.setFont(QtGui.QFont('Sanserif', 15)) timeedit.setTime(time) vbox.addWidget(timeedit) self.setLayout(vbox) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/40-列表部件.html":{"url":"Python/第三方库/PyQt5/40-列表部件.html","title":"列表部件","keywords":"","body":"datetime:2019/5/23 14:52 author:nzb 列表部件 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit, QTimeEdit, QListWidget from PyQt5.QtCore import QTime class Window(QWidget): \"\"\"列表部件\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QListWidget\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) vbox = QVBoxLayout() self.list = QListWidget() self.list.insertItem(0, \"Python\") self.list.insertItem(1, \"PHP\") self.list.insertItem(2, \"Java\") self.list.insertItem(3, \"C++\") self.list.clicked.connect(self.listview_clicked) self.label = QLabel() self.setFont(QtGui.QFont(\"Sanserif\", 15)) vbox.addWidget(self.label) vbox.addWidget(self.list) self.setLayout(vbox) self.show() def listview_clicked(self): item = self.list.currentItem() self.label.setText(str(item.text())) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/41-列表部件小示例.html":{"url":"Python/第三方库/PyQt5/41-列表部件小示例.html","title":"列表部件小示例","keywords":"","body":"datetime:2019/5/23 15:25 author:nzb 列表部件小示例 from PyQt5.QtWidgets import QApplication, QDialog, QLineEdit, QMessageBox, QInputDialog, QListWidget, QVBoxLayout, QPushButton, QHBoxLayout from PyQt5.QtGui import QIcon from PyQt5 import QtGui import sys class ProgrammingDialog(QDialog): def __init__(self, name, prolist = None): super(ProgrammingDialog, self).__init__() self.setWindowTitle(\"PyQt5 simple List project\") self.setWindowIcon(QtGui.QIcon('../img/home.ico')) self.name = name self.list = QListWidget() if prolist is not None: self.list.addItems(prolist) self.list.setCurrentRow(0) vbox = QVBoxLayout() for text, slot in ((\"Add\", self.Add), (\"Edit\", self.Edit), (\"Remove\", self.Remove), (\"Sort\", self.Sort), (\"Close\", self.Close)): button = QPushButton(text) button.clicked.connect(slot) vbox.addWidget(button) hbox = QHBoxLayout() hbox.addWidget(self.list) hbox.addLayout(vbox) self.setLayout(hbox) def Add(self): row = self.list.currentRow() title = \"Add {0}\".format(self.name) string, ok = QInputDialog.getText(self, title, title) if ok and string is not None: self.list.insertItem(row, string) def Edit(self): row = self.list.currentRow() item = self.list.item(row) if item is not None: title = \"Edit {0}\".format(self.name) string, ok = QInputDialog.getText(self, title, title, QLineEdit.Normal, item.text()) if ok and string is not None: item.setText(string) def Remove(self): row = self.list.currentRow() item = self.list.item(row) if item is None: return reply = QMessageBox.question(self, \"Remove{0}\".format( self.name), \"Remove{0} '{1}'?\".format( self.name, str(item.text())), QMessageBox.Yes | QMessageBox.No) if reply == QMessageBox.Yes: item = self.list.takeItem(row) del item def Sort(self): self.list.sortItems() def Close(self): self.close() # self.accept() if __name__ == '__main__': programming = [\"Python\", \"Java\", \"PHP\", \"C++\"] app = QApplication(sys.argv) dialog = ProgrammingDialog(\"Language\", programming) dialog.exec_() "},"Python/第三方库/PySide/01-Qt简介.html":{"url":"Python/第三方库/PySide/01-Qt简介.html","title":"Qt简介","keywords":"","body":"Python Qt 简介 Python图形界面开发的几种方案 程序的用户交互界面，英文称之为 UI (user interface) 当一个应用的 UI 比较复杂的时候，命令行方式就不便用户使用了，这时我们需要图形界面。 如果用 Python 语言开发 跨平台 的图形界面的程序，主要有3种选择： Tkinter 基于Tk的Python库，这是Python官方采用的标准库，优点是作为Python标准库、稳定、发布程序较小，缺点是控件相对较少。适合开发小工具，界面比较简单。 wxPython 基于wxWidgets的Python库，优点是控件比较丰富，缺点是稳定性相对差点、文档少、用户少。 PySide2、PyQt5 基于Qt 的Python库，优点是控件比较丰富、跨平台体验好、文档完善、用户多。 缺点是库比较大，发布出来的程序比较大。适合发布功能比较多的正式产品。 注意：现在已经到 PySide6 了 PySide2、PyQt5 简介 PySide2、PyQt5 都是基于著名的 Qt 库。 Qt库里面有非常强大的图形界面开发库，但是Qt库是C++语言开发的，PySide2、PyQt5可以让我们通过Python语言使用Qt。 但是 PySide2、PyQt5 这两者有什么区别呢？ 可以形象地这样说： PySide2 是Qt的 亲儿子 ， PyQt5 是Qt还没有亲儿子之前的收的 义子 （Riverbank Computing这个公司开发的）。 那为什么 PyQt5 这个义子 反而比 PySide2 这个亲儿子更出名呢？ 原因很简单：PySide2 这亲儿子最近（2018年7月）才出生。 但是亲儿子毕竟是亲儿子，Qt准备大力培养，PySide2 或许更有前途。 已经在使用 PyQt5 的朋友不要皱眉， 两个库的使用 对程序员来说，差别很小：它们的调用接口几乎一模一样。 如果你的程序是PyQt5开发的，通常只要略作修改，比如把导入的名字从 PyQt5 换成 PySide2 就行了。反之亦然。 安装 PySide2 很简单，直接执行 pip install pyside2 即可下载安装。 这个库比较大，大概有100M左右，大家耐心等待。 有的朋友，网络比较慢，可以指定国内的安装源，下载安装。 比如，使用豆瓣源下载安装：pip install pyside2 -i https://pypi.douban.com/simple/ 安装PyQt5 如果你选择PyQt5，直接执行 pip install pyqt5-tools 即可同时安装 PyQt5 和 一些重要的工具，比如 Qt designer。 "},"Python/第三方库/PySide/02-界面设计师QtDesigner.html":{"url":"Python/第三方库/PySide/02-界面设计师QtDesigner.html","title":"界面设计师QtDesigner","keywords":"","body":"界面设计师 Qt Designer Qt Designer 简介 QT程序界面的 一个个窗口、控件，就是像上面那样用相应的代码创建出来的。 但是，把你的脑海里的界面，用代码直接写出来，是有些困难的。 很多时候，运行时呈现的样子，不是我们要的。我们经常还要修改代码调整界面上控件的位置，再运行预览。反复多次这样操作。 可是这样，真的…太麻烦了。 其实，我们可以用QT界面生成器 Qt Designer ，拖拖拽拽就可以直观的创建出程序大体的界面。 怎么运行这个工具呢？ Windows下，运行 Python安装目录下 Scripts\\pyside2-designer.exe 这个可执行文件 如果你安装的是pyqt5， 运行 Python安装目录下 Scripts\\pyqt5designer.exe 这个可执行文件 通过 Qt Designer 设计的界面，最终是保存在一个ui文件中的。 大家可以打开这个ui文件看看，就是一个XML格式的界面定义。 动态加载UI文件 有了界面定义文件，我们的Python程序就可以从文件中加载UI定义，并且动态创建一个相应的窗口对象。 如下： from PySide2.QtWidgets import QApplication, QMessageBox from PySide2.QtUiTools import QUiLoader class Stats: def __init__(self): # 从文件中加载UI定义 # 从 UI 定义中动态 创建一个相应的窗口对象 # 注意：里面的控件对象也成为窗口对象的属性了 # 比如 self.ui.button , self.ui.textEdit self.ui = QUiLoader().load('main.ui') self.ui.button.clicked.connect(self.handleCalc) def handleCalc(self): info = self.ui.textEdit.toPlainText() salary_above_20k = '' salary_below_20k = '' for line in info.splitlines(): if not line.strip(): continue parts = line.split(' ') parts = [p for p in parts if p] name, salary, age = parts if int(salary) >= 20000: salary_above_20k += name + '\\n' else: salary_below_20k += name + '\\n' QMessageBox.about(self.ui, '统计结果', f'''薪资20000 以上的有：\\n{salary_above_20k} \\n薪资20000 以下的有：\\n{salary_below_20k}''' ) app = QApplication([]) stats = Stats() stats.ui.show() app.exec_() 如果你使用的是PyQt5 而不是 PySide2，加载UI文件的代码如下 from PyQt5 import uic class Stats: def __init__(self): # 从文件中加载UI定义 self.ui = uic.loadUi(\"main.ui\") 转化 UI文件为 Python 代码 还有一种使用 UI 文件的方式：先把UI文件直接转化为包含界面定义的 Python 代码文件，然后在你的程序中使用定义界面的类 执行如下的命令把 UI 文件直接转化为包含界面定义的 Python 代码文件 pyside2-uic main.ui > ui_main.py 如果你安装的是PyQt5，执行如下格式的命令转化 pyuic5 main.ui > ui_main.py 然后在你的代码文件中这样使用定义界面的类 from PySide2.QtWidgets import QApplication, QMainWindow from ui_main import Ui_MainWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() # 使用ui文件导入定义界面类 self.ui = Ui_MainWindow() # 初始化界面 self.ui.setupUi(self) # 使用界面定义的控件，也是从ui里面访问 self.ui.webview.load('http://www.baidu.com') app = QApplication([]) mainw = MainWindow() mainw.show() app.exec_() 那么我们该使用哪种方式比较好呢？动态加载还是转化为Python代码？ 建议：通常采用动态加载比较方便，因为改动界面后，不需要转化，直接运行，特别方便。 但是，如果你的程序里面有非qt designer提供的控件， 这时候，需要在代码里面加上一些额外的声明，而且可能还会有奇怪的问题。往往就要采用转化Python代码的方法。 界面布局 Layout 我们前面写的界面程序有个问题，如果你用鼠标拖拽主窗口边框右下角，进行缩放，就会发现里面的控件一直保持原有大小不变。这样会很难看。 我们通常希望，随着主窗口的缩放， 界面里面的控件、控件之间的距离也相应的进行缩放。 Qt是通过界面布局 Layout 类来实现这种功能的。 我们最常用的 Layout布局 有4种，分别是 QHBoxLayout 水平布局：把控件从左到右 水平横着摆放，如下所示 QVBoxLayout 垂直布局：把控件从上到下竖着摆放，如下所示 QGridLayout 表格布局：把多个控件 格子状摆放，有的控件可以 占据多个格子，如下所示 QFormLayout 表单布局：表单就像一个只有两列的表格，非常适合填写注册表单这种类型的界面，如下所示 MainWindow 的 Layout 如果我们选择的主窗口是MainWindow类型，要给MainWindow整体设定Layout，必须先添加一个控件到 centralwidget 下面 ，如下 然后才能右键点击 MainWindow，选择布局，如下 调整控件位置和大小 调整 layout 中控件的大小比例可以通过设定控件的 sizePolicy 给不同的值来调整。 调整控件间距要调整控件上下间距，可以给控件添加layout，然后通过设定layout的上下的padding 和 margin 来调整间距。要调整控件的左右间距，可以通过添加 horizontal spacer （弹簧）进行控制，也可以通过layout的左右margin。 调整控件次序有的时候 我们需要调整一个layout里面，控件的上下显示次序，或者左右显示次序，该怎么做呢？如果是简单的两个控件在 layout里面，通常直接拖动就行了。 界面布局步骤建议 先不使用任何 Layout，把所有控件按位置摆放在界面上 然后先从 最内层开始 进行控件的 Layout 设定 逐步拓展到外层 进行控件的 Layout设定 最后调整 layout中控件的大小比例， 优先使用 Layout的 layoutStrentch 属性来控制 从一个窗口跳转到另外一个窗口 程序开始的时候显示一个窗口（比如登录窗口），操作后进入到另外一个窗口，怎么做。 方法很简单，主要就是 实例化另外一个窗口，显示新窗口，关闭老窗口。 如下代码所示 from PySide2 import QtWidgets import sys class Window2(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('窗口2') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('按钮2') grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) class MainWindow(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('窗口1') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('打开新窗口') button.clicked.connect(self.open_new_window) grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) def open_new_window(self): # 实例化另外一个窗口 self.window2 = Window2() # 显示新窗口 self.window2.show() # 关闭自己 self.close() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) 如果经常要在两个窗口来回跳转，可以使用 hide() 方法 隐藏窗口， 而不是 closes() 方法关闭窗口。 这样还有一个好处：被隐藏的窗口再次显示时，原来的操作内容还保存着，不会消失。 弹出模式对话框 有的时候，我们需要弹出一个模式对话框输入一些数据，然后回到 原窗口。 所谓模式对话框，就是弹出此对话框后， 原窗口就处于不可操作的状态，只有当模式对话框关闭才能继续。 参考如下代码 from PySide2 import QtWidgets import sys class MyDialog(QtWidgets.QDialog): def __init__(self): super().__init__() self.setWindowTitle('模式对话框') self.resize(500, 400) self.textEdit = QtWidgets.QPlainTextEdit(self) self.textEdit.setPlaceholderText(\"请输入薪资表\") self.textEdit.move(10, 25) self.textEdit.resize(300, 350) self.button = QtWidgets.QPushButton('统计', self) self.button.move(380, 80) class MainWindow(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('主窗口') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('打开模式对话框') button.clicked.connect(self.open_new_window) grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) def open_new_window(self): # 实例化一个对话框类 self.dlg = MyDialog() # 显示对话框，代码阻塞在这里， # 等待对话框关闭后，才能继续往后执行 self.dlg.exec_() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) "},"Python/第三方库/PySide/03-发布程序.html":{"url":"Python/第三方库/PySide/03-发布程序.html","title":"发布程序","keywords":"","body":"正式发布程序 前面，我们开发好了一个HTTP协议测试程序，但是这个程序是Python程序，运行它需要Python解释器。 如果我们要发布程序给客户使用，当然不能要求别人去安装Python解释器，并且敲命令 python httpclient.py。 我们应该做成 可执行程序 发布别人使用。详情 我们前面开发的QT界面程序，在Windows 上只需要执行下面的命令，即可制作独立exe程序 pyinstaller httpclient.py --noconsole --hidden-import PySide2.QtXml这样就会在当前目录下产生一个名为 dist 的目录。里面就有一个名为 httpclient 的目录，我们的可执行程序 httpclient.exe 就在里面。 其中 --noconsole 指定不要命令行窗口，否则我们的程序运行的时候，还会多一个黑窗口。 但是我建议大家可以先去掉这个参数，等确定运行成功后，再加上参数重新制作exe。因为这个黑窗口可以显示出程序的报错，这样我们容易找到问题的线索。 --hidden-import PySide2.QtXml 参数是因为这个 QtXml库是动态导入，PyInstaller没法分析出来，需要我们告诉它， 最后，别忘了，把程序所需要的ui文件拷贝到打包目录中。 因为PyInstaller只能分析出需要哪些代码文件。 而你的程序动态打开的资源文件，比如 图片、excel、ui这些，它是不会帮你打包的。 我们的 示例代码需要从 httpclient.ui 中加载界面，手动拷贝到 dist/httpclient 目录中。 然后，再双击运行 httpclient.exe ，完美！！ 程序图标 添加主窗口图标我们程序运行的窗口，需要显示自己的图标，这样才更像一个正式的产品。 通过如下代码，我们可以把一个png图片文件作为 程序窗口图标。 from PySide2.QtGui import QIcon app = QApplication([]) # 加载 icon app.setWindowIcon(QIcon('logo.png')) 注意：这些图标png文件，在使用PyInstaller创建可执行程序时，也要拷贝到程序所在目录。否则可执行程序运行后不会显示图标。 应用程序图标 应用程序图标是放在可执行程序里面的资源。 可以在PyInstaller创建可执行程序时，通过参数 --icon=\"logo.ico\" 指定。 比如 pyinstaller httpclient.py --noconsole --hidden-import PySide2.QtXml --icon=\"logo.ico\" 注意参数一定是存在的ico文件，不能是png等图片文件。 如果你只有png文件，可以通过在线的png转ico文件网站，生成ico，比如下面两个网站 网站1 网站2 注意：这些应用程序图标ico文件，在使用PyInstaller创建可执行程序时，不需要要拷贝到程序所在目录。因为它已经被嵌入可执行程序了。 "},"Python/第三方库/PySide/04-常用控件1.html":{"url":"Python/第三方库/PySide/04-常用控件1.html","title":"常用控件1","keywords":"","body":"常用控件 1 按钮 QPushButton 就是常见的按钮 信号：被点击 当按钮被点击就会发出 clicked 信号，可以这样指定处理该信号的函数 button.clicked.connect(handleCalc) 方法：改变文本 代码中可以使用 setText 方法来改变按钮文本，比如 button.setText(text) 方法：禁用、启用所有控件（继承自QWidget类）都支持 禁用和启用方法。 禁用后，该控件不再处理用户操作 禁用 button.setEnabled(False) 启用 button.setEnabled(True) 单行文本框 QLineEdit 是只能单行编辑的文本框。 信号：文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数edit.textChanged.connect(handleTextChange)Qt在调用这个信号处理函数时，传入的参数就是 文本框目前的内容字符串。 信号：按下回车键当用户在文本框中任何时候按下回车键，就会发出 returnPressed 信号。有时我们需要处理这种情况，比如登录界面，用户输完密码直接按回车键就进行登录处理，比再用鼠标点击登录按钮快捷的多。 可以指定处理 returnPressed 信号，如下所示passwordEdit.returnPressed.connect(onLogin) 方法：获取文本通过 text 方法获取编辑框内的文本内容，比如text = edit.text() 方法：设置提示通过 setPlaceholderText 方法可以设置提示文本内容，比如edit.setPlaceholderText('请在这里输入URL') 方法：设置文本通过 setText 方法设置编辑框内的文本内容为参数里面的文本字符串，比如edit.setText('你好，白月黑羽')原来的所有内容会被清除 方法：清除所有文本clear 方法可以清除编辑框内所有的文本内容，比如edit.clear() 方法：拷贝文本到剪贴板 copy 方法可以拷贝当前选中文本到剪贴板，比如edit.copy() 方法：粘贴剪贴板文本 paste 方法可以把剪贴板内容，拷贝到编辑框当前光标所在处，比如 edit.paste() 多行纯文本框 QPlainTextEdit 是可以多行的纯文本编辑框。 注意：在苹果MacOS上，有 更新文本框内容后，需要鼠标滑过才能更新显示的bug，参考这里 信号：文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数edit.textChanged.connect(handleTextChange) 注意： Qt在调用这个信号处理函数时，不会传入文本框目前的内容字符串，作为参数。这个行为 和 单行文本框不同。 信号：光标位置改变当文本框中的光标位置变动，就会发出 cursorPositionChanged 信号，可以这样指定处理该信号的函数 edit.cursorPositionChanged.connect(handleChanged) 方法：获取文本通过 toPlainText 方法获取编辑框内的文本内容，比如text = edit.toPlainText() 方法：获取选中文本 # 获取 QTextCursor 对象 textCursor = edit.textCursor() selection = textCursor.selectedText() 方法：设置提示通过 setPlaceholderText 方法可以设置提示文本内容，比如edit.setPlaceholderText('请在这里输入薪资表') 方法：设置文本通过 setPlainText 方法设置编辑框内的文本内容 为参数里面的文本字符串，比如edit.setPlainText('''你好，白月黑羽 hello byhy''')原来的所有内容会被清除 方法：在末尾添加文本通过 appendPlainText 方法在编辑框末尾添加文本内容，比如 edit.appendPlainText('你好，白月黑羽')注意：这种方法会在添加文本后 自动换行 方法：在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如edit.insertPlainText('你好，白月黑羽')注意：这种方法 不会 在添加文本后自动换行 方法：清除所有文本 clear 方法可以清除编辑框内所有的文本内容，比如edit.clear() 方法：拷贝文本到剪贴板 copy 方法可以拷贝当前选中文本到剪贴板，比如edit.copy() 方法：粘贴剪贴板文本 paste 方法可以把剪贴板内容，拷贝到编辑框当前光标所在处，比如edit.paste() 文本浏览框 QTextBrowser 是只能查看文本控件。通常用来显示一些操作日志信息、或者不需要用户编辑的大段文本内容。该控件 获取文本、设置文本、清除文本、剪贴板复制粘贴 等等， 都和上面介绍的 多行纯文本框是一样的。 方法：在末尾添加文本通过 append 方法在编辑框末尾添加文本内容，比如textBrowser.append('你好，白月黑羽')有时，浏览框里面的内容长度超出了可见范围，我们在末尾添加了内容，往往希望控件自动翻滚到当前添加的这行， 可以通过 ensureCursorVisible 方法来实现 textBrowser.append('你好，白月黑羽') textBrowser.ensureCursorVisible() 注意：这种方法会在添加文本后 自动换行 方法：在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如edit.insertPlainText('你好，白月黑羽') 注意：这种方法不会在添加文本后自动换行 标签 QLabel 就是常见的标签，可以用来显示文字（包括纯文本和富文本）、图片 甚至动画。 方法：改变文本代码中可以使用 setText 方法来改变标签文本内容，比如 button.setText(text) 显示图片QLabel 可以用来显示图片，有时一个图片可以让界面好看很多，如下图所示 怎么用 QLabel 显示图片呢？可以在 Qt Designer 上 属性编辑器 QLabel 栏 的 pixmap 属性设置中选择图片文件指定。 "},"Python/第三方库/PySide/05-常用控件2.html":{"url":"Python/第三方库/PySide/05-常用控件2.html","title":"常用控件2","keywords":"","body":"常用控件2 组合选择框 QComboBox 是组合选择框，如下图所示 信号：选项改变如果用户操作修改了QComboBox中的选项就会发出 currentIndexChanged 信号，可以这样指定处理该信号的函数cbox.currentIndexChanged.connect(handleSelectionChange) 方法：添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本cbox.addItem('byhy') 方法：添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表cbox.addItems(['byhy','白月黑羽','python教程']) 方法：清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项cbox.clear() 方法：获取当前选项文本代码中可以使用 currentText 方法来获取当前 选中的选项 的文本，比如method = cbox.currentText() 列表 QListWidget 是列表控件，如下图所示Qt Designer如下图 选择： 方法：添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本listWidget.addItem('byhy') 方法：添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表listWidget.addItems(['byhy','白月黑羽','python教程']) 方法：删除一个选项代码中可以使用 takeItem 方法来删除1个选项，参数是该选项所在行listWidget.takeItem(1)就会删除第二行选项 方法：清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项listWidget.clear() 方法：获取当前选项文本currentItem 方法可以得到列表当前选中项对象（QListWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如listWidget.currentItem().text()就获取了 第1行，第1列 的单元格里面的文本。listWidget.currentItem().text() 表格 QTableWidget 是表格控件，如下图所示Qt Designer 如下图 选择： 创建列和标题栏 我们可以通过 Qt designer 为一个表格创建列和对应的标题栏。只需要双击 Qt designer 设计的窗体中的 表格控件， 就会出现这样的对话框。 在列标签栏中，点击左下角的加号，就可以为 添加一个列，并且设置标题栏名称。 方法：插入一行、删除一行 insertRow 方法可以在指定位置插入一行，比如table.insertRow(0)就插入一行到第 1 行这个位置， 表格原来第1行（包括原来的第1行）以后的内容，全部往下移动一行。table.insertRow(2)就插入一行到第 3 行这个位置， 表格原来第3行（包括原来的第3行）以后的内容，全部往下移动一行。removeRow 方法可以删除指定位置的一行，比如table.removeRow(0) 就删除第 1 行， 表格原来第1行以后的内容，全部往上移动一行。table.removeRow(2)就删除第 3 行， 表格原来第3行以后的内容，全部往上移动一行。 方法：设置单元格文本内容qt表格的单元格内的内容对象 是一个 单元格对象 QTableWidgetItem 实例 如果单元格 没有被设置过 内容，可以这样 from PySide2.QtWidgets import QTableWidgetItem item = QTableWidgetItem() item.setText('白月黑羽') table.setItem(row, 0, item) 也可以简写为 from PySide2.QtWidgets import QTableWidgetItem table.setItem(row, 0, QTableWidgetItem('白月黑羽')) 如果单元格 已经被设置过 文本内容，item 方法可以获取指定位置的 QTableWidgetItem ，再调用这个对象的 setText 方法，就可以设置单元格文本内容，比如table.item(0,0).setText('白月黑羽-江老师')就设置了 第1行，第1列 的单元格里面的文本。table.item(2,4).setText('白月黑羽-江老师')就设置了 第3行，第5列 的单元格里面的文本。如果希望某个单元格为 只读，不允许修改，可以使用QTableWidgetItem对象的 setFlags 方法，像这样 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem('白月黑羽') item.setFlags(Qt.ItemIsEnabled) # 参数名字段不允许修改 table.setItem(row, 0, item) 如果想文本内容 居中对齐，每个当对应的QTableWidgetItem 调用 setTextAlignment，如下 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem() item.setText('白月黑羽') # 文本居中 item.setTextAlignment(Qt.AlignHCenter) table.setItem(row, 0, item) 方法：获取单元格文本的内容item 方法可以指定位置的单元格对象（QTableWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如table.item(0,0).text()就获取了 第1行，第1列 的单元格里面的文本。table.item(2,4).text() 就获取了 第3行，第5列 的单元格里面的文本。 方法：获取所有行数、列数代码中可以使用 rowCount 方法来获取表格所有的 行数 ，比如rowcount = table.rowCount()可以使用 columnCount 方法来获取表格所有的 列数 ，比如rowcount = table.columnCount() 方法：获取当前选中是第几行代码中可以使用 currentRow 方法来获取当前选中是第几行，比如currentrow = table.currentRow()注意：行数是从0开始的， 第一行的行数是 0 方法：设置表格行数、列数代码中可以使用 setRowCount 方法来设置表格 行数 ，比如table.setRowCount(10)代码中可以使用 setColumnCount 方法来设置表格 列数 ，比如table.setColumnCount(10) 方法：清除/删除所有内容clearContents 方法可以清除表格所有的内容，比如table.clearContents()清除后，仍然会留下表格栏如果连表格栏都要删除，可以使用 setRowCount(0)，像这样table.setRowCount(0) 方法：设定列宽、宽度自动缩放Qt Designer 上目前没法拖拽设定 每个列的宽度，只能在代码中指定。如下所示 # 设定第1列的宽度为 180像素 table.setColumnWidth(0, 180) # 设定第2列的宽度为 100像素 table.setColumnWidth(1, 100) 如想让 表格控件宽度 随着父窗口的缩放自动缩放，可以 在 属性编辑器 中 勾选 HorizontalHeaderStretchLastSection或者使用下面代码table.horizontalHeader().setStretchLastSection(True) 信号：单元格内容改动当用户修改了一个单元格的内容，会发出 cellChanged 信号，并且携带参数指明该单元格的行号和列号。 我们的代码可以对该信号进行相应的处理。示例代码如下 def __init__(self): # 指定单元格改动信号处理函数 self.ui.table.cellChanged.connect(self.cfgItemChanged) def cfgItemChanged(self, row, column): # 获取更改内容 cfgName = self.ui.table.item(row, 0).text() # 首列为配置名称 cfgValue = self.ui.table.item(row, column).text() "},"Python/第三方库/PySide/06-常用控件3.html":{"url":"Python/第三方库/PySide/06-常用控件3.html","title":"常用控件3","keywords":"","body":"常用控件3 单选按钮和按钮组 QRadioButton 是单选按钮，如下图所示 说明同一个父窗口 里面的多个单选按钮，只能选中一项。如果你有多组单选按钮， 每组都应该有不同的父控件，或者不同的Layout。通常建议：多组单选按钮，放到不同的 按钮组 QButtonGroup 中 信号：选中状态改变如果用户操作点击了按钮组 QButtonGroup 中的一个按钮， QButtonGroup 就会发出 buttonClicked 信号，可以这样指定处理该信号的函数buttongroup.buttonClicked.connect(handleButtonClicked)然后，在处理函数中调用QButtonGroup对象的 checkedButton() 函数，返回值就是被选中的按钮对象。再调用这个返回的按钮对象的 text() 方法得到界面文本，就可以知道是哪个选项被选中了。 勾选按钮和按钮组 QCheckBox 是勾选按钮，如下图所示 说明通常建议：多组勾选按钮，放到不同的 按钮组 QButtonGroup 中，按钮组就是父控件。可以在 Qt设计师中设置 QButtonGroup 的 exclusive 属性， 来控制 是否 只能单选一个选项。 信号：选中状态改变如果用户操作点击了按钮组 QButtonGroup 中的一个按钮， QButtonGroup 就会发出 buttonClicked 信号，可以这样指定处理该信号的函数buttongroup.buttonClicked.connect(handleButtonClicked)QButtonGroup 设置为 单选 情况下： 在处理函数中调用QButtonGroup对象的 checkedButton() 函数，返回值就是被选中的按钮对象。 再调用这个返回的按钮对象的 text() 方法得到界面文本，就可以知道是哪个选项被选中了。 QButtonGroup 设置为 多选 情况下：要得知哪些按钮被选中， 可以 对所有该组中的 按钮调用 isChecked 方法 ，来判断。 tab页控件 我们可以通过tab页控件把界面分为好几个页面，如下所示通过Qt designer 只需要拖拽控件到各个页面即可。要修改 tab 页的标题，可以先点击该 tab 页，然后在下图所示处修改 tab页中布局Layout 如果要在tab页上布局， 你可能会在对象查看器总直接右键点击该tab，可以你会发现 右键菜单里面没有布局项。 这是 Qt designer 非常坑爹的地方。 首先需要你在tab页上添加一个控件 然后点击 在对象查看器 右键点击上层 TabWidget ，这时，你就会发现有布局菜单了 进度条 QProgressBar 是进度条，如下图所示 说明进度条也是一个常用的控件，当程序需要做一件比较耗费时间的任务（比如统计数据，下载文件等）时，可以用来向用户指示操作的进度。而且有了进度显示，用户就知道应用程序仍在运行，并没有出问题。QProgressBar进度条把每个进度称之为一个step（步骤）。我们可以通过它的 setRange 方法设定步骤个数，比如progressBar.setRange(0,5)就设定了，进度分为5步。然后，通过 setValue 方法，指定当前完成到了哪一步，比如progressBar.setValue(3) 就表示完成了 3/5， 也就是 60%， 进度条就会显示60%的进度。可以使用reset()将进度条倒退到开头。有时候我们的任务没法知道完成了多少，比如下载一个未知大小的文件。这时，可以把 range 范围都设置为0，这样，进度条会显示忙碌指示符，而不是显示进度百分比。下面是一个进度条程序的示例代码 from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QProgressBar,QMessageBox from time import sleep from threading import Thread class Stats(): def __init__(self): self.window = QMainWindow() self.window.resize(500, 400) self.window.move(300, 300) self.progressBar = QProgressBar(self.window) self.progressBar.resize(300, 20) self.progressBar.move(80, 30) # 进度是 0 - 5， self.progressBar.setRange(0,5) self.button = QPushButton('统计', self.window) self.button.move(80, 80) self.button.clicked.connect(self.handleCalc) # 统计进行中标记，不能同时做两个统计 self.ongoing = False def handleCalc(self): def workerThreadFunc(): self.ongoing = True for i in range(1,6): sleep(1) # 设置进度值 self.progressBar.setValue(i) self.ongoing = False if self.ongoing: QMessageBox.warning( self.window, '警告','任务进行中，请等待完成') return # 通常任务执行比较耗时，应该在新的线程中进行 # 否则会阻塞主线程显示界面 worker = Thread(target=workerThreadFunc) worker.start() app = QApplication([]) stats = Stats() stats.window.show() app.exec_() 上面的代码，运行时，会有很多告警，因为我们在新线程中操作界面对象，容易出问题。更合理的方法是通过信号，在线程之间传递信息，对界面的操作都在主线程中完成。如下 ```python from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QProgressBar, QMessageBox from time import sleep from threading import Thread from PySide2.QtCore import Signal, QObject 信号库 class SignalStore(QObject): # 定义一种信号 progress_update = Signal(int) # 还可以定义其他作用的信号 实例化 so = SignalStore() class Stats(): def init(self): # 连接信号到处理的slot函数 so.progress_update.connect(self.setProgress) self.window = QMainWindow() self.window.resize(500, 400) self.window.move(300, 300) self.progressBar = QProgressBar(self.window) self.progressBar.resize(300, 20) self.progressBar.move(80, 30) # 进度是 0 - 5， self.progressBar.setRange(0, 5) self.button = QPushButton('统计', self.window) self.button.move(80, 80) self.button.clicked.connect(self.handleCalc) # 统计进行中标记，不能同时做两个统计 self.ongoing = False def handleCalc(self): def workerThreadFunc(): self.ongoing = True for i in range(1, 6): sleep(1) # 发出信息，通知主线程进行进度处理 so.progress_update.emit(i) self.ongoing = False if self.ongoing: QMessageBox.warning( self.window, '警告', '任务进行中，请等待完成') return worker = Thread(target=workerThreadFunc) worker.start() # 处理进度的slot函数 def setProgress(self, value): self.progressBar.setValue(value) app = QApplication([]) stats = Stats() stats.window.show() app.exec_() ### 数字输入框 `QSpinBox` 是数字输入框，可以输入或使用上下箭头选择数字，如下图所示 ![](./imgs/qspinbox.png) - 获取数字 通过 `value` 方法获取编辑框内的文本内容，比如 `number = box.value()` 注意：返回的是整数对象，不是字符串 - 方法：设置数字 通过 `setValue` 方法可以设置提示文本内容，比如 `box.setValue(100)` ### 日期控件 `QDateEdit` 类可以用来选择日期时间，如下图所示 ![](./imgs/windows-dateedit.png) 获取日期 当用户点击日期时间控件并且选取了 日期和时间，后来程序要获取这个控件里面选定的日期时间，可以使用date方法获取日期对象。 如下所示 ```python # 返回 PySide2.QtCore.QDate 对象 qdate = dateEdit.date() # 可以转化为 指定格式的字符串 dateStr = qdate.toString('yyyy-MM-dd') # 也可以获取年月日 对应的数字 ，比如日期是2020年5月2号 year = qdate.year() # 返回 2020 month = qdate.month() # 返回 5 day = qdate.day() # 返回 2 选择文件框 QFileDialog 类可以用来选择文件或者目录，如下图所示 选择目录通过 getExistingDirectory 静态方法 选择目录。该方法，第一个参数是父窗口对象，第二个参数是选择框显示的标题。比如 from PySide2.QtWidgets import QFileDialog filePath = QFileDialog.getExistingDirectory(self.ui, \"选择存储路径\") 返回值即为选择的路径字符串。如果用户点击了 选择框的 取消选择按钮，返回 空字符串。 选择单个文件 如果你想弹出文件选择框，选择一个 已经存在 的文件，可以使用 QFileDialog 静态方法 getOpenFileName ，比如 from PySide2.QtWidgets import QFileDialog filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 该方法返回值 是一个元组，第一个元素是选择的文件路径，第二个元素是文件类型，如果你只想获取文件路径即可，可以采用上面的代码写法。如果用户点击了 选择框的 取消选择按钮，返回 空字符串。如果你想弹出文件选择框，选择路径和文件名，来 保存一个文件 ，可以使用 QFileDialog 静态方法 getSaveFileName ，比如 from PySide2.QtWidgets import QFileDialog filePath, _ = QFileDialog.getSaveFileName( self.ui, # 父窗口对象 \"保存文件\", # 标题 r\"d:\\\\data\", # 起始目录 \"json类型 (*.json)\" # 选择类型过滤项，过滤内容在括号中 ) 选择多个文件如果要选择多个文件，使用 getOpenFileNames 静态方法 from PySide2.QtWidgets import QFileDialog filePaths, _ = QFileDialog.getOpenFileNames( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 上例中 filePaths 对应的返回值是一个列表，里面包含了选择的文件。如果用户点击了 选择框的 取消选择按钮，返回 空列表。 "},"Python/第三方库/PySide/07-常用控件4.html":{"url":"Python/第三方库/PySide/07-常用控件4.html","title":"常用控件4","keywords":"","body":"常用控件4 树控件 QTreeWidget 树控件树控件， 是和 QTreeWidgetItem 树节点控件 结合使用的。如下图所示 提示框 QMessageBox 类可以用来弹出各种提示框 该类可以通过一系列静态方法，显示 如下弹出框 错误报告使用 critical 方法 QMessageBox.critical( self.ui, '错误', '请选择爬取数据存储路径！') 警告使用 warning 方法 QMessageBox.warning( self.ui, '阅读太快', '阅读客户协议必须超过1分钟') 信息提示使用 information 方法 QMessageBox.information( self.ui, '操作成功', '请继续下一步操作') 也可以使用 about 方法 QMessageBox.about( self.ui, '操作成功', '请继续下一步操作') 确认继续使用 question 方法 choice = QMessageBox.question( self.ui, '确认', '确定要删除本文件吗？') if choice == QMessageBox.Yes: print('你选择了yes') if choice == QMessageBox.No: print('你选择了no') 输入对话框 QInputDialog 输入对话框 只让用户输入一行数据信息，比如 姓名、年龄等。可以方便的用来获取简单的信息。比如 from PySide2.QtWidgets import QInputDialog, QLineEdit # 返回值分别是输入数据 和 是否点击了 OK 按钮（True/False） title, okPressed = QInputDialog.getText( self, \"输入目录名称\", \"名称:\", QLineEdit.Normal, \"\") if not okPressed: print('你取消了输入') 常用的方法有： getText弹出对话框，让用户输入 单行文本 getMultiLineText弹出对话框，让用户输入 多行文本 getInt弹出对话框，让用户输入 整数 getItem弹出对话框，让用户选择 选项 items = [\"春天\", \"夏天\", \"秋天\", \"冬天\"] item, ok = QInputDialog().getItem(self, \"请选择\", \"季节:\", items, 0, False) if ok and not item.isEmpty(): itemLabel.setText(item) 菜单 可以在 Qt Designer上很方便的添加菜单，如下所示点击菜单的信号是 triggered， 处理点击菜单的的代码如下self.ui.actionOpenFile.triggered.connect(self.openPageFile)注意：如果菜单和工具栏有 相同的 action ，通常是先在 动作编辑器 创建一个action， 然后分别拖动到 菜单和工具栏 工具栏 在 Qt 设计师上添加工具栏，可以右键点击 Main Window 类型的窗体空白处，如下所示选择添加工具栏注意，只有 Main Window 类型的窗体，才能添加工具栏，如下添加工具栏后，还要在工具栏上添加图标。 方法是点击右下角 动作编辑器，新建动作，如下图所示然后如下图所示进行设置添加动作成功后，就可以直接拖到工具栏上了。然后，在代码中定义动作触发后的处理函数，如下所示 self.ui.actionAddNote.triggered.connect(self.actionAddNode) 状态栏 要在状态栏显示文本信息，只需要调用 QStatusBar 的 showMessage 方法self.ui.statusbar.showMessage(f'打开文件{filePath}') 剪贴板 Qt程序可以获取和设置剪贴板内容 from PySide2.QtGui import QGuiApplication cb = QGuiApplication.clipboard() # 获取剪贴板内容 originalText = cb.text() # 设置剪贴板内容 clipboard.setText(newText) MDI 多个子窗口 QMdiArea 提供了一个主窗口区，里面可以存放多个 QMdiSubWindow 子窗口如图： "},"Python/第三方库/OpenCV/01-图像基本操作.html":{"url":"Python/第三方库/OpenCV/01-图像基本操作.html","title":"图像基本操作","keywords":"","body":"datetime:2022/04/11 15:07 author:nzb 图像基本操作 数据读取 图像 读取图像使用imread()函数 img = cv2.imread(\"test.jpg\") opencv读取的格式是：BGR img.shape：获得图像的大小，返回的元组（tuple）中的三个数依次表示高度、宽度和通道数（蓝通道、绿通道、红通道）。 img.dtype：获得图片的类型。uint8是一个 8 位无符号整数。图像的RGB分量通常用 0 到 255 的 256 个灰度表示。例如，红色像素为 (R,G,B)=(255,0,0) ，白色是 (R,G,B)=( 255,255,255) 。如果图像不以这个类型保存的话，图像会变得很奇怪。 cv2.imshow()：来显示图像。cv2.imshow()的第一个参数是窗口的名字（不写也没有关系），第二个参数是要显示的图像的名称，一定要写。 cv2.imshow('image', img) cv2.waitKey(0) cv2.destroyAllWindows() img.astype(np.float32)：让img的类型变更为float32的话，可以使用astype()。 如果用这种类型显示图片，就会变成得很奇怪。所以当你想要操作图像时： 使用cv2.imread读取图像； 将图像的类型变为浮点型np.float32； 操作图像； 像素值不满 0 的将值设置为 0 ，像素值超过 255 的将值设置为 255 （超重要）； img = np.clip（img, 0 , 255） 或者 img.clip（0，255） 将图像类型变更为np.uint8并保存； astype(np.uint8) img2 = img.copy()：拷贝图像 cv2.imwrite()：保存图像 cv2.imwrite(\"sample.jpg\", img2)：例如之前的被保存为名称为的图像，如果返回值为的话，这就说明该图像被保存在同一个文件夹中，文件名为。 视频 cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如0,1。 vc = cv2.VideoCapture(\"../img/test.mp4\") 如果是视频文件，直接指定好路径即可。 操作像素 例如，操作 x=30,y=20 的像素值时，进行以下的操作。像素值是按 BGR 的顺序排列的。array() 表示这个图像是 NumPy 格式。也就是说，OpenCV 是 NumPy 的高层封装。 img[20,30] 更进一步，要得到 x=30,y=20 处的 G 分量，可以使用以下代码 img[20,30,1] 切片 例如要查看 y=20, x=[30, 32] 这个范围之内（的像素）时，如果设置为30:33可以得到一个矩阵。如果设置a:b，可以获得在 a img[20, 30:33] 例如将图片左上角（ x=[0, 50], y = [0, 50] ）设置为黑色，是照下面这样做。copy()这个函数在后面介绍。 img2[:50, :50] = 0 获取颜色通道 b,g,r = cv2.split(img) 合并颜色通道 cv2.merge((b,g,r)) # 合并 之前有提到：像素的值小于 0 的时候设置为 0，超过 255 的时候修改为 255。 例如，图像的类型为float32，将一部分的B分量改为 260。uint8类型的整数范围只能取 [0,255] ，如果变成uint8型的话蝾螈的颜色一部分就会变成黄色的。 这是因为，如果将 260 变为uint8型的话，因为 260-256，所以会让B的值为 4。经常会由于这个原因让像素的值变得不正确。所以上面的第四步的操作（限定值的范围在[0,255]之间）是必要的。 边界填充 cv2.copyMakeBorder（） 选项 BORDER_REPLICATE：复制法，也就是复制最边缘像素。 BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制 例如：fedcba|abcdefgh|hgfedcb BORDER_REFLECT_101：反射法，也就是以最边缘像素为轴，对称 gfedcb|abcdefgh|gfedcba BORDER_WRAP：外包装法 cdefgh|abcdefgh|abcdefg BORDER_CONSTANT：常量法，常数值填充。 图像缩放 cv2.resize(src， dsize[， dst[， fx[， fy[，interpolation]]]]) 选项 src：必须，原图像 dsize：必须，输出图像所需大小 fx：可选，沿水平轴的比例因子 fy：可选，沿垂直轴的比例因子 interpolation：可选，插值方式 通常的，缩小使用cv.INTER_AREA，放缩使用cv.INTER_CUBIC(较慢)和cv.INTER_LINEAR(较快效果也不错)。默认情况下，所有的放缩都使用cv.INTER_LINEAR。 cv2.INTER_NEAREST：最近邻插值 cv2.INTER_LINEAR：双线性插值 cv2.INTER_CUBIC：双线性插值 cv2.INTER_AREA：使用像素区域关系重新采样。它可能是图像抽取的首选方法，因为它可以提供无莫尔条纹的结果。但是当图像被缩放时，它类似于INTER_NEAREST方法。 示例 cv2.resize（img，（0，0），fx=5，fy=5）：按不同比例缩放 cv2.resize（img，（400，500））：缩放成高400，宽500的大小 图像融合 两张图片维度需要一样 cv2.addWeighted() cv2.addWeighted（img_cat， 0.4，img_dog， 0.6，0） R = αx + βy + b；其中α和β是对应的权重，哪个值大就更明显，b是亮度级上提亮 图片拼接展示 需要注意的是图片维度需要一样 水平拼接 res = np.hstack((blur1,gussian,median)) # 水平拼接 cv2.imshow('median vs gussian vs median', res) cv2.waitKey(0) cv2.destroyAllWindows() 垂直拼接 res = np.vstack((blur1,gussian,median)) # 水平拼接 x, y, w, h作为参数的时候获取图像 操作像素：img [ y ：y + h， x：x + w ] 作为参数传递函数时：（x，y）或者（x + w，y + h） "},"Python/第三方库/OpenCV/02-图像处理.html":{"url":"Python/第三方库/OpenCV/02-图像处理.html","title":"图像处理","keywords":"","body":"datetime:2022/04/11 15:07 author:nzb 图像处理 灰度图 灰度是一种图像亮度的表示方法 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY ) 二值化（图像阈值） ret, dst = cv2.threshold(src, thresh, maxval, type) 简单二值化 src： 输入图，只能输入单通道图像，通常来说为灰度图 dst： 输出图 thresh（ret）： 阈值 maxval： 当像素值超过了阈值（或者小于阈值，根据type来决定），所赋予的值 最大：255 type：二值化操作的类型，包含以下5种类型 cv2.THRESH_BINARY：超过阈值部分取maxval（最大值），否则取0 cv2.THRESH_BINARY_INV：THRESH_BINARY的反转 cv2.THRESH_TRUNC：大于阈值部分设为阈值，否则不变 cv2.THRESH_TOZERO：大于阈值部分不改变，否则设为0 cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转 ret2,dst2= cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU) Otsu （大津）二值化：找到最合适的阈值，其中threshold设置为0配合cv2.THRESH_OTSU，寻找最适合的阈值 示例 HSV变换 HSV即使用：色相（Hue）、饱和度（Saturation）、明度（Value）来表示色彩的一种方式。 色相：将颜色使用0∘到360∘表示，就是平常所说的颜色名称，如红色、蓝色。 饱和度：是指色彩的纯度，饱和度越低则颜色越黯淡（0≤S 明度：即颜色的明暗程度。数值越高越接近白色，数值越低越接近黑色（0≤V hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) 图像滤波 图像降噪，使图像更清晰，更平滑 均值滤波 blur1 = cv2.blur(noise_img, (3,3)) 3 * 3的卷积核 方框滤波 基本和均值一样，可以选择归一化 归一化 计算均值滤波 blur2 = cv2.boxFilter(noise_img,-1, (3,3), normalize=True) -1是固定值，一般不需要改变 未归一化 容易越界（未取均值，超过255，一旦越界就取255） blur3 = cv2.boxFilter(noise_img,-1, (3,3), normalize=False) 高斯滤波 更看重权重，离目标远的权重小，离目标近的权重大 gussian = cv2.GaussianBlur(noise_img, (5, 5), 1) 5*5的卷积核 中值滤波 median = cv2.medianBlur(noise_img, 5) 5*5的卷积核 形态学处理 处理二值化图像，获取轮廓 腐蚀=瘦身，膨胀=增 腐蚀（Erode） kernel = np.ones((3,3), dtype=np.uint8) 核 erode_img = cv2.erode(img, kernel, iterations=1) iterations：迭代（腐蚀）次数 不同腐蚀次数的变化 膨胀（Dilate） kernel = np.ones((3,3), dtype=np.uint8) 核 dilate_img = cv2.dilate(erosion, kernel, iterations=1) 不同膨胀次数的变化 开运算与闭运算 open_close_kernel = np.ones((5,5), np.uint8) 开运算：先腐蚀，后膨胀 开运算可以用来去除仅存的小块像素。 openimg = cv2.morphologyEx(img, cv2.MORPH_OPEN, open_close_kernel) 闭运算：先膨胀，后腐蚀 closeimg = cv2.morphologyEx(img, cv2.MORPH_CLOSE, open_close_kernel) 梯度运算 kernel = np.ones((7,7), np.uint8) 梯度 = 膨胀 - 腐蚀 形态学梯度为经过膨胀操作（dilate）的图像与经过腐蚀操作（erode）的图像的差，可以用于抽出物体的边缘。 gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel) 顶帽和黑帽 kernel = np.ones((7,7), np.uint8) 顶帽 顶帽 = 原始输入 - 开运算 tophat = cv2.morphologyEx(img1, cv2.MORPH_TOPHAT, kernel) 黑帽 黑帽 = 闭运算 - 原始输入 blackhat = cv2.morphologyEx(img1, cv2.MORPH_BLACKHAT, kernel) 角点检测（图像梯度，边缘检测步骤） Sobel算子 卷积核 dst = cv2.Sobel(src, ddepth, dx, dy, ksize) dx=0，dy=1，只计算垂直方向dx=1，dy=0，只计算水平方向dx=1，dy=1，直接计算（不建议，效果不好，建议分开计算再） ddepth：图像的深度 dx和dy：分别表示水平和竖直方向 ksize：是Sobel算子的大小（核大小） sobel = cv2.convertScaleAbs(sobel) 白到黑是正数，黑到白就是负数了，所有的负数会被截断成0，所以要取绝对值 sobelxy = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0) 分别计算x和y，再求和 0.5：为权重 示例 代码 lena = cv2.imread(\"../img/lena.jpg\", cv2.IMREAD_GRAYSCALE) # 分开计算 sobelx = cv2.Sobel(lena, cv2.CV_64F, 1, 0, ksize=3) sobelx = cv2.convertScaleAbs(sobelx) sobely = cv2.Sobel(lena, cv2.CV_64F, 0, 1, ksize=3) sobely = cv2.convertScaleAbs(sobely) sobelxy1 = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0) # 直接计算 sobelxy2 = cv2.Sobel(lena, cv2.CV_64F, 1, 1, ksize=3) sobelxy2 = cv2.convertScaleAbs(sobelxy2) show_img([lena, sobelxy1, sobelxy2], hstack=True) Scharr算子 更敏感 卷积核 dst = cv2.Scharr(src, ddepth, dx, dy) 示例 代码 scharrx = cv2.Scharr(lena, cv2.CV_64F, 1, 0) scharry = cv2.Scharr(lena, cv2.CV_64F, 0, 1) scharrx = cv2.convertScaleAbs(scharrx) scharry = cv2.convertScaleAbs(scharry) scharrxy = cv2.addWeighted(scharrx, 0.5, scharry, 0.5, 0) Laplacian算子 二阶导，反应一阶导的变化率，所以对变化更敏感（对噪音点敏感，如果有噪音点就不好检测了） 卷积核 dst = cv2.Laplacian(src, ddepth) 示例 代码 laplacian = cv2.Laplacian(lena, cv2.CV_64F) laplacian = cv2.convertScaleAbs(laplacian) 三者对比 代码 lena = cv2.imread(\"../img/lena.jpg\", cv2.IMREAD_GRAYSCALE) # 分开计算 sobelx = cv2.Sobel(lena, cv2.CV_64F, 1, 0, ksize=3) sobelx = cv2.convertScaleAbs(sobelx) sobely = cv2.Sobel(lena, cv2.CV_64F, 0, 1, ksize=3) sobely = cv2.convertScaleAbs(sobely) sobelxy1 = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0) # Scharr算子 scharrx = cv2.Scharr(lena, cv2.CV_64F, 1, 0) scharry = cv2.Scharr(lena, cv2.CV_64F, 0,1) scharrx = cv2.convertScaleAbs(scharrx) scharry = cv2.convertScaleAbs(scharry) scharrxy = cv2.addWeighted(scharrx, 0.5, scharry, 0.5, 0) # Laplacian算子 laplacian = cv2.Laplacian(lena, cv2.CV_64F) laplacian = cv2.convertScaleAbs(laplacian) show_img([lena, sobelxy1, scharrxy, laplacian], hstack=True) Canny边缘检测 1、 使用高斯滤波器，以平滑图像，滤除噪声。 高斯滤波器 2、 计算图像中每个像素点的梯度强度和方向。 在x方向和y方向上使用Sobel滤波器，在此之上求出边缘的强度和边缘的梯度 梯度和方向 3、 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。 非极大值抑制 4、 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。 双阈值检测 5、 通过抑制孤立的弱边缘最终完成边缘检测。 示例 代码 img=cv2.imread(\"lena.jpg\",cv2.IMREAD_GRAYSCALE) v1=cv2.Canny(img,80,150) v2=cv2.Canny(img,50,100) # 80和150：minVal和maxVal res = np.hstack((v1,v2)) cv_show(res,'res') 图像金字塔 高斯金字塔 高斯金字塔：向下采样方法（缩小） 高斯金字塔：向上采样方法（放大） 示例 代码 AM = cv2.imread(\"../img/AM.png\") up = cv2.pyrUp(AM) down = cv2.pyrDown(AM) show_img([AM,up,down]) 展示 原图 向上 向下 拉普拉斯金字塔 Gi：原图 示例 代码 down = cv2.pyrDown(AM) down_up = cv2.pyrUp(down) ret = AM - down_up show_img([AM,ret], hstack=True) 图像轮廓 contours, hierarchy = cv2.findContours(img,mode,method) 为了更高的准确率，使用二值图像。 contours：轮廓信息（用得较多的数据） hierarchy：层级 mode：轮廓检索模式 RETR_EXTERNAL ：只检索最外面的轮廓； RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中； RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界; RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次; 常用 method：轮廓逼近方法 CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。 常用 CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分。 示例 代码# 为了更高的准确率，使用二值图像。 img = cv2.imread(\"../img/car.png\") gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY) contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) show_img([img, thresh]) 绘制轮廓 res = cv2.drawContours(copy_img, contours, -1, (0,0,255), 2) 传入绘制图像， 轮廓， 轮廓索引， 颜色模式， 线条厚度 -1：所有的轮廓都画出来，0：对应的第0个轮廓，1：对应的第1个轮廓 （0,0,255）：对应：B,G,R，轮廓的颜色（这里是红色） 2：线条宽度 示例 代码 # 注意需要copy,要不原图会变 copy_img = img.copy() res = cv2.drawContours(copy_img, contours, -1, (0,0,255), 2) show_img([img, res]) 轮廓特征 # 第一个轮廓 cnt = contours[0] # 面积 area = cv2.contourArea(cnt) # 周长，True：表示闭合的 perimeter = cv2.arcLength(cnt, True) print(\"面积：\",area) print(\"周长：\", perimeter) 轮廓近似 示例 代码 img = cv2.imread(\"../img/contours2.png\") gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) ret, thresh = cv2.threshold(gray, 127,255, cv2.THRESH_BINARY) contours,hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] # 绘制轮廓 draw_img = img.copy() res1 = cv2.drawContours(draw_img, [cnt], -1, (0, 0, 255), 2) # 轮廓近似 epsilon = 0.1 * cv2.arcLength(cnt, True) # 按周长比例 approx = cv2.approxPolyDP(cnt, epsilon, True) # 近似 draw_img = img.copy() res2 = cv2.drawContours(draw_img, [approx], -1, (0, 0, 255), 2) show_img([img, res1,res2], hstack=True) 边界矩形 示例 代码 img = cv2.imread(\"../img/contours.png\") gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) ret, thresh = cv2.threshold(gray, 127,255, cv2.THRESH_BINARY) contours,hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cnt = contours[0] # 0：第0个轮廓也就是这里的三角形的外接矩形（外轮廓）; 1：内轮廓（内接矩形）..... x,y,w,h = cv2.boundingRect(cnt) img = cv2.rectangle(img, (x,y), (x+w, y+h), (0,0,255), 2) show_img([img]) 应用 计算面积比 area = cv2.contourArea(cnt) x, y, w, h = cv2.boundingRect(cnt) rect_area = w * h extent = float(area) / rect_area print ('轮廓面积与边界矩形比',extent) 外接圆 示例 代码 (x,y),radius = cv2.minEnclosingCircle(cnt) center = (int(x),int(y)) radius = int(radius) img =cv2.circle(img,center,radius,(0,255,0),2) show_img([img]) 图像模板匹配 * 模板匹配和卷积原理很像，模板在原图像上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的差别程度，这个差别程度的计算方法在opencv里有6种，然后将每次计算的结果放入一个矩阵里，作为结果输出。假如原图形是AxB大小，而模板是axb大小，则输出结果的矩阵是( A-a+1)x(B-b+1) res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF) 推荐使用包含归一化的 TM_SQDIFF：计算平方不同，计算出来的值越小，越相关 TM_CCORR：计算相关性，计算出来的值越大，越相关 TM_CCOEFF：计算相关系数，计算出来的值越大，越相关 TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关 TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关 TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关 公式 min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) 最小值，最大值，最小值位置，最大值位置 示例 代码 img = cv2.imread('../img/lena.jpg', 0) template = cv2.imread('../img/face.jpg',0) h,w = template.shape[:2] methods = ['cv2.TM_CCOEFF', 'cv2.TM_CCOEFF_NORMED', 'cv2.TM_CCORR', 'cv2.TM_CCORR_NORMED', 'cv2.TM_SQDIFF', 'cv2.TM_SQDIFF_NORMED'] # 模板匹配 res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF) # 最小值，最大值，最小值位置，最大值位置 min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) # 绘图比较 for meth in methods: img2 = img.copy() # 匹配方法的真值 method = eval(meth) # 不能是字符串 res = cv2.matchTemplate(img, template, method) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) # 如果是平方差匹配TM_SQDIFF或归一化平方差匹配TM_SQDIFF_NORMED，取最小值 if method in [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]: top_left = min_loc else: top_left = max_loc bottom_right = (top_left[0] + w, top_left[1] + h) # 画矩形 cv2.rectangle(img2, top_left, bottom_right, 255, 2) plt.subplot(121), plt.imshow(res, cmap='gray') plt.xticks([]), plt.yticks([]) # 隐藏坐标轴 plt.subplot(122), plt.imshow(img2, cmap='gray') plt.xticks([]), plt.yticks([]) plt.suptitle(meth) plt.show() 展示 模板 匹配多个对象 代码 img_rgb = cv2.imread('../img/mario.jpg') img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY) template = cv2.imread('../img/mario_coin.jpg', 0) h, w = template.shape[:2] res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED) threshold = 0.8 # 取匹配程度大于%80的坐标 loc = np.where(res >= threshold) # *号表示可选参数 for pt in zip(*loc[::-1]): bottom_right = (pt[0] + w, pt[1] + h) cv2.rectangle(img_rgb, pt, bottom_right, (0, 0, 255), 2) show_img([template, img_rgb]) "},"Python/第三方库/PyInstaller/01-pyInstaller打包基础.html":{"url":"Python/第三方库/PyInstaller/01-pyInstaller打包基础.html","title":"pyInstaller打包基础","keywords":"","body":"datetime:2022/04/16 17:10 author:nzb pyinstaller 官方文档 常用参数 -F, –onefile：打包一个单个文件，如果你的代码都写在一个.py文件的话，可以用这个，如果是多个.py文件就别用 -D, –onedir：打包多个文件，在dist中生成很多依赖文件，适合以框架形式编写工具代码，我个人比较推荐这样，代码易于维护 -K, –tk：在部署时包含 TCL/TK -a, –ascii：不包含编码.在支持Unicode的python版本上默认包含所有的编码. -d, –debug：产生debug版本的可执行文件 -w,–windowed,–noconsole：使用Windows子系统执行.当程序启动的时候不会打开命令行(只对Windows有效) -c,–nowindowed,–console：使用控制台子系统执行(默认)(只对Windows有效) pyinstaller -c xxxx.py - pyinstaller xxxx.py --console -s,–strip： 可执行文件和共享库将run through strip.注意Cygwin的strip往往使普通的win32 Dll无法使用. -X, –upx：如果有UPX安装(执行Configure.py时检测),会压缩执行文件(Windows系统中的DLL也会)(参见note) -o DIR, –out=DIR：指定spec文件的生成目录,如果没有指定,而且当前目录是PyInstaller的根目录,会自动创建一个用于输出(spec和生成的可执行文件) 的目录.如果没有指定,而当前目录不是PyInstaller的根目录,则会输出到当前的目录下. -p DIR, –path=DIR：设置导入路径(和使用PYTHONPATH效果相似).可以用路径分割符(Windows使用分号,Linux使用冒号) 分割,指定多个目录.也可以使用多个-p参数来设置多个导入路径，让pyinstaller自己去找程序需要的资源 –icon=：将file.ico添加为可执行文件的资源(只对Windows系统有效)，改变程序的图标 pyinstaller -i ico路径 xxxxx.py –icon=：将file.exe的第n个图标添加为可执行文件的资源(只对Windows系统有效) -v FILE, –version=FILE：将verfile作为可执行文件的版本资源(只对Windows系统有效) -n NAME, –name=NAME：可选的项目(产生的spec的)名字.如果省略,第一个脚本的主文件名将作为spec的名字 通用参数 参数名 描述 说明 -h, --help 显示帮助 无 -v, --version 显示版本号 无 –-distpath DIR 生成文件放在哪里 默认：当前目录的dist文件夹内 --workpath WORKPATH 生成过程中的中间文件放在哪里 默认：当前目录的build文件夹内 -y, --noconfirm 如果dist文件夹内已经存在生成文件，则不询问用户，直接覆盖 默认：询问是否覆盖 --upx-dir UPX_DIR UPX_DIR 指定upx工具的目录 默认：execution path -a, --ascii 不包含unicode支持 默认：尽可能支持unicode –-clean 在本次编译开始时，清空上一次编译生成的各种文件 默认：不清除 --log-level LEVEL 控制编译时pyi打印的信息 一共有5个等级，由低到高分别为TRACE DEBUG INFO(默认) WARN ERROR CRITICAL。 默认INFO，不打印TRACE和DEBUG信息 与生成结果有关的参数 参数名 描述 说明 -D, --onedir 生成one-folder的程序（默认） 生成结果是一个目录，各种第三方依赖、资源和exe同时存储在该目录 -F, --onefile 生成one-file的程序 生成结果是一个exe文件，所有的第三方依赖、资源和代码均被打包进该exe内 --specpath DIR 指定.spec文件的存储路径 默认：当前目录 -n NAME, --name NAME 生成的.exe文件和.spec的文件名 默认：用户脚本的名称，即main.py和main.spec 指定打包哪些资源、代码 参数名 描述 说明 --add-data 打包额外资源 用法：pyinstaller main.py –add-data=src;dest windows以;分割，linux以:分割，可多次使用 --add-binary 打包额外的代码 用法：同–add-data。与–add-data不同的是，用binary添加的文件，pyi会分析它引用的文件并把它们一同添加进来 -p DIR, --paths DIR 指定额外的import路径，类似于使用PYTHONPATH 参见PYTHONPATH --hidden-import MODULENAME, --hiddenimport MODULENAME 打包额外py库pyi在分析过程中，有些import没有正确分析出来，运行时会报import error，这时可以使用该参数 --additional-hooks-dir HOOKSPATH 指定用户的hook目录 hook用法参见其他，系统hook在PyInstaller\\hooks目录下 --runtime-hook RUNTIME_HOOKS 指定用户runtime-hook 如果设置了此参数，则runtime-hook会在运行main.py之前被运行 --exclude-module EXCLUDES 需要排除的module pyi会分析出很多相互关联的库，但是某些库对用户来说是没用的，可以用这个参数排除这些库，有助于减少生成文件的大小 --key KEY pyi会存储字节码，指定加密字节码的key 16位的字符串 为什么要使用 --add-data？程序里文件格式有很多种： 源代码 .py 图片格式 .png .jpg .ico 等 配置文件 .ini .json .xml等 其他可执行文件 .bin .exe等 模型文件 .pth 等 说明文档 .txt .md等 注意： 除了.py之外，其他格式不会编译。 除了.py之外，其他格式若要打包进去，需要使用 --add-data 处理，或者手动拷贝(嫌麻烦，你每次都能记住？) 如何使用 --add-data? 用法：pyinstaller x.py --add-data=\"源地址;目标地址\"。 windows以;分割，linux以:分割 例如：将 config 目录的所有文件打包到目标的 config 文件夹（不存在会自动创建）下 pyinstaller x.py --add-data \".\\\\config\\\\*;.\\\\config\" 可使用多次 --add-data pyinstaller x.py -n Demo2.0.3 --key !@)v -i \"res\\logo.ico\" --add-data=\".\\*.txt;.\" --add-data=\".\\*.json;.\" --add-data=\"res\\*.*;.\\res\" --add-data=\"dist\\models\\*.*;.\\models\" 生成参数 参数名 描述 说明 -d, --debug 执行生成的main.exe时，会输出pyi的一些log，有助于查错 默认：不输出pyi的log -s, --strip 优化符号表 原文明确表示不建议在windows上使用 --noupx 强制不使用upx 默认：尽可能使用。 其他 参数名 描述 说明 --runtime-tmpdir PATH 指定运行时的临时目录 默认：使用系统临时目录 Windows和Mac特有的参数 参数名 描述 说明 -c, --console, --nowindowed 显示命令行窗口，与-w相反 默认含有此参数 -w, --windowed, --noconsole 不显示命令行窗口 编写GUI程序时使用此参数有用。 -i , --icon 为main.exe指定图标 pyinstaller -i beauty.ico main.py Windows特有的参数 参数名 描述 说明 --version-file FILE 添加版本信息文件 pyinstaller –version-file ver.txt -m , --manifest 添加manifest文件 pyinstaller -m main.manifest -r RESOURCE, --resource RESOURCE 请参考原文 --uac-admin 请参考原文 --uac-uiaccess 请参考原文 .spec文件打包 生成 .spec 文件：pyinstaller -F xxx.py 编写 .spec 内容 打包：pyinstaller xxx.py # -*- mode: python ; coding: utf-8 -*- block_cipher = None a = Analysis( ['run.py'], # 此列表存放项目设计的所有Python脚本文件 pathex=[\"/upper_computer/src/upper_computer_ui/script/qs_apis\"], # 此列表为项目的绝对路径 binaries=[], datas=[('./dist/*', './dist')], hiddenimports=['redis', 'paramiko', 'aioredis', 'gevent', 'requests', 'zmq', 'run'], # fastapi的打包示例，run 也要加进来，否则启动不了 hookspath=[], hooksconfig={}, runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher, noarchive=False, ) pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher) exe = EXE( pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [], name='run', # 打包程序的名字 debug=False, bootloader_ignore_signals=False, strip=False, upx=True, upx_exclude=[], runtime_tmpdir=None, console=True, # 程序运行时是否打开控制台 disable_windowed_traceback=False, argv_emulation=False, target_arch=None, codesign_identity=None, entitlements_file=None, ) 常见打包错误及解决办法 1、在用pyinstaller打包（-F 选项），如果用到的第三方库含有data文件，而pyinstaller又没有自带该第三方库文件的hook的时候，执行打包后的exe一般会报以下错误 友情链接 FileNotFoundError: [Errno 2] No such file or directory: ‘C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\1\\_MEI54762\\jieba\\dict.txt’ [20784] Failed to execute script bat_server 上面就是没把python库jieba的dict.txt打包进来，导致了错误。 那么，解决问题也很简单，自己写个hook，然后放进pyinstaller的hooks里面即可。 hook文件的命名规范为: hook-【库名】.py，以结巴分词为例，即为hook-jieba.py，然后简单敲入以下两行： from PyInstaller.utils.hooks import copy_metadata, collect_data_files datas = copy_metadata('jieba') # 解决 `pkg_resources` 错误 datas.extend(collect_data_files(\"jieba\")) # 解决静态文件不存在错误 接下来，找到pyinstaller的hooks文件夹，大概位于： python根目录\\Lib\\site-packages\\PyInstaller\\hooks下，然后把hook-jieba.py丢进去 注意是\\Lib\\site-packages\\PyInstaller\\hooks 不是 \\Lib\\site-packages\\PyInstaller\\utils\\hooks 或者可以使用参数 --additional-hooks-dir HOOKSPATH 指定用户自定义的 hook 文件夹目录 最后，回到项目根目录，用pyinstaller打包即可。（注意需要把build目录删了，使pyinstaller从头开始打包） 当看到pyinstaller的日志里使用了我们自定义的hook后，就万事大吉了。 ok 打包tushare 或 akshare 的时候也有类似问题，下次可以直接用此法解决。 "},"Python/第三方库/ZeroMQ/01-zmq基础.html":{"url":"Python/第三方库/ZeroMQ/01-zmq基础.html","title":"zmq基础","keywords":"","body":"ZeroMQ 1、zmq套接字 创建和销毁套接字：zmq.socket(), zmq.close() 配置和读取套接字：zmq.setsockopt(), zmq.getsockopt() 为套接字建立连接：zmq.bind(), zmq.connect() 发送和接收消息： zmq.send(), zmq.recv() 注： 使用zmq.bind()连接的节点称之为服务端，它有着一个较为固定的网络地址； 使用zmq.connect()连接的节点称为客户端，其地址不固定。 2、zmq消息模式 主要有三种常用模式 req/rep(请求答复模式)：主要用于远程调用及任务分配等。 pub/sub(订阅模式)： 主要用于数据分发。 push/pull(管道模式)： 主要用于多任务并行。 3、zmq内置的有效绑定对 PUB and SUB REQ and REP REQ and XREP XREQ and REP XREQ and XREP XREQ and XREQ XREP and XREP PUSH and PULL PAIR and PAIR 4、具体消息模式举例 (1)、req/rep(请求/答复模式) 一对一模式，一问一答 server服务端 import zmq context = zmq.Context() socket = context.socket(zmq.REP) # 设置socket的类型，zmq.REP答复 socket.bind(\"tcp://*:15000\") # 绑定服务端的IP和端口 while True: # 循环接收客户端发来的消息 message = socket.recv() # 接收客户端发送来的消息，注：是byte类型 print(message) socket.send_string(\"copy!\") # 再发回客户端消息 # 结果：客户单每请求一次就打印一次消息体 # b'request' # b'request' # b'request' # b'request' client客户端 import zmq, sys context = zmq.Context() socket = context.socket(zmq.REQ) # 设置socket类型，请求端 socket.connect(\"tcp://localhost:15000\") #连接服务端的IP和端口 socket.connect(\"tcp://127.0.0.1:15000\") while True: data = input(\"input your request:\") if data == \"q\": sys.exit() socket.send_string(data) # 向服务端发送消息 message=socket.recv() #接收服务端返回的消息，注：是byte类型 print(message) recv_msg = socket.recv_string() print(f\"recv msg: {recv_msg}\") \"\"\" 结果：每输入请求一次，就得到服务端的一次返回 input your data:123 b'copy!' input your data:456 b'copy!' \"\"\" send()、recv()扩展 发送 接收 发送数据结构 返回数据结构 说明 send() recv() bytes, Frame, memoryview bytes, Frame, memoryview - send_string() recv_string() str str - send_pyobj() recv_pyobj() Python object Python object - send_json() recv_json() Python object List, str, int, float, Dict - send_serialized() recv_serialized() The message to be sent. Can be any object serializable by serialize. 自定义反序列化函数 自定义序列化函数 注意：zmq.error.ZMQError: Operation cannot be accomplished in current state zmq模式为zmq.REP。在这种模式下，我们的程序必须要遵守recv()和send()配对使用的编程模式。 也就是说，在服务程序中，必须要有完整的recv()和send()成对出现。同理，在客户端程序中，send()后，也要有recv()。 (2)、pub/sub(订阅模式) 一对多模式 一个发布者，多个订阅者，订阅者可以通过设置过滤器过滤数据。 Publisher发布者 import zmq context = zmq.Context() socket = context.socket(zmq.PUB) socket.bind(\"tcp://*:15000\") while True: data = input(\"input your data:\") print(data) socket.send_string(data) \"\"\" 结果：循环提示输入数据，当输入一次，就发送一次到订阅者 input your data:123 123 input your data:456 456 input your data:789 789 input your data: \"\"\" Subscriber订阅者 import sys import zmq context = zmq.Context() socket = context.socket(zmq.SUB) socket.connect(\"tcp://localhost:15000\") socket.setsockopt_string(zmq.SUBSCRIBE, '') # 或者： socket.setsockopt_string(zmq.SUBSCRIBE, '123') # 表示只过滤出收到消息为'123'的消息 # 或者： socket.subscribe('topic') # 订阅一个主题, 表示只过滤出收到消息为'topic'的消息 while True: message = socket.recv() print(message) \"\"\" 结果：发布者每发布一次，都能订阅到 b'123' b'456' b'789' \"\"\" (3)、push/pull(管道模式) 管道是单向的，从PUSH端单向的向PULL端单向的推送数据流。 由三部分组成，push进行数据推送，work进行数据缓存，pull进行数据竞争获取处理。 区别于Publish-Subscribe, 管道模式存在一个数据缓存和处理负载。 当连接被断开，数据不会丢失，重连后数据继续发送到对端。 推送端 import zmq context = zmq.Context() socket = context.socket(zmq.PUSH) # 设置socket类型PUSH推送 socket.bind(\"tcp://*:5557\") #绑定IP和端口 while True: data = input(\"input your data:\") socket.send_string(data) \"\"\" input your data:123 input your data:456 input your data:789 \"\"\" worker端 import zmq context = zmq.Context() socket_receive = context.socket(zmq.PULL) # 设置socket类型PULL拉取推送端的消息 socket_receive.connect(\"tcp://localhost:5557\") # 连接推送端IP和端口 socket_sender = context.socket(zmq.PUSH) # 再设置一个socket类型PUSH推送 socket_sender.connect(\"tcp://localhost:5558\") # 连接IP和端口向其推送消息 while True: data = socket_receive.recv_string() # 拉取接收消息 print(data) socket_sender.send_string(data) # 再将消息推送出去 \"\"\" 123 456 789 \"\"\" 拉取端 import zmq context = zmq.Context() socket = context.socket(zmq.PULL) # 设置socket类型PULL拉取消息 socket.bind(\"tcp://*:5558\") #绑定IP和端口去拉取消息 while True: message = socket.recv_string() print(message) \"\"\" 123 456 789 \"\"\" "},"GoLang/Go简明教程/01-Go语言简明教程.html":{"url":"GoLang/Go简明教程/01-Go语言简明教程.html","title":"Go语言简明教程","keywords":"","body":"datetime:2022/1/15 19:52 author:nzb Go 语言简明教程 Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 —— Go - wikipedia.org 1 Go 安装 最新版本下载地址官方下载 golang.org，当前是 1.13.6。如无法访问，可以在 studygolang.com/dl 下载 使用 Linux，可以用如下方式快速安装。 $ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz $ tar -zxvf go1.13.6.linux-amd64.tar.gz $ sudo mv go /usr/local/ $ go version go version go1.13.6 linux/amd64 从 Go 1.11 版本开始，Go 提供了 Go Modules 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。 $ go env -w GOPROXY=https://goproxy.cn,direct 或在 ~/.profile 中设置环境变量 export GOPROXY=https://goproxy.cn 2 Hello World 新建一个文件 main.go，写入 package main import \"fmt\" func main() { fmt.Println(\"Hello World!\") } 执行go run main.go 或 go run .，将会输出 $ go run . Hello World! 如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello 否则会报错误：go: cannot find main module; see ‘go help modules’ 我们的第一个 Go 程序就完成了，接下来我们逐行来解读这个程序： package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。 import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。 func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 main。 fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!” go run main.go，其实是 2 步： go build main.go：编译成二进制可执行程序 ./main：执行该程序 3 变量与内置数据类型 3.1 变量(Variable) Go 语言是静态类型的，变量声明时必须明确变量的类型。Go 语言与其他语言显著不同的一个地方在于，Go 语言的类型在变量后面。 比如 java 中，声明一个整体一般写成 int a = 1，在 Go 语言中，需要这么写： var a int // 如果没有赋值，默认为0 var a int = 1 // 声明时赋值 var a = 1 // 声明时赋值 var a = 1，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达： a := 1 msg := \"Hello World!\" 3.2 简单类型 空值：nil 整型类型： int(取决于操作系统), int8, int16, int32, int64, uint8, uint16, … 浮点数类型：float32, float64 字节类型：byte (等价于uint8) 字符串类型：string 布尔值类型：boolean，(true 或 false) var a int8 = 10 var c1 byte = 'a' var b float32 = 12.2 var msg = \"Hello World\" ok := false 3.3 字符串 在 Go 语言中，字符串使用 UTF8 编码，UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占3字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。 我们看下面的例子： package main import ( \"fmt\" \"reflect\" ) func main() { str1 := \"Golang\" str2 := \"Go语言\" fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8 fmt.Println(str1[2], string(str1[2])) // 108 l fmt.Printf(\"%d %c\\n\", str2[2], str2[2]) // 232 è fmt.Println(\"len(str2)：\", len(str2)) // len(str2)： 8 } reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占1个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。 因为字符串是以 byte 数组的形式存储的，所以，str2[2] 的值并不等于语。str2 的长度 len(str2) 也不是 4，而是 8（ Go 占 2 byte，语言占 6 byte）。 正确的处理方式是将 string 转为 rune 数组 str2 := \"Go语言\" runeArr := []rune(str2) fmt.Println(reflect.TypeOf(runeArr[2]).Kind()) // int32 fmt.Println(runeArr[2], string(runeArr[2])) // 35821 语 fmt.Println(\"len(runeArr)：\", len(runeArr)) // len(runeArr)： 4 转换成 []rune 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。 3.4 数组(array)与切片(slice) 声明数组 var arr [5]int // 一维 var arr2 [5][5]int // 二维 声明时初始化 var arr = [5]int{1, 2, 3, 4, 5} // 或 arr := [5]int{1, 2, 3, 4, 5} 使用 [] 索引/修改数组 arr := [5]int{1, 2, 3, 4, 5} for i := 0; i 数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展 声明切片： slice1 := make([]float32, 0) // 长度为0的切片 slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片 fmt.Println(len(slice2), cap(slice2)) // 3 5 使用切片： // 添加元素，切片容量可以根据需要自动扩展 slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4] fmt.Println(len(slice2), cap(slice2)) // 7 12 // 子切片 [start, end) sub1 := slice2[3:] // [1 2 3 4] sub2 := slice2[:3] // [0 0 0] sub3 := slice2[1:4] // [0 0 1] // 合并切片 combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0] 声明切片时可以为切片设置容量大小，为切片预分配空间。在实际使用的过程中，如果容量不够，切片容量会自动扩展。 sub2... 是切片解构的写法，将切片解构为 N 个独立的元素。 3.5 字典(键值对，map) map 类似于 java 的 HashMap，Python的字典(dict)，是一种存储键值对(Key-Value)的数据解构。使用方式和其他语言几乎没有区别。 // 仅声明 m1 := make(map[string]int) // 声明时初始化 m2 := map[string]string{ \"Sam\": \"Male\", \"Alice\": \"Female\", } // 赋值/修改 m1[\"Tom\"] = 18 3.6 指针(pointer) 指针即某个值的地址，类型定义时使用符号*，对一个已经存在的变量，使用 & 获取该变量的地址。 str := \"Golang\" var p *string = &str // p 是指向 str 的指针 *p = \"Hello\" fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变 一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。 例如： func add(num int) { num += 1 } func realAdd(num *int) { *num += 1 } func main() { num := 100 add(num) fmt.Println(num) // 100，num 没有变化 realAdd(&num) fmt.Println(num) // 101，指针传递，num 被修改 } 4 流程控制(if, for, switch) 4.1 条件语句 if else age := 18 if age 4.2 switch type Gender int8 const ( MALE Gender = 1 FEMALE Gender = 2 ) gender := MALE switch gender { case FEMALE: fmt.Println(\"female\") case MALE: fmt.Println(\"male\") default: fmt.Println(\"unknown\") } // male 在这里，使用了 type 关键字定义了一个新的类型 Gender。 使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。 和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如：switch gender { case FEMALE: fmt.Println(\"female\") fallthrough case MALE: fmt.Println(\"male\") fallthrough default: fmt.Println(\"unknown\") } // 输出结果 // male // unknown 4.3 for 循环 一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。sum := 0 for i := 0; i 50 { break } sum += i } 对数组(arr)、切片(slice)、字典(map) 使用 for range 遍历： nums := []int{10, 20, 30, 40} for i, num := range nums { fmt.Println(i, num) } // 0 10 // 1 20 // 2 30 // 3 40 m2 := map[string]string{ \"Sam\": \"Male\", \"Alice\": \"Female\", } for key, value := range m2 { fmt.Println(key, value) } // Sam Male // Alice Female 5 函数(functions) 5.1 参数与返回值 一个典型的函数定义如下，使用关键字 func，参数可以有多个，返回值也支持有多个。特别地，package main 中的 func main() 约定为可执行程序的入口。 func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) { // body } 例如，实现2个数的加法（一个返回值）和除法（多个返回值）： func add(num1 int, num2 int) int { return num1 + num2 } func div(num1 int, num2 int) (int, int) { return num1 / num2, num1 % num2 } func main() { quo, rem := div(100, 17) fmt.Println(quo, rem) // 5 15 fmt.Println(add(100, 17)) // 117 } 也可以给返回值命名，简化 return，例如 add 函数可以改写为 func add(num1 int, num2 int) (ans int) { ans = num1 + num2 return } 5.2 错误处理(error handling) 如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数os.Open读取文件，os.Open 有2个返回值，第一个是 *File，第二个是 error， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。 import ( \"fmt\" \"os\" ) func main() { _, err := os.Open(\"filename.txt\") if err != nil { fmt.Println(err) } } // open filename.txt: no such file or directory 可以通过 errorw.New 返回自定义的错误 import ( \"errors\" \"fmt\" ) func hello(name string) error { if len(name) == 0 { return errors.New(\"error: name is null\") } fmt.Println(\"Hello,\", name) return nil } func main() { if err := hello(\"\"); err != nil { fmt.Println(err) } } // error: name is null error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。 func get(index int) int { arr := [3]int{2, 3, 4} return arr[index] } func main() { fmt.Println(get(5)) fmt.Println(\"finished\") } $ go run . panic: runtime error: index out of range [5] with length 3 goroutine 1 [running]: exit status 2 在 Python、Java 等语言中有 try...catch 机制，在 try 中捕获各种类型的异常，在 catch 中定义异常处理的行为。Go 语言也提供了类似的机制 defer 和 recover。 func get(index int) (ret int) { defer func() { if r := recover(); r != nil { fmt.Println(\"Some error happened!\", r) ret = -1 } }() arr := [3]int{2, 3, 4} return arr[index] } func main() { fmt.Println(get(5)) fmt.Println(\"finished\") } $ go run . Some error happened! runtime error: index out of range [5] with length 3 -1 finished 在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。 在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。 6 结构体，方法和接口 6.1 结构体(struct) 和方法(methods) 结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 hello() 方法。 type Student struct { name string age int } func (stu *Student) hello(person string) string { return fmt.Sprintf(\"hello %s, I am %s\", person, stu.name) } func main() { stu := &Student{ name: \"Tom\", } msg := stu.hello(\"Jack\") fmt.Println(msg) // hello Jack, I am Tom } 使用 Student{field: value, ...} 的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。 实现方法与实现函数的区别在于，func 和函数名 hello 之间，加上该方法对应的实例名 stu 及其类型 *Student，可以通过实例名访问该实例的字段name和其他方法了。 调用方法通过 实例名.方法名(参数) 的方式。 除此之外，还可以使用 new 实例化： func main() { stu2 := new(Student) fmt.Println(stu2.hello(\"Alice\")) // hello Alice, I am , name 被赋予默认值\"\" } 6.2 接口(interfaces) 一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。 举一个简单的例子，定义一个接口 Person 和对应的方法 getName() 和 getAge()： type Person interface { getName() string } type Student struct { name string age int } func (stu *Student) getName() string { return stu.name } type Worker struct { name string gender string } func (w *Worker) getName() string { return w.name } func main() { var p Person = &Student{ name: \"Tom\", age: 18, } fmt.Println(p.getName()) // Tom } Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。 实例化 Student 后，强制类型转换为接口类型 Person。 在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 (*Student).getName() 删掉，编译时会出现如下报错信息。 *Student does not implement Person (missing getName method) 但是删除 (*Worker).getName() 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。 var _ Person = (*Student)(nil) var _ Person = (*Worker)(nil) 将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。 Worker 同上。 实例可以强制类型转换为接口，接口也可以强制类型转换为实例。 func main() { var p Person = &Student{ name: \"Tom\", age: 18, } stu := p.(*Student) // 接口转为实例 fmt.Println(stu.getAge()) } 6.3 空接口 如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如 func main() { m := make(map[string]interface{}) m[\"name\"] = \"Tom\" m[\"age\"] = 18 m[\"scores\"] = [3]int{98, 99, 85} fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]] } 7 并发编程(goroutine) 7.1 sync Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。 例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。 import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func download(url string) { fmt.Println(\"start to download\", url) time.Sleep(time.Second) // 模拟耗时操作 wg.Done() } func main() { for i := 0; i wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。 go download()：启动新的协程并发执行 download 函数。 wg.Wait()：等待所有的协程执行结束。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 Done! real 0m1.563s 可以看到串行需要 3s 的下载操作，并发后，只需要 1s。 7.2 channel var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道 func download(url string) { fmt.Println(\"start to download\", url) time.Sleep(time.Second) ch 使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 finish a.com/2 finish a.com/1 finish a.com/0 Done! real 0m1.528s 8 单元测试(unit test) 假设我们希望测试 package main 下 calc.go 中的函数，要只需要新建 calc_test.go 文件，在 ``calc_test.go 中新建测试用例即可。 // calc.go package main func add(num1 int, num2 int) int { return num1 + num2 } // calc_test.go package main import \"testing\" func TestAdd(t *testing.T) { if ans := add(1, 2); ans != 3 { t.Error(\"add(1, 2) should be equal to 3\") } } 运行 go test，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加 -v 参数。 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.040s 9 包(Package)和模块(Modules) 9.1 Package 一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。 比如我们新建一个文件 calc.go，main.go 平级，分别定义 add 和 main 方法。 // calc.go package main func add(num1 int, num2 int) int { return num1 + num2 } // main.go package main import \"fmt\" func main() { fmt.Println(add(3, 5)) // 8 } 运行 go run main.go，会报错，add 未定义： ./main.go:6:14: undefined: add 因为 go run main.go 仅编译 main.go 一个文件，所以命令需要换成 $ go run main.go calc.go 8 或 $ go run . 8 Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。 9.2 Modules Go Modules 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 go mod 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。 在一个空文件夹下，初始化一个 Module $ go mod init example go: creating new go.mod: module example 此时，在当前文件夹下生成了go.mod，这个文件记录当前模块的模块名以及所有依赖包的版本。 接着，我们在当前目录下新建文件 main.go，添加如下代码： package main import ( \"fmt\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Hello()) // Ahoy, world! } 运行 go run .，将会自动触发第三方包 rsc.io/quote 的下载，具体的版本信息也记录在了 go.mod 中： module example go 1.13 require rsc.io/quote v3.1.0+incompatible 我们在当前目录，添加一个子 package calc，代码目录如下： demo/ |--calc/ |--calc.go |--main.go 在 calc.go 中写入 package calc func Add(num1 int, num2 int) int { return num1 + num2 } 在 package main 中如何使用 package cal 中的 Add 函数呢？import 模块名/子目录名 即可，修改后的 main 函数如下： package main import ( \"fmt\" \"example/calc\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Hello()) fmt.Println(calc.Add(10, 3)) } $ go run . Ahoy, world! 13 "},"GoLang/Go简明教程/02-Go-Gin-简明教程.html":{"url":"GoLang/Go简明教程/02-Go-Gin-简明教程.html","title":"Gin-简明教程","keywords":"","body":"datetime:2022/1/15 22:26 author:nzb Go Gin 简明教程 Gin 简介 Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API with much better performance – up to 40 times faster. If you need smashing performance, get yourself some Gin. Gin 是使用 Go/golang 语言实现的 HTTP Web 框架。接口简洁，性能极高。截止 1.4.0 版本，包含测试代码，仅14K，其中测试代码 9K 左右，也就是说框架源码仅 5K 左右。 $ find . -name \"*_test.go\" | xargs cat | wc -l 8657 $ find . -name \"*.go\" | xargs cat | wc -l 14115 Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。 中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。这个特性和 NodeJs 的 Koa 框架很像。中间件机制也极大地提高了框架的可扩展性。 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。 JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。 路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。 渲染内置：原生支持JSON，XML和HTML的渲染。 安装Go & Gin 安装 Go (Ubuntu)$ sudo apt-get install golang-go $ go version # go version go1.6.2 linux/amd64 Ubuntu自带版本太老了，安装新版可以使用如下命令。 $ sudo add-apt-repository ppa:gophers/archive $ sudo apt-get update $ sudo apt-get install golang-1.11-go 默认安装在/usr/lib/go-1.11，需要将/usr/lib/go-1.11/bin手动加入环境变量。在 .bashrc 中添加下面的配置，并 source ~/.bashrc export PATH=$PATH:/usr/lib/go-1.11/bin 参考：[Golang Ubuntu - Github]https://github.com/golang/go/wiki/Ubuntu) 安装 Go (Mac) $ brew install go $ go version # go version go1.12.5 darwin/amd64 设置环境变量 设置环境变量 export GOPATH=~/go export PATH=$PATH:$GOPATH/bin 添加完后，source ~/.bashrc 安装一些辅助的工具库 由于网络原因，不能够直接访问 golang.org，但相关的库已经镜像到 Golang - Github 例如，直接安装 go-outline 时会报网络错误，因为golang.org/x/tools是go-outline的依赖库。 $ go get -u -v github.com/ramya-rao-a/go-outline github.com/ramya-rao-a/go-outline (download) Fetching https://golang.org/x/tools/go/buildutil?go-get=1 https fetch failed: Get https://golang.org/x/tools/go/buildutil?go-get=1: dial tcp 216.239.37.1:443: i/o timeout 因此，可以先从 Github 手动安装好，再安装 go-outline 和 goreturns。 git clone https://github.com/golang/tools.git $GOPATH/src/golang.org/x/tools go get -v github.com/ramya-rao-a/go-outline go get -v github.com/sqs/goreturns go get -v github.com/rogpeppe/godef Go语言有大量的辅助工具，如果你使用VSCode，将会提示你将必要的工具，例如静态检查、自动补全等工具依次安装完毕。 安装 Gin go get -u -v github.com/gin-gonic/gin -v：打印出被构建的代码包的名字 -u：已存在相关的代码包，强行更新代码包及其依赖包 第一个Gin程序 在一个空文件夹里新建文件main.go。 // geektutu.com // main.go package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/\", func(c *gin.Context) { c.String(200, \"Hello, Golang\") }) r.Run() // listen and serve on 0.0.0.0:8080 } 首先，我们使用了gin.Default()生成了一个实例，这个实例即 WSGI 应用程序。 接下来，我们使用r.Get(\"/\", ...)声明了一个路由，告诉 Gin 什么样的URL 能触发传入的函数，这个函数返回我们想要显示在用户浏览器中的信息。 最后用 r.Run()函数来让应用运行在本地服务器上，默认监听端口是 8080，可以传入参数设置端口，例如r.Run(\":9999\")即运行在 9999端口。 运行 $ go run main.go [GIN-debug] GET / --> main.main.func1 (3 handlers) [GIN-debug] Environment variable PORT is undefined. Using port :8080 by default [GIN-debug] Listening and serving HTTP on :8080 浏览器访问 http://localhost:8080 路由(Route) 路由方法有 GET, POST, PUT, PATCH, DELETE 和 OPTIONS，还有 Any，可匹配以上任意类型的请求。 无参数 // 无参数 r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"Who are you?\") }) $ curl http://localhost:9999/ Who are you? curl参数可参考https://man.linuxde.net/curl 解析路径参数 有时候我们需要动态的路由，如 /user/:name，通过调用不同的 url 来传入不同的 name。/user/:name/*role，* 代表可选。 // 匹配 /user/geektutu r.GET(\"/user/:name\", func(c *gin.Context) { name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) }) $ curl http://localhost:9999/user/golang Hello golang 获取Query参数 // 匹配users?name=xxx&role=xxx，role可选 r.GET(\"/users\", func(c *gin.Context) { name := c.Query(\"name\") role := c.DefaultQuery(\"role\", \"teacher\") c.String(http.StatusOK, \"%s is a %s\", name, role) }) $ curl \"http://localhost:9999/users?name=Tom&role=student\" Tom is a student 获取POST参数 // POST r.POST(\"/form\", func(c *gin.Context) { username := c.PostForm(\"username\") password := c.DefaultPostForm(\"password\", \"000000\") // 可设置默认值 c.JSON(http.StatusOK, gin.H{ \"username\": username, \"password\": password, }) }) $ curl http://localhost:9999/form -X POST -d 'username=golang&password=1234' {\"password\":\"1234\",\"username\":\"golang\"} Query和POST混合参数 // GET 和 POST 混合 r.POST(\"/posts\", func(c *gin.Context) { id := c.Query(\"id\") page := c.DefaultQuery(\"page\", \"0\") username := c.PostForm(\"username\") password := c.DefaultPostForm(\"username\", \"000000\") // 可设置默认值 c.JSON(http.StatusOK, gin.H{ \"id\": id, \"page\": page, \"username\": username, \"password\": password, }) }) $ curl \"http://localhost:9999/posts?id=9876&page=7\" -X POST -d 'username=golang&password=1234' {\"id\":\"9876\",\"page\":\"7\",\"password\":\"1234\",\"username\":\"golang\"} Map参数(字典参数) r.POST(\"/post\", func(c *gin.Context) { ids := c.QueryMap(\"ids\") names := c.PostFormMap(\"names\") c.JSON(http.StatusOK, gin.H{ \"ids\": ids, \"names\": names, }) }) $ curl -g \"http://localhost:9999/post?ids[Jack]=001&ids[Tom]=002\" -X POST -d 'names[a]=Sam&names[b]=David' {\"ids\":{\"Jack\":\"001\",\"Tom\":\"002\"},\"names\":{\"a\":\"Sam\",\"b\":\"David\"} } 重定向(Redirect) r.GET(\"/redirect\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"/index\") }) r.GET(\"/goindex\", func(c *gin.Context) { c.Request.URL.Path = \"/\" r.HandleContext(c) }) $ curl -i http://localhost:9999/redirect HTTP/1.1 301 Moved Permanently Content-Type: text/html; charset=utf-8 Location: / Date: Thu, 08 Aug 2019 17:22:14 GMT Content-Length: 36 Moved Permanently. $ curl \"http://localhost:9999/goindex\" Who are you? 分组路由(Grouping Routes)如果有一组路由，前缀都是/api/v1开头，是否每个路由都需要加上/api/v1这个前缀呢？答案是不需要，分组路由可以解决这个问题。利用分组路由还可以更好地实现权限控制，例如将需要登录鉴权的路由放到同一分组中去，简化权限控制。 // group routes 分组路由 defaultHandler := func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"path\": c.FullPath(), }) } // group: v1 v1 := r.Group(\"/v1\") { v1.GET(\"/posts\", defaultHandler) v1.GET(\"/series\", defaultHandler) } // group: v2 v2 := r.Group(\"/v2\") { v2.GET(\"/posts\", defaultHandler) v2.GET(\"/series\", defaultHandler) } $ curl http://localhost:9999/v1/posts {\"path\":\"/v1/posts\"} $ curl http://localhost:9999/v2/posts {\"path\":\"/v2/posts\"} 上传文件 单个文件 r.POST(\"/upload1\", func(c *gin.Context) { file, _ := c.FormFile(\"file\") // c.SaveUploadedFile(file, dst) c.String(http.StatusOK, \"%s uploaded!\", file.Filename) }) 多个文件 r.POST(\"/upload2\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"upload[]\"] for _, file := range files { log.Println(file.Filename) // c.SaveUploadedFile(file, dst) } c.String(http.StatusOK, \"%d files uploaded!\", len(files)) }) HTML模板(Template) type student struct { Name string Age int8 } r.LoadHTMLGlob(\"templates/*\") stu1 := &student{Name: \"Geektutu\", Age: 20} stu2 := &student{Name: \"Jack\", Age: 22} r.GET(\"/arr\", func(c *gin.Context) { c.HTML(http.StatusOK, \"arr.tmpl\", gin.H{ \"title\": \"Gin\", \"stuArr\": [2]*student{stu1, stu2}, }) }) hello, { {.title} } { {range $index, $ele := .stuArr } } { { $index } }: { { $ele.Name } } is { { $ele.Age } } years old { { end } } $ curl http://localhost:9999/arr hello, Gin 0: Geektutu is 20 years old 1: Jack is 22 years old Gin默认使用模板Go语言标准库的模板text/template和html/template，语法与标准库一致，支持各种复杂场景的渲染。 参考官方文档text/template，html/template 中间件(Middleware) // 作用于全局 r.Use(gin.Logger()) r.Use(gin.Recovery()) // 作用于单个路由 r.GET(\"/benchmark\", MyBenchLogger(), benchEndpoint) // 作用于某个组 authorized := r.Group(\"/\") authorized.Use(AuthRequired()) { authorized.POST(\"/login\", loginEndpoint) authorized.POST(\"/submit\", submitEndpoint) } 如何自定义中间件呢？ func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // 给Context实例设置一个值 c.Set(\"geektutu\", \"1111\") // 请求前 c.Next() // 请求后 latency := time.Since(t) log.Print(latency) } } 热加载调试 Hot Reload Python 的 Flask 框架，有 debug 模式，启动时传入 debug=True 就可以热加载(Hot Reload, Live Reload)了。即更改源码，保存后，自动触发更新，浏览器上刷新即可。免去了杀进程、重新启动之苦。 Gin 原生不支持，但有很多额外的库可以支持。例如 github.com/codegangsta/gin github.com/pilu/fresh 这次，我们采用 github.com/pilu/fresh 。 go get -v -u github.com/pilu/fresh 安装好后，只需要将go run main.go命令换成fresh即可。每次更改源文件，代码将自动重新编译(Auto Compile)。 参考 github.com/pilu/fresh - Github 相关链接 Golang Gin - Github Gin Web Framework - 英文官方网站 "},"GoLang/Go简明教程/03-Go2新特性简明教程.html":{"url":"GoLang/Go简明教程/03-Go2新特性简明教程.html","title":"Go2新特性简明教程","keywords":"","body":"datetime:2022/1/16 11:33 author:nzb Go2 新特性简明教程 Go 的演进 Go语言/golang 诞生于2007年，经过12年的发展，Go逐渐成为了云计算领域新一代的开发语言。Go语言在牺牲很少性能的情况下，语法简洁，功能强大。我是Python的重度用户，在学习Go时，却有一种在学习Python的感觉。并非语法相似，而是Go语言作为一门编译型语言，竟然能够像Python一样，少量的代码就能够完成尽可能多的事情。Go语言仿佛是C和Python的结合体。 Go是如何火起来的呢？我觉得有几个主要的原因，除了语言本身性能好，语法简单，易上手外。Go语言原生支持 Goroutine 和 Channel，极大地降低了并发和异步编程的复杂度。对于服务端编程，并发和异步尤其重要，相比之下，C++，Java等语言的并发和异步控制逻辑过于复杂。另外，杀手级应用Docker的出现起到了很大的推动作用。 Go语言也有很多令人诟病的地方，例如包管理机制，Go直到v1.6才默认开启了vendor机制，vendor机制非常简陋，简单说就是在项目目录下增加一个vendor文件夹，里面放第三方依赖。vendor机制是没有版本概念的，而且不能解决vendor目录嵌套的问题以及同名包函数冲突问题。后来社区涌现了大量的包管理工具，仅官方推荐的包管理工具就有15种之多，应用比较广泛的，如dep、govendor。直到v1.11，官方增加了Go modules机制，才算较为完整地解决了包管理的问题。 Go2 可以说是Go语言一个非常重要的里程碑，Go1 目前虽然已经到了1.12版本，事实上每一个版本很少涉及语法层面的变化，而且每个版本都是向前兼容的。较大的改动如下： Go1.2 切片操作 var a = make([]int, 10) var b = a[i:j:k] Go1.4 for语言加强 ```text // for i := range x { // ... } // 1.4 新增 var times [5][0]int for i := 0; i for _ = range times { // ... } - Go1.9 类型别名 ```text type T1 = T2 Go 2 设计草案 为了进一步完善Go语言，提供更好的体验。Go语言社区目前发布了三类重要的设计草案，分别是错误处理(Error handling)、错误值(Error values)、泛型(Generics)，这几个草案代表了社区重点关注的完善方向，但并不代表最终的实现。 错误处理(Error Handling) Go1 的错误处理机制非常简单，通过返回值的方式，强迫调用者对错误进行处理，这种设计导致会在代码中写大量的 if 判断。例如： func CopyFile(src, dst string) { r := os.Open(src) defer r.Close() w := os.Create(dst) io.Copy(w, r) w.Close() } IO操作容易引发错误，文件打开失败，创建失败，拷贝失败等都会产生错误。如果要对这个函数进行完整的错误处理，代码将变成这样： func CopyFile(src, dst string) error { r, err := os.Open(src) if err != nil { return err } defer r.Close() w, err := os.Create(dst) if err != nil { return err } defer w.Close() if _, err := io.Copy(w, r); err != nil { return err } if err := w.Close(); err != nil { return err } } 看似逻辑清晰，但不够优雅，充斥了大量重复的逻辑。这是Go错误处理机制的缺陷。同时，因为错误处理机制的繁琐，很多开发者在开发应用时，很少去检查并处理错误，程序的健壮性得不到保证。 为了解决这个问题，Go2 发布了一个设计草案供社区讨论，Go2将会完善错误处理机制，错误处理的语法将会简洁很多。 这个提案引入了handle err和check关键字，上面的函数可以简化成： func CopyFile(src, dst string) error { handle err { return fmt.Errorf(\"copy %s %s: %v\", src, dst, err) } r := check os.Open(src) defer r.Close() w := check os.Create(dst) check io.Copy(w, r) check w.Close() } 为什么不使用被Java、Python等语言采用的try关键字呢？比如写成： data := try parseHexdump(string(hex)) 上面的写法看似和谐，但try关键字直接应用在 error values 时，可读性就没那么好了： data, err := parseHexdump(string(hex)) if err == ErrBadHex { ... special handling ... } try err 很明显，在这种场景下，check err显然比try err更有意义。 错误值(Error values) 同样由于错误处理机制设计得较为简陋，Go语言对Error values支持有限。任何值，只要实现了error接口，都是错误类型。由于缺少细粒度的设计，在各种库当中，判断是否产生错误以及产生了哪类错误的方式多种多样，例如io.EOF，os.IsNotExist，err.Error()等，。另外，Go语言目前没有机制追溯到完整的错误链条。例如， func funcB() error { if v, err := funcA(); if err != nil { return fmt.Errorf(\"connect to db: %v\", err) } } func funcC() error { v, err := funcB() if err != nil { return fmt.Errorf(\"write users database: %v\", err) } } funcC返回的错误信息是： write users database: connect to db: open /etc/xx.conf: permission denied 每一层，用额外的字符串对错误进行封装，是目前最常用的方法，除了通过字符串解析，很难还原出完整的错误链条。 为了解决Error values缺少标准的问题，有2个提案，分别针对Error inspection和Error formatting。 针对 Error inspection ，为error定义了一个可选的接口Unwrap，用来返回错误链上的下一个错误。 ```text package errors type Wrapper interface { Unwrap() error } 例如， ```text // WriteError 实现 Unwrap 接口 func (e *WriteError) Unwrap() error { return e.Err } 针对 Error format，定义了一个可选的接口Format，用来返回错误信息。 ```text package errors type Formatter interface { Format(p Printer) (next error) } 例如， ```text func (e *WriteError) Format(p errors.Printer) (next error) { p.Printf(\"write %s database\", e.Database) if p.Detail() { p.Printf(\"more detail here\") } return e.Err } 泛型(Generics) Go语言当前可使用inferface{}，允许函数参数和返回值是任何类型的值。但这过于灵活，很多时候需要在获取参数后使用类型断言，进而决定下一步的处理。对比C++/Java的标准容器，Go语言在泛型方面有很大不足，因此针对泛型的提案即希望弥补这方面的不足。提案希望能够支持以下功能： type List(type T) []T // 返回map的键 func Keys(type K, V)(m map[K]V) []K // 去重过滤 func Uniq( 例如，我们需要返回一个map对象中所有的键，而希望这个键的类型可以是任意类型。 var ints List(int) keysA := Keys(int, string)(map[int]string{1:\"one\", 2: \"two\"}) keysB := Keys(string, string)(map[string]string{\"name\":\"geektutu\", \"age\": \"twenty\"}) // [1, 2] Go 2 新特性 Go2还未正式发布，发布后更新 参考：Go2 wiki - Github "},"GoLang/Go简明教程/04-Go-Protobuf简明教程.html":{"url":"GoLang/Go简明教程/04-Go-Protobuf简明教程.html","title":"Protobuf简明教程","keywords":"","body":"datetime:2022/1/16 12:27 author:nzb Go Protobuf 简明教程 1 Protocol Buffers 简介 protobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 Memcached 的 Go 语言版本 groupcache 就使用了 protobuf 作为其 RPC 数据格式。 Protobuf 在 .proto 定义需要处理的结构化数据，可以通过 protoc 工具，将 .proto 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。 2 安装 2.1 protoc 从 Protobuf Releases 下载最先版本的发布包安装。如果是 Ubuntu，可以按照如下步骤操作（以3.11.2为例）。 # 下载安装包 $ wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.2/protoc-3.11.2-linux-x86_64.zip # 解压到 /usr/local 目录下 $ sudo 7z x protoc-3.11.2-linux-x86_64.zip -o/usr/local 如果不想安装在 /usr/local 目录下，可以解压到其他的其他，并把解压路径下的 bin 目录 加入到环境变量即可。 如果能正常显示版本，则表示安装成功。 $ protoc --version libprotoc 3.11.2 2.2 protoc-gen-go 我们需要在 Golang 中使用 protobuf，还需要安装 protoc-gen-go，这个工具用来将 .proto 文件转换为 Golang 代码。 go get -u github.com/golang/protobuf/protoc-gen-go protoc-gen-go 将自动安装到 $GOPATH/bin 目录下，也需要将这个目录加入到环境变量中。 3 定义消息类型 接下来，我们创建一个非常简单的示例，student.proto syntax = \"proto3\"; package main; // this is a comment message Student { string name = 1; bool male = 2; repeated int32 scores = 3; } 在当前目录下执行： $ protoc --go_out=. *.proto $ ls student.pb.go student.proto 即是，将该目录下的所有的 .proto 文件转换为 Go 代码，我们可以看到该目录下多出了一个 Go 文件 student.pb.go。这个文件内部定义了一个结构体 Student，以及相关的方法： type Student struct { Name string `protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"` Male bool `protobuf:\"varint,2,opt,name=male,proto3\" json:\"male,omitempty\"` Scores []int32 `protobuf:\"varint,3,rep,packed,name=scores,proto3\" json:\"scores,omitempty\"` ... } 逐行解读student.proto protobuf 有2个版本，默认版本是 proto2，如果需要 proto3，则需要在非空非注释第一行使用 syntax = \"proto3\" 标明版本。 package，即包名声明符是可选的，用来防止不同的消息类型有命名冲突。 消息类型 使用 message 关键字定义，Student 是类型名，name, male, scores 是该类型的 3 个字段，类型分别为 string, bool 和 []int32。字段可以是标量类型，也可以是合成类型。 每个字段的修饰符默认是 singular，一般省略不写，repeated 表示字段可重复，即用来表示 Go 语言中的数组类型。 每个字符 =后面的数字称为标识符，每个字段都需要提供一个唯一的标识符。标识符用来在消息的二进制格式中识别各个字段，一旦使用就不能够再改变，标识符的取值范围为 [1, 2^29 - 1] 。 .proto 文件可以写注释，单行注释 //，多行注释 /* ... */ 一个 .proto 文件中可以写多个消息类型，即对应多个结构体(struct)。 接下来，就可以在项目代码中直接使用了，以下是一个非常简单的例子，即证明被序列化的和反序列化后的实例，包含相同的数据。 package main import ( \"log\" \"github.com/golang/protobuf/proto\" ) func main() { test := &Student{ Name: \"geektutu\", Male: true, Scores: []int32{98, 85, 88}, } data, err := proto.Marshal(test) if err != nil { log.Fatal(\"marshaling error: \", err) } newTest := &Student{} err = proto.Unmarshal(data, newTest) if err != nil { log.Fatal(\"unmarshaling error: \", err) } // Now test and newTest contain the same data. if test.GetName() != newTest.GetName() { log.Fatalf(\"data mismatch %q != %q\", test.GetName(), newTest.GetName()) } } 保留字段(Reserved Field) 更新消息类型时，可能会将某些字段/标识符删除。这些被删掉的字段/标识符可能被重新使用，如果加载老版本的数据时，可能会造成数据冲突，在升级时，可以将这些字段/标识符保留(reserved)，这样就不会被重新使用了，protoc 会检查。 message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; } 4 字段类型 4.1 标量类型(Scalar) proto类型 go类型 备注 double float64 float float32 int32 int32 int64 int64 uint32 uint32 uint64 uint64 sint32 int32 适合负数 sint64 int64 适合负数 fixed32 uint32 固长编码，适合大于2^28的值 fixed64 uint64 固长编码，适合大于2^56的值 sfixed32 int32 固长编码 sfixed64 int64 固长编码 bool bool string string UTF8 编码，长度不超过 2^32 bytes []byte 任意字节序列，长度不超过 2^32 标量类型如果没有被赋值，则不会被序列化，解析时，会赋予默认值。 strings：空字符串 bytes：空序列 bools：false 数值类型：0 4.2 枚举(Enumerations) 枚举类型适用于提供一组预定义的值，选择其中一个。例如我们将性别定义为枚举类型。 message Student { string name = 1; enum Gender { FEMALE = 0; MALE = 1; } Gender gender = 2; repeated int32 scores = 3; } 枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。 别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开allow_alias选项。message EnumAllowAlias { enum Status { option allow_alias = true; UNKOWN = 0; STARTED = 1; RUNNING = 1; } } 4.3 使用其他消息类型 Result 是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。 message SearchResponse { repeated Result results = 1; } message Result { string url = 1; string title = 2; repeated string snippets = 3; } 嵌套写也是支持的： message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } 如果定义在其他文件中，可以导入其他消息类型来使用： import \"myproject/other_protos.proto\"; 4.4 任意类型(Any) Any 可以表示不在 .proto 中定义任意的内置类型。 import \"google/protobuf/any.proto\"; message ErrorStatus { string message = 1; repeated google.protobuf.Any details = 2; } 4.5 oneof message SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; } } 4.6 map message MapRequest { map points = 1; } 5 定义服务(Services) 如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 Search 接口，入参是 SearchRequest 类型，返回类型是 SearchResponse service SearchService { rpc Search (SearchRequest) returns (SearchResponse); } 官方仓库也提供了一个插件列表，帮助开发基于 Protocol Buffer 的 RPC 服务。 6 protoc 其他参数 命令行使用方法 protoc --proto_path=IMPORT_PATH --_out=DST_DIR path/to/file.proto --proto_path=IMPORT_PATH：可以在 .proto 文件中 import 其他的 .proto 文件，proto_path 即用来指定其他 .proto 文件的查找目录。如果没有引入其他的 .proto 文件，该参数可以省略。 --_out=DST_DIR：指定生成代码的目标文件夹，例如 –go_out=. 即生成 GO 代码在当前文件夹，另外支持 cpp/java/python/ruby/objc/csharp/php 等语言 7 推荐风格 文件(Files) 文件名使用小写下划线的命名风格，例如 lower_snake_case.proto 每行不超过 80 字符 使用 2 个空格缩进 包(Packages) 包名应该和目录结构对应，例如文件在my/package/目录下，包名应为 my.package 消息和字段(Messages & Fields) 消息名使用首字母大写驼峰风格(CamelCase)，例如message StudentRequest { ... } 字段名使用小写下划线的风格，例如 string status_code = 1 枚举类型，枚举名使用首字母大写驼峰风格，例如 enum FooBar，枚举值使用全大写下划线隔开的风格(CAPITALS_WITH_UNDERSCORES )，例如 FOO_DEFAULT=1 服务(Services) RPC 服务名和方法名，均使用首字母大写驼峰风格，例如 service FooService{ rpc GetSomething() } 附：参考 protobuf 代码仓库 - github.com golang protobuf 代码仓库 - github.com Remote procedure call 远程过程调用 - wikipedia.org Groupcache Go语言版 memcached - github.com Language Guide (proto3) 官方指南 - google.com Proto Style Guide 代码风格指南 - google.com Protocol Buffer 插件列表 - github.com "},"GoLang/Go简明教程/05-Go-RPC&TLS鉴权简明教程.html":{"url":"GoLang/Go简明教程/05-Go-RPC&TLS鉴权简明教程.html","title":"RPC&TLS鉴权简明教程","keywords":"","body":"datetime:2022/1/16 14:32 author:nzb Go RPC & TLS 鉴权简明教程 本文介绍了 Go 语言远程过程调用(Remote Procedure Call, RPC)的使用方式，示例基于 Golang 标准库 net/rpc，同时介绍了如何基于 TLS/SSL 实现服务器端和客户端的单向鉴权、双向鉴权。 1 RPC 简介 远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 – 远程过程调用 - Wikipedia.org 划重点：程序员就像调用本地程序一样，无需关注细节 RPC 协议假定某种传输协议(TCP, UDP)存在，为通信程序之间携带信息数据。使用 RPC 协议，无需关注底层网络技术协议，调用远程方法就像在调用本地方法一样。 RPC 流程： RPC 模型是一个典型的客户端-服务器模型(Client-Server, CS)，相比于调用本地的接口，RPC 还需要知道的是服务器端的地址信息。本地调用，好比两个人面对面说话，而 RPC 好比打电话，需要知道对方的电话号码，但是并不需要关心语音是怎么编码，如何传输，又如何解码的。 接下来我们将展示如何将一个简单的本地调用的程序一步步地改造一个 RPC 服务。 示例使用 Go 语言，RPC 使用 Golang 提供的net/rpc 标准库 2 一个简单的计算二次方的程序 不考虑 RPC 调用，仅考虑本地调用的场景，程序实现如下： // main.go package main import \"log\" type Result struct { Num, Ans int } type Cal int func (cal *Cal) Square(num int) *Result { return &Result{ Num: num, Ans: num * num, } } func main() { cal := new(Cal) result := cal.Square(12) log.Printf(\"%d^2 = %d\", result.Num, result.Ans) } 在这个20行的程序中，我们做了以下几件事： Cal 结构体，提供了 Square 方法，用于计算传入参数 num 的 二次方。 Result 结构体，包含 Num 和 Ans 两个字段，Ans 是计算后的值，Num 是待计算的值。 main 函数，测试我们实现的 Square 方法。 运行 main.go，将会输出 $ go run main.go 2020/01/13 20:27:08 12^2 = 144 3 RPC 需要满足什么条件 虽然说，远程过程调用并不需要我们关心如何编解码，如何通信，但是最基本的，如果一个方法需要支持远程过程调用，需要满足一定的约束和规范。不同 RPC 框架的约束和规范是不同的，如果使用 Golang 的标准库 net/rpc，方法需要长这个样子： func (t *T) MethodName(argType T1, replyType *T2) error 即需要满足以下 5 个条件： 方法类型（T）是导出的（首字母大写） 方法名（MethodName）是导出的 方法有2个参数(argType T1, replyType *T2)，均为导出/内置类型 方法的第2个参数一个指针(replyType *T2) 方法的返回值类型是 error net/rpc 对参数个数的限制比较严格，仅能有2个，第一个参数是调用者提供的请求参数，第二个参数是返回给调用者的响应参数，也就是说，服务端需要将计算结果写在第二个参数中。如果调用过程中发生错误，会返回 error 给调用者。 接下来，我们改造下 Square 函数，以满足上述 5 个条件。 func (cal *Cal) Square(num int, result *Result) error { result.Num = num result.Ans = num * num return nil } func main() { cal := new(Cal) var result Result cal.Square(11, &result) log.Printf(\"%d^2 = %d\", result.Num, result.Ans) } Cal 和 Square 均为导出类型，满足条件 1) 和 2) 2 个参数，num int 为内置类型，result *Result 为导出类型，满足条件 3) 第2个参数 result *Result 是一个指针，满足条件 4) 返回值类型是 error，满足条件 5) 至此，方法 Cal.Square 满足了 RPC 调用的5个条件。 4 RPC 服务与调用 4.1 基于HTTP，启动 RPC 服务 RPC 是一个典型的客户端-服务器(Client-Server, CS) 架构模型，很显然，需要将 Cal.Square 方法放在服务端。服务端需要提供一个套接字服务，处理客户端发送的请求。通常可以基于 HTTP 协议，监听一个端口，等待 HTTP 请求。 接下来我们新建一个文件夹 server，将 Cal.Square 方法移动到 server/main.go 中，并在 main 函数中启动 RPC 服务。 // server/main.go package main import ( \"log\" \"net\" \"net/http\" \"net/rpc\" ) type Result struct { Num, Ans int } type Cal int func (cal *Cal) Square(num int, result *Result) error { result.Num = num result.Ans = num * num return nil } func main() { rpc.Register(new(Cal)) rpc.HandleHTTP() log.Printf(\"Serving RPC server on port %d\", 1234) if err := http.ListenAndServe(\":1234\", nil); err != nil { log.Fatal(\"Error serving: \", err) } } 使用 rpc.Register，发布 Cal 中满足 RPC 注册条件的方法（Cal.Square） 使用 rpc.HandleHTTP 注册用于处理 RPC 消息的 HTTP Handler 使用 http.ListenAndServe 监听 1234 端口，等待 RPC 请求。 我们在 server 目录下，执行 $ go run main.go 2020/01/13 20:59:22 Serving RPC server on port 1234 此时，RPC 服务已经启动，等待客户端的调用。 4.2 实现客户端 我们在 client 目录中新建文件 client/main.go，创建 HTTP 客户端，调用 Cal.Square 方法。 // client/main.go package main import ( \"log\" \"net/rpc\" ) type Result struct { Num, Ans int } func main() { client, _ := rpc.DialHTTP(\"tcp\", \"localhost:1234\") var result Result if err := client.Call(\"Cal.Square\", 12, &result); err != nil { log.Fatal(\"Failed to call Cal.Square. \", err) } log.Printf(\"%d^2 = %d\", result.Num, result.Ans) } 在客户端的实现中，因为要用到 Result 类型，简单起见，我们拷贝了 Result 的定义。 使用 rpc.DialHTTP 创建了 HTTP 客户端 client，并且创建了与 localhost:1234 的链接，1234 恰好是 RPC 服务监听的端口。 使用 rpc.Call 调用远程方法，第1个参数是方法名 Cal.Square，后两个参数与 Cal.Square 的定义的参数相对应。 我们在 client 目录下，执行 2020/01/13 21:17:45 12^2 = 144 如果能够返回计算的结果，说明调用成功。 4.3 异步调用 client.Call 是同步调用的方式，会阻塞当前的程序，直到结果返回。如果有异步调用的需求，可以考虑使用 client.Go，如下 func main() { client, _ := rpc.DialHTTP(\"tcp\", \"localhost:1234\") var result Result asyncCall := client.Go(\"Cal.Square\", 12, &result, nil) log.Printf(\"%d^2 = %d\", result.Num, result.Ans) 执行结果如下： 2020/01/13 21:34:26 0^2 = 0 2020/01/13 21:34:26 12^2 = 144 因为 client.Go 是异步调用，因此第一次打印 result，result 没有被赋值。而通过调用 ，阻塞当前程序直到 RPC 调用结束，因此第二次打印 result 时，能够看到正确的赋值。 5 证书鉴权(TLS/SSL) 5.1 客户端对服务器端鉴权 HTTP 协议默认是不加密的，我们可以使用证书来保证通信过程的安全。 生成私钥和自签名的证书，并将 server.key 权限设置为只读，保证私钥的安全。 # 生成私钥 openssl genrsa -out server.key 2048 # 生成证书 openssl req -new -x509 -key server.key -out server.crt -days 3650 # 只读权限 chmod 400 server.key 执行完，当前文件夹下多出了 server.crt 和 server.key 2 个文件。 服务器端可以使用生成的 server.crt 和 server.key 文件启动 TLS 的端口监听。 // server/main.go import ( \"crypto/tls\" \"log\" \"net/rpc\" ) func main() { rpc.Register(new(Cal)) cert, _ := tls.LoadX509KeyPair(\"server.crt\", \"server.key\") config := &tls.Config{ Certificates: []tls.Certificate{cert}, } listener, _ := tls.Listen(\"tcp\", \":1234\", config) log.Printf(\"Serving RPC server on port %d\", 1234) for { conn, _ := listener.Accept() defer conn.Close() go rpc.ServeConn(conn) } } 客户端也需要做相应的修改，使用 tls.Dial 代替 rpc.DialHTTP 连接服务端，如果客户端不需要对服务端鉴权，那么可以设置 InsecureSkipVerify:true，即可跳过对服务端的鉴权，例如： // client/main.go import ( \"crypto/tls\" \"log\" \"net/rpc\" ) func main() { config := &tls.Config{ InsecureSkipVerify: true, } conn, _ := tls.Dial(\"tcp\", \"localhost:1234\", config) defer conn.Close() client := rpc.NewClient(conn) var result Result if err := client.Call(\"Cal.Square\", 12, &result); err != nil { log.Fatal(\"Failed to call Cal.Square. \", err) } log.Printf(\"%d^2 = %d\", result.Num, result.Ans) } 如果需要对服务器端鉴权，那么需要将服务端的证书添加到信任证书池中，如下： // client/main.go func main() { certPool := x509.NewCertPool() certBytes, err := ioutil.ReadFile(\"../server/server.crt\") if err != nil { log.Fatal(\"Failed to read server.crt\") } certPool.AppendCertsFromPEM(certBytes) config := &tls.Config{ RootCAs: certPool, } conn, _ := tls.Dial(\"tcp\", \"localhost:1234\", config) defer conn.Close() client := rpc.NewClient(conn) var result Result if err := client.Call(\"Cal.Square\", 12, &result); err != nil { log.Fatal(\"Failed to call Cal.Square. \", err) } log.Printf(\"%d^2 = %d\", result.Num, result.Ans) } 5.2 服务器端对客户端的鉴权 服务器端对客户端的鉴权是类似的，核心在于 tls.Config 的配置： 把对方的证书添加到自己的信任证书池 RootCAs(客户端配置)，ClientCAs(服务器端配置) 中。 创建链接时，配置自己的证书 Certificates。 客户端的 config 作如下修改： // client/main.go cert, _ := tls.LoadX509KeyPair(\"client.crt\", \"client.key\") certPool := x509.NewCertPool() certBytes, _ := ioutil.ReadFile(\"../server/server.crt\") certPool.AppendCertsFromPEM(certBytes) config := &tls.Config{ Certificates: []tls.Certificate{cert}, RootCAs: certPool, } 服务器端的 config 作如下修改： // server/main.go cert, _ := tls.LoadX509KeyPair(\"server.crt\", \"server.key\") certPool := x509.NewCertPool() certBytes, _ := ioutil.ReadFile(\"../client/client.crt\") certPool.AppendCertsFromPEM(certBytes) config := &tls.Config{ Certificates: []tls.Certificate{cert}, ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: certPool, } 附：参考 Golang net/rpc 官方文档 - golang.org Golang TLS 配置 - github.com "},"GoLang/Go简明教程/06-Go-WebAssembly简明教程.html":{"url":"GoLang/Go简明教程/06-Go-WebAssembly简明教程.html","title":"WebAssembly(Wasm)简明教程","keywords":"","body":"datetime:2022/1/16 16:00 author:nzb Go WebAssembly (Wasm) 简明教程 1 WebAssembly 简介 WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C / C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。 —— MDN web docs - mozilla.org 从 MDN 的介绍中，我们可以得出几个结论： WebAssembly 是一种二进制编码格式，而不是一门新的语言。 WebAssembly 不是为了取代 JavaScript，而是一种补充（至少现阶段是这样），结合 WebAssembly 的性能优势，很大可能集中在对性能要求高（例如游戏，AI），或是对交互体验要求高（例如移动端）的场景。 C/C++ 等语言可以编译 WebAssembly 的目标文件，也就是说，其他语言可以通过编译器支持，而写出能够在浏览器前端运行的代码。 Go 语言在 1.11 版本(2018年8月) 加入了对 WebAssembly (Wasm) 的原生支持，使用 Go 语言开发 WebAssembly 相关的应用变得更加地简单。Go 语言的内建支持是 Go 语言进军前端的一个重要的里程碑。在这之前，如果想使用 Go 语言开发前端，需要使用 GopherJS，GopherJS 是一个编译器，可以将 Go 语言转换成可以在浏览器中运行的 JavaScript 代码。新版本的 Go 则直接将 Go 代码编译为 wasm 二进制文件，而不再需要转为 JavaScript 代码。更巧的是，实现 GopherJS 和在 Go 语言中内建支持 WebAssembly 的是同一拨人。 Go 语言实现的函数可以直接导出供 JavaScript 代码调用，同时，Go 语言内置了 syscall/js 包，可以在 Go 语言中直接调用 JavaScript 函数，包括对 DOM 树的操作。 2 Hello World 接下来，我们使用 Go 语言实现一个最简单的程序，在网页上弹出 Hello World。 第一步，新建文件 main.go，使用 js.Global().get(‘alert’) 获取全局的 alert 对象，通过 Invoke 方法调用。等价于在 js 中调用 window.alert(\"Hello World\")。 // main.go package main import \"syscall/js\" func main() { alert := js.Global().Get(\"alert\") alert.Invoke(\"Hello World!\") } 第二步，将 main.go 编译为 static/main.wasm 如果启用了 GO MODULES，则需要使用 go mod init 初始化模块，或设置 GO111MODULE=auto。 $ GOOS=js GOARCH=wasm go build -o static/main.wasm 第三步，拷贝 wasm_exec.js (JavaScript 支持文件，加载 wasm 文件时需要) 到 static 文件夹 $ cp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" static 第四步，创建 index.html，引用 static/main.wasm 和 static/wasm_exec.js。 ```text const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"static/main.wasm\"), go.importObject) .then((result) => go.run(result.instance)); 第五步，使用 goexec 启动 Web 服务 > 如果没有安装 goexec，可用 `go get -u github.com/shurcooL/goexec` 安装，需要将 $GOBIN 或 $GOPATH/bin 加入环境变量 当前的目录结构如下： ```text demo/ |--static/ |--wasm_exec.js |--main.wasm |--main.go |--index.html $ goexec 'http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))' 浏览器访问 localhost:9999，则会有一个弹出窗口，上面写着 Hello World!。 为了避免每次编译都需要输入繁琐的命令，可将这个过程写在 Makefile 中 all: static/main.wasm static/wasm_exec.js goexec 'http.ListenAndServe(`:9999`, http.FileServer(http.Dir(`.`)))' static/wasm_exec.js: cp \"$(shell go env GOROOT)/misc/wasm/wasm_exec.js\" static static/main.wasm : main.go GO111MODULE=auto GOOS=js GOARCH=wasm go build -o static/main.wasm . 这样一个敲一下 make 就够了 3 注册函数(Register Functions) 在 Go 语言中调用 JavaScript 函数是一方面，另一方面，如果仅仅是使用 WebAssembly 替代性能要求高的模块，那么就需要注册函数，以便其他 JavaScript 代码调用。 假设我们需要注册一个计算斐波那契数列的函数，可以这么实现。 // main.go package main import \"syscall/js\" func fib(i int) int { if i == 0 || i == 1 { return 1 } return fib(i-1) + fib(i-2) } func fibFunc(this js.Value, args []js.Value) interface{} { return js.ValueOf(fib(args[0].Int())) } func main() { done := make(chan int, 0) js.Global().Set(\"fibFunc\", js.FuncOf(fibFunc)) fib 是一个普通的 Go 函数，通过递归计算第 i 个斐波那契数，接收一个 int 入参，返回值也是 int。 定义了 fibFunc 函数，为 fib 函数套了一个壳，从 args[0] 获取入参，计算结果用 js.ValueOf 包装，并返回。 使用 js.Global().Set() 方法，将注册函数 fibFunc 到全局，以便在浏览器中能够调用。 js.Value 可以将 Js 的值转换为 Go 的值，比如 args[0].Int()，则是转换为 Go 语言中的整型。js.ValueOf，则用来将 Go 的值，转换为 Js 的值。另外，注册函数的时候，使用 js.FuncOf 将函数转换为 Func 类型，只有 Func 类型的函数，才能在 JavaScript 中调用。可以认为这是 Go 与 JavaScript 之间的接口/约定。 js.Func() 接受一个函数类型作为其参数，该函数的定义必须是： func(this Value, args []Value) interface{} // this 即 JavaScript 中的 this // args 是在 JavaScript 中调用该函数的参数列表。 // 返回值需用 js.ValueOf 映射成 JavaScript 的值 在 main 函数中，创建了信道(chan) done，阻塞主协程(goroutine)。fibFunc 如果在 JavaScript 中被调用，会开启一个新的子协程执行。 A wrapped function triggered during a call from Go to JavaScript gets executed on the same goroutine. A wrapped function triggered by JavaScript’s event loop gets executed on an extra goroutine. —— FuncOf - golang.org 接下来，修改之前的 index.html，在其中添加一个输入框(num)，一个按钮(btn) 和一个文本框(ans，用来显示计算结果)，并给按钮添加了一个点击事件，调用 fibFunc，并将计算结果显示在文本框(ans)中。 ... Click 1 使用之前的命令重新编译 main.go，并在 9999 端口启动 Web 服务，如果我们已经将命令写在 Makefile 中了，只需要运行 make 即可。 接下来访问 localhost:9999，可以看到如下效果。输入一个数字，点击Click，计算结果显示在输入框下方。 4 操作 DOM 在上一个例子中，仅仅是注册了全局函数 fibFunc，事件注册，调用，对 DOM 元素的操作都是在 HTML 中通过原生的 JavaScript 函数实现的。这些事情，能不能全部在 Go 语言中完成呢？答案可以。 首先修改 index.html，删除事件注册部分和 对 DOM 元素的操作部分。 ... Click 1 修改 main.go： package main import ( \"strconv\" \"syscall/js\" ) func fib(i int) int { if i == 0 || i == 1 { return 1 } return fib(i-1) + fib(i-2) } var ( document = js.Global().Get(\"document\") numEle = document.Call(\"getElementById\", \"num\") ansEle = document.Call(\"getElementById\", \"ans\") btnEle = js.Global().Get(\"btn\") ) func fibFunc(this js.Value, args []js.Value) interface{} { v := numEle.Get(\"value\") if num, err := strconv.Atoi(v.String()); err == nil { ansEle.Set(\"innerHTML\", js.ValueOf(fib(num))) } return nil } func main() { done := make(chan int, 0) btnEle.Call(\"addEventListener\", \"click\", js.FuncOf(fibFunc)) 通过 js.Global().Get(\"btn\") 或 document.Call(\"getElementById\", \"num\") 两种方式获取到 DOM 元素。 btnEle 调用 addEventListener 为 btn 绑定点击事件 fibFunc。 在 fibFunc 中使用 numEle.Get(\"value\") 获取到 numEle 的值（字符串），转为整型并调用 fib 计算出结果。 ansEle 调用 Set(\"innerHTML\", ...) 渲染计算结果。 重新编译 main.go，访问 localhost:9999，效果与之前是一致的。 5 回调函数(Callback Functions) 在 JavaScript 中，异步+回调是非常常见的，比如请求一个 Restful API，注册一个回调函数，待数据获取到，再执行回调函数的逻辑，这个期间程序可以继续做其他的事情。Go 语言可以通过协程实现异步。 假设 fib 的计算非常耗时，那么可以启动注册一个回调函数，待 fib 计算完成后，再把计算结果显示出来。 我们先修改 main.go，使得 fibFunc 支持传入回调函数。 package main import ( \"syscall/js\" \"time\" ) func fib(i int) int { if i == 0 || i == 1 { return 1 } return fib(i-1) + fib(i-2) } func fibFunc(this js.Value, args []js.Value) interface{} { callback := args[len(args)-1] go func() { time.Sleep(3 * time.Second) v := fib(args[0].Int()) callback.Invoke(v) }() js.Global().Get(\"ans\").Set(\"innerHTML\", \"Waiting 3s...\") return nil } func main() { done := make(chan int, 0) js.Global().Set(\"fibFunc\", js.FuncOf(fibFunc)) 假设调用 fibFunc 时，回调函数作为最后一个参数，那么通过 args[len(args)-1] 便可以获取到该函数。这与其他类型参数的传递并无区别。 使用 go func() 启动子协程，调用 fib 计算结果，计算结束后，调用回调函数 callback，并将计算结果传递给回调函数，使用 time.Sleep() 模拟 3s 的耗时操作。 计算结果出来前，先在界面上显示 Waiting 3s... 接下来我们修改 index.html，为按钮添加点击事件，调用 fibFunc ... ans.innerHTML=v)\">Click 为 btn 注册了点击事件，第一个参数是待计算的数字，从 num 输入框获取。 第二个参数是一个回调函数，将参数 v 显示在 ans 文本框中。 接下来，重新编译 main.go，访问 localhost:9999，随便输入一个数字，点击 Click。页面会先显示 Waiting 3s...，3s过后显示计算结果。 6 进一步的尝试 6.1 工具框架 WebAssembly 的二进制分析工具 WebAssembly Code Explorer 使用NodeJs 或浏览器测试 Go Wasm 代码 Github Wiki 借鉴 Vue 实现的 Golang WebAssembly 前端框架 Vugu，完全使用 Go，不用写任何的 JavaScript 代码。6.2 Demo/项目 使用 Go Assembly 前端渲染的一些例子 jsgo 这个项目汇聚一些小而精的项目，包括 2048，俄罗斯方块等游戏，还有证明 Go 可以完整开发前端项目的 TodoMVC6.3 相关文档 syscall/js 官方文档 - golang.org Go WebAssembly 官方文档 - github.com "},"GoLang/Go简明教程/07-Go-Test单元测试简明教程.html":{"url":"GoLang/Go简明教程/07-Go-Test单元测试简明教程.html","title":"Test单元测试简明教程","keywords":"","body":"datetime:2022/01/31 16:35 author:nzb Go Test 单元测试简明教程 1 如何写好单元测试 单元测试(Unit Tests, UT) 是一个优秀项目不可或缺的一部分，特别是在一些频繁变动和多人合作开发的项目中尤为重要。你或多或少都会有因为自己的提交，导致应用挂掉或服务宕机的经历。如果这个时候你的修改导致测试用例失败，你再重新审视自己的修改，发现之前的修改还有一些特殊场景没有包含，恭喜你减少了一次上库失误。也会有这样的情况，项目很大，启动环境很复杂，你优化了一个函数的性能，或是添加了某个新的特性，如果部署在正式环境上之后再进行测试，成本太高。对于这种场景，几个小小的测试用例或许就能够覆盖大部分的测试场景。而且在开发过程中，效率最高的莫过于所见即所得了，单元测试也能够帮助你做到这一点，试想一下，假如你一口气写完一千行代码，debug 的过程也不会轻松，如果在这个过程中，对于一些逻辑较为复杂的函数，同时添加一些测试用例，即时确保正确性，最后集成的时候，会是另外一番体验。 如何写好单元测试呢？ 首先，学会写测试用例。比如如何测试单个函数/方法；比如如何做基准测试；比如如何写出简洁精炼的测试代码；再比如遇到数据库访问等的方法调用时，如何 mock。 然后，写可测试的代码。高内聚，低耦合是软件工程的原则，同样，对测试而言，函数/方法写法不同，测试难度也是不一样的。职责单一，参数类型简单，与其他函数耦合度低的函数往往更容易测试。我们经常会说，“这种代码没法测试”，这种时候，就得思考函数的写法可不可以改得更好一些。为了代码可测试而重构是值得的。 接下来将介绍如何使用 Go 语言的标准库 testing 进行单元测试。 2 一个简单例子 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。 example/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下： package main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.go 中的测试用例可以这么写： package main import \"testing\" func TestAdd(t *testing.T) { if ans := Add(1, 2); ans != 3 { t.Errorf(\"1 + 2 expected be 3, but %d got\", ans) } if ans := Add(-10, -20); ans != -30 { t.Errorf(\"-10 + -20 expected be -30, but %d got\", ans) } } 测试用例名称一般命名为 Test 加上待测试的方法名。 测试用的参数有且只有一个，在这里是 t *testing.T。 基准测试(benchmark)的参数是 testing.B，TestMain 的参数是 testing.M 类型。 运行 go test，该 package 下所有的测试用例都会被执行。 $ go test ok example 0.009s 或 go test -v，-v 参数会显示每个用例的测试结果，另外 -cover 参数可以查看覆盖率。 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) === RUN TestMul --- PASS: TestMul (0.00s) PASS ok example 0.007s 如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。 $ go test -run TestAdd -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.007s 3 子测试(Subtests) 子测试是 Go 语言内置支持的，可以在某个测试用例中，根据测试场景使用 t.Run创建不同的子测试用例： // calc_test.go func TestMul(t *testing.T) { t.Run(\"pos\", func(t *testing.T) { if Mul(2, 3) != 6 { t.Fatal(\"fail\") } }) t.Run(\"neg\", func(t *testing.T) { if Mul(2, -3) != -6 { t.Fatal(\"fail\") } }) } 之前的例子测试失败时使用 t.Error/t.Errorf，这个例子中使用 t.Fatal/t.Fatalf，区别在于前者遇错不停，还会继续执行其他的测试用例，后者遇错即停。 运行某个测试用例的子测试： $ go test -run TestMul/pos -v === RUN TestMul === RUN TestMul/pos --- PASS: TestMul (0.00s) --- PASS: TestMul/pos (0.00s) PASS ok example 0.008s 对于多个子测试的场景，更推荐如下的写法(table-driven tests)： // calc_test.go func TestMul(t *testing.T) { cases := []struct { Name string A, B, Expected int }{ {\"pos\", 2, 3, 6}, {\"neg\", 2, -3, -6}, {\"zero\", 2, 0, 0}, } for _, c := range cases { t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\"%d * %d expected %d, but %d got\", c.A, c.B, c.Expected, ans) } }) } } 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试。这样写的好处有： 新增用例非常简单，只需给 cases 新增一条测试数据即可。 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。 用例失败时，报错信息的格式比较统一，测试报告易于阅读。 如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取。 4 帮助函数(helpers) 对一些重复的逻辑，抽取出来作为公共的帮助函数(helpers)，可以增加测试代码的可读性和可维护性。 借助帮助函数，可以让测试用例的主逻辑看起来更清晰。 例如，我们可以将创建子测试的逻辑抽取出来： // calc_test.go package main import \"testing\" type calcCase struct{ A, B, Expected int } func createMulTestCase(t *testing.T, c *calcCase) { // t.Helper() if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\"%d * %d expected %d, but %d got\", c.A, c.B, c.Expected, ans) } } func TestMul(t *testing.T) { createMulTestCase(t, &calcCase{2, 3, 6}) createMulTestCase(t, &calcCase{2, -3, -6}) createMulTestCase(t, &calcCase{2, 0, 1}) // wrong case } 在这里，我们故意创建了一个错误的测试用例，运行 go test，用例失败，会报告错误发生的文件和行号信息： $ go test --- FAIL: TestMul (0.00s) calc_test.go:11: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.007s 可以看到，错误发生在第11行，也就是帮助函数 createMulTestCase 内部。18, 19, 20行都调用了该方法，我们第一时间并不能够确定是哪一行发生了错误。有些帮助函数还可能在不同的函数中被调用，报错信息都在同一处，不方便问题定位。因此，Go 语言在 1.9 版本中引入了 t.Helper()，用于标注该函数是帮助函数，报错时将输出帮助函数调用者的信息，而不是帮助函数的内部信息。 修改 createMulTestCase，调用 t.Helper() func createMulTestCase(c *calcCase, t *testing.T) { t.Helper() t.Run(c.Name, func(t *testing.T) { if ans := Mul(c.A, c.B); ans != c.Expected { t.Fatalf(\"%d * %d expected %d, but %d got\", c.A, c.B, c.Expected, ans) } }) } 运行 go test，报错信息如下，可以非常清晰地知道，错误发生在第 20 行。 $ go test --- FAIL: TestMul (0.00s) calc_test.go:20: 2 * 0 expected 1, but 0 got FAIL exit status 1 FAIL example 0.006s 关于 helper 函数的 2 个建议： 不要返回错误， 帮助函数内部直接使用 t.Error 或 t.Fatal 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。 调用 t.Helper() 让报错信息更准确，有助于定位。 5 setup 和 teardown 如果在同一个测试文件中，每一个测试用例运行前后的逻辑是相同的，一般会写在 setup 和 teardown 函数中。例如执行前需要实例化待测试的对象，如果这个对象比较复杂，很适合将这一部分逻辑提取出来；执行后，可能会做一些资源回收类的工作，例如关闭网络连接，释放文件等。标准库 testing 提供了这样的机制： func setup() { fmt.Println(\"Before all tests\") } func teardown() { fmt.Println(\"After all tests\") } func Test1(t *testing.T) { fmt.Println(\"I'm test1\") } func Test2(t *testing.T) { fmt.Println(\"I'm test2\") } func TestMain(m *testing.M) { setup() code := m.Run() teardown() os.Exit(code) } 在这个测试文件中，包含有2个测试用例，Test1 和 Test2。 如果测试文件中包含函数 TestMain，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。 调用 m.Run() 触发所有测试用例的执行，并使用 os.Exit() 处理返回的状态码，如果不为0，说明有用例失败。 因此可以在调用 m.Run() 前后做一些额外的准备(setup)和回收(teardown)工作。 执行 go test，将会输出 $ go test Before all tests I'm test1 I'm test2 PASS After all tests ok example 0.006s 6 网络测试(Network) 6.1 TCP/HTTP 假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler func helloHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"hello world\")) } 那我们可以创建真实的网络连接进行测试： // test code import ( \"io/ioutil\" \"net\" \"net/http\" \"testing\" ) func handleError(t *testing.T, err error) { t.Helper() if err != nil { t.Fatal(\"failed\", err) } } func TestConn(t *testing.T) { ln, err := net.Listen(\"tcp\", \"127.0.0.1:0\") handleError(t, err) defer ln.Close() http.HandleFunc(\"/hello\", helloHandler) go http.Serve(ln, nil) resp, err := http.Get(\"http://\" + ln.Addr().String() + \"/hello\") handleError(t, err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) handleError(t, err) if string(body) != \"hello world\" { t.Fatal(\"expected hello world, but got\", string(body)) } } net.Listen(\"tcp\", \"127.0.0.1:0\")：监听一个未被占用的端口，并返回 Listener。 调用 http.Serve(ln, nil) 启动 http 服务。 使用 http.Get 发起一个 Get 请求，检查返回值是否正确。 尽量不对 http 和 net 库使用 mock，这样可以覆盖较为真实的场景。 6.2 httptest 针对 http 开发的场景，使用标准库 net/http/httptest 进行测试更为高效。 上述的测试用例改写如下： // test code import ( \"io/ioutil\" \"net/http\" \"net/http/httptest\" \"testing\" ) func TestConn(t *testing.T) { req := httptest.NewRequest(\"GET\", \"http://example.com/foo\", nil) w := httptest.NewRecorder() helloHandler(w, req) bytes, _ := ioutil.ReadAll(w.Result().Body) if string(bytes) != \"hello world\" { t.Fatal(\"expected hello world, but got\", string(bytes)) } } 使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。 7 Benchmark 基准测试 基准测试用例的定义如下： func BenchmarkName(b *testing.B){ // ... } 函数名必须以 Benchmark 开头，后面一般跟待测试的函数名 参数为 b *testing.B。 执行基准测试时，需要添加 -bench 参数。 例如： func BenchmarkHello(b *testing.B) { for i := 0; i $ go test -benchmem -bench . ... BenchmarkHello-16 15991854 71.6 ns/op 5 B/op 1 allocs/op ... 基准测试报告每一列值对应的含义如下： type BenchmarkResult struct { N int // 迭代次数 T time.Duration // 基准测试花费的时间 Bytes int64 // 一次迭代处理的字节数 MemAllocs uint64 // 总的分配内存的次数 MemBytes uint64 // 总的分配内存的字节数 } 如果在运行前基准测试需要一些耗时的配置，则可以使用 b.ResetTimer() 先重置定时器，例如： func BenchmarkHello(b *testing.B) { ... // 耗时操作 b.ResetTimer() for i := 0; i 使用 RunParallel 测试并发性能 func BenchmarkParallel(b *testing.B) { templ := template.Must(template.New(\"test\").Parse(\"Hello, { {.} }!\")) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { // 所有 goroutine 一起，循环一共执行 b.N 次 buf.Reset() templ.Execute(&buf, \"World\") } }) } $ go test -benchmem -bench . ... BenchmarkParallel-16 3325430 375 ns/op 272 B/op 8 allocs/op ... 参考链接 testing - golang.org Advanced Testing in Go - sourcegraph.com "},"GoLang/Go简明教程/08-Go-Mock简明教程.html":{"url":"GoLang/Go简明教程/08-Go-Mock简明教程.html","title":"Mock(gomock)简明教程","keywords":"","body":"datetime:2022/02/01 15::02 author:nzb Go Mock (gomock)简明教程 1 gomock 简介 上一篇文章 Go Test 单元测试简明教程 介绍了 Go 语言中单元测试的常用方法，包括子测试(subtests)、表格驱动测试(table-driven tests)、帮助函数(helpers)、网络测试和基准测试(Benchmark)等。这篇文章介绍一种新的测试方法，mock/stub 测试，当待测试的函数/对象的依赖关系很复杂，并且有些依赖不能直接创建，例如数据库连接、文件I/O等。这种场景就非常适合使用 mock/stub 测试。简单来说，就是用 mock 对象模拟依赖项的行为。 GoMock is a mocking framework for the Go programming language. It integrates well with Go’s built-in testing package, but can be used in other contexts too. gomock 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。 使用如下命令即可安装： go get -u github.com/golang/mock/gomock go get -u github.com/golang/mock/mockgen 2 一个简单的 Demo // db.go type DB interface { Get(key string) (int, error) } func GetFromDB(db DB, key string) int { if value, err := db.Get(key); err == nil { return value } return -1 } 假设 DB 是代码中负责与数据库交互的部分(在这里用 map 模拟)，测试用例中不能创建真实的数据库连接。这个时候，如果我们需要测试 GetFromDB 这个函数内部的逻辑，就需要 mock 接口 DB。 第一步：使用 mockgen 生成 db_mock.go。一般传递三个参数。包含需要被mock的接口得到源文件source，生成的目标文件destination，包名package。 $ mockgen -source=db.go -destination=db_mock.go -package=main 第二步：新建 db_test.go，写测试用例。 func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Eq(\"Tom\")).Return(100, errors.New(\"not exist\")) if v := GetFromDB(m, \"Tom\"); v != -1 { t.Fatal(\"expected -1, but got\", v) } } 这个测试用例有2个目的，一是使用 ctrl.Finish() 断言 DB.Get() 被是否被调用，如果没有被调用，后续的 mock 就失去了意义； 二是测试方法 GetFromDB() 的逻辑是否正确(如果 DB.Get() 返回 error，那么 GetFromDB() 返回 -1)。 NewMockDB() 的定义在 db_mock.go 中，由 mockgen 自动生成。 最终的代码结构如下： project/ |--db.go |--db_mock.go // generated by mockgen |--db_test.go 执行测试： $ go test . -cover -v === RUN TestGetFromDB --- PASS: TestGetFromDB (0.00s) PASS coverage: 81.2% of statements ok example 0.008s coverage: 81.2% of statements 3 打桩(stubs) 在上面的例子中，当 Get() 的参数为 Tom，则返回 error，这称之为打桩(stub)，有明确的参数和返回值是最简单打桩方式。除此之外，检测调用次数、调用顺序，动态设置返回值等方式也经常使用。 3.1 参数(Eq, Any, Not, Nil) m.EXPECT().Get(gomock.Eq(\"Tom\")).Return(0, errors.New(\"not exist\")) m.EXPECT().Get(gomock.Any()).Return(630, nil) m.EXPECT().Get(gomock.Not(\"Sam\")).Return(0, nil) m.EXPECT().Get(gomock.Nil()).Return(0, errors.New(\"nil\")) Eq(value) 表示与 value 等价的值。 Any() 可以用来表示任意的入参。 Not(value) 用来表示非 value 以外的值。 Nil() 表示 None 值 3.2 返回值(Return, DoAndReturn) m.EXPECT().Get(gomock.Not(\"Sam\")).Return(0, nil) m.EXPECT().Get(gomock.Any()).Do(func(key string) { t.Log(key) }) m.EXPECT().Get(gomock.Any()).DoAndReturn(func(key string) (int, error) { if key == \"Sam\" { return 630, nil } return 0, errors.New(\"not exist\") }) Return 返回确定的值 Do Mock 方法被调用时，要执行的操作吗，忽略返回值。 DoAndReturn 可以动态地控制返回值。 3.3 调用次数(Times) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() m := NewMockDB(ctrl) m.EXPECT().Get(gomock.Not(\"Sam\")).Return(0, nil).Times(2) GetFromDB(m, \"ABC\") GetFromDB(m, \"DEF\") } Times() 断言 Mock 方法被调用的次数。 MaxTimes() 最大次数。 MinTimes() 最小次数。 AnyTimes() 任意次数（包括 0 次）。 3.4 调用顺序(InOrder) func TestGetFromDB(t *testing.T) { ctrl := gomock.NewController(t) defer ctrl.Finish() // 断言 DB.Get() 方法是否被调用 m := NewMockDB(ctrl) o1 := m.EXPECT().Get(gomock.Eq(\"Tom\")).Return(0, errors.New(\"not exist\")) o2 := m.EXPECT().Get(gomock.Eq(\"Sam\")).Return(630, nil) gomock.InOrder(o1, o2) GetFromDB(m, \"Tom\") GetFromDB(m, \"Sam\") } 4 如何编写可 mock 的代码 写可测试的代码与写好测试用例是同等重要的，如何写可 mock 的代码呢？ mock 作用的是接口，因此将依赖抽象为接口，而不是直接依赖具体的类。 不直接依赖的实例，而是使用依赖注入降低耦合性。 在软件工程中，依赖注入的意思为，给予调用方它所需要的事物。 “依赖”是指可被方法调用的事物。依赖注入形式下，调用方不再直接指使用“依赖”，取而代之是“注入” 。“注入”是指将“依赖”传递给调用方的过程。在“注入”之后，调用方才会调用该“依赖”。传递依赖给调用方，而不是让让调用方直接获得依赖，这个是该设计的根本需求。 依赖注入 - Wikipedia 如果 GetFromDB() 方法长这个样子 func GetFromDB(key string) int { db := NewDB() if value, err := db.Get(key); err == nil { return value } return -1 } 对 DB 接口的 mock 并不能作用于 GetFromDB() 内部，这样写是没办法进行测试的。那如果将接口 db DB 通过参数传递到 GetFromDB()，那么就可以轻而易举地传入 Mock 对象了。 "},"GoLang/Go简明教程/09-Go-Mmap-文件内存映射简明教程.html":{"url":"GoLang/Go简明教程/09-Go-Mmap-文件内存映射简明教程.html","title":"Mmap-文件内存映射简明教程","keywords":"","body":"datetime:2022/02/01 18:53 author:nzb Go Mmap 文件内存映射简明教程 1 mmap 简介 In computing, mmap is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O. mmap - wikipedia.org 简单理解，mmap 是一种将文件/设备映射到内存的方法，实现文件的磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系。也就是说，可以在某个进程中通过操作这一段映射的内存，实现对文件的读写等操作。修改了这一段内存的内容，文件对应位置的内容也会同步修改，而读取这一段内存的内容，相当于读取文件对应位置的内容。 mmap 另一个非常重要的特性是：减少内存的拷贝次数。在 linux 系统中，文件的读写操作通常通过 read 和 write 这两个系统调用来实现，这个过程会产生频繁的内存拷贝。比如 read 函数就涉及了 2 次内存拷贝： 操作系统读取磁盘文件到页缓存； 从页缓存将数据拷贝到 read 传递的 buf 中(例如进程中创建的byte数组)。 mmap 只需要一次拷贝。即操作系统读取磁盘文件到页缓存，进程内部直接通过指针方式修改映射的内存。因此 mmap 特别适合读写频繁的场景，既减少了内存拷贝次数，提高效率，又简化了操作。KV数据库 bbolt 就使用了这个方法持久化数据。 2 标准库 mmap Go 语言标准库 golang.org/x/exp/mmap 仅实现了 read 操作，后续能否支持 write 操作未知。使用场景非常有限。看一个简单的例子： 从第4个byte开始，读取 tmp.txt 2个byte的内容。 package main import ( \"fmt\" \"golang.org/x/exp/mmap\" ) func main() { at, _ := mmap.Open(\"./tmp.txt\") buff := make([]byte, 2) _, _ = at.ReadAt(buff, 4) _ = at.Close() fmt.Println(string(buff)) } $ echo \"abcdefg\" > tmp.txt $ go run . ef 如果使用 os.File 操作，代码几乎是一样的，os.File 还支持写操作 WriteAt： package main import ( \"fmt\" \"os\" ) func main() { f, _ := os.OpenFile(\"tmp.txt\", os.O_CREATE|os.O_RDWR, 0644) _, _ = f.WriteAt([]byte(\"abcdefg\"), 0) buff := make([]byte, 2) _, _ = f.ReadAt(buff, 4) _ = f.Close() fmt.Println(string(buff)) } 3 mmap(linux) 如果要支持 write 操作，那么就需要直接调用 mmap 的系统调用来实现了。Linux 和 Windows 都支持 mmap，但接口有所不同。对于 linux 系统，mmap 方法定义如下： func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) 每个参数的含义分别是： - fd：待映射的文件描述符。 - offset：映射到内存区域的起始位置，0 表示由内核指定内存地址。 - length：要映射的内存区域的大小。 - prot：内存保护标志位，可以通过或运算符`|`组合 - PROT_EXEC // 页内容可以被执行 - PROT_READ // 页内容可以被读取 - PROT_WRITE // 页可以被写入 - PROT_NONE // 页不可访问 - flags：映射对象的类型，常用的是以下两类 - MAP_SHARED // 共享映射，写入数据会复制回文件, 与映射该文件的其他进程共享。 - MAP_PRIVATE // 建立一个写入时拷贝的私有映射，写入数据不影响原文件。 首先定义2个常量和数据类型Demo： const defaultMaxFileSize = 1 内存有换页机制，映射的物理内存可以远小于文件。 Demo结构体由3个字段构成，file 即文件描述符，data 是映射内存的起始地址，dataRef 用于后续取消映射。 定义 mmap, grow, ummap 三个方法： func (demo *Demo) mmap() { b, err := syscall.Mmap(int(demo.file.Fd()), 0, defaultMemMapSize, syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED) _assert(err == nil, \"failed to mmap\", err) demo.dataRef = b demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(&b[0])) } func (demo *Demo) grow(size int64) { if info, _ := demo.file.Stat(); info.Size() >= size { return } _assert(demo.file.Truncate(size) == nil, \"failed to truncate\") } func (demo *Demo) munmap() { _assert(syscall.Munmap(demo.dataRef) == nil, \"failed to munmap\") demo.data = nil demo.dataRef = nil } mmap 传入的内存保护标志位为 syscall.PROT_WRITE|syscall.PROT_READ，即可读可写，映射类型为 syscall.MAP_SHARED，即对内存的修改会同步到文件。 syscall.Mmap 返回的是一个切片对象，需要从该切片中获取到内存的起始地址，并转换为可操作的 byte 数组，byte数组的长度为 defaultMaxFileSize。 grow 用于修改文件的大小，Linux 不允许操作超过文件大小之外的内存地址。例如文件大小为 4K，可访问的地址是data[0~4095]，如果访问 data[10000] 会报错。 munmap 用于取消映射。 在文件中写入 hello, world! func main() { _ = os.Remove(\"tmp.txt\") f, _ := os.OpenFile(\"tmp.txt\", os.O_CREATE|os.O_RDWR, 0644) demo := &Demo{file: f} demo.grow(1) demo.mmap() defer demo.munmap() msg := \"hello world!\" demo.grow(int64(len(msg) * 2)) for i, v := range msg { demo.data[2*i] = byte(v) demo.data[2*i+1] = byte(' ') } } 在调用 mmap 之前，调用了 grow(1)，因为在 mmap 中使用 &b[0] 获取到映射内存的起始地址，所以文件大小至少为 1 byte。 接下来，便是通过直接操作 demo.data，修改文件内容了。 运行：$ go run . $ cat tmp.txt h e l l o w o r l d ! 4 mmap(Windows) 相对于 Linux，Windows 上 mmap 的使用要复杂一些。 func (demo *Demo) mmap() { h, err := syscall.CreateFileMapping(syscall.Handle(demo.file.Fd()), nil, syscall.PAGE_READWRITE, 0, defaultMemMapSize, nil) _assert(h != 0, \"failed to map\", err) addr, err := syscall.MapViewOfFile(h, syscall.FILE_MAP_WRITE, 0, 0, uintptr(defaultMemMapSize)) _assert(addr != 0, \"MapViewOfFile failed\", err) err = syscall.CloseHandle(syscall.Handle(h)); _assert(err == nil, \"CloseHandle failed\") // Convert to a byte array. demo.data = (*[defaultMaxFileSize]byte)(unsafe.Pointer(addr)) } func (demo *Demo) munmap() { addr := (uintptr)(unsafe.Pointer(&demo.data[0])) _assert(syscall.UnmapViewOfFile(addr) == nil, \"failed to munmap\") } 需要 CreateFileMapping 和 MapViewOfFile 两步才能完成内存映射。MapViewOfFile 返回映射成功的内存地址，因此可以直接将该地址转换成 byte 数组。 Windows 对文件的大小没有要求，直接操作内存data，文件大小会自动发生改变。 使用时无需关注文件的大小。 func main() { _ = os.Remove(\"tmp.txt\") f, _ := os.OpenFile(\"tmp.txt\", os.O_CREATE|os.O_RDWR, 0644) demo := &Demo{file: f} demo.mmap() defer demo.munmap() msg := \"hello world!\" for i, v := range msg { demo.data[2*i] = byte(v) demo.data[2*i+1] = byte(' ') } } $ go run . $ cat .\\tmp.txt h e l l o w o r l d ! 参考链接 edsrzf/mmap-go - github.com golang 官方文档 syscall - golang.org "},"GoLang/Go简明教程/10-Go-Context并发编程简明教程.html":{"url":"GoLang/Go简明教程/10-Go-Context并发编程简明教程.html","title":"Context并发编程简明教程","keywords":"","body":"datetime:2022/02/01 19:13 author:nzb Go Context 并发编程简明教程 1 为什么需要 Context WaitGroup 和信道(channel)是常见的 2 种并发控制的方式。 如果并发启动了多个子协程，需要等待所有的子协程完成任务，WaitGroup 非常适合于这类场景，例如下面的例子： var wg sync.WaitGroup func doTask(n int) { time.Sleep(time.Duration(n)) fmt.Printf(\"Task %d Done\\n\", n) wg.Done() } func main() { for i := 0; i wg.Wait() 会等待所有的子协程任务全部完成，所有子协程结束后，才会执行 wg.Wait() 后面的代码。 Task 3 Done Task 1 Done Task 2 Done All Task Done WaitGroup 只是傻傻地等待子协程结束，但是并不能主动通知子协程退出。假如开启了一个定时轮询的子协程，有没有什么办法，通知该子协程退出呢？这种场景下，可以使用 select+chan 的机制。 var stop chan bool func reqTask(name string) { for { select { case 子协程使用 for 循环定时轮询，如果 stop 信道有值，则退出，否则继续轮询。 worker1 send request worker1 send request worker1 send request stop worker1 更复杂的场景如何做并发控制呢？比如子协程中开启了新的子协程，或者需要同时控制多个子协程。这种场景下，select+chan的方式就显得力不从心了。 Go 语言提供了 Context 标准库可以解决这类场景的问题，Context 的作用和它的名字很像，上下文，即子协程的下上文。Context 有两个主要的功能： 通知子协程退出（正常退出，超时退出等）； 传递必要的参数。 2 context.WithCancel context.WithCancel() 创建可取消的 Context 对象，即可以主动通知子协程退出。 2.1 控制单个协程 使用 Context 改写上述的例子，效果与 select+chan 相同。 func reqTask(ctx context.Context, name string) { for { select { case context.Backgroud() 创建根 Context，通常在 main 函数、初始化和测试代码中创建，作为顶层 Context。 context.WithCancel(parent) 创建可取消的子 Context，同时返回函数 cancel。 在子协程中，使用 select 调用 判断是否需要退出。 主协程中，调用 cancel() 函数通知子协程退出。 2.2 控制多个协程 func main() { ctx, cancel := context.WithCancel(context.Background()) go reqTask(ctx, \"worker1\") go reqTask(ctx, \"worker2\") time.Sleep(3 * time.Second) cancel() time.Sleep(3 * time.Second) } 为每个子协程传递相同的上下文 ctx 即可，调用 cancel() 函数后该 Context 控制的所有子协程都会退出。 worker1 send request worker2 send request worker1 send request worker2 send request worker1 send request worker2 send request stop worker1 stop worker2 3 context.WithValue 如果需要往子协程中传递参数，可以使用 context.WithValue()。 type Options struct{ Interval time.Duration } func reqTask(ctx context.Context, name string) { for { select { case context.WithValue() 创建了一个基于 ctx 的子 Context，并携带了值 options。 在子协程中，使用 ctx.Value(\"options\") 获取到传递的值，读取/修改该值。 4 context.WithTimeout 如果需要控制子协程的执行时间，可以使用 context.WithTimeout 创建具有超时通知机制的 Context 对象。 func main() { ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) go reqTask(ctx, \"worker1\") go reqTask(ctx, \"worker2\") time.Sleep(3 * time.Second) fmt.Println(\"before cancel\") cancel() time.Sleep(3 * time.Second) } WithTimeout()的使用与 WithCancel() 类似，多了一个参数，用于设置超时时间。执行结果如下： worker2 send request worker1 send request worker1 send request worker2 send request stop worker2 stop worker1 before cancel 因为超时时间设置为 2s，但是 main 函数中，3s 后才会调用 cancel()，因此，在调用 cancel() 函数前，子协程因为超时已经退出了。 5 context.WithDeadline 超时退出可以控制子协程的最长执行时间，那 context.WithDeadline() 则可以控制子协程的最迟退出时间。 func reqTask(ctx context.Context, name string) { for { select { case WithDeadline 用于设置截止时间。在这个例子中，将截止时间设置为1s后，cancel() 函数在 3s 后调用，因此子协程将在调用 cancel() 函数前结束。 在子协程中，可以通过 ctx.Err() 获取到子协程退出的错误原因。 运行结果如下： worker2 send request worker1 send request stop worker2 context deadline exceeded stop worker1 context deadline exceeded before cancel 可以看到，子协程 worker1 和 worker2 均是因为截止时间到了而退出。 "},"GoLang/GoLang基础/01-GoLang发展史.html":{"url":"GoLang/GoLang基础/01-GoLang发展史.html","title":"GoLang发展史","keywords":"","body":"datetime:2020/8/18 10:53 author:nzb Go语言发展简史 开发文档 https://studygolang.com/pkgdoc Go语言核心开发团队 Ken Thompson（肯·汤普森）：1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言，同时也是C语言的主要发明人。 Rob Pike（罗布-派克）：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。 他与Thompson共事多年，并共创出广泛使用的UTF-8字元编码。 Robert Griesemer：曾协助制作Java的HotSpot编译器，和Chrome浏览器的JavaScript引擎V8。 Google为什么要创建Go 计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能。 软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。 现有编程语言存在：风格不统一、计算能力不够、处理大并发不够好 企业运行维护很多c/c++的项目，c/c++程序运行速度虽然很快，但是编译速度确很慢，同时还存在内存泄漏的一系列的困扰需要解决。 Go语言发展历史 2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型。 2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。 2015年8月19日，Go1.5版发布，本次更新中移除了”最后残余的c代码” 2017年2月17日，Go语言Go1.8版发布。 2017年8月24日，Go语言Go1.9版发布。 2018年2月16日，Go语言Go1.10版发布。 Go语言的特点 Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言：Go=C+Python，说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发。 从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针。 // go语言的指针使用特点 func testPtr(num *int) { *num = 20 } 引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。 垃圾回收机制，内存自动回收，不需开发人员管理 【稍微不注意就会出现内存泄漏】 天然并发【重要特点】 从语言层面支持并发，实现简单 goroutine，轻量级线程，可实现大并发处理，高效利用多核。 基于CPS并发模型（Communicating Sequential Processes）实现 吸收了管道通信机制，形成go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信 函数返回多个值（实例代码） 新的创新：比如切片slice，延时执行defer等 Hello Go 我们写一个最简单的入门代码，在控制台输出hello go！ package main // fmt包中提供格式化，输入和输出的函数 import \"fmt\" func main() { fmt.Println(\"hello go!\") } Golang执行流程分析 我们可以通过以下命令来进行操作 go build hello.go -> hello.exe go run hello.go 两种执行流程分析 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，然可以运行 如果我们是直接go rungo源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。 什么是编译 有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件。 在该源文件目录下，通过go build 对hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。 如果程序没有错误，没有任何提示，会在当前目录下会出现一个可执行文件（windows下是.exe Linux下是一个可执行文件），该文件是二进制码文件，也是可以执行的程序。 如果程序有错误，编译时，会在错误的那行报错。 Go语言代码风格 代码每一行结束后不用写分号（：） 运算符左右建议各加一个空格 Go语言程序员推荐使用驼峰式命名 强制的代码风格 左括号必须紧接着语句不换行，这个特性刚开始会使开发者不习惯，但随着对Go语言的不断熟悉，就会发现风格统一让大家在阅读代码时把注意力集中在解决问题上，而不是代码风格上 Go语言开发注意事项 Go源文件以“go”为扩展名 Go应用程序的执行入口是main()方法 Go语言严格区分大小写。 Go方法由一条条语句构成，每个语句后不需要分号（Go语言会在每行后自动加分号），这也体现出Golang的简洁性。 Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错 Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过 大括号都是成对出现的，缺一不可。 Go语言中的转义字符 GoLang常用的转义字符（escape char） \\t：一个制表位，实现对齐的功能 \\n：换行符 \\：一个\\ \\r：一个回车 "},"GoLang/GoLang基础/02-打印输出.html":{"url":"GoLang/GoLang基础/02-打印输出.html","title":"打印输出","keywords":"","body":"datetime:2020/8/17 15:17 author:nzb 打印输出和键盘输入 1、打印输出 1.1、fmt包 import 'fmt' 1.2、常用打印函数 打印：fmt.Print() 格式化打印：fmt.Printf 格式化打印中的常用占位符 占位符 说明 %v 原样输出 %T 打印类型 %t bool类型 %s 字符串 %f 浮点 %d 10进制的整数 %b 2进制的整数 %o 8进制 %x,%X 16进制%x：0-9，a-f%X：0-9，A-F %c 打印字符 %p 打印地址 ... ... 打印后换行：fmt.Println() 示例代码 示例 package main import \"fmt\" func main(){ a := 100 b := 3.14 c := true d := \"Hello Golang\" e := `Golang` f := 'A' fmt.Printf(\"--------------Print--------------\\n\") fmt.Print(a, b, c, d, e, f) fmt.Printf(\"\\n--------------Printf格式化输出--------------\\n\") fmt.Printf(\"%T, %b\\n\", a, a) fmt.Printf(\"%T, %f\", b, b) fmt.Printf(\"%T,%t\\n\", c, c) fmt.Printf(\"%T,%s\\n\", d, d) fmt.Printf(\"%T,%s\\n\", e, e) fmt.Printf(\"%T,%d,%c\\n\", f, f, f) fmt.Printf(\"\\n--------------Printf原样输出--------------\\n\") fmt.Printf(\"%v\\n\", a) fmt.Printf(\"%v\\n\", b) fmt.Printf(\"%v\\n\", c) fmt.Printf(\"%v\\n\", d) fmt.Printf(\"%v\\n\", e) fmt.Printf(\"%v\\n\", f) fmt.Printf(\"\\n--------------Println--------------\\n\") fmt.Println(a) fmt.Println(b) } 输出 --------------Print-------------- 100 3.14 trueHello GolangGolang65 --------------Printf格式化输出-------------- int, 1100100 float64, 3.140000bool,true string,Hello Golang string,Golang int32,65,A --------------Printf原样输出-------------- 100 3.14 true Hello Golang Golang 65 --------------Println-------------- 100 3.14 2、键盘输入 fmt.Scan() fmt.Scanf() fmt.Scanln() 示例代码 示例 package main import \"fmt\" func main(){ var x int var y float64 fmt.Println(\"请输入一个整数，一个浮点数：\") fmt.Scanln(&x, &y) //读取键盘的输入，通过操作地址，赋值给x和y 阻塞式 fmt.Printf(\"x的数值：%d, y的数值：%f\\n\", x, y) fmt.Scanf(\"%d, %f\", &x, &y) fmt.Printf(\"x:%d, y:%f\\n\", x, y) } 输出 请输入一个整数，一个浮点数： x的数值：12, y的数值：34.000000 x:21, y:34.000000 "},"GoLang/GoLang基础/03-变量和常量.html":{"url":"GoLang/GoLang基础/03-变量和常量.html","title":"变量和常量","keywords":"","body":"datetime:2020/8/18 10:57 author:nzb Go语言中的变量和常量 1、Go语言中变量的声明 Go语言变量是由字母、数字、下划线组成，其中首个字符不能为数字。Go语言中关键字和保留字都不能用作变量名 Go语言中变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。 变量声明后，没有初始化，打印出来的是空 1.1、如何定义变量 方式1 var name = \"zhangsan\" 方式2：带类型 var name string = \"zhangsan\" 方式3：类型推导方式定义变量 在函数内部，可以使用更简略的 := 方式声明并初始化变量 注意：短变量只能用于声明局部变量，不能用于全局变量声明 变量名 := 表达式 方式4：声明多个变量 类型都是一样的变量 var 变量名称， 变量名称 类型 a, b, c := 1,2,\"3\" 类型不一样的变量 var ( 变量名称 类型 变量名称 类型 ) 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable） 匿名变量用一个下划线“_”表示 func Getuser(){ return username, age } var username, _ = Getuser() 示例代码 代码 package main import \"fmt\" func main() { var a = 10 fmt.Printf(\"%d\\n\", a) var name1 = \"zhangsan\" var name2 string = \"lishi\" name3 := \"wangwu\" fmt.Println(name1) fmt.Println(name2) fmt.Println(name3) fmt.Printf(\"name1=%v, name2=%v, name3=%v\", name1, name2, name3) var b, c string b = \"b\" c = \"c\" fmt.Printf(\"\\nb=%v, c=%v\\n\", b, c) var ( d int e string f bool ) d = 100 e = \"string\" f = true //var ( // d int = 1 // e string = 'e' // f bool = false //) fmt.Printf(\"d=%v, e=%v, f=%v\\n\", d, e, f) } 输出 10 zhangsan lishi wangwu name1=zhangsan, name2=lishi, name3=wangwu b=b, c=c d=100, e=string, f=true 2、常量 2.1、如何定义常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。 // 定义了常量，可以不用立即使用 const pi = 3.14 // 定义两个常量 const( A = \"A\" B = \"B\" ) // const同时声明多个常量时，如果省略了值表示和上面一行的值相同 const( A = \"A\" B C ) 2.2、 Const常量结合iota的使用 iota是golang 语言的常量计数器，只能在常量的表达式中使用 iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。 每次const出现，都会让iota初始化为0【自增长】 const a = iota // a = 0 const ( b = iota // b=0 c // c = 1 d // d = 2 ) const iota使用_跳过某些值 const ( b = iota // b=0 _ d // d = 2 ) 多个赋值 const ( n1, n2 = iota + 1, iota + 2 //1 2 n3, n4 // 2 3 n5, n6 //3 4 ) 3、Go语言变量、常量命名规则 变量名必须有数字、字母、下划线组成 标识符不能是数字 标识符不能是保留字和关键字 变量的名字是区分大小写的 标识符（变量名称）一定要见名思意：变量名称建议用名词，方法名称建议用动词 变量命名一般采用驼峰式。 "},"GoLang/GoLang基础/04-数据类型.html":{"url":"GoLang/GoLang基础/04-数据类型.html","title":"数据类型","keywords":"","body":"datetime:2020/8/18 15:42 author:nzb Golang的数据类型 1、概述 Go 语言中数据类型分为：基本数据类型和复合数据类型基本数据类型有： 整型、浮点型、布尔型、字符串 复合数据类型有： 数组、切片、结构体、函数、map、通道（channel）、接口等。 2、整型 整型的类型有很多中，包括 int8，int16，int32，int64。我们可以根据具体的情况来进行定义 如果我们直接写 int也是可以的，它在不同的操作系统中，int的大小是不一样的 32位操作系统：int -> int32 64位操作系统：int -> int64 默认值为：0 有符号和无符号整型 可以通过unsafe.Sizeof 查看不同长度的整型，在内存里面的存储空间 var num2 = 12 fmt.Println(unsafe.Sizeof(num2)) 2.1、类型转换 通过在变量前面添加指定类型，就可以进行强制类型转换 var a1 int16 = 10 var a2 int32 = 12 var a3 = int32(a1) + a2 fmt.Println(a3) 注意，高位转低位的时候，需要注意，会存在精度丢失，比如上述16转8位的时候，就丢失了 var n1 int16 = 130 fmt.Println(int8(n1)) // 变成 -126 2.2、数字字面量语法 Go1.13版本之后，引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如： v := 0b00101101 // 代表二进制的101101 v := Oo377 // 代表八进制的377 2.3、进制转换 var number = 17 // 原样输出 fmt.Printf(\"%v\\n\", number) // 十进制输出 fmt.Printf(\"%d\\n\", number) // 以八进制输出 fmt.Printf(\"%o\\n\", number) // 以二进制输出 fmt.Printf(\"%b\\n\", number) // 以十六进制输出 fmt.Printf(\"%x\\n\", number) 3、浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE754标准： float32的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。float64的浮点数的最大范围约为1.8e308，可以使用一个常量定义：math.MaxFloat64 默认值为：0 打印浮点数时，可以使用fmt包配合动词%f，代码如下： var pi = math.Pi // 打印浮点类型，默认小数点6位 fmt.Printf(\"%f\\n\", pi) // 打印浮点类型，打印小数点后2位 fmt.Printf(\"%.2f\\n\", pi) // 科学计数 var f2 = 3.14e2 // 3.14 * 10的2次方 fmt.Printf(\"\\n%v,%T\\n\", f2, f2) // 314,float64 3.1、Golang中精度丢失的问题 几乎所有的编程语言都有精度丢失的问题，这是典型的二进制浮点数精度损失问题，在定长条件下，二进制小数和十进制小数互转可能有精度丢失 d := 1129.6 fmt.Println(d*100) //输出112959.99999999 解决方法，使用第三方包来解决精度损失的问题 4、布尔类型 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true和false 注意 布尔类型变量的默认值为false Go语言中不允许将整型强制转换为布尔型 布尔型无法参与数值运算，也无法与其他类型进行转换 var fl = false if f1 { fmt.Println(\"true\") } else { fmt.Println(\"false\") } 5、字符串类型 Go 语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64等）一样。Go语言里的字符串的内部实现使用UTF-8编码。字符串的值为双引号（\"）中的内容，可以在Go语言的源码中直接添加非ASCll码字符，例如： s1 := \"hello\" s1 := \"你好\" 默认值为：空字符串 如果想要定义多行字符串，可以使用反引号 var str = `第一行 第二行` fmt.Println(str) 转义输出 str1 := \"this is \\nstr\" str2 := \"C:\\\\go\\\\demo\" str3 := \"this is\\\" str3\" fmt.Println(str1) fmt.Println(str2) fmt.Println(str3) this is str C:\\go\\demo this is\" str3 5.1、字符串常见操作 len(str)：求长度 \"aaa\"：3（3个字节） \"你好\"：6（一个汉字3个字节） +或fmt.Sprintf：拼接字符串 str1 := \"你好\" str2 := \"golang\" str3 := fmt.Sprintf(\"%v%v, str1, str2) fmt.Println(str3) fmt.Sprintf(\"%v%v, str1, str2) // 可以任意拼接（加空格加符号） strings.Split：分割 strings.contains：判断是否包含 strings.HasPrefix，strings.HasSuffix：前缀/后缀判断 strings.Index()，strings.LastIndex()：子串出现的位置，不存在返回：-1 strings.Join()：join操作 strings.Index()：判断在字符串中的位置 6、byte 和 rune类型 组成每个字符串的元素叫做 “字符”，可以通过遍历字符串元素获得字符。字符用单引号 '' 包裹起来 Go语言中的字符有以下两种类型 uint8类型：或者叫byte型，代表了ACII码的一个字符 rune类型：代表一个UTF-8字符 当需要处理中文，日文或者其他复合字符时，则需要用到rune类型，rune类型实际上是一个int32 Go使用了特殊的rune类型来处理Unicode，让基于Unicode的文本处理更为方便，也可以使用byte型进行默认字符串处理，性能和扩展性都有照顾。 需要注意的是，在go语言中，一个汉字占用3个字节（utf-8），一个字母占用1个字节 ```go package main import \"fmt\" func main() { var a byte = 'a' // 输出的是ASCII码值，也就是说当我们直接输出byte（字符）的时候，输出的是这个字符对应的码值 fmt.Println(a) // 输出的是字符 fmt.Printf(\"%c\", a) fmt.Printf(\"\\n--------------通过len来循环的，相当于打印的是ASCII码，汉字出现乱码--------------\\n\") // for循环打印字符串里面的字符 // 通过len来循环的，相当于打印的是ASCII码 s := \"你好 golang\" for i := 0; i 结果 97 a --------------通过len来循环的，相当于打印的是ASCII码，汉字出现乱码-------------- 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 32( ) 103(g) 111(o) 108(l) 97(a) 110(n) 103(g) ------通过rune打印的是 utf-8字符，汉字就不能乱码，rune类型兼容byte类型------- 0 20320 3 22909 6 32 7 103 8 111 9 108 10 97 11 110 12 103 6.1、修改字符串 要修改字符串，需要先将其转换成[]rune 或 []byte类型，完成后在转换成string，无论哪种转换都会重新分配内存，并复制字节数组 转换为 []byte 类型 // 字符串转换 s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'p' fmt.Println(string(byteS1)) 转换为rune类型 // rune类型 s2 := \"你好golang\" byteS2 := []rune(s2) byteS2[0] = '我' fmt.Println(string(byteS2)) 7、基本数据类型转换 7.1、数值类型转换 // 整型和浮点型之间转换 var aa int8 = 20 var bb int16 = 40 fmt.Println(int16(aa) + bb) // 建议整型转换成浮点型 var cc int8 = 20 var dd float32 = 40 fmt.Println(float32(cc) + dd) 建议从低位转换成高位，这样可以避免 7.2、转换成字符串类型 第一种方式，就是通过 fmt.Sprintf()来转换 // 字符串类型转换 var i int = 20 var f float64 = 12.456 var t bool = true var b byte = 'a' str1 := fmt.Sprintf(\"%d\", i) fmt.Printf(\"类型：%v-%T \\n\", str1, str1) str2 := fmt.Sprintf(\"%f\", f) fmt.Printf(\"类型：%v-%T \\n\", str2, str2) str3 := fmt.Sprintf(\"%t\", t) fmt.Printf(\"类型：%v-%T \\n\", str3, str3) str4 := fmt.Sprintf(\"%c\", b) fmt.Printf(\"类型：%v-%T \\n\", str4, str4) 第二种方法就是通过strconv包里面的集中转换方法进行转换 package main import ( \"fmt\" \"strconv\" ) func main() { // int类型转换str类型 var num1 int64 = 20 s1 := strconv.FormatInt(num1, 10) fmt.Printf(\"转换值：%v - 类型：%T\\n\", s1, s1) // float类型转换成string类型 var num2 float64 = 3.1415926 /* 参数1：要转换的值 参数2：格式化类型 'f'表示float，'b'表示二进制，‘e’表示 十进制 参数3：表示保留的小数点，-1表示不对小数点格式化 参数4：格式化的类型，传入64位 或者 32位 */ s2 := strconv.FormatFloat(num2, 'f', -1, 64) fmt.Printf(\"转换值：%v-类型：%T\", s2, s2) } 结果 转换值：20 - 类型：string 转换值：3.1415926-类型：string 7.3、字符串转换成int 和 float类型 str := \"10\" // 第一个参数：需要转换的数，第二个参数：进制， 参数三：32位或64位 num,_ = strconv.ParseInt(str, 10, 64) // 转换成float类型 str2 := \"3.141592654\" num,_ = strconv.ParseFloat(str2, 10) 7.4 不建议string类型转换为bool类型（无意义） "},"GoLang/GoLang基础/05-运算符.html":{"url":"GoLang/GoLang基础/05-运算符.html","title":"运算符","keywords":"","body":"datetime:2020/8/31 16:26 author:nzb Go的运算符 1、算数运算符 运算符 说明 + 相加 - 相减 * 相乘 / 相除 % 求余= 被除数 - (被除数 / 除数) * 除数 fmt.Println(-10 % 3) // 结果是 -1 fmt.Println(10 % -3) // 结果是 1 1.2、注意事项 ++ 和 --在go语言中不是运算符 除法注意，如果运算的数是整数，那么除后，去掉小数部分，保留整数部分，如果是浮点数，保留小数部分 在golang中， ++ 和 -- 只能单独使用，错误的写法如下 var i int = 8 var a int a = i++ // 错误，i++只能单独使用 a = i-- // 错误，i--只能单独使用 同时在golang中，没有 ++i这样的操作 var i int = 1 ++i // 错误 正确的写法 var i int = 1 i++ //正确 2、关系运算符 运算符 说明 == 检查两个值是否相等，如果相等返回True，否则返回False != 检查两个值是否不相等，如果不相等返回True，否则返回False > 检查左边值是否大于右边值，如果是返回True，否则返回False >= 检查左边值是否大于等于右边值，如果是返回True，否则返回False 检查左边值是否小于右边值，如果是返回True，否则返回False 检查左边值是否小于等于右边值，如果是返回True，否则返回False 3、逻辑运算符 运算符 说明 && 逻辑 AND 运算符，如果两边的操作数都是True，则为True，否则为False || 逻辑 OR 运算符，如果两边的操作数有一个是True，则为True，否则为False ! 逻辑 NOT 运算符，如果条件为True，则为False，否则为True 短路用法，逻辑与前面为False后面的就不执行了，逻辑或前面的为True后面的也不执行了 4、赋值辑运算符 运算符 说明 = 简单的赋值运算符，将一个表达式的值赋给一个左值(从右往左计算赋值) += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值（跟上面算术运算符的注意事项相同） %= 求余后再赋值 5、位运算符 位运算符对整数在内存中的二进制位进行操作 运算符 说明 & 参与运算的两数各对应的二进位相与。（两位均为1才为1） | 参与运算的两数各对应的二进位相或。（两位有一个为1就为1） ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1,。（两位不一样则为1） 左移n位就是乘以2的n次方。“a >> 左移n位就是除以2的n次方。“a>>b”是把a的各二进位全部右移b位。 "},"GoLang/GoLang基础/06-流程控制.html":{"url":"GoLang/GoLang基础/06-流程控制.html","title":"流程控制","keywords":"","body":"datetime:2020/9/16 11:41 author:nzb Go的流程控制 流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉\" Go 语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 1、条件语句 1.1、if else 推荐if后面不适用括号，当然也可以使用括号括起来 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else { /* 在布尔表达式为 false 时执行 */ } func main() { var num = 10 if num == 10 { fmt.Println(\"hello == 10\") } else if(num > 10) { fmt.Println(\"hello > 10\") } else { fmt.Println(\"hello if的另外一种写法，下面的方法的区别是 num2是局部变量 if num2:= 10; num2>=10 { fmt.Println(\"hello >=10\") fmt.Println(num2) // 可打印 } fmt.Println(num2) // 报错，因为 num2 是局部变量 if 语句嵌套 if 布尔表达式 1 { /* 在布尔表达式 1 为 true 时执行 */ if 布尔表达式 2 { /* 在布尔表达式 2 为 true 时执行 */ } } 你可以以同样的方式在 if 语句中嵌套 else if...else 语句 1、if 后的 大括号 {}不能省略 2、{必须紧挨着条件 1.2、switch case 使用switch语句可方便的对大量的值进行条件判断 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。 switch var1 { case val1: ... case val2: ... default: ... } extname := \".a\" switch extname { case \".html\": { fmt.Println(\".html\") break } case \".doc\": { fmt.Println(\".doc\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } switch的另外一种写法 switch extname := \".a\"; extname { case \".html\": { fmt.Println(\".html\") break } case \".doc\": { fmt.Println(\".doc\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } 同时一个分支可以有多个值 extname := \".txt\" switch extname { case \".html\": { fmt.Println(\".html\") break } case \".txt\",\".doc\": { fmt.Println(\"传递来的是文档\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } tip：在golang中，break可以不写，也能够跳出case，而不会执行其它的。 如果我们需要使用switch的穿透 fallthrought，fallthrough语法可以执行满足条件的 case 的下一个case，为了兼容c语言中的case设计 extname := \".txt\" switch extname { case \".html\": { fmt.Println(\".html\") fallthrought } case \".txt\",\".doc\": { fmt.Println(\"传递来的是文档\") fallthrought } case \".js\": { fmt.Println(\".js\") fallthrought } default: { fmt.Println(\"其它后缀\") } } fallthrought 只能穿透紧挨着的一层，不会一直穿透，但是如果每一层都写的话，就会导致每一层都进行穿透 2、循环语句 2.1、for 循环结构 Go语言中的所有循环类型均可使用for关键字来完成 for循环的基本格式如下： for 初始语句; 条件表达式; 结束语句 { 循环体 } 第一种写法： for i := 1 ; i 第二种写法：和 C 的 while 一样： for condition { } 示例： i := 1 for ; i 第三种写法 i := 1 for i 第四种写法：和 C 的 for(;;) 一样： for { } 示例： i := 1 for { if i 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环 实例：打印1 ~ 10 for i := 0; i 2.2、for range（键值循环） Go 语言中可以使用for range遍历数组、切片、字符串、map及通道（channel）。通过for range遍历的返回值有以下规律： for key, value := range oldMap { newMap[key] = value } 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 实例：遍历字符串 var str = \"你好golang\" for key, value := range str { fmt.Printf(\"%v - %c \", key, value) } 遍历切片（数组） var array = []string{\"php\", \"java\", \"node\", \"golang\"} for index, value := range array { fmt.Printf(\"%v %s \", index, value) } for循环可以通过break、goto、return、panic语句退出循环 2.3、循环嵌套 for [condition | ( init; condition; increment ) | Range] { for [condition | ( init; condition; increment ) | Range] { statement(s); } statement(s); } 2.4、循环控制语句 2.4.1、break：跳出循环 Go语言中break 语句用于以下几个方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break在switch（开关语句）中在执行一条case后跳出语句的作用。 在多重循环中，可以用标号label标出想break的循环。 var i = 0 for { if i == 10{ fmt.Println(\"跳出循环\") break } i++ fmt.Println(i) } 使用label package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- break ----\") for i := 1; i ---- break ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 ---- break label ---- i: 1 i2: 11 2.4.2、 continue：跳过当前循环的剩余语句，然后继续进行下一轮循环 Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 for 循环中，执行 continue 语句会触发 for 增量语句的执行。 在多重循环中，可以用标号 label 标出想 continue 的循环。 package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- continue ---- \") for i := 1; i ---- continue ---- i: 1 i2: 11 i2: 12 i2: 13 i: 2 i2: 11 i2: 12 i2: 13 i: 3 i2: 11 i2: 12 i2: 13 ---- continue label ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 2.4.3、 goto：跳转到指定标签 Go 语言的 goto 语句可以无条件地转移到过程中指定的行。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 goto label; .. . label: statement; var n = 20 if n > 24 { fmt.Println(\"成年人\") } else { goto lable3 } fmt.Println(\"aaa\") fmt.Println(\"bbb\") lable3: fmt.Println(\"ccc\") fmt.Println(\"ddd\") "},"GoLang/GoLang基础/07-数组.html":{"url":"GoLang/GoLang基础/07-数组.html","title":"数组","keywords":"","body":"datetime:2020/9/16 14:56 author:nzb Go的数组 1、Array数组介绍 数组是指一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素（element），这种类型可以是意的原始类型，比如int、string等，也可以是用户自定义的类型。一个数组包含的元素个数被称为数组的长度。在Golang中数组是一个长度固定的数据类型，数组的长度是类型的一部分，也就是说[5]int和[10]int是两个不同的类型。Golang中数组的另一个特点是占用内存的连续性，也就是说数组中的元素是被分配到连续的内存地址中的，因而索引数组元素的速度非常快。 和数组对应的类型是Slice（切片），Slice是可以增长和收缩的动态序列，功能也更灵活，但是想要理解slice工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用。 2、数组定义 var variable_name [SIZE] variable_type 示例 // 数组的长度是类型的一部分 var arr1 [3]int var arr2 [4]string fmt.Printf(\"%T, %T \\n\", arr1, arr2) 第一种方法 var arr3 [3]int arr3[0] = 1 arr3[1] = 2 arr3[2] = 3 fmt.Println(arr3) 第二种初始化数组的方法 var arr4 = [4]int {10, 20, 30, 40} fmt.Println(arr4) 第三种数组初始化方法，自动推断数组长度 var arr5 = [...]int{1, 2} fmt.Println(arr5) 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} fmt.Println(a) 3、遍历数组 方法1 // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} for i := 0; i 方法2 // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} for _, value := range a { fmt.Print(value, \" \") } 4、数组的值类型 数组是值类型，赋值和传参会赋值整个数组，因此改变副本的值，不会改变本身的值 // 数组 var array1 = [...]int {1, 2, 3} array2 := array1 array2[0] = 3 fmt.Println(array1, array2) 例如上述的代码，我们将数组进行赋值后，该改变数组中的值时，发现结果如下 [1 2 3] [3 2 3] 这就说明了，golang中的数组是值类型，而不是和java一样属于引用数据类型 5、切片定义(引用类型) 在golang中，切片的定义和数组定义是相似的，但是需要注意的是，切片是引用数据类型，如下 // 切片定义 var array3 = []int{1,2,3} array4 := array3 array4[0] = 3 fmt.Println(array3, array4) 我们通过改变第一个切片元素，然后查看最后的效果 [3 2 3] [3 2 3] 6、二维数组 Go语言支持多维数组，我们这里以二维数组为例（数组中又嵌套数组）： 二维 var arrayName [ x ][ y ] variable_type 示例 // 二维数组 var array5 = [2][2]int{ {1,2},{2,3} } fmt.Println(array5) 多维 var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 7、数组遍历 二维数据组的遍历 // 二维数组 var array5 = [2][2]int{ {1,2},{2,3} } for i := 0; i 遍历方式2 for _, item := range array5 { for _, item2 := range item { fmt.Println(item2) } } 8、类型推导 另外我们在进行数组的创建的时候，还可以使用类型推导，但是只能使用一个 ... // 二维数组（正确写法） var array5 = [...][2]int{ {1,2},{2,3} } 错误写法 // 二维数组 var array5 = [2][...]int{ {1,2},{2,3} } 9、完整代码 package main import \"fmt\" func main() { // 数组的长度是类型的一部分 var arr1 [3]int var arr2 [4]string fmt.Printf(\"%T, %T \\n\", arr1, arr2) // 数组的初始化 第一种方法 var arr3 [3]int arr3[0] = 1 arr3[1] = 2 arr3[2] = 3 fmt.Println(arr3) // 第二种初始化数组的犯法 var arr4 = [4]int {10, 20, 30, 40} fmt.Println(arr4) // 第三种数组初始化方法，自动推断数组长度 var arr5 = [...]int{1, 2} fmt.Println(arr5) // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} fmt.Println(a) for i := 0; i 10、向函数传递数组 方式一：形参设定数组大小： void myFunction(param [10]int) { . . . } 方式二：形参未设定数组大小： void myFunction(param []int) { . . . } "},"GoLang/GoLang基础/08-切片.html":{"url":"GoLang/GoLang基础/08-切片.html","title":"切片","keywords":"","body":"datetime:2020/10/23 10:48 author:nzb Go的切片 1、为什么要使用切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。 它非常灵活，支持自动扩容。 切片是一个引用类型，它的内部结构包含地址、长度和容量。 声明切片类型的基本语法如下： var name [] T 其中： name：表示变量名 T：表示切片中的元素类型 举例 // 声明切片，把长度去除就是切片 var slice = []int{1,2,3} fmt.Println(slice) 2、关于nil的认识 当你声明了一个变量，但却还并没有赋值时，golang中会自动给你的变量赋值一个默认的零值。这是每种类型对应的零值。 bool：false numbers：0 string：\"\" pointers：nil slices：nil maps：nil channels：nil functions：nil nil表示空，也就是数组初始化的默认值就是nil var slice2 [] int fmt.Println(slice2 == nil) 运行结果 true 3、切片的遍历 切片的遍历和数组是一样的 var slice = []int{1,2,3} for i := 0; i 4、基于数组定义切片 由于切片的底层就是一个数组，所以我们可以基于数组来定义切片 // 基于数组定义切片 a := [5]int {55,56,57,58,59} // 获取数组所有值，返回的是一个切片 b := a[:] // 从数组获取指定的切片 c := a[1:4] // 获取 下标3之前的数据（不包括3） d := a[:3] // 获取下标3以后的数据（包括3） e := a[3:] 运行结果 [55 56 57 58 59] [55 56 57 58 59] [56 57 58] [55 56 57] [58 59] 同理，我们不仅可以对数组进行切片，还可以切片在切片 5、切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len）函数求长度，使用内置的cap（） 函数求切片的容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。切片s的长度和容量可通过表达式len（s）和cap（s）来获取。 举例 // 长度和容量 s := []int {2,3,5,7,11,13} fmt.Printf(\"长度%d 容量%d\\n\", len(s), cap(s)) ss := s[2:] fmt.Printf(\"长度%d 容量%d\\n\", len(ss), cap(ss)) sss := s[2:4] fmt.Printf(\"长度%d 容量%d\\n\", len(sss), cap(sss)) 运行结果 长度6 容量6 长度4 容量4 长度2 容量4 为什么最后一个容量不一样呢，因为我们知道，经过切片后sss = [5, 7] 所以切片的长度为2，但是因为容量是从2的位置一直到末尾，所以为4 6、切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息 底层数组的指针 切片的长度(len) 切片的容量(cap) 举个例子，现在有一个数组 a := [8]int {0,1,2,3,4,5,6,7}，切片 s1 := a[:5]，相应示意图如下 切片 s2 := a[3:6]，相应示意图如下： 7、使用make函数构造切片 我们上面都是基于数组来创建切片的，如果需要动态的创建一个切片，我们就需要使用内置的make函数，格式如下： make ([]T, size, cap) 其中： T：切片的元素类型 size：切片中元素的数量 cap：切片的容量 举例： // make()函数创建切片 fmt.Println() var slices = make([]int, 4, 8) //[0 0 0 0] fmt.Println(slices) // 长度：4, 容量8 fmt.Printf(\"长度：%d, 容量%d\", len(slices), cap(slices)) 需要注意的是，golang中没办法通过下标来给切片扩容，如果需要扩容，需要用到append slices2 := []int{1,2,3,4} slices2 = append(slices2, 5) fmt.Println(slices2) // 输出结果 [1 2 3 4 5] 同时切片还可以将两个切片进行合并 // 合并切片 slices3 := []int{6,7,8} slices2 = append(slices2, slices3...) fmt.Println(slices2) // 输出结果 [1 2 3 4 5 6 7 8] 需要注意的是，切片会有一个扩容操作，当元素存放不下的时候，会将原来的容量扩大两倍，详情 8、使用copy()函数复制切片 前面我们知道，切片就是引用数据类型 值类型：改变变量副本的时候，不会改变变量本身 引用类型：改变变量副本值的时候，会改变变量本身的值 如果我们需要改变切片的值，同时又不想影响到原来的切片，那么就需要用到copy函数 // 需要复制的切片 var slices4 = []int{1,2,3,4} // 使用make函数创建一个切片 var slices5 = make([]int, len(slices4), len(slices4)) // 拷贝切片的值 copy(slices5, slices4) // 修改切片 slices5[0] = 4 fmt.Println(slices4) fmt.Println(slices5) 运行结果为 [1 2 3 4] [4 2 3 4] 9、删除切片中的值 Go语言中并没有删除切片元素的专用方法，我们可以利用切片本身的特性来删除元素。代码如下 // 删除切片中的值 var slices6 = []int {0,1,2,3,4,5,6,7,8,9} // 删除下标为1的值 slices6 = append(slices6[:1], slices6[2:]...) fmt.Println(slices6) 运行结果 [0 2 3 4 5 6 7 8 9] 10、切片的排序算法以及sort包 编写一个简单的冒泡排序算法 func main() { var numSlice = []int{9,8,7,6,5,4} for i := 0; i numSlice[j+1] { var temp = numSlice[j+1] numSlice[j+1] = numSlice[j] numSlice[j] = temp flag = true } } if !flag { break } } fmt.Println(numSlice) } 在来一个选择排序 // 编写选择排序 var numSlice2 = []int{9,8,7,6,5,4} for i := 0; i numSlice2[j] { var temp = numSlice2[i] numSlice2[i] = numSlice2[j] numSlice2[j] = temp } } } fmt.Println(numSlice2) 对于int、float64 和 string数组或是切片的排序，go分别提供了sort.Ints()、sort.Float64s() 和 sort.Strings()函数，默认都是从小到大进行排序 var numSlice2 = []int{9,8,7,6,5,4} sort.Ints(numSlice2) fmt.Println(numSlice2) 降序排列 Golang的sort包可以使用 sort.Reverse(slic e) 来调换slice.Interface.Less，也就是比较函数，所以int、float64 和 string的逆序排序函数可以这样写 // 逆序排列 var numSlice4 = []int{9,8,4,5,1,7} sort.Sort(sort.Reverse(sort.IntSlice(numSlice4))) fmt.Println(numSlice4) "},"GoLang/GoLang基础/09-map.html":{"url":"GoLang/GoLang基础/09-map.html","title":"map","keywords":"","body":"datetime:2020/10/23 15:57 author:nzb Go的map 1、map的介绍 map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 Go语言中map的定义语法如下： map[KeyType]ValueType 其中： KeyType：表示键的类型 ValueType：表示键对应的值的类型 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为： make：用于slice、map和channel的初始化 示例如下所示： // 方式1初始化 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" userInfo[\"age\"] = \"20\" userInfo[\"sex\"] = \"男\" fmt.Println(userInfo) fmt.Println(userInfo[\"userName\"]) // 创建方式2，map也支持声明的时候填充元素 var userInfo2 = map[string]string { \"username\":\"张三\", \"age\":\"21\", \"sex\":\"女\", } fmt.Println(userInfo2) 2、遍历map 使用for range遍历 // 遍历map for key, value := range userInfo2 { fmt.Println(\"key:\", key, \" value:\", value) } 3、判断map中某个键值是否存在 我们在获取map的时候，会返回两个值，也可以是返回的结果，一个是是否有该元素 // 判断是否存在,如果存在 ok = true，否则 ok = false value, ok := userInfo2[\"username2\"] fmt.Println(value, ok) 4、使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete函数的格式如下所示 delete(map 对象, key) 其中： map对象：表示要删除键值对的map对象 key：表示要删除的键值对的键 示例代码如下 // 删除map数据里面的key，以及对应的值 delete(userInfo2, \"sex\") fmt.Println(userInfo2) 5、元素为map类型的切片 我们想要在切片里面存放一系列用户的信息，这时候我们就可以定义一个元素为map类型的切片 // 切片中存放map var userInfoList = make([]map[string]string, 3, 3) var user = map[string]string{ \"userName\": \"张安\", \"age\": \"15\", } var user2 = map[string]string{ \"userName\": \"张2\", \"age\": \"15\", } var user3 = map[string]string{ \"userName\": \"张3\", \"age\": \"15\", } userInfoList[0] = user userInfoList[1] = user2 userInfoList[2] = user3 fmt.Println(userInfoList) for _, item := range userInfoList { fmt.Println(item) } 6、值为切片类型的map 我们可以在map中存储切片 // 将map类型的值定义为切片 var userinfo = make(map[string][]string) userinfo[\"hobby\"] = []string {\"吃饭\", \"睡觉\", \"敲代码\"} fmt.Println(userinfo) 7、示例 统计字符串中单词出现的次数 // 写一个程序，统计一个字符串中每个单词出现的次数。比如 \"how do you do\" var str = \"how do you do\" array := strings.Split(str, \" \") fmt.Println(array) countMap := make(map[string]int) for _, item := range array { countMap[item]++ } fmt.Println(countMap) 升序输出 map 的值 ```go map1 := make(map[int]int, 10) map1[10] = 100 map1[1] = 13 map1[4] = 56 map1[8] = 90 map1[12] = 43 map1[7] = 32 // 1、把 map 的 key 升序放入切片 keySlice []int for k, := range map1{ keySlice = append(keySlice, k) } fmt.Println(keySlice) // 2、升序 sort.Ints(keySlice) fmt.Println(keySlice) // 3、输出 for , v := range keySlice{ fmt.Printf(\"key=%v, value=%v\", v, map1[v]) } ``` "},"GoLang/GoLang基础/10-函数.html":{"url":"GoLang/GoLang基础/10-函数.html","title":"函数","keywords":"","body":"datetime:2020/10/26 15:40 author:nzb Go的函数 1、函数定义 函数是组织好的、可重复使用的、用于执行指定任务的代码块 Go语言支持：函数、匿名函数和闭包 Go语言中定义函数使用func关键字，具体格式如下： func 函数名(参数)(返回值) { 函数体 } 其中： 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也不能重名 示例 // 求两个数的和 func sumFn(x int, y int) int{ return x + y } // 调用方式 sunFn(1, 2) // 类型可以简写（多个返回值时也是） func sumFn(x, y int) int{ return x + y } // 调用方式 sunFn(1, 2) 获取可变的参数，可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后面加 ... 来标识。 注意：可变参数通常要作为函数的最后一个参数 func sunFn2(x ...int) int { sum := 0 for _, num := range x { sum = sum + num } return sum } // 调用方法 sunFn2(1, 2, 3, 4, 5, 7) 方法多返回值，Go语言中函数支持多返回值，同时还支持返回值命名，函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回 // 方法多返回值1 func sunFn4(x int, y int)(int, int) { sum = x + y sub = x -y return sum, sub } // 方法多返回值2 func sunFn4(x int, y int)(sum int, sub int) { sum = x + y sub = x -y return } 2、函数类型和变量 2.1、定义函数类型 我们可以使用type关键字来定义一个函数类型，具体格式如下 type calculation func(int, int) int 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。 简单来说，凡是满足这两个条件的函数都是calculation类型的函数，例如下面的add 和 sub 是calculation类型 type calc func(int, int) int // 求两个数的和 func sumFn(x int, y int) int{ return x + y } func main() { var c calc c = add // 打印：c的类型是：main.cal，事先声明了类型为 calc d := add // 打印：d的类型是：func(int, int) int，使用类型推导，没有事先声明 } 2.2、方法作为参数 类型Python的filter、sorted等方法 /** 传递两个参数和一个方法 */ func sunFn (a int, b int, sum func(int, int)int) int { return sum(a, b) } 返回值是函数：使用switch定义方法，这里用到了匿名函数 // 返回一个方法 type calcType func(int, int)int func sumFn(x int, y int) int{ return x + y } func do(o string) calcType { switch o { case \"+\": return sumFn /* return func(i int, i2 int) int { return i + i2 } */ case \"-\": // 匿名函数 return func(i int, i2 int) int { return i - i2 } case \"*\": return func(i int, i2 int) int { return i * i2 } case \"/\": return func(i int, i2 int) int { return i / i2 } default: return nil } } func main() { add := do(\"+\") fmt.Println(add(1,5)) } 3、匿名函数 函数当然还可以作为返回值，但是在Go语言中，函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下 func (参数)(返回值) { 函数体 } 匿名函数因为没有函数名，所以没有办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数： func main() { // 第一种 func () { fmt.Println(\"匿名自执行函数\") }() //第二种 a := func () { fmt.Println(\"匿名自执行函数\") } a() } 4、闭包 4.1、全局变量和局部变量 全局变量的特点： 常驻内存 污染全局 局部变量的特点（注意if语句中的局部变量） 不常驻内存 不污染全局 4.2、闭包 可以让一个变量常驻内存 可以让一个变量不污染全局 闭包可以理解成 “定义在一个函数内部的函数”。在本质上，闭包就是将函数内部 和 函数外部连接起来的桥梁。或者说是函数和其引用环境的组合体。 闭包是指有权访问另一个函数作用域中的变量的函数 创建闭包的常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量 注意：由于闭包里作用域返回的局部变量资源不会被立刻销毁，所以可能会占用更多的内存，过度使用闭包会导致性能下降，建议在非常有必要的时候才使用闭包。 // 闭包的写法：函数里面嵌套一个函数，最后返回里面的函数就形成了闭包 // 返回值是一个匿名函数 func adder() func() int { var i = 10 return func() int { return i + 1 } } func main() { var fn = adder() fmt.Println(fn()) fmt.Println(fn()) fmt.Println(fn()) } 最后输出的结果 11 11 11 另一个闭包的写法，让一个变量常驻内存，不污染全局 func adder2() func(y int) int { var i = 10 return func(y int) int { i = i + y return i } } func main() { var fn2 = adder2() fmt.Println(fn2(10)) // 20 fmt.Println(fn2(10)) // 30 fmt.Println(fn2(10)) // 40 } 5、defer语句 Go 语言中的defer 语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。 // defer函数 fmt.Println(\"1\") defer fmt.Println(\"2\") fmt.Println(\"3\") fmt.Println(\"4\") defer将会延迟执行 1 3 4 2 如果有多个defer修饰的语句，将会逆序进行执行 // defer函数 fmt.Println(\"1\") defer fmt.Println(\"2\") defer fmt.Println(\"3\") fmt.Println(\"4\") 运行结果 1 4 3 2 如果需要用defer运行一系列的语句，那么就可以使用匿名函数 func main() { fmt.Println(\"开始\") defer func() { fmt.Println(\"1\") fmt.Println(\"2\") }() fmt.Println(\"结束\") } 运行结果 开始 结束 1 2 5.1、defer执行时机 在Go语言的函数中return语句在底层并不是原子操作，它分为返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前，具体如下图所示 示例1 ```text package main import \"fmt\" func f1() int{ x := 5 defer func(){ x++ }() return x // 5，匿名返回值，直接返回 5 } func f2() (x int){ defer func(){ x++ }() return 5 // 6， 顺序：x=0, return 5, 赋值 x, 再执行 x++，返回 } func f3() (y int){ 变量x, y不一样 x := 5 defer func(){ x++ }() return x // 5 因为 y 不存在，先把 x 的值 5 赋给了 y, 所以 x++ 后不会改变返回值 } func f4() (x int){ defer func(x int){ // 参数可类比 ay int // x = 0 x++ // y ++ }(x) // defer 注册要延迟执行的函数时该函数所有的参数都需要确定其值，及 x = 0 return 5 // 5 } func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) fmt.Println(f4()) } 结果 ```text 5 6 5 5 示例2 ```text package main import \"fmt\" // defer 注册要延迟执行的函数时该函数所有的参数都需要确定其值，及 x = 0 func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\"AA\", x, calc(\"A\", x, y)) x = 10 defer calc(\"BB\", x, calc(\"B\", x, y)) y = 20 } /* // 注册 defer calc(\"AA\", x, calc(\"A\", x, y)) defer calc(\"BB\", x, calc(\"B\", x, y)) // 执行 defer calc(\"BB\", x, calc(\"B\", x, y)) defer calc(\"AA\", x, calc(\"A\", x, y)) 1、calc(\"A\", x, y) A 1 2 3 2、calc(\"B\", x, y) B 10 2 12 3、calc(\"BB\", x, calc(\"B\", x, y)) BB 10 12 22 4、calc(\"AA\", x, calc(\"A\", x, y)) AA 1 3 4 */ 结果 ```text A 1 2 3 B 10 2 12 BB 10 12 22 AA 1 3 4 6、panic/revocer处理异常 Go语言中是没有异常机制，但是使用panic / recover模式来处理错误 panic：可以在任何地方引发 recover：只有在defer调用函数内有效 func fn1() { fmt.Println(\"fn1\") } func fn2() { panic(\"抛出一个异常\") } func main() { fn1() fn2() fmt.Println(\"结束\") } 上述程序会直接抛出异常，无法正常运行 fn1 panic: 抛出一个异常 解决方法就是使用 recover进行异常的监听 func fn1() { fmt.Println(\"fn1\") } func fn2() { // 使用recover监听异常 defer func() { err := recover() if err != nil { fmt.Println(err) } }() panic(\"抛出一个异常\") } func main() { fn1() fn2() fmt.Println(\"结束\") } 7、异常运用场景 模拟一个读取文件的方法，这里可以主动发送使用panic 和 recover func readFile(fileName string) error { if fileName == \"main.go\" { return nil } else { return errors.New(\"读取文件失败\") } } func myFn () { defer func() { e := recover() if e != nil { fmt.Println(\"给管理员发送邮件\") } }() err := readFile(\"XXX.go\") if err != nil { panic(err) } } func main() { myFn() } 8、内置函数 内置函数 介绍 close 主要用来关闭channel len 用来求长度，比如string、array、slice、map、channel new 用来分配内存、主要用来分配值类型，比如 int、struct ，返回的是指针 make 用来分配内存，主要用来分配引用类型，比如chan、map、slice append 用来追加元素到数组、slice中 panic\\recover 用来处理错误 "},"GoLang/GoLang基础/11-time包日期函数.html":{"url":"GoLang/GoLang基础/11-time包日期函数.html","title":"time包日期函数","keywords":"","body":"datetime:2020/10/26 16:57 author:nzb Go中的日期函数 time包 时间和日期是我们编程中经常会用到的，在golang中time包提供了时间的显示和测量用的函数。 1、time.Now获取当前时间 timeObj := time.Now() year := timeObj.Year() month := timeObj.Month() day := timeObj.Day() fmt.Printf(\"%d-%02d-%02d \\n\", year, month, day) %02d 2 表示宽度，如果整数不够 2 列就补上 0 2、格式化日期 时间类型有一个自带的方法 Format进行格式化 需要注意的是Go语言中格式化时间模板不是长久的 Y-m-d H:M:S 而是使用Go的诞生时间 2006年1月2日 15点04分 （记忆口诀：2006 1 2 3 4 5） /** 时间类型有一个自带的方法 Format进行格式化 需要注意的是Go语言中格式化时间模板不是长久的 Y-m-d H:M:S 而是使用Go的诞生时间 2006年1月2日 15点04分 （记忆口诀：2006 1 2 3 4 5） */ timeObj2 := time.Now() // 24小时值 （15表示二十四小时） fmt.Println(timeObj2.Format(\"2006-01-02 15:04:05\")) // 12小时制 fmt.Println(timeObj2.Format(\"2006-01-02 03:04:05\")) 3、获取当前时间戳 时间戳是自1070年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳 10位数的时间戳是以 秒 为单位； 13位数的时间戳是以 毫秒 为单位； 19位数的时间戳是以 纳秒 为单位； /** 获取当前时间戳 */ timeObj3 := time.Now() // 获取秒时间戳 unixTime := timeObj3.Unix() // 获取纳秒时间戳 unixNaTime := timeObj3.UnixNano() package main import ( \"time\" \"fmt\" ) func main() { fmt.Printf(\"时间戳（秒）：%v;\\n\", time.Now().Unix()) fmt.Printf(\"时间戳（纳秒）：%v;\\n\",time.Now().UnixNano()) fmt.Printf(\"时间戳（毫秒）：%v;\\n\",time.Now().UnixNano() / 1e6) fmt.Printf(\"时间戳（纳秒转换为秒）：%v;\\n\",time.Now().UnixNano() / 1e9) } //输出 时间戳（秒）：1530027865; 时间戳（纳秒）：1530027865231834600; 时间戳（毫秒）：1530027865231; 时间戳（纳秒转换为秒）：1530027865; 4、时间戳转日期字符串 通过将时间戳我们可以转换成日期字符串 // 时间戳转换年月日时分秒（一个参数是秒，另一个参数是毫秒） var timeObj4 = time.Unix(1595289901, 0) var timeStr = timeObj4.Format(\"2006-01-02 15:04:05\") fmt.Println(timeStr) 5、日期字符串转换成时间戳 // 日期字符串转换成时间戳 var timeStr2 = \"2020-07-21 08:10:05\"; var tmp = \"2006-01-02 15:04:05\" timeObj5, _ := time.ParseInLocation(tmp, timeStr2, time.Local) fmt.Println(timeObj5.Unix()) 6、时间间隔 time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最大长度段大约290年。 time包中定义的时间间隔类型的常量如下： 7、时间操作函数 我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下 func (t Time) Add(d Duration)Time 例如 // 时间相加 now := time.Now() // 当前时间加1个小时后 later := now.Add(time.Hour) fmt.Println(later) 同理的方法还有：时间差、判断相等 8、定时器 方式1：使用time.NewTicker（时间间隔）来设置定时器 // 定时器, 定义一个1秒间隔的定时器 ticker := time.NewTicker(time.Second) n := 0 for i := range ticker.C { fmt.Println(i) n++ if n>5 { // 终止定时器 ticker.Stop() return } } 方式2：time.Sleep(time.Second)来实现定时器 for { time.Sleep(time.Second) fmt.Println(\"一秒后\") } "},"GoLang/GoLang基础/12-指针.html":{"url":"GoLang/GoLang基础/12-指针.html","title":"指针","keywords":"","body":"datetime:2020/10/26 17:42 author:nzb Go中的指针 要搞明白Go语言中的指针需要先知道三个概念 指针地址 指针类型 指针取值 Go语言中的指针操作非常简单，我们只需要记住两个符号：&：取地址，*：根据地址取值 1、关于指针 我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量a:=10，这个时候可以直接通过a这个变量来读取内存中保存的10这个值。在计算机底层a这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 2、指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用&字符放在变量前面对变量进行取地址操作。Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如： *int、，*int64、*string等 取变量指针的语法如下： ptr := &v 其中： v：代表被取地址的变量，类型为T ptr：用于接收地址的变量，ptr的类型就为T，被称做T的指针类型。\\ 代表指针 举个例子： 3、指针取值 在对普通变量进行&操作符取地址后，会获得这个变量指针，然后可以对指针使用*操作，也就是指针取值 // 指针取值 var c = 20 // 得到c的地址，赋值给d var d = &c // 指针类型 *int // 打印d的值，也就是c的地址 fmt.Println(d) // 取出d指针所对应的值 fmt.Println(*d) // c对应地址的值，改成30 *d = 30 // c已经变成30了 fmt.Println(c) 改变内存中的值，会直接改变原来的变量值 // 这个类似于值传递 func fn4(x int) { x = 10 } // 这个类似于引用数据类型 func fn5(x *int) { *x = 20 } func main() { x := 5 fn4(x) fmt.Println(x) fn5(&x) fmt.Println(x) } 我们创建了两个方法，一个是传入局部变量，一个是传入指针类型，最后运行得到的结果 5 20 4、new和make函数 需要注意的是，指针必须在创建内存后才可以使用，这个和 slice 和 map是一样的 // 报错，map,slice等是引用数据类型需要分配空间 var userInfo = map[string]string userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) // 引用数据类型map、slice等，必须使用make分配空间，才能够使用 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) var array = make([]int, 4, 4) array[0] = 1 fmt.Println(array) 对于指针变量来说 // 指针变量初始化 var a *int *a = 100 fmt.Println(a) 正确做法 var a *int a = new(int) *a = 100 fmt.Println(a) 执行上面的代码会引发panic，为什么呢？在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。Go 语言中new和make是内建的两个函数，主要用来分配内存。 这个时候，我们就需要使用new关键字来分配内存，new是一个内置的函数，它的函数签名如下： func new(Type) *Type 其中 Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子： // 使用new关键字创建指针 aPoint := new(int) bPoint := new(bool) fmt.Printf(\"%T \\n\", aPoint) fmt.Printf(\"%T \\n\", bPoint) fmt.Println(*aPoint) fmt.Println(*bPoint) 本节开始的示例代码中 var a *int 只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的 5、make和new的区别 两者都是用来做内存分配的 make只能用于slice、map以及channel的初始化，返回的还是这三个引用类型的本身 而new用于类型的内存分配，并且内存对应的值为类型的零值，返回的是指向类型的指针（不常用） "},"GoLang/GoLang基础/13-结构体.html":{"url":"GoLang/GoLang基础/13-结构体.html","title":"结构体","keywords":"","body":"datetime:2020/10/26 18:03 author:nzb Go中的结构体 1、关于结构体 Golang中没有“类”的概念，Golang中的结构体和其他语言中的类有点相似。和其他面向对象语言中的类相比，Golang中的结构体具有更高的扩展性和灵活性。 Golang中的基础数据类型可以装示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型就无法满足需求了，Golang提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。也就是我们可以通过struct来定义自己的类型了。 2、Type关键字 Golang中通过type关键词定义一个结构体，需要注意的是，数组和结构体都是值类型，在这个和Java是有区别的 2.1、自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。 type myInt int 上面代码表示：将mylnt定义为int类型，通过type关键字的定义，mylnt就是一种新的类型，它具有int的特性。 示例：如下所示，我们定义了一个myInt类型 type myInt int func main() { var a myInt = 10 fmt.Printf(\"%v %T\", a, a) } 输出查看它的值以及类型，能够发现该类型就是myInt类型 10 main.myInt 除此之外，我们还可以定义一个方法类型 func fun(x int, y int)int { return x + y } func main() { var fn myFn = fun fmt.Println(fn(1, 2)) } 然后调用并输出 3 2.2、类型别名 Golang1.9版本以后添加的新功能 类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有大名、小名、英文名，但这些名字都指的是他本人 type TypeAlias = Type 我们之前见过的rune 和 byte 就是类型别名，他们的底层代码如下 type byte = uint8 type rune = int32 示例 type myInt int // 自定义类型 type myFloat = float64 // 类型别名 func main(){ var a myInt = 10 fmt.Printf(\"%v %T\", a, a) // 10 main.myInt var b myFloat = 12.3 fmt.Printf(\"%v %T\", b, b) // 12.3 float64s } 3、结构体定义和初始化 3.1、结构体的定义 使用type 和 struct关键字来定义结构体，具体代码格式如下所示： type 类型名 struct { 字段名 字段类型 字段名 字段类型 ... } 其中 类型名：表示自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。 /** 定义一个人结构体 */ type Person struct { name string age int sex string } func main() { // 实例化结构体 var person Person person.name = \"张三\" person.age = 20 person.sex = \"男\" fmt.Printf(\"%#v\", person) } 注意：结构体首字母可以大写也可以小写，大写表示这个结构体是公有的，在其它的包里面也可以使用，小写表示结构体属于私有的，在其它地方不能使用 例如： type Person struct { Name string Age int Sex string } 3.2、实例化结构体1 刚刚实例化结构体用到了：var person Person // 实例化结构体 var person Person person.name = \"张三\" person.age = 20 person.sex = \"男\" 3.3、实例化结构体2 我们下面使用另外一个方式来实例化结构体，通过new关键字来实例化结构体，得到的是结构体的地址，格式如下 var person2 = new(Person) person2.name = \"李四\" person2.age = 30 person2.sex = \"女\" fmt.Printf(\"%#v\", person2) 输出如下所示，从打印结果可以看出person2是一个结构体指针 &main.Person{name:\"李四\", age:30, sex:\"女\"} 需要注意：在Golang中支持对结构体指针直接使用，来访问结构体的成员 person2.name = \"李四\" // 等价于 (*person2).name = \"李四\" 3.4、实例化结构体3 使用&对结构体进行取地址操作，相当于对该结构体类型进行了一次new实例化操作 // 第三种方式实例化 var person3 = &Person{} person3.name = \"赵四\" person3.age = 28 person3.sex = \"男\" fmt.Printf(\"%#v\", person3) 3.5、实例化结构体4 使用键值对的方式来实例化结构体，实例化的时候，可以直接指定对应的值 // 第四种方式初始化 var person4 = Person{ name: \"张三\", age: 10, sex: \"女\", } fmt.Printf(\"%#v\", person4) 3.6、实例化结构体5 第五种和第四种差不多，不过是用了取地址，然后返回的也是一个地址 // 第五种方式初始化 var person5 = &Person{ name: \"孙五\", age: 10, sex: \"女\", } fmt.Printf(\"%#v\", person5) 3.7、实例化结构体6 第六种方式是可以简写结构体里面的key var person6 = Person{ \"张三\", 5, \"女\", } fmt.Println(person6) 4、结构体方法和接收者 在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接收者的函数。接收者的概念就类似于其他语言中的this 或者self。 方法的定义格式如下： func (接收者变量 接收者类型) 方法名(参数列表)(返回参数) { 函数体 } 其中 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为p，Connector类型的接收者变量应该命名为c等。、 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 非指针类型：表示不修改结构体的内容 指针类型：表示修改结构体中的内容 方法名、参数列表、返回参数：具体格式与函数定义相同 如果示例所示： /** 定义一个人结构体 */ type Person struct { name string age int sex string } // 定义一个结构体方法 func (p Person) PrintInfo() { fmt.Print(\" 姓名: \", p.name) fmt.Print(\" 年龄: \", p.age) fmt.Print(\" 性别: \", p.sex) fmt.Println() } func (p *Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } func main() { var person = Person{ \"张三\", 18, \"女\", } person.PrintInfo() person.SetInfo(\"李四\", 18, \"男\") person.PrintInfo() } 运行结果为： 姓名: 张三 年龄: 18 性别: 女 姓名: 李四 年龄: 18 性别: 男 注意，因为结构体是值类型，所以我们修改的时候，因为是传入的指针(修改的是实例里面的属性) func (p *Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } 不传指针(修改是结构体的属性p，不是修改的结构体实例的值，所以都一样)func (p Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } 姓名: 张三 年龄: 18 性别: 女 姓名: 张三 年龄: 18 性别: 女 5、给任意类型添加方法 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。 type myInt int func fun(x int, y int)int { return x + y } func (m myInt) PrintInfo() { fmt.Println(\"我是自定义类型里面的自定义方法\") } func main() { var a myInt = 10 fmt.Printf(\"%v %T \\n\", a, a) a.PrintInfo() } 注意：非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。 6、结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就被称为匿名字段 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能一个 /** 定义一个人结构体 */ type Person struct { string int } func main() { // 结构体的匿名字段 var person = Person{ \"张三\", 18 } } 结构体的字段类型可以是：基本数据类型，也可以是切片、Map 以及结构体 如果结构体的字段类型是：指针、slice、和 map 的零值都是nil，即还没有分配空间 如果需要使用这样的字段，需要先make，才能使用 /** 定义一个人结构体 */ type Person struct { name string age int hobby []string mapValue map[string]string } func main() { // 结构体的匿名字段 var person = Person{} person.name = \"张三\" person.age = 10 // 给切片申请内存空间 person.hobby = make([]string, 4, 4) person.hobby[0] = \"睡觉\" person.hobby[1] = \"吃饭\" person.hobby[2] = \"打豆豆\" // 给map申请存储空间 person.mapValue = make(map[string]string) person.mapValue[\"address\"] = \"北京\" person.mapValue[\"phone\"] = \"123456789\" // 加入#打印完整信息 fmt.Printf(\"%#v\", person) } 同时我们还支持结构体的嵌套，如下所示 // 用户结构体 type User struct { userName string password string sex string age int address Address // User结构体嵌套Address结构体 } // 收货地址结构体 type Address struct { name string phone string city string } func main() { var u User u.userName = \"moguBlog\" u.password = \"123456\" u.sex = \"男\" u.age = 18 var address Address address.name = \"张三\" address.phone = \"110\" address.city = \"北京\" u.address = address fmt.Printf(\"%#v\", u) } 7、嵌套结构体的字段名冲突 嵌套结构体内部可能存在相同的字段名，这个时候为了避免歧义，需要指定具体的内嵌结构体的字段。（例如，父结构体中的字段 和 子结构体中的字段相似） 默认会从父结构体中寻找，如果找不到的话，再去子结构体中在找(可获取值和设置值) 如果子类的结构体中，同时存在着两个相同的字段，那么这个时候就会报错了，因为程序不知道修改那个字段的为准。 8、结构体的继承 结构体的继承，其实就类似于结构体的嵌套，可嵌套结构体或结构体指针，如下所示，我们定义了两个结构体，分别是Animal 和 Dog，其中每个结构体都有各自的方法，然后通过Dog结构体 继承于 Animal结构体 继承-嵌套结构体 // 用户结构体 type Animal struct { name string } func (a Animal) run() { fmt.Printf(\"%v 在运动 \\n\", a.name) } // 子结构体 type Dog struct { age int // 通过结构体嵌套，完成继承 Animal } func (dog Dog) wang() { fmt.Printf(\"%v 在汪汪汪 \\n\", dog.name) } func main() { var dog = Dog{ age: 10, Animal: Animal{ name: \"阿帕奇\", }, } dog.run(); dog.wang(); } 运行后，发现Dog拥有了父类的方法 阿帕奇 在运动 阿帕奇 在汪汪汪 继承-嵌套结构体指针 // 用户结构体 type Animal struct { name string } func (a Animal) run() { fmt.Printf(\"%v 在运动 \\n\", a.name) } // 子结构体 type Dog struct { age int // 通过结构体嵌套，完成继承 *Animal // 这边继承的是指结构体指针 } func (dog Dog) wang() { fmt.Printf(\"%v 在汪汪汪 \\n\", dog.name) } func main() { var dog = Dog{ age: 10, Animal: &Animal{ // 因为什么继承的是结构体指针，所以这边需要传指针 name: \"阿帕奇\", }, } dog.run(); dog.wang(); } 9、Go中的结构体和Json相互转换 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。RESTfull Api接口中返回的数据都是json数据。 { \"name\": \"张三\", \"age\": 15 } 比如我们Golang要给App或者小程序提供Api接口数据，这个时候就需要涉及到结构体和Json之间的相互转换 Golang JSON序列化是指把结构体数据转化成JSON格式的字符串，Golang JSON的反序列化是指把JSON数据转化成Golang中的结构体对象 Golang中的序列化和反序列化主要通过“encoding/json”包中的 json.Marshal() 和 son.Unmarshal() // 定义一个学生结构体，注意结构体的首字母必须大写，代表公有，否则将无法转换 type Student struct { ID string Gender string Name string Sno string } func main() { var s1 = Student{ ID: \"12\", Gender: \"男\", Name: \"李四\", Sno: \"s001\", } // 结构体转换成Json（返回的是byte类型的切片） jsonByte, _ := json.Marshal(s1) jsonStr := string(jsonByte) fmt.Printf(jsonStr) } 将字符串转换成结构体类型 // 定义一个学生结构体，注意结构体的首字母必须大写，代表公有，否则将无法转换 type Student struct { ID string Gender string Name string Sno string } func main() { // Json字符串转换成结构体 var str = `{\"ID\":\"12\",\"Gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s001\"}` var s2 = Student{} // 第一个是需要传入byte类型的数据，第二参数需要传入转换的地址，因为需要修改 s2 的属性 err := json.Unmarshal([]byte(str), &s2) if err != nil { fmt.Printf(\"转换失败 \\n\") } else { fmt.Printf(\"%#v \\n\", s2) } } 注意 我们想要实现结构体转换成字符串，必须保证结构体中的字段是公有的，也就是首字母必须是大写的，这样才能够实现结构体 到 Json字符串的转换。 10、结构体标签Tag Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下： key1：\"value1\" key2：\"value2\" 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。 注意事项：为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。 如下所示，我们通过tag标签，来转换字符串的key // 定义一个Student体，使用结构体标签 type Student2 struct { Id string `json:\"id\"` // 通过指定tag实现json序列化该字段的key Gender string `json:\"gender\"` Name string `json:\"name\"` Sno string `json:\"sno\"` } func main() { var s1 = Student2{ Id: \"12\", Gender: \"男\", Name: \"李四\", Sno: \"s001\", } // 结构体转换成Json jsonByte, _ := json.Marshal(s1) jsonStr := string(jsonByte) fmt.Println(jsonStr) // Json字符串转换成结构体 var str = `{\"Id\":\"12\",\"Gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s001\"}` var s2 = Student2{} // 第一个是需要传入byte类型的数据，第二参数需要传入转换的地址 err := json.Unmarshal([]byte(str), &s2) if err != nil { fmt.Printf(\"转换失败 \\n\") } else { fmt.Printf(\"%#v \\n\", s2) } } 11、嵌套结构体和Json序列化反序列化 和刚刚类似，我们同样也是使用的是 json.Marshal() // 嵌套结构体 到 Json的互相转换 // 定义一个Student结构体 type Student3 struct { Id int Gender string Name string } // 定义一个班级结构体 type Class struct { Title string Students []Student3 } func main() { var class = Class{ Title: \"1班\", Students: make([]Student3, 0), } for i := 0; i "},"GoLang/GoLang基础/14-GoMod及包.html":{"url":"GoLang/GoLang基础/14-GoMod及包.html","title":"GoMod及包","keywords":"","body":"datetime:2020/10/28 15:19 author:nzb Go中的包 1、Go中的包的介绍和定义 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、strconv、strings、sort、errors、time、encoding/json、os、io等。 Golang中的包可以分为三种：1、系统内置包 2、自定义包 3、第三方包 系统内置包：Golang 语言给我们提供的内置包，引入后可以直接使用，如fmt、strconv、strings、sort、errors、time、encoding/json、os、io等。 自定义包：开发者自己写的包 第三方包：属于自定义包的一种，需要下载安装到本地后才可以使用，如前面给大家介绍的 \"github.com/shopspring/decimal\"包解决float精度丢失问题。 2、Go包管理工具 go mod 在Golang1.11版本之前如果我们要自定义包的话必须把项目放在GOPATH目录。Go1.11版本之后无需手动配置环境变量，使用go mod 管理项目，也不需要非得把项目放到GOPATH指定目录下，你可以在你磁盘的任何位置新建一个项目，Go1.13以后可以彻底不要GOPATH了。 2.1、go mod init初始化项目 实际项目开发中我们首先要在我们项目目录中用go mod命令生成一个go.mod文件管理我们项目的依赖。 比如我们的golang项目文件要放在了 goProject 这个文件夹，这个时候我们需要在 goProject 文件夹里面使用go mod命令生成一个go.mod文件 go mod init goProject 然后会生成一个 go.mod 的文件，里面的内容是go版本，以及以后添加的包 module goProject go 1.14 2.2、引入其它项目的包 首先我们创建一个 calc，然后里面有一个calc的文件 package calc // 自定义包，最好和文件夹统一起来 // 私有变量 var age = 10 // 公有变量 var Name = \"张三\" // 首字母大写，表示共有方法 func Add(x, y int)int { return x + y } func Sub(x, y int)int { return x - y } 在其它地方需要引用的话，就是这样 package main import ( \"fmt\" \"goProject/calc\" ) func main() { fmt.Printf(\"%v\", calc.Add(2, 5)) } 2.3、导入一个包 单行导入import \"包1\" import \"包2\" 多行导入 import ( \"包1\" \"包2\" ) 自定义包名在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体格式 ```text import 别名 \"包的路径\" // 单行引入定义别名 import c \"goProject/calc\" // 多行引入定义别名 import ( \"fmt\" T \"goProject/calc\" ) fmt.Println(T.test()) - 匿名导入包 如果只希望导入包，而不使用内部的数据时，可以使用匿名导入包。具体格式 ```text import _ \"包的路径\" 3、Golang中自定义包 包（package）是多个Go源码的集合，一个包可以简单理解为一个存放多个.go文件的文件夹。该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。 package 包名 注意事项 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。 包名可以不和文件夹的名字一样，包名不能包含-符号。 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。 4、Go中init()初始化函数 4.1、init函数介绍 在Go 语言程序执行时导入包语句会自动触发包内部init（）函数的调用。需要注意的是：init（） 函数没有参数也没有返回值。init（）函数在程序运行时自动被调用执行，不能在代码中主动调用它。 包初始化执行的顺序如下图所示： 包初始化执行的顺序如下图所示： 4.2、init函数执行顺序 Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。 在运行时，被最后导入的包会最先初始化并调用其init（）函数，如下图示： 也就是父类中的init先执行 5、Go中的第三方包 我们可以在 https://pkg.go.dev/ 查找看常见的golang第三方包 例如，前面找到前面我们需要下载的第三方包的地址 https://github.com/shopspring/decimal 然后安装这个包 5.1、方法1：go get 包全名 （全局） go get github.com/shopspring/decimal 5.2、方法2：go mod download （全局） go mod download 依赖包会自动下载到 $GOPATH/pkg/mod目录，并且多个项目可以共享缓存的mod，注意使用go mod download的时候，需要首先在你的项目中引入第三方包 5.3、方法3：go mod vendor 将依赖复制到当前项目的vendor（本项目） go mod vendor 将依赖复制到当前项目的vendor下 注意：使用go mod vendor的时候，首先需要在你的项目里面引入第三方包 5.4、go mod常见命令 go download：下载依赖的module到本地cache go edit：编辑go.mod文件 go graph：打印模块依赖图 go init：在当前文件夹下初始化一个新的module，创建go.mod文件 tidy：增加丢失的module，去掉未使用的module vendor：将依赖复制到vendor下 verify：校验依赖，检查下载的第三方库有没有本地修改，如果有修改，则会返回非0，否则校验成功 6、安装依赖 首先我们先去官网找到这个包，https://github.com/shopspring/decimal 然后在我们的项目中引入 import ( \"fmt\" \"github.com/shopspring/decimal\" \"goProject/calc\" ) func main() { fmt.Printf(\"%v \\n\", calc.Add(2, 5)) // 打印公有变量 fmt.Println(calc.Name) _, err := decimal.NewFromString(\"136.02\") if err != nil { panic(err) } } 引入后，我们运行项目，就会去下载了，下载完成后，我们到 go.mod文件，能够看到依赖被引入了 module goProject go 1.14 require github.com/shopspring/decimal v1.2.0 // indirect 同时还生成了一个 go.sum文件 github.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ= github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o= 这样我们就可以使用第三包开始具体的使用了~，我们实现一个Float类型的加法 package main import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main() { var num1 float64 = 3.1 var num2 float64 = 4.2 d1 := decimal.NewFromFloat(num1).Add(decimal.NewFromFloat(num2)) fmt.Println(d1) } 7、完整案例 寻找依赖 首先我们需要去 依赖官网，类似于我们的 maven repository 然后我们搜索gJson的包，这个包主要是用于json相关的操作 我们进去后，找到它的https://github.com/tidwall/gjson，然后提供了完整的教程 # 下载依赖 go get -u github.com/tidwall/gjson 使用 package main import \"github.com/tidwall/gjson\" const json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}` func main() { value := gjson.Get(json, \"name.last\") println(value.String()) } "},"GoLang/GoLang基础/15-接口.html":{"url":"GoLang/GoLang基础/15-接口.html","title":"接口","keywords":"","body":"datetime:2021/12/02 14:55 author:nzb Go中的接口 接口的介绍 现实生活中手机、相机、U盘都可以和电脑的USB接口建立连接。我们不需要关注usb卡槽大小是否一样，因为所有的USB接口都是按照统一的标准来设计的。 Golang中的接口是一种抽象数据类型，Golang中接口定义了对象的行为规范，只定义规范不实现。接口中定义的规范由具体的对象来实现。 通俗的讲接口就一个标准，它是对一个对象的行为和规范进行约定，约定实现接口的对象必须得按照接口的规范。 Go接口的定义 在Golang中接口（interface）是一种类型，一种抽象的类型。接口（interface）是一组函数method的集合，Golang中的接口不能包含任何变量。 在Golang中接口中的所有方法都没有方法体，接口定义了一个对象的行为规范，只定义规范不实现。接口体现了程序设计的多态和高内聚低耦合的思想N Golang中的接口也是一种数据类型，不需要显示实现。只需要一个变量含有接口类型中的所有方法，那么这个变量就实现了这个接口。 Golang中每个接口由数个方法组成，接口的定义格式如下： type 接口名 interface { 方法名1 (参数列表1) 返回值列表1 方法名2 (参数列表2) 返回值列表2 } 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等，接口名最好突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名是可以省略 演示：定义一个Usber接口让Phone 和 Camera结构体实现这个接口 首先我们定义一个Usber接口，接口里面就定义了两个方法 // 定义一个Usber接口 type Usber interface { start() stop() } 注意：如果接口里面有方法的话，必须要通过结构体或自定义类型实现这个接口 然后我们创建一个Phone的结构体，来实现这个接口 // 使用结构体来实现 接口 type Phone struct { Name string } // 手机要实现Usber接口的话，必须实现usb接口的所有方法 func (p Phone) start() { fmt.Println(p.Name, \"启动\") } func (p Phone) stop() { fmt.Println(p.Name, \"关闭\") } func main() { var phone Usber = Phone{ \"三星手机\", } phone.start() phone.stop() } 我们再创建一个Camera结构体 // 使用相机结构体来实现 接口 type Camera struct { Name string } // 相机要实现Usber接口的话，必须实现usb接口的所有方法 func (p Camera) start() { fmt.Println(p.Name, \"启动\") } func (p Camera) stop() { fmt.Println(p.Name, \"关闭\") } func main() { var camera Usber = Camera{ \"佳能\", } camera.start() camera.stop() } 我们创建一个电脑的结构体，电脑的结构体就是用于接收两个实现了Usber的结构体，然后让其工作 // 电脑 type Computer struct { } // 接收一个实现了Usber接口的 结构体 func (computer Computer) Startup(usb Usber) { usb.start() } // 关闭 func (computer Computer) Shutdown (usb Usber) { usb.stop() } 最后我们在main中调用方法 func main() { var camera interfaceDemo.Camera = interfaceDemo.Camera{ \"佳能\", } var phone interfaceDemo.Phone = interfaceDemo.Phone{ \"苹果\", } var computer interfaceDemo.Computer = interfaceDemo.Computer{} computer.Startup(camera) computer.Startup(phone) computer.Shutdown(camera) computer.Shutdown(phone) 运行结果如下所示： 佳能 启动 苹果 启动 佳能 关闭 苹果 关闭 空接口（Object类型） Golang中的接口可以不定义任何方法，没有定义任何方法的接口就是空接口。空接口表示没有任何约束，因此任何类型变量都可以实现空接口。 空接口在实际项目中用的是非常多的，用空接口可以表示任意数据类型。 // 空接口表示没有任何约束，任意的类型都可以实现空接口 type EmptyA interface { } func main() { var a EmptyA var str = \"你好golang\" // 让字符串实现A接口 a = str fmt.Println(a) } 同时golang中空接口也可以直接当做类型来使用，可以表示任意类型。相当于Java中的Object类型 var a interface{} a = 20 a = \"hello\" a = true 空接口可以作为函数的参数，使用空接口可以接收任意类型的函数参数 // 空接口作为函数参数 func show(a interface{}) { fmt.println(a) } map的值实现空接口 使用空接口实现可以保存任意值的字典 // 定义一个值为空接口类型 var studentInfo = make(map[string]interface{}) studentInfo[\"userName\"] = \"张三\" studentInfo[\"age\"] = 15 studentInfo[\"isWork\"] = true slice切片实现空接口 // 定义一个空接口类型的切片 var slice = make([]interface{}, 4, 4) slice[0] = \"张三\" slice[1] = 1 slice[2] = true 类型断言 一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。 如果我们想要判断空接口中值的类型，那么这个时候就可以使用类型断言，其语法格式： x.(T) x：表示类型为interface{}的变量 T：表示断言x可能是的类型 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败 // 类型断言 var a interface{} a = \"132\" value, isString := a.(string) if isString { fmt.Println(\"是String类型, 值为：\", value) } else { fmt.Println(\"断言失败\") } 或者我们可以定义一个能传入任意类型的方法 // 定义一个方法，可以传入任意数据类型，然后根据不同类型实现不同的功能 func Print(x interface{}) { if _,ok := x.(string); ok { fmt.Println(\"传入参数是string类型\") } else if _, ok := x.(int); ok { fmt.Println(\"传入参数是int类型\") } else { fmt.Println(\"传入其它类型\") } } 上面的示例代码中，如果要断言多次，那么就需要写很多if，这个时候我们可以使用switch语句来实现： 注意： 类型.(type) 只能结合switch语句使用 func Print2(x interface{}) { switch x.(type) { case int: fmt.Println(\"int类型\") case string: fmt.Println(\"string类型\") case bool: fmt.Println(\"bool类型\") default: fmt.Println(\"其它类型\") } } 结构体接收者 值接收者 如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量 package main import \"fmt\" type Usber interface { start() stop() } type Phone struct { Name string } func (p Phone) start() { // 值接收者 fmt.Println(p.Name, \"启动\") } func (p Phone) stop() { fmt.Println(p.Name, \"关机\") } func main() { var p1 = Phone{ // 结构体值类型 Name: \"华为手机\", } var p2 Usber = p1 // 表示让 Phone 实现 Usb 的接口 p2.start() var p3 = &Phone{ // 结构体指针类型 Name: \"小米手机\", } var p4 Usber = p3 p4.start() } 指针接收者 如果结构体中的方法是指针接收者，那么实例化后结构体指针类型都可以赋值给接口变量，结构体指类型不能赋值给接口变量 package main import \"fmt\" type Usber interface { start() stop() } type Phone struct { Name string } func (p *Phone) start() { // 指针接收者 fmt.Println(p.Name, \"启动\") } func (p *Phone) stop() { fmt.Println(p.Name, \"关机\") } func main() { /* 错误写法 var p1 = Phone{ // 结构体值类型 Name: \"华为手机\", } var p2 Usber = p1 // Phone does not implement Usber (start method has pointer receiver) p2.start() */ var p3 = &Phone{ // 结构体指针类型 Name: \"小米手机\", } var p4 Usber = p3 p4.start() } 结构体实现多个接口 实现多个接口的话，可能就同时用两个接口进行结构体的接受 // 定义一个Animal的接口，Animal中定义了两个方法，分别是setName 和 getName，分别让DOg结构体和Cat结构体实现 type Animal interface { SetName(string) } // 接口2 type Animal2 interface { GetName()string } type Dog struct { Name string } func (d *Dog) SetName(name string) { d.Name = name } func (d Dog)GetName()string { return d.Name } func main() { var dog = &Dog{ \"小黑\", } // 同时实现两个接口 var d1 Animal = dog var d2 Animal2 = dog d1.SetName(\"小鸡\") fmt.Println(d2.GetName()) } 接口嵌套 在golang中，允许接口嵌套接口，我们首先创建一个 Animal1 和 Animal2 接口，然后使用Animal接受刚刚的两个接口，实现接口的嵌套。 // 定义一个Animal的接口，Animal中定义了两个方法，分别是setName 和 getName，分别让DOg结构体和Cat结构体实现 type Animal1 interface { SetName(string) } // 接口2 type Animal2 interface { GetName()string } type Animal interface { Animal1 Animal2 } type Dog struct { Name string } func (d *Dog) SetName(name string) { d.Name = name } func (d Dog)GetName()string { return d.Name } func main() { var dog = &Dog{ \"小黑\", } // 同时实现两个接口 var d Animal = dog d.SetName(\"小鸡\") fmt.Println(d.GetName()) } Golang中空接口和类型断言 package main import \"fmt\" type Address struct { Name string Phone int } func main() { // golang中空接口和类型断言 var userInfo = make(map[string]interface{}) userInfo[\"userName\"] = \"zhangsan\" userInfo[\"age\"] = 10 userInfo[\"hobby\"] = []string{\"吃饭\", \"睡觉\"} fmt.Println(userInfo[\"userName\"]) fmt.Println(userInfo[\"age\"]) fmt.Println(userInfo[\"hobby\"]) // 但是我们空接口如何获取数组中的值？发现 userInfo[\"hobby\"][0] 这样做不行 // fmt.Println(userInfo[\"hobby\"][0]) // invalid operation: userInfo[\"hobby\"][0] (index of type interface {}) var address = Address{ Name: \"李四\", Phone: 110, } userInfo[\"address\"] = address fmt.Println(address.Name) fmt.Println(userInfo[\"address\"]) // {李四 110} // fmt.Println(userInfo[\"address\"].Name) //userInfo[\"address\"].Name undefined (type interface {} has no field or method Name) // 可通过断言获取 hobby2, _ := userInfo[\"hobby\"].([]string) fmt.Println(hobby2[1]) address2, _ := userInfo[\"address\"].(Address) fmt.Println(address2.Name) } 也就是我们的空接口，无法直接通过索引获取数组中的内容，因此这个时候就需要使用类型断言了 // 这个时候我们就可以使用类型断言了 hobbyValue,ok := userInfo[\"hobby\"].([]string) if ok { fmt.Println(hobbyValue[0]) } 通过类型断言返回来的值，我们就能够直接通过角标获取了。 确保接口的所有方法被实现（利用强制类型转换） 一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。 举一个简单的例子，定义一个接口 Person和对应的方法 getName()： package main import \"fmt\" type Person interface { getName() string } type Student struct { name string age int } func (stu *Student) getName() string { return stu.name } type Worker struct { name string age int } func (w *Worker) getName() string { return w.name } // 确保某个类型实现了某个接口的所有方法 var _ Person = (*Student)(nil) var _ Person = (*Worker)(nil) func main() { var p Person = &Student{ name: \"小明\", age: 18, } fmt.Println(p.getName()) // 小明 } Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。 实例化 Student后，强制类型转换为接口类型 Person。 在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 (*Student).getName() 删掉，编译时会出现如下报错信息。 *Student does not implement Person (missing getName method) 但是删除 (*Worker).getName() 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。 var _ Person = (*Student)(nil) var _ Person = (*Worker)(nil) 将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。 Worker 同上。 实例可以强制类型转换为接口，接口也可以强制类型转换为实例。 func main() { var p Person = &Student{ name: \"Tom\", age: 18, } stu := p.(*Student) // 接口转为实例 fmt.Println(stu.getAge()) } 这是确保接口被实现常用的方式。即利用强制类型转换，确保 struct Student 实现了接口 Person。这样 IDE 和编译期间就可以检查，而不是等到使用的时候。 "},"GoLang/GoLang基础/16-goroutine实现并行和并发.html":{"url":"GoLang/GoLang基础/16-goroutine实现并行和并发.html","title":"协程","keywords":"","body":"datetime:2021/12/27 21:53 author:nzb Golang goroutine channel 实现并发和并行 为什么要使用goroutine呢 需求：要统计1-10000000的数字中那些是素数，并打印这些素数？ 素数：就是除了1和它本身不能被其他数整除的数 实现方法： 传统方法，通过一个for循环判断各个数是不是素数 使用并发或者并行的方式，将统计素数的任务分配给多个 goroutine 去完成，这个时候就用到了goroutine goroutine 结合 channel 进程、线程以及并行、并发 进程 进程（Process）就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间。一个进程至少有5种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。 通俗的讲进程就是一个正在执行的程序。 线程 线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位 一个进程可以创建多个线程，同一个进程中多个线程可以并发执行 ，一个线程要运行的话，至少有一个进程 并发和并行 并发：多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。 并行：多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。 通俗的讲多线程程序在单核CPU上面运行就是并发，多线程程序在多核CUP上运行就是并行，如果线程数大于CPU核数，则多线程程序在多个CPU上面运行既有并行又有并发 Golang中协程（goroutine）以及主线程 Golang 中的主线程：（可以理解为线程/也可以理解为进程），在一个 Golang 程序的主线程上可以起多个协程。Golang 中多协程可以实现并行或者并发。 协程：可以理解为用户级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。Golang的一大特色就是从语言层面原生持协程，在函数或者方法前面加go关键字就可创建一个协程。可以说Golang中的协程就是 goroutine。 Golang中的多协程有点类似于Java中的多线程 多协程和多线程 多协程和多线程：Golang 中每个 goroutine（协程）默认占用内存远比 Java、C的线程少。 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB左右），一个 goroutine（协程）占用内存非常小，只有 2KB 左右，多协程 goroutine 切换调度开销方面远比线程要少。 这也是为什么越来越多的大公司使用Golang的原因之一。 goroutine的使用以及sync.WaitGroup 并行执行需求 在主线程（可以理解成进程）中，开启一个 goroutine，该协程每隔50毫秒秒输出“你好golang\" 在主线程中也每隔50毫秒输出“你好golang\"，输出10次后，退出程序，要求主线程和 goroutine 同时执行。 这时候，我们就可以开启协程来了，通过 go 关键字开启 // 协程需要运行的方法 func test() { for i := 0; i 运行结果如下，我们能够看到他们之间不存在所谓的顺序关系了 main 你好golang test 你好golang main 你好golang test 你好golang test 你好golang main 你好golang main 你好golang test 你好golang test 你好golang main 你好golang 但是上述的代码其实还有问题的，也就是说当主进程执行完毕后，不管协程有没有执行完成，都会退出 这是使用我们就需要用到 sync.WaitGroup 等待协程 首先我们需要创建一个协程计数器 // 定义一个协程计数器 var wg sync.WaitGroup 然后当我们开启协程的时候，我们要让计数器加1 // 开启协程，协程计数器加1 wg.Add(1) go test2() 当我们协程结束前，我们需要让计数器减1 // 协程计数器减1 wg.Done() 完整代码如下 // 定义一个协程计数器 var wg sync.WaitGroup func test() { // 这是主进程执行的 for i := 0; i 设置Go并行运行的时候占用的cpu数量 Go 运行时的调度器使用 GOMAXPROCS 参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把 Go 代码同时调度到 8个 OS 线程上。 Go 语言中可以通过 runtime.GOMAXPROCS（）函数设置当前程序并发时占用的 CPU 逻辑核心数。 Go1.5 版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的 CPU 逻辑核心数。 func main() { // 获取cpu个数 npmCpu := runtime.NumCPU() fmt.Println(\"cup的个数:\", npmCpu) // 设置允许使用的CPU数量 runtime.GOMAXPROCS(runtime.NumCPU() - 1) } for循环开启多个协程 类似于Java里面开启多个线程，同时执行 func test(num int) { for i := 0; i 因为我们协程会在主线程退出后就终止，所以我们还需要使用到 sync.WaitGroup 来控制主线程的终止。 Channel管道 管道是Golang在语言级别上提供的goroutine间的通讯方式，我们可以使用channel在多个goroutine之间传递消息。如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 Golang的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。 Go语言中的管道（channel）是一种特殊的类型。管道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个管道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 channel类型 channel是一种类型，一种引用类型。声明管道类型的格式如下： // 声明一个传递整型的管道 var ch1 chan int // 声明一个传递布尔类型的管道 var ch2 chan bool // 声明一个传递int切片的管道 var ch3 chan []int 创建channel 声明管道后，需要使用make函数初始化之后才能使用 make(chan 元素类型, 容量) 举例如下： // 创建一个能存储10个int类型的数据管道 ch1 = make(chan int, 10) // 创建一个能存储4个bool类型的数据管道 ch2 = make(chan bool, 4) // 创建一个能存储3个[]int切片类型的管道 ch3 = make(chan []int, 3) channel操作 管道有发送，接收和关闭的三个功能 发送和接收都使用 符号 现在我们先使用以下语句定义一个管道： ch := make(chan int, 3) 发送 将数据放到管道内，将一个值发送到管道内 // 把10发送到ch中 ch 取操作 x := 关闭管道 通过调用内置的close函数来关闭管道 close(ch) 完整示例 // 创建管道 ch := make(chan int, 3) // 给管道里面存储数据 ch for range从管道循环取值 当向管道中发送完数据时，我们可以通过close函数来关闭管道，当管道被关闭时，再往该管道发送值会引发panic，从该管道取值的操作会去完管道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个管道是否被关闭的呢？ // 创建管道 ch := make(chan int, 10) // 循环写入值 for i := 0; i 注意：使用for range遍历的时候，一定在之前需要先关闭管道 思考：通过for循环来遍历管道，需要关闭么？ // 创建管道 ch := make(chan int, 10) // 循环写入值 for i := 0; i 上述代码没有报错，说明通过for i的循环方式，可以不关闭管道 Goroutine 结合 channel 管道 需求1：定义两个方法，一个方法给管道里面写数据，一个给管道里面读取数据。要求同步进行。 开启一个fn1的的协程给向管道inChan中写入00条数据 开启一个fn2的协程读取inChan中写入的数据 注意：fn1和fn2同时操作一个管道 主线程必须等待操作完成后才可以退出 func write(ch chan int) { for i := 0; i 管道是安全的，是一边写入，一边读取，当读取比较快的时候，会等待写入 goroutine 结合 channel打印素数 // 想intChan中放入 1~ 120000个数 func putNum(intChan chan int) { for i := 2; i 单向管道 有时候我们会将管道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中，使用管道都会对其进行限制，比如限制管道在函数中只能发送或者只能接受 默认的管道是 可读可写 ```go // 定义一种可读可写的管道 var ch = make(chan int, 2) ch // 管道声明为只写管道，只能够写入，不能读 var ch2 = make(chan // 声明一个只读管道 var ch3 = make( // 只写函数 func inputChan(ch chan ## Select多路复用 在某些场景下我们需要同时从多个通道接收数据。这个时候就可以用到golang中给我们提供的select多路复用。 通常情况通道在接收数据时，如果没有数据可以接收将会发生阻塞。 比如说下面代码来实现从多个通道接受数据的时候就会发生阻塞 这种方式虽然可以实现从多个管道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个管道的操作。 select的使用类似于switch 语句，它有一系列case分支和一个默认的分支。每个case会对应一个管道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下： ```go intChan := make(chan int, 10) intChan 使用select来获取数据的时候，不需要关闭channel，不然会出现问题 Goroutine Recover 解决协程中出现的 Panic func sayHello() { for i := 0; i 当我们出现问题的时候，我们还是按照原来的方法，通过defer func创建匿名自启动 // 捕获异常 defer func() { if err := recover(); err != nil { fmt.Println(\"errTest发生错误\") } }() Go中的并发安全和锁 如下面一段代码，我们在并发环境下进行操作，就会出现并发访问的问题 var count = 0 var wg sync.WaitGroup func test() { count++ fmt.Println(\"the count is : \", count) time.Sleep(time.Millisecond) wg.Done() } func main() { for i := 0; i 互斥锁 互斥锁是传统并发编程中对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock 进行解锁 // 定义一个锁 var mutex sync.Mutex // 加锁 mutex.Lock() // 解锁 mutex.Unlock() 完整代码 var count = 0 var wg sync.WaitGroup var mutex sync.Mutex func test() { // 加锁 mutex.Lock() count++ fmt.Println(\"the count is : \", count) time.Sleep(time.Millisecond) wg.Done() // 解锁 mutex.Unlock() } func main() { for i := 0; i 通过下面命令，build的时候，可以查看是否具有竞争关系 // 通过 -race 参数进行构建 go build -race main.go // 运行插件 main.ext 读写互斥锁 互斥锁的本质是当一个goroutine访问的时候，其他goroutine都不能访问。这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。 其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在资源竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的。 所以问题不是出在“读”上，主要是修改，也就是“写”。修改的数据要同步，这样其他goroutine才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的。 因此，衍生出另外一种锁，叫做读写锁。 读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。 GO中的读写锁由结构体类型sync.RWMutex表示。此类型的方法集合中包含两对方法： 一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”func (*RWMutex)Lock() func (*RWMutex)UnLock() 另一组是对读操作的锁定和解锁，简称“读锁定”和“读解锁” func(*RWMutex)Rlock() func(*RWMutex)RUnlock()读写锁示例 示例代码 package main import ( \"fmt\" \"sync\" \"time\" ) var wg = sync.WaitGroup //var mutex = sync.Mutex // 互斥锁 var mutex = sync.RWMutex // 读写互斥锁 fund write(){ mutex.Lock() fmt.Println(\"+++执行写操作\") time.Sleep(time.Seconde * 2) mutex.UnLock() wg.Done() } func read(){ mutex.RLock() fmt.Println(\"执行读操作\") time.Sleep(time.Seconde * 2) wg.Done() mutex.RUnLock() } func main(){ // 开启10个协程执行写操作 for i:=0; i "},"GoLang/GoLang基础/17-反射.html":{"url":"GoLang/GoLang基础/17-反射.html","title":"反射","keywords":"","body":"datetime:2022/1/1 15:10 author:nzb GoLang中的反射 反射 有时我们需要写一个函数，这个函数有能力统一处理各种值类型，而这些类型可能无法共享同一个接口，也可能布局未知，也有可能这个类型在我们设计函数时还不存在，这个时候我们就可以用到反射。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存数据的类型是什么？ 值是什么呢？ 可以使用类型断言 可以使用反射实现，也就是在程序运行时动态的获取一个变量的类型信息和值信息。 把结构体序列化成json字符串，自定义结构体Tab标签的时候就用到了反射 后面所说的ORM框架，底层就是用到了反射技术 ORM：对象关系映射（Object Relational Mapping，简称 ORM）是通过使用描述对象和数据库之间的映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。 反射的基本介绍 反射是指在程序运行期间对程序本身进行访问和修改的能力。正常情况程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。 Go可以实现的功能 反射可以在程序运行期间动态的获取变量的各种信息，比如变量的类型类别 如果是结构体，通过反射还可以获取结构体本身的信息，比如结构体的字段、结构体的方法。 通过反射，可以修改变量的值，可以调用关联的方法 Go语言中的变量是分为两部分的： 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个重要函数来获取任意对象的 Value 和 Type reflect.TypeOf()获取任意值的类型对象 在Go 语言中，使用 reflect.TypeOf() 函数可以接受任意interface}参数，可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。 通过反射获取空接口的类型 func reflectFun(x interface{}) { v := reflect.TypeOf(x) fmt.Println(v) } func main() { reflectFun(10) reflectFun(10.01) reflectFun(\"abc\") reflectFun(true) } type Name 和 type Kind 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。 Go 语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。 v := reflect.TypeOf(x) fmt.Println(\"类型 \", v) fmt.Println(\"类型名称 \", v.Name()) fmt.Println(\"类型种类 \", v.Kind()) reflect.ValueOf reflect.ValueOf() 返回的是 reflect.Value 类型，其中包含了原始值的值信息，reflect.Value与原始值之间可以互相转换 reflect.value类型提供的获取原始值的方法如下 方法 说明 interface{} 将值以interface{}类型返回，可以通过类型断言转换为指定类型 Int() int64 将值以int类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以uint类型返回，所有无符号整型均可以以此方式返回 Float() float64 将值以双精度(float 64)类型返回，所有浮点数(float 32、float64)均可以以此方式返回 我们之前可以通过类型断言来实现空接口类型的数相加操作 func reflectValue(x interface{}) { b,_ := x.(int) var num = 10 + b fmt.Println(num) } 到现在的话，我们就可以使用reflect.TypeOf来实现了 func reflectValue2(x interface{}) { // 通过反射来获取变量的原始值 v := reflect.ValueOf(x) fmt.Println(v) // 获取到V的int类型 var n = v.Int() + 12 fmt.Println(n) } 同时我们还可以通过switch来完成 // 通过反射来获取变量的原始值 v := reflect.ValueOf(x) // 获取种类 kind := v.Kind() switch kind { case reflect.Int: fmt.Println(\"我是int类型\") case reflect.Float64: fmt.Println(\"我是float64类型\") default: fmt.Println(\"我是其它类型\") } 通过反射设置变量的值 package main import ( \"fmt\" \"reflect\" ) func reflectSetValue(x interface{}) { // 第一种：不行 // *x = 120 //invalid indirect of x (type interface {}) // 第二种：不行 // v, _ := x.(*int) // *v = 120 // panic: runtime error: invalid memory address or nil pointer dereference // 第三种：利用反射 v := reflect.ValueOf(x) // fmt.Println(v.Kind()) // ptr // fmt.Println(v.Elem().Kind()) // int64 if v.Elem().Kind() == reflect.Int64 { v.Elem().SetInt(123) } else if v.Elem().Kind() == reflect.String { v.Elem().SetString(\"你好 Golang\") } } func main() { var a int64 = 100 reflectSetValue(&a) fmt.Println(a) var b string = \"Hello GoLang\" reflectSetValue(&b) fmt.Println(b) } 结构体反射 与结构体相关的方法 任意值通过reflect.Typeof() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField（）和Field（）方法获得结构体成员的详细信息。 reflect.Type中与获取结构体成员相关的的方法如下表所示。 方法 说明 Field(i int)StructField 根据索引，返回索引对应的结构体字段的信息 NumField() int 返回结构体成员字段数量 FieldByName(name string)(StructField, bool) 根据给定字符串返回字符串匹配的结构体字段信息 FieldByIndex(index []int)StructField 多层成员访问时，根据[] int 提供的每个结构体的字段索引，返回字段信息 FieldByNameFunc(match func(string)bool)(StructField, bool) 根据传入的匹配函数匹配需要的字段 NumMethod() int 返回该类型的方法集中方法的数目 Method(int) Method 返回该类型的方法集中的第i个方法 MethodByName(string)(Method, bool) 根据方法名返回该类型的方法集中的方法 StructField 类型 StructField 类型用来描述结构体中的字段的信息。StructField的定义如下： type StructField struct { // Name is the field name. Name string // 字段的名字 PkgPath string // 是非导出字段的包路径，对导出字段该字段为“” Type Type // field type， 字段的类型 Tag StructTag // field tag string，字段的标签 Offset uintptr // offset within struct, in bytes，结构体中的字节偏移量 Index []int // index sequence for Type.FieldByIndex，用于 Type.FieldByIndex时的索引切片 Anonymous bool // is an embedded field } 示例代码，如下所示 我们修改结构体中的字段和类型 package main import ( \"fmt\" \"reflect\" ) // 学生结构体 type Student4 struct { Name string `json: \"name\" form:\"username\"` Age int `json: \"age\"` Score int `json: \"score\"` } func (s Student4) GetInfo() string { var str = fmt.Sprintf(\"姓名：%v 年龄：%v 成绩：%v\", s.Name, s.Age, s.Score) return str } func (s *Student4) SetInfo(name string, age int, score int) { s.Name = name s.Age = age s.Score = score } func (s Student4) PrintStudent() { fmt.Println(\"打印学生\") } // 打印结构体中的字段 func PrintStructField(s interface{}) { t := reflect.TypeOf(s) // 判断传递过来的是否是结构体, 如果传入的是指针地址则需要 .Elem().Kind 查看原始类型 if t.Kind() != reflect.Struct && t.Elem().Kind() != reflect.Struct { fmt.Println(\"请传入结构体类型!\") return } // 通过类型变量里面的Field可以获取结构体的字段 field0 := t.Field(0) // 获取第0个字段 fmt.Printf(\"%#v \\n\", field0) fmt.Println(\"字段名称:\", field0.Name) fmt.Println(\"字段类型:\", field0.Type) fmt.Println(\"字段Tag1:\", field0.Tag.Get(\"json\")) fmt.Println(\"字段Tag2:\", field0.Tag.Get(\"form\")) // 通过类型变量里面的FieldByName可以获取结构体的字段中 field1, ok := t.FieldByName(\"Age\") if ok { fmt.Println(\"字段名称:\", field1.Name) fmt.Println(\"字段类型:\", field1.Type) fmt.Println(\"字段Tag:\", field1.Tag) } // 通过类型变量里面的NumField获取该结构体有几个字段 var fieldCount = t.NumField() fmt.Println(\"结构体有：\", fieldCount, \" 个属性\") // 获取结构体属性对应的值 v := reflect.ValueOf(s) nameValue := v.FieldByName(\"Name\") fmt.Println(\"nameValue:\", nameValue) // for 循环遍历 for i := 0; i 下列代码是获取结构体中的方法，然后调用 // 打印执行方法 func PrintStructFn(s interface{}) { t := reflect.TypeOf(s) // 判断传递过来的是否是结构体 if t.Kind() != reflect.Struct && t.Elem().Kind() != reflect.Struct { fmt.Println(\"请传入结构体类型!\") return } // 通过类型变量里面的Method，可以获取结构体的方法 method0 := t.Method(0) // 获取第一个方法， 这个是和ACSII相关 fmt.Println(method0.Name) // 通过类型变量获取这个结构体有多少方法 methodCount := t.NumMethod() fmt.Println(\"拥有的方法\", methodCount) // 通过值变量 执行方法（注意需要使用值变量，并且要注意参数） v := reflect.ValueOf(s) // 通过值变量来获取参数 v.MethodByName(\"PrintStudent\").Call(nil) // 手动传参 var params []reflect.Value params = append(params, reflect.ValueOf(\"张三\")) params = append(params, reflect.ValueOf(23)) params = append(params, reflect.ValueOf(99)) // 执行setInfo方法 v.MethodByName(\"SetInfo\").Call(params) // 通过值变量来获取参数 v.MethodByName(\"PrintStudent\").Call(nil) } 不要乱用反射 反射是一个强大并附有表现力的工具，能让我们写出更灵活的代码，但是反射不应该被滥用，原因： 基于反射的代码是及其脆弱的，反射中的类型错误会在真正运行的时候才会引发 panic，那可能是在代码写完很长时间之后 大量使用反射的代码通常难以理解（对于不熟悉反射的开发者来说，代码可读性差） "},"GoLang/GoLang基础/18-文件和目录操作.html":{"url":"GoLang/GoLang基础/18-文件和目录操作.html","title":"文件和目录操作","keywords":"","body":"datetime:2022/1/2 13:35 author:nzb Go中的文件和目录操作 文件的读取 通过os.Open方法读取文件 func main() { // 读取文件 方法1 file, err := os.Open(\"./main/test.txt\") // 关闭文件流 defer file.Close(); if err != nil { fmt.Println(\"打开文件出错\") return } // 读取文件里面的内容 var tempSlice = make([]byte, 1024) var strSlice []byte for { n, err := file.Read(tempSlice) if err == io.EOF { // err==io.EOF表示读取完毕 fmt.Printf(\"读取完毕\") break } fmt.Printf(\"读取到了%v 个字节 \\n\", n) strSlice := append(strSlice, tempSlice[:n]...) // 切片，防止最后读到的数据没有 1024 长度，导致拼接乱码 fmt.Println(string(strSlice)) } } 通过bufio的方式读取 func main() { // 读取文件 方法2 file, err := os.Open(\"./main/test.txt\") // 关闭文件流 defer file.Close(); if err != nil { fmt.Println(\"打开文件出错\") } // 通过创建bufio来读取 reader := bufio.NewReader(file) var fileStr string var count int = 0 for { // 相当于读取一行 str, err := reader.ReadString('\\n') if err == io.EOF { // 读取完成的时候，也会有内容 fileStr += str fmt.Println(\"读取结束\", count) break } if err != nil { fmt.Println(err) break } count ++ fileStr += str } fmt.Println(fileStr) } 通过ioutil读取 文件大小比较小的时候，可以通过ioutil来读取文件 // 通过 ioutil 读取 byteStr, _ := ioutil.ReadFile(\"./main/test.txt\") fmt.Println(string(byteStr)) 文件的写入 文件的写入，我们首先需要通过 os.OpenFile 打开文件 // 打开文件 file, _ := os.OpenFile(\"./main/test.txt\", os.O_CREATE | os.O_RDWR, 777) 这里有三个参数 name：要打开的文件名 flag：打开文件的模式 os.O_WRONLY：只读 os.O_CREATE：创建 os.O_RDONLY：只读 os.O_RDWR：读写 os.O_TRUNC：清空 os.O_APPEND：追加 perm：文件权限，一个八进制数，r（读）04，w（写）02，x（执行）01 通过OpenFile打开文件写入 package main import ( \"fmt\" \"os\" ) func main() { // 打开文件 file, err := os.OpenFile(\"./test.txt\", os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666) if err != nil { fmt.Println(err) return } defer file.Close() str := \"啦啦啦 \\r\\n\" for i := 0; i 通过bufio写入 package main import ( \"bufio\" \"os\" ) func main() { // 打开文件 file, _ := os.OpenFile(\"./test.txt\", os.O_CREATE|os.O_RDWR|os.O_APPEND, 777) defer file.Close() str := \"啦啦啦 \\r\\n\" file.WriteString(str) // 通过bufio写入 writer := bufio.NewWriter(file) // 先将数据写入缓存 writer.WriteString(\"你好，我是通过writer写入的 \\r\\n\") // 将缓存中的内容写入文件 writer.Flush() } 通过ioutil写入 package main import \"io/ioutil\" func main() { // 第三种方式，通过ioutil str2 := \"hello\" ioutil.WriteFile(\"./test.txt\", []byte(str2), 777) } 文件复制 通过ioutil读取和复制文件 // 读取文件 byteStr, err := ioutil.ReadFile(\"./main/test.txt\") if err != nil { fmt.Println(\"读取文件出错\") return } // 写入指定的文件 ioutil.WriteFile(\"./main/test2.txt\", byteStr, 777) 大文件通过文件流复制文件 package main import ( \"io\" \"os\" ) func CopyFile(srcFileName string, dstFileName string) (err error) { sFile, err1 := os.Open(srcFileName) dFile, err2 := os.OpenFile(dstFileName, os.O_CREATE|os.O_WRONLY, 0666) defer sFile.Close() defer dFile.Close() if err1 != nil { return err1 } if err2 != nil { return err2 } var tmpSlice = make([]byte, 128) for { n1, e1 := sFile.Read(tmpSlice) if err == io.EOF { break } if e1 != nil { return e1 } if _, err := dFile.Write(tmpSlice[:n1]); err != nil { return err } } return nil } func main() { // 读取文件 srcFile := \"./test.txt\" dstFile := \"C:/Users/lenovo/Desktop/test.txt\" CopyFile(srcFile, dstFile) } 创建目录 package main import ( \"fmt\" \"os\" ) func main() { err1 := os.Mkdir(\"./abc\", 777) if err1 != nil { fmt.Println(err1) } err2 := os.MkdirAll(\"./efg/abc/hij\", 777) //创建多级目录 if err2 != nil { fmt.Println(err2) } } 删除操作 package main import ( \"fmt\" \"os\" ) func main() { // 删除文件 os.Remove(\"./test.txt\") err1 := os.Remove(\"./abc\") // 删除目录 if err1 != nil { fmt.Println(err1) } err2 := os.RemoveAll(\"./efg\") //删除多个文件和目录 if err2 != nil { fmt.Println(err2) } } 重命名 package main import ( \"os\" ) func main() { os.Rename(\"./test.txt\", \"11.txt\") } "},"GoLang/7daysGoLang/":{"url":"GoLang/7daysGoLang/","title":"目录","keywords":"","body":"datetime:2022-01-02 16:40:30 author:nzb 7 days golang programs from scratch 基于该项目【7天用Go动手写/从零实现系列】所写 7天用Go从零实现系列 7天能写什么呢？类似 gin 的 web 框架？类似 groupcache 的分布式缓存？或者一个简单的 Python 解释器？希望这个仓库能给你答案。 推荐先阅读 Go 语言基础，一篇文章了解Go的基本语法、并发编程，依赖管理等内容。 推荐 Go 语言笔试面试题，加深对 Go 语言的理解。 推荐 Go 语言高性能编程(项目地址)，写出高性能的 Go 代码。 7天用Go从零实现Web框架 - Gee Gee 是一个模仿 gin 实现的 Web 框架，Go Gin简明教程可以快速入门。 第一天：前置知识(http.Handler接口) | Code - Github 第二天：上下文设计(Context) | Code - Github 第三天：Trie树路由(Router) | Code - Github 第四天：分组控制(Group) | Code - Github 第五天：中间件(Middleware) | Code - Github 第六天：HTML模板(Template) | Code - Github 第七天：错误恢复(Panic Recover) | Code - Github 7天用Go从零实现分布式缓存 GeeCache GeeCache 是一个模仿 groupcache 实现的分布式缓存系统 第一天：LRU 缓存淘汰策略 | Code 第二天：单机并发缓存 | Code 第三天：HTTP 服务端 | Code 第四天：一致性哈希(Hash) | Code 第五天：分布式节点 | Code 第六天：防止缓存击穿 | Code 第七天：使用 Protobuf 通信 | Code 7天用Go从零实现ORM框架 GeeORM GeeORM 是一个模仿 gorm 和 xorm 的 ORM 框架 gorm 准备推出完全重写的 v2 版本(目前还在开发中)，相对 gorm-v1 来说，xorm 的设计更容易理解，所以 geeorm 接口设计上主要参考了 xorm，一些细节实现上参考了 gorm。 第一天：database/sql 基础 | Code 第二天：对象表结构映射 | Code 第三天：记录新增和查询 | Code 第四天：链式操作与更新删除 | Code 第五天：实现钩子(Hooks) | Code 第六天：支持事务(Transaction) | Code 第七天：数据库迁移(Migrate) | Code 7天用Go从零实现RPC框架 GeeRPC GeeRPC 是一个基于 net/rpc 开发的 RPC 框架 GeeRPC 是基于 Go 语言标准库 net/rpc 实现的，添加了协议交换、服务注册与发现、负载均衡等功能，代码约 1k。 第一天 - 服务端与消息编码 | Code 第二天 - 支持并发与异步的客户端 | Code 第三天 - 服务注册(service register) | Code 第四天 - 超时处理(timeout) | Code 第五天 - 支持HTTP协议 | Code 第六天 - 负载均衡(load balance) | Code 第七天 - 服务发现与注册中心(registry) | Code WebAssembly 使用示例 具体的实践过程记录在 Go WebAssembly 简明教程。 示例一：Hello World | Code 示例二：注册函数 | Code 示例三：操作 DOM | Code 示例四：回调函数 | Code README 英文版本 What can be accomplished in 7 days? A gin-like web framework? A distributed cache like groupcache? Or a simple Python interpreter? Hope this repo can give you the answer. ## Web Framework - Gee [Gee](https://geektutu.com/post/gee.html) is a [gin](https://github.com/gin-gonic/gin)-like framework - Day 1 - http.Handler Interface Basic [Code](gee-web/day1-http-base) - Day 2 - Design a Flexiable Context [Code](gee-web/day2-context) - Day 3 - Router with Trie-Tree Algorithm [Code](gee-web/day3-router) - Day 4 - Group Control [Code](gee-web/day4-group) - Day 5 - Middleware Mechanism [Code](gee-web/day5-middleware) - Day 6 - Embeded Template Support [Code](gee-web/day6-template) - Day 7 - Panic Recover & Make it Robust [Code](gee-web/day7-panic-recover) ## Distributed Cache - GeeCache [GeeCache](https://geektutu.com/post/geecache.html) is a [groupcache](https://github.com/golang/groupcache)-like distributed cache - Day 1 - LRU (Least Recently Used) Caching Strategy [Code](gee-cache/day1-lru) - Day 2 - Single Machine Concurrent Cache [Code](gee-cache/day2-single-node) - Day 3 - Launch a HTTP Server [Code](gee-cache/day3-http-server) - Day 4 - Consistent Hash Algorithm [Code](gee-cache/day4-consistent-hash) - Day 5 - Communication between Distributed Nodes [Code](gee-cache/day5-multi-nodes) - Day 6 - Cache Breakdown & Single Flight | [Code](gee-cache/day6-single-flight) - Day 7 - Use Protobuf as RPC Data Exchange Type | [Code](gee-cache/day7-proto-buf) ## Object Relational Mapping - GeeORM [GeeORM](https://geektutu.com/post/geeorm.html) is a [gorm](https://github.com/jinzhu/gorm)-like and [xorm](https://github.com/go-xorm/xorm)-like object relational mapping library Xorm's desgin is easier to understand than gorm-v1, so the main designs references xorm and some detailed implementions references gorm-v1. - Day 1 - database/sql Basic | [Code](gee-orm/day1-database-sql) - Day 2 - Object Schame Mapping | [Code](gee-orm/day2-reflect-schema) - Day 3 - Insert and Query | [Code](gee-orm/day3-save-query) - Day 4 - Chain, Delete and Update | [Code](gee-orm/day4-chain-operation) - Day 5 - Support Hooks | [Code](gee-orm/day5-hooks) - Day 6 - Support Transaction | [Code](gee-orm/day6-transaction) - Day 7 - Migrate Database | [Code](gee-orm/day7-migrate) ## RPC Framework - GeeRPC [GeeRPC](https://geektutu.com/post/geerpc.html) is a [net/rpc](https://github.com/golang/go/tree/master/src/net/rpc)-like RPC framework Based on golang standard library `net/rpc`, GeeRPC implements more features. eg, protocol exchange, service registration and discovery, load balance, etc. - Day 1 - Server Message Codec | [Code](gee-rpc/day1-codec) - Day 2 - Concurrent Client | [Code](gee-rpc/day2-client) - Day 3 - Service Register | [Code](gee-rpc/day3-service ) - Day 4 - Timeout Processing | [Code](gee-rpc/day4-timeout ) - Day 5 - Support HTTP Protocol | [Code](gee-rpc/day5-http-debug) - Day 6 - Load Balance | [Code](gee-rpc/day6-load-balance) - Day 7 - Discovery and Registry | [Code](gee-rpc/day7-registry) ## Golang WebAssembly Demo - Demo 1 - Hello World [Code](demo-wasm/hello-world) - Demo 2 - Register Functions [Code](demo-wasm/register-functions) - Demo 3 - Manipulate DOM [Code](demo-wasm/manipulate-dom) - Demo 4 - Callback [Code](demo-wasm/callback) "},"GoLang/7daysGoLang/gee-web/doc/gee-day1.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day1.html","title":"前置知识(http.Handler接口)","keywords":"","body":"datetime:2022/02/05 16:52 author:nzb Go语言动手写Web框架 - Gee第一天 http.Handler 本文是7天用Go从零实现Web框架Gee教程系列的第一篇。 简单介绍net/http库以及http.Handler接口。 搭建Gee框架的雏形，代码约50行。 标准库启动Web服务 Go语言内置了 net/http库，封装了HTTP网络编程的基础的接口，我们实现的Gee Web 框架便是基于net/http的。我们接下来通过一个例子，简单介绍下这个库的使用。 day1-http-base/base1/main.go package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", indexHandler) http.HandleFunc(\"/hello\", helloHandler) log.Fatal(http.ListenAndServe(\":9999\", nil)) } // handler echoes r.URL.Path func indexHandler(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path) } // handler echoes r.URL.Header func helloHandler(w http.ResponseWriter, req *http.Request) { for k, v := range req.Header { fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) } } 我们设置了2个路由，/和/hello，分别绑定 indexHandler 和 helloHandler ， 根据不同的HTTP请求会调用不同的处理函数。访问/，响应是URL.Path = /，而/hello的响应则是请求头(header)中的键值对信息。 用 curl 这个工具测试一下，将会得到如下的结果。 $ curl http://localhost:9999/ URL.Path = \"/\" $ curl http://localhost:9999/hello Header[\"Accept\"] = [\"*/*\"] Header[\"User-Agent\"] = [\"curl/7.54.0\"] main 函数的最后一行，是用来启动 Web 服务的，第一个参数是地址，:9999表示在 9999 端口监听。而第二个参数则代表处理所有的HTTP请求的实例，nil 代表使用标准库中的实例处理。第二个参数，则是我们基于net/http标准库实现Web框架的入口。 实现http.Handler接口 package http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } func ListenAndServe(address string, h Handler) error 第二个参数的类型是什么呢？通过查看net/http的源码可以发现，Handler是一个接口，需要实现方法 ServeHTTP ，也就是说，只要传入任何实现了 ServerHTTP 接口的实例，所有的HTTP请求，就都交给了该实例处理了。马上来试一试吧。 day1-http-base/base2/main.go package main import ( \"fmt\" \"log\" \"net/http\" ) // Engine is the uni handler for all requests type Engine struct{} func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { switch req.URL.Path { case \"/\": fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path) case \"/hello\": for k, v := range req.Header { fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) } default: fmt.Fprintf(w, \"404 NOT FOUND: %s\\n\", req.URL) } } func main() { engine := new(Engine) log.Fatal(http.ListenAndServe(\":9999\", engine)) } 我们定义了一个空的结构体Engine，实现了方法ServeHTTP。这个方法有2个参数，第二个参数是 Request ，该对象包含了该HTTP请求的所有的信息，比如请求地址、Header和Body等信息；第一个参数是 ResponseWriter ，利用 ResponseWriter 可以构造针对该请求的响应。 在 main 函数中，我们给 ListenAndServe 方法的第二个参数传入了刚才创建的engine实例。至此，我们走出了实现Web框架的第一步，即，将所有的HTTP请求转向了我们自己的处理逻辑。还记得吗，在实现Engine之前，我们调用 http.HandleFunc 实现了路由和Handler的映射，也就是只能针对具体的路由写处理逻辑。比如/hello。但是在实现Engine之后，我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。 代码的运行结果与之前的是一致的。 Gee框架的雏形 我们接下来重新组织上面的代码，搭建出整个框架的雏形。 最终的代码目录结构是这样的。 gee/ |--gee.go |--go.mod main.go go.mod go.mod day1-http-base/base3/go.mod module example go 1.13 require gee v0.0.0 replace gee => ./gee 在 go.mod 中使用 replace 将 gee 指向 ./gee 从 go 1.11 版本开始，引用相对路径的 package 需要使用上述方式。 main.go day1-http-base/base3/main.go package main import ( \"fmt\" \"net/http\" \"gee\" ) func main() { r := gee.New() r.GET(\"/\", func(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, \"URL.Path = %q\\n\", req.URL.Path) }) r.GET(\"/hello\", func(w http.ResponseWriter, req *http.Request) { for k, v := range req.Header { fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) } }) r.Run(\":9999\") } 看到这里，如果你使用过gin框架的话，肯定会觉得无比的亲切。gee框架的设计以及API均参考了gin。使用New()创建 gee 的实例，使用 GET()方法添加路由，最后使用Run()启动Web服务。这里的路由，只是静态路由，不支持/hello/:name这样的动态路由，动态路由我们将在下一次实现。 gee.go day1-http-base/base3/gee/gee.go package gee import ( \"fmt\" \"net/http\" ) // HandlerFunc defines the request handler used by gee type HandlerFunc func(http.ResponseWriter, *http.Request) // Engine implement the interface of ServeHTTP type Engine struct { router map[string]HandlerFunc } // New is the constructor of gee.Engine func New() *Engine { return &Engine{router: make(map[string]HandlerFunc)} } func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) { key := method + \"-\" + pattern engine.router[key] = handler } // GET defines the method to add GET request func (engine *Engine) GET(pattern string, handler HandlerFunc) { engine.addRoute(\"GET\", pattern, handler) } // POST defines the method to add POST request func (engine *Engine) POST(pattern string, handler HandlerFunc) { engine.addRoute(\"POST\", pattern, handler) } // Run defines the method to start a http server func (engine *Engine) Run(addr string) (err error) { return http.ListenAndServe(addr, engine) } func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { key := req.Method + \"-\" + req.URL.Path if handler, ok := engine.router[key]; ok { handler(w, req) } else { fmt.Fprintf(w, \"404 NOT FOUND: %s\\n\", req.URL) } } 那么gee.go就是重头戏了。我们重点介绍一下这部分的实现。 首先定义了类型HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法。我们在Engine中，添加了一张路由映射表router，key 由请求方法和静态路由地址构成，例如GET-/、GET-/hello、POST-/hello，这样针对相同的路由，如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。 当用户调用(*Engine).GET()方法时，会将路由和处理方法注册到映射表 router 中，(*Engine).Run()方法，是 ListenAndServe 的包装。 Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND 。 执行go run main.go，再用 curl 工具访问，结果与最开始的一致。 $ curl http://localhost:9999/ URL.Path = \"/\" $ curl http://localhost:9999/hello Header[\"Accept\"] = [\"*/*\"] Header[\"User-Agent\"] = [\"curl/7.54.0\"] curl http://localhost:9999/world 404 NOT FOUND: /world 至此，整个Gee框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。当然，到目前为止，我们还没有实现比net/http标准库更强大的能力，不用担心，很快就可以将动态路由、中间件等功能添加上去了。 "},"GoLang/7daysGoLang/gee-web/doc/gee-day2.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day2.html","title":"上下文设计(Context)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第二天 上下文Context 本文是 7天用Go从零实现Web框架Gee教程系列的第二篇。 将路由(router)独立出来，方便之后增强。 设计上下文(Context)，封装 Request 和 Response ，提供对 JSON、HTML 等返回类型的支持。 动手写 Gee 框架的第二天，框架代码140行，新增代码约90行 使用效果 为了展示第二天的成果，我们看一看在使用时的效果。 day2-context/main.go func main() { r := gee.New() r.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Hello Gee\") }) r.GET(\"/hello\", func(c *gee.Context) { // expect /hello?name=geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) r.POST(\"/login\", func(c *gee.Context) { c.JSON(http.StatusOK, gee.H{ \"username\": c.PostForm(\"username\"), \"password\": c.PostForm(\"password\"), }) }) r.Run(\":9999\") } Handler的参数变成成了gee.Context，提供了查询Query/PostForm参数的功能。 gee.Context封装了HTML/String/JSON函数，能够快速构造HTTP响应。 设计Context 必要性 对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。 用返回 JSON 数据作比较，感受下封装前后的差距。 封装前 obj = map[string]interface{}{ \"name\": \"geektutu\", \"password\": \"1234\", } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) encoder := json.NewEncoder(w) if err := encoder.Encode(obj); err != nil { http.Error(w, err.Error(), 500) } VS 封装后： c.JSON(http.StatusOK, gee.H{ \"username\": c.PostForm(\"username\"), \"password\": c.PostForm(\"password\"), }) 针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。 具体实现 day2-context/gee/context.go type H map[string]interface{} type Context struct { // origin objects Writer http.ResponseWriter Req *http.Request // request info Path string Method string // response info StatusCode int } func newContext(w http.ResponseWriter, req *http.Request) *Context { return &Context{ Writer: w, Req: req, Path: req.URL.Path, Method: req.Method, } } func (c *Context) PostForm(key string) string { return c.Req.FormValue(key) } func (c *Context) Query(key string) string { return c.Req.URL.Query().Get(key) } func (c *Context) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code) } func (c *Context) SetHeader(key string, value string) { c.Writer.Header().Set(key, value) } func (c *Context) String(code int, format string, values ...interface{}) { c.SetHeader(\"Content-Type\", \"text/plain\") c.Status(code) c.Writer.Write([]byte(fmt.Sprintf(format, values...))) } func (c *Context) JSON(code int, obj interface{}) { c.SetHeader(\"Content-Type\", \"application/json\") c.Status(code) encoder := json.NewEncoder(c.Writer) if err := encoder.Encode(obj); err != nil { http.Error(c.Writer, err.Error(), 500) } } func (c *Context) Data(code int, data []byte) { c.Status(code) c.Writer.Write(data) } func (c *Context) HTML(code int, html string) { c.SetHeader(\"Content-Type\", \"text/html\") c.Status(code) c.Writer.Write([]byte(html)) } 代码最开头，给map[string]interface{}起了一个别名gee.H，构建JSON数据时，显得更简洁。 Context目前只包含了http.ResponseWriter和*http.Request，另外提供了对 Method 和 Path 这两个常用属性的直接访问。 提供了访问Query和PostForm参数的方法。 提供了快速构造String/Data/JSON/HTML响应的方法。 路由(Router) 我们将和路由相关的方法和结构提取了出来，放到了一个新的文件中router.go，方便我们下一次对 router 的功能进行增强，例如提供动态路由的支持。 router 的 handle 方法作了一个细微的调整，即 handler 的参数，变成了 Context。 day2-context/gee/router.go type router struct { handlers map[string]HandlerFunc } func newRouter() *router { return &router{handlers: make(map[string]HandlerFunc)} } func (r *router) addRoute(method string, pattern string, handler HandlerFunc) { log.Printf(\"Route %4s - %s\", method, pattern) key := method + \"-\" + pattern r.handlers[key] = handler } func (r *router) handle(c *Context) { key := c.Method + \"-\" + c.Path if handler, ok := r.handlers[key]; ok { handler(c) } else { c.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", c.Path) } } 框架入口 day2-context/gee/gee.go // HandlerFunc defines the request handler used by gee type HandlerFunc func(*Context) // Engine implement the interface of ServeHTTP type Engine struct { router *router } // New is the constructor of gee.Engine func New() *Engine { return &Engine{router: newRouter()} } func (engine *Engine) addRoute(method string, pattern string, handler HandlerFunc) { engine.router.addRoute(method, pattern, handler) } // GET defines the method to add GET request func (engine *Engine) GET(pattern string, handler HandlerFunc) { engine.addRoute(\"GET\", pattern, handler) } // POST defines the method to add POST request func (engine *Engine) POST(pattern string, handler HandlerFunc) { engine.addRoute(\"POST\", pattern, handler) } // Run defines the method to start a http server func (engine *Engine) Run(addr string) (err error) { return http.ListenAndServe(addr, engine) } func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := newContext(w, req) engine.router.handle(c) } 将router相关的代码独立后，gee.go简单了不少。最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。相比第一天的代码，这个方法也有细微的调整，在调用 router.handle 之前，构造了一个 Context 对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context插上翅膀。 如何使用，main.go一开始就已经亮相了。运行go run main.go，借助 curl ，一起看一看今天的成果吧。 $ curl -i http://localhost:9999/ HTTP/1.1 200 OK Date: Mon, 12 Aug 2019 16:52:52 GMT Content-Length: 18 Content-Type: text/html; charset=utf-8 Hello Gee $ curl \"http://localhost:9999/hello?name=geektutu\" hello geektutu, you're at /hello $ curl \"http://localhost:9999/login\" -X POST -d 'username=geektutu&password=1234' {\"password\":\"1234\",\"username\":\"geektutu\"} $ curl \"http://localhost:9999/xxx\" 404 NOT FOUND: /xxx "},"GoLang/7daysGoLang/gee-web/doc/gee-day3.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day3.html","title":"Trie树路由(Router)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第三天 前缀树路由Router 本文是 7天用Go从零实现Web框架Gee教程系列的第三篇。 使用 Trie 树实现动态路由(dynamic route)解析。 支持两种模式:name和*filepath，代码约150行。 Trie 树简介 之前，我们用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。那如果我们想支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。例如/hello/:name，可以匹配/hello/geektutu、hello/jack等。 动态路由有很多种实现方式，支持的规则、性能等有很大的差异。例如开源的路由实现gorouter支持在路由规则中嵌入正则表达式，例如/p/[0-9A-Za-z]+，即路径中的参数仅匹配数字和字母；另一个开源实现httprouter就不支持正则表达式。著名的Web开源框架gin 在早期的版本，并没有实现自己的路由，而是直接使用了httprouter，后来不知道什么原因，放弃了httprouter，自己实现了一个版本。 实现动态路由最常用的数据结构，被称为前缀树(Trie树)。看到名字你大概也能知道前缀树长啥样了：每一个节点的所有的子节点都拥有相同的前缀。这种结构非常适用于路由匹配，比如我们定义了如下路由规则： /:lang/doc /:lang/tutorial /:lang/intro /about /p/blog /p/related 我们用前缀树来表示，是这样的。 HTTP请求的路径恰好是由/分隔的多段构成的，因此，每一段可以作为前缀树的一个节点。我们通过树结构查询，如果中间某一层的节点都不满足条件，那么就说明没有匹配到的路由，查询结束。 接下来我们实现的动态路由具备以下两个功能。 参数匹配:。例如 /p/:lang/doc，可以匹配 /p/c/doc 和 /p/go/doc。 通配*。例如 /static/*filepath，可以匹配/static/fav.ico，也可以匹配/static/js/jQuery.js，这种模式常用于静态服务器，能够递归地匹配子路径。 Trie 树实现 首先我们需要设计树节点上应该存储那些信息。 day3-router/gee/trie.go type node struct { pattern string // 待匹配路由，例如 /p/:lang part string // 路由中的一部分，例如 :lang children []*node // 子节点，例如 [doc, tutorial, intro] isWild bool // 是否精确匹配，part 含有 : 或 * 时为true } 与普通的树不同，为了实现动态路由匹配，加上了isWild这个参数。即当我们匹配 /p/go/doc/这个路由时，第一层节点，p精准匹配到了p，第二层节点，go模糊匹配到:lang，那么将会把lang这个参数赋值为go，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。 // 第一个匹配成功的节点，用于插入 func (n *node) matchChild(part string) *node { for _, child := range n.children { if child.part == part || child.isWild { return child } } return nil } // 所有匹配成功的节点，用于查找 func (n *node) matchChildren(part string) []*node { nodes := make([]*node, 0) for _, child := range n.children { if child.part == part || child.isWild { nodes = append(nodes, child) } } return nodes } 对于路由来说，最重要的当然是注册与匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie 树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个，有一点需要注意，/p/:lang/doc只有在第三层节点，即doc节点，pattern才会设置为/p/:lang/doc。p和:lang节点的pattern属性皆为空。因此，当匹配结束时，我们可以使用n.pattern == \"\"来判断路由规则是否匹配成功。例如，/p/python虽能成功匹配到:lang，但:lang的pattern值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了*，匹配失败，或者匹配到了第len(parts)层节点。 func (n *node) insert(pattern string, parts []string, height int) { if len(parts) == height { n.pattern = pattern return } part := parts[height] child := n.matchChild(part) if child == nil { child = &node{part: part, isWild: part[0] == ':' || part[0] == '*'} n.children = append(n.children, child) } child.insert(pattern, parts, height+1) } func (n *node) search(parts []string, height int) *node { if len(parts) == height || strings.HasPrefix(n.part, \"*\") { if n.pattern == \"\" { return nil } return n } part := parts[height] children := n.matchChildren(part) for _, child := range children { result := child.search(parts, height+1) if result != nil { return result } } return nil } Router Trie 树的插入与查找都成功实现了，接下来我们将 Trie 树应用到路由中去吧。我们使用 roots 来存储每种请求方式的Trie 树根节点。使用 handlers 存储每种请求方式的 HandlerFunc 。getRoute 函数中，还解析了:和*两种匹配符的参数，返回一个 map 。例如/p/go/doc匹配到/p/:lang/doc，解析结果为：{lang: \"go\"}，/static/css/geektutu.css匹配到/static/*filepath，解析结果为{filepath: \"css/geektutu.css\"}。 day3-router/gee/router.go type router struct { roots map[string]*node handlers map[string]HandlerFunc } // roots key eg, roots['GET'] roots['POST'] // handlers key eg, handlers['GET-/p/:lang/doc'], handlers['POST-/p/book'] func newRouter() *router { return &router{ roots: make(map[string]*node), handlers: make(map[string]HandlerFunc), } } // Only one * is allowed func parsePattern(pattern string) []string { vs := strings.Split(pattern, \"/\") parts := make([]string, 0) for _, item := range vs { if item != \"\" { parts = append(parts, item) if item[0] == '*' { break } } } return parts } func (r *router) addRoute(method string, pattern string, handler HandlerFunc) { parts := parsePattern(pattern) key := method + \"-\" + pattern _, ok := r.roots[method] if !ok { r.roots[method] = &node{} } r.roots[method].insert(pattern, parts, 0) r.handlers[key] = handler } func (r *router) getRoute(method string, path string) (*node, map[string]string) { searchParts := parsePattern(path) params := make(map[string]string) root, ok := r.roots[method] if !ok { return nil, nil } n := root.search(searchParts, 0) if n != nil { parts := parsePattern(n.pattern) for index, part := range parts { if part[0] == ':' { params[part[1:]] = searchParts[index] } if part[0] == '*' && len(part) > 1 { params[part[1:]] = strings.Join(searchParts[index:], \"/\") break } } return n, params } return nil, nil } Context与handle的变化 在 HandlerFunc 中，希望能够访问到解析的参数，因此，需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到Params中，通过c.Param(\"lang\")的方式获取到对应的值。 day3-router/gee/context.go type Context struct { // origin objects Writer http.ResponseWriter Req *http.Request // request info Path string Method string Params map[string]string // response info StatusCode int } func (c *Context) Param(key string) string { value, _ := c.Params[key] return value } day3-router/gee/router.go func (r *router) handle(c *Context) { n, params := r.getRoute(c.Method, c.Path) if n != nil { c.Params = params key := c.Method + \"-\" + n.pattern r.handlers[key](c) } else { c.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", c.Path) } } router.go的变化比较小，比较重要的一点是，在调用匹配到的handler前，将解析出来的路由参数赋值给了c.Params。这样就能够在handler中，通过Context对象访问到具体的值了。 单元测试 func newTestRouter() *router { r := newRouter() r.addRoute(\"GET\", \"/\", nil) r.addRoute(\"GET\", \"/hello/:name\", nil) r.addRoute(\"GET\", \"/hello/b/c\", nil) r.addRoute(\"GET\", \"/hi/:name\", nil) r.addRoute(\"GET\", \"/assets/*filepath\", nil) return r } func TestParsePattern(t *testing.T) { ok := reflect.DeepEqual(parsePattern(\"/p/:name\"), []string{\"p\", \":name\"}) ok = ok && reflect.DeepEqual(parsePattern(\"/p/*\"), []string{\"p\", \"*\"}) ok = ok && reflect.DeepEqual(parsePattern(\"/p/*name/*\"), []string{\"p\", \"*name\"}) if !ok { t.Fatal(\"test parsePattern failed\") } } func TestGetRoute(t *testing.T) { r := newTestRouter() n, ps := r.getRoute(\"GET\", \"/hello/geektutu\") if n == nil { t.Fatal(\"nil shouldn't be returned\") } if n.pattern != \"/hello/:name\" { t.Fatal(\"should match /hello/:name\") } if ps[\"name\"] != \"geektutu\" { t.Fatal(\"name should be equal to 'geektutu'\") } fmt.Printf(\"matched path: %s, params['name']: %s\\n\", n.pattern, ps[\"name\"]) } 使用Demo 看看框架使用的样例吧。 day3-router/main.go func main() { r := gee.New() r.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Hello Gee\") }) r.GET(\"/hello\", func(c *gee.Context) { // expect /hello?name=geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) r.GET(\"/hello/:name\", func(c *gee.Context) { // expect /hello/geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Param(\"name\"), c.Path) }) r.GET(\"/assets/*filepath\", func(c *gee.Context) { c.JSON(http.StatusOK, gee.H{\"filepath\": c.Param(\"filepath\")}) }) r.Run(\":9999\") } 使用curl工具，测试结果。 $ curl \"http://localhost:9999/hello/geektutu\" hello geektutu, you're at /hello/geektutu $ curl \"http://localhost:9999/assets/css/geektutu.css\" {\"filepath\":\"css/geektutu.css\"} "},"GoLang/7daysGoLang/gee-web/doc/gee-day4.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day4.html","title":"分组控制(Group)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第四天 分组控制Group 本文是 7天用Go从零实现Web框架Gee教程系列的第四篇。 实现路由分组控制(Route Group Control)，代码约50行 分组的意义 分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如： 以/post开头的路由匿名可访问。 以/admin开头的路由需要鉴权。 以/api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。 大部分情况下的路由分组，是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如/post是一个分组，/post/a和/post/b可以是该分组下的子分组。作用在/post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。 中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如/admin的分组，可以应用鉴权中间件；/分组应用日志中间件，/是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。 提供扩展能力支持中间件的内容，我们将在下一节当中介绍。 分组嵌套 一个 Group 对象需要具备哪些属性呢？首先是前缀(prefix)，比如/，或者/api；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数(*Engine).addRoute()来映射所有的路由规则和 Handler 。如果Group对象需要直接映射路由规则的话，比如我们想在使用框架时，这么调用： r := gee.New() v1 := r.Group(\"/v1\") v1.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Hello Gee\") }) 那么Group对象，还需要有访问Router的能力，为了方便，我们可以在Group中，保存一个指针，指向Engine，整个框架的所有资源都是由Engine统一协调的，那么就可以通过Engine间接地访问各种接口了。 所以，最后的 Group 的定义是这样的： day4-group/gee/gee.go RouterGroup struct { prefix string middlewares []HandlerFunc // support middleware parent *RouterGroup // support nesting engine *Engine // all groups share a Engine instance } 我们还可以进一步地抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup所有的能力。 Engine struct { *RouterGroup router *router groups []*RouterGroup // store all groups } 那我们就可以将和路由有关的函数，都交给RouterGroup实现了。 // New is the constructor of gee.Engine func New() *Engine { engine := &Engine{router: newRouter()} engine.RouterGroup = &RouterGroup{engine: engine} engine.groups = []*RouterGroup{engine.RouterGroup} return engine } // Group is defined to create a new RouterGroup // remember all groups share the same Engine instance func (group *RouterGroup) Group(prefix string) *RouterGroup { engine := group.engine newGroup := &RouterGroup{ prefix: group.prefix + prefix, parent: group, engine: engine, } engine.groups = append(engine.groups, newGroup) return newGroup } func (group *RouterGroup) addRoute(method string, comp string, handler HandlerFunc) { pattern := group.prefix + comp log.Printf(\"Route %4s - %s\", method, pattern) group.engine.router.addRoute(method, pattern, handler) } // GET defines the method to add GET request func (group *RouterGroup) GET(pattern string, handler HandlerFunc) { group.addRoute(\"GET\", pattern, handler) } // POST defines the method to add POST request func (group *RouterGroup) POST(pattern string, handler HandlerFunc) { group.addRoute(\"POST\", pattern, handler) } 可以仔细观察下addRoute函数，调用了group.engine.router.addRoute来实现了路由的映射。由于Engine从某种意义上继承了RouterGroup的所有属性和方法，因为 (*Engine).engine 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。 使用 Demo 测试框架的Demo就可以这样写了： func main() { r := gee.New() r.GET(\"/index\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Index Page\") }) v1 := r.Group(\"/v1\") { v1.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Hello Gee\") }) v1.GET(\"/hello\", func(c *gee.Context) { // expect /hello?name=geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Query(\"name\"), c.Path) }) } v2 := r.Group(\"/v2\") { v2.GET(\"/hello/:name\", func(c *gee.Context) { // expect /hello/geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Param(\"name\"), c.Path) }) v2.POST(\"/login\", func(c *gee.Context) { c.JSON(http.StatusOK, gee.H{ \"username\": c.PostForm(\"username\"), \"password\": c.PostForm(\"password\"), }) }) } r.Run(\":9999\") } 通过 curl 简单测试： $ curl \"http://localhost:9999/v1/hello?name=geektutu\" hello geektutu, you're at /v1/hello $ curl \"http://localhost:9999/v2/hello/geektutu\" hello geektutu, you're at /hello/geektutu "},"GoLang/7daysGoLang/gee-web/doc/gee-day5.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day5.html","title":"中间件(Middleware)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第五天 中间件Middleware 本文是7天用Go从零实现Web框架Gee教程系列的第五篇。 设计并实现 Web 框架的中间件(Middlewares)机制。 实现通用的Logger中间件，能够记录请求到响应所花费的时间，代码约50行 中间件是什么 中间件(middlewares)，简单说，就是非业务的技术类组件。Web 框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点： 插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。 中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。 那对于一个 Web 框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了 Gin 框架。 中间件设计 Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是Context对象。插入点是框架接收到请求初始化Context对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对Context进行二次加工。另外通过调用(*Context).Next()函数，中间件可等待用户自己定义的 Handler处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，c.Next()表示等待执行其他的中间件或用户的Handler： day5-middleware/gee/logger.go func Logger() HandlerFunc { return func(c *Context) { // Start timer t := time.Now() // Process request c.Next() // Calculate resolution time log.Printf(\"[%d] %s in %v\", c.StatusCode, c.Req.RequestURI, time.Since(t)) } } 另外，支持设置多个中间件，依次进行调用。 我们上一篇文章分组控制 Group Control中讲到，中间件是应用在RouterGroup上的，应用在最顶层的 Group，相当于作用于全局，所有的请求都会被中间件处理。那为什么不作用在每一条路由规则上呢？作用在某条路由规则，那还不如用户直接在 Handler 中调用直观。只作用在某条路由规则的功能通用性太差，不适合定义为中间件。 我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在Context中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在Context中，依次进行调用。为什么依次调用后，还需要在Context中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的 Handler 处理完毕后，还可以执行剩下的操作。 为此，我们给Context添加了2个参数，定义了Next方法： day5-middleware/gee/context.go type Context struct { // origin objects Writer http.ResponseWriter Req *http.Request // request info Path string Method string Params map[string]string // response info StatusCode int // middleware handlers []HandlerFunc index int } func newContext(w http.ResponseWriter, req *http.Request) *Context { return &Context{ Path: req.URL.Path, Method: req.Method, Req: req, Writer: w, index: -1, } } func (c *Context) Next() { c.index++ s := len(c.handlers) for ; c.index index是记录当前执行到第几个中间件，当在中间件中调用Next方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在Next方法之后定义的部分。如果我们将用户在映射路由时定义的Handler添加到c.handlers列表中，结果会怎么样呢？想必你已经猜到了。 func A(c *Context) { part1 c.Next() part2 } func B(c *Context) { part3 c.Next() part4 } 假设我们应用了中间件 A 和 B，和路由映射的 Handler。c.handlers是这样的[A, B, Handler]，c.index初始化为-1。调用c.Next()，接下来的流程是这样的： c.index++，c.index 变为 0 0 执行 part1，调用 c.Next() c.index++，c.index 变为 1 1 执行 part3，调用 c.Next() c.index++，c.index 变为 2 2 Handler 调用完毕，返回到 B 中的 part4，执行 part4 part4 执行完毕，返回到 A 中的 part2，执行 part2 part2 执行完毕，结束。 一句话说清楚重点，最终的顺序是part1 -> part3 -> Handler -> part 4 -> part2。恰恰满足了我们对中间件的要求，接下来看调用部分的代码，就能全部串起来了。 代码实现 定义Use函数，将中间件应用到某个 Group 。 day5-middleware/gee/gee.go // Use is defined to add middleware to the group func (group *RouterGroup) Use(middlewares ...HandlerFunc) { group.middlewares = append(group.middlewares, middlewares...) } func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { var middlewares []HandlerFunc for _, group := range engine.groups { if strings.HasPrefix(req.URL.Path, group.prefix) { middlewares = append(middlewares, group.middlewares...) } } c := newContext(w, req) c.handlers = middlewares engine.router.handle(c) } ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 c.handlers。 handle 函数中，将从路由匹配得到的 Handler 添加到 c.handlers列表中，执行c.Next()。 day5-middleware/gee/router.go func (r *router) handle(c *Context) { n, params := r.getRoute(c.Method, c.Path) if n != nil { key := c.Method + \"-\" + n.pattern c.Params = params c.handlers = append(c.handlers, r.handlers[key]) } else { c.handlers = append(c.handlers, func(c *Context) { c.String(http.StatusNotFound, \"404 NOT FOUND: %s\\n\", c.Path) }) } c.Next() } 使用 Demo func onlyForV2() gee.HandlerFunc { return func(c *gee.Context) { // Start timer t := time.Now() // if a server error occurred c.Fail(500, \"Internal Server Error\") // Calculate resolution time log.Printf(\"[%d] %s in %v for group v2\", c.StatusCode, c.Req.RequestURI, time.Since(t)) } } func main() { r := gee.New() r.Use(gee.Logger()) // global midlleware r.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"Hello Gee\") }) v2 := r.Group(\"/v2\") v2.Use(onlyForV2()) // v2 group middleware { v2.GET(\"/hello/:name\", func(c *gee.Context) { // expect /hello/geektutu c.String(http.StatusOK, \"hello %s, you're at %s\\n\", c.Param(\"name\"), c.Path) }) } r.Run(\":9999\") } gee.Logger()即我们一开始就介绍的中间件，我们将这个中间件和框架代码放在了一起，作为框架默认提供的中间件。在这个例子中，我们将gee.Logger()应用在了全局，所有的路由都会应用该中间件。onlyForV2()是用来测试功能的，仅在v2对应的 Group 中应用了。 接下来使用 curl 测试，可以看到，v2 Group 2个中间件都生效了。 $ curl http://localhost:9999/ >>> log 2019/08/17 01:37:38 [200] / in 3.14µs (2) global + group middleware $ curl http://localhost:9999/v2/hello/geektutu >>> log 2019/08/17 01:38:48 [200] /v2/hello/geektutu in 61.467µs for group v2 2019/08/17 01:38:48 [200] /v2/hello/geektutu in 281µs "},"GoLang/7daysGoLang/gee-web/doc/gee-day6.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day6.html","title":"HTML模板(Template)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第六天 模板(HTML Template) 本文是7天用Go从零实现Web框架Gee教程系列的第六篇。 实现静态资源服务(Static Resource)。 支持HTML模板渲染。 服务端渲染 现在越来越流行前后端分离的开发模式，即 Web 后端提供 RESTful 接口，返回结构化的数据(通常为 JSON 或者 XML)。前端使用 AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势非常突出。后端童鞋专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端童鞋专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。使用 JSP 写过网站的童鞋，应该能感受到前后端耦合的痛苦。JSP 的表现力肯定是远不如 Vue/React 等专业做前端渲染的框架的。而且前后端分离在当前还有另外一个不可忽视的优势。因为后端只关注于数据，接口返回值是结构化的，与前端解耦。同一套后端服务能够同时支撑小程序、移动APP、PC端 Web 页面，以及对外提供的接口。随着前端工程化的不断地发展，Webpack，gulp 等工具层出不穷，前端技术越来越自成体系了。 但前后分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好。Google 爬虫已经能够爬取渲染后的网页，但是短期内爬取服务端直接渲染的 HTML 页面仍是主流。 今天的内容便是介绍 Web 框架如何支持服务端渲染的场景。 静态文件(Serve Static Files) 网页的三剑客，JavaScript、CSS 和 HTML。要做到服务端渲染，第一步便是要支持 JS、CSS 等静态文件。还记得我们之前设计动态路由的时候，支持通配符*匹配多级子路径。比如路由规则/assets/*filepath，可以匹配/assets/开头的所有的地址。例如/assets/js/geektutu.js，匹配后，参数filepath就赋值为js/geektutu.js。 那如果我么将所有的静态文件放在/usr/web目录下，那么filepath的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。 找到文件后，如何返回这一步，net/http库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给http.FileServer处理就好了。 day6-template/gee/gee.go // create static handler func (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc { absolutePath := path.Join(group.prefix, relativePath) fileServer := http.StripPrefix(absolutePath, http.FileServer(fs)) return func(c *Context) { file := c.Param(\"filepath\") // Check if file exists and/or if we have permission to access it if _, err := fs.Open(file); err != nil { c.Status(http.StatusNotFound) return } fileServer.ServeHTTP(c.Writer, c.Req) } } // serve static files func (group *RouterGroup) Static(relativePath string, root string) { handler := group.createStaticHandler(relativePath, http.Dir(root)) urlPattern := path.Join(relativePath, \"/*filepath\") // Register GET handlers group.GET(urlPattern, handler) } 我们给RouterGroup添加了2个方法，Static这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹root映射到路由relativePath。例如： r := gee.New() r.Static(\"/assets\", \"/usr/geektutu/blog/static\") // 或相对路径 r.Static(\"/assets\", \"./static\") r.Run(\":9999\") 用户访问localhost:9999/assets/js/geektutu.js，最终返回/usr/geektutu/blog/static/js/geektutu.js。 HTML 模板渲染 Go语言内置了text/template和html/template2个模板标准库，其中html/template为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了html/template提供的能力。 Engine struct { *RouterGroup router *router groups []*RouterGroup // store all groups htmlTemplates *template.Template // for html render funcMap template.FuncMap // for html render } func (engine *Engine) SetFuncMap(funcMap template.FuncMap) { engine.funcMap = funcMap } func (engine *Engine) LoadHTMLGlob(pattern string) { engine.htmlTemplates = template.Must(template.New(\"\").Funcs(engine.funcMap).ParseGlob(pattern)) } 首先为 Engine 示例添加了 *template.Template 和 template.FuncMap对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。 另外，给用户分别提供了设置自定义渲染函数funcMap和加载模板的方法。 接下来，对原来的 (*Context).HTML()方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。 day6-template/gee/context.go type Context struct { // ... // engine pointer engine *Engine } func (c *Context) HTML(code int, name string, data interface{}) { c.SetHeader(\"Content-Type\", \"text/html\") c.Status(code) if err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != nil { c.Fail(500, err.Error()) } } 我们在 Context 中添加了成员变量 engine *Engine，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 c.engine 赋值。 day6-template/gee/gee.go func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { // ... c := newContext(w, req) c.handlers = middlewares c.engine = engine engine.router.handle(c) } 使用Demo 最终的目录结构 ---gee/ ---static/ |---css/ |---geektutu.css |---file1.txt ---templates/ |---arr.tmpl |---css.tmpl |---custom_func.tmpl ---main.go geektutu.css is loaded day6-template/main.go type student struct { Name string Age int8 } func FormatAsDate(t time.Time) string { year, month, day := t.Date() return fmt.Sprintf(\"%d-%02d-%02d\", year, month, day) } func main() { r := gee.New() r.Use(gee.Logger()) r.SetFuncMap(template.FuncMap{ \"FormatAsDate\": FormatAsDate, }) r.LoadHTMLGlob(\"templates/*\") r.Static(\"/assets\", \"./static\") stu1 := &student{Name: \"Geektutu\", Age: 20} stu2 := &student{Name: \"Jack\", Age: 22} r.GET(\"/\", func(c *gee.Context) { c.HTML(http.StatusOK, \"css.tmpl\", nil) }) r.GET(\"/students\", func(c *gee.Context) { c.HTML(http.StatusOK, \"arr.tmpl\", gee.H{ \"title\": \"gee\", \"stuArr\": [2]*student{stu1, stu2}, }) }) r.GET(\"/date\", func(c *gee.Context) { c.HTML(http.StatusOK, \"custom_func.tmpl\", gee.H{ \"title\": \"gee\", \"now\": time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC), }) }) r.Run(\":9999\") } 访问下主页，模板正常渲染，CSS 静态文件加载成功。 "},"GoLang/7daysGoLang/gee-web/doc/gee-day7.html":{"url":"GoLang/7daysGoLang/gee-web/doc/gee-day7.html","title":"错误恢复(Panic Recover)","keywords":"","body":"datetime:2022/02/05 16:58 author:nzb Go语言动手写Web框架 - Gee第七天 错误恢复(Panic Recover) 本文是7天用Go从零实现Web框架Gee教程系列的第七篇。 实现错误处理机制。 panic Go 语言中，比较常见的错误处理方法是返回 error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发 panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic 也会被触发。panic 会中止当前执行的程序，退出。 下面是主动触发的例子： // hello.go func main() { fmt.Println(\"before panic\") panic(\"crash\") fmt.Println(\"after panic\") } $ go run hello.go before panic panic: crash goroutine 1 [running]: main.main() ~/go_demo/hello/hello.go:7 +0x95 exit status 2 下面是数组越界触发的 panic // hello.go func main() { arr := []int{1, 2, 3} fmt.Println(arr[4]) } $ go run hello.go panic: runtime error: index out of range [4] with length 3 defer panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经defer 的任务，执行完成后再退出。效果类似于 java 语言的 try...catch。 // hello.go func main() { defer func() { fmt.Println(\"defer func\") }() arr := []int{1, 2, 3} fmt.Println(arr[4]) } $ go run hello.go defer func panic: runtime error: index out of range [4] with length 3 可以 defer 多个任务，在同一个函数中 defer 多个任务，会逆序执行。即先执行最后 defer 的任务。 在这里，defer 的任务执行完成之后，panic 还会继续被抛出，导致程序非正常结束。 recover Go 语言还提供了 recover 函数，可以避免因为 panic 发生而导致整个程序终止，recover 函数只在 defer 中生效。 // hello.go func test_recover() { defer func() { fmt.Println(\"defer func\") if err := recover(); err != nil { fmt.Println(\"recover success\") } }() arr := []int{1, 2, 3} fmt.Println(arr[4]) fmt.Println(\"after panic\") } func main() { test_recover() fmt.Println(\"after recover\") } $ go run hello.go defer func recover success after recover 我们可以看到，recover 捕获了 panic，程序正常结束。test_recover() 中的 after panic 没有打印，这是正确的，当 panic 被触发时，控制权就被交给了 defer 。就像在 java 中，try代码块中发生了异常，控制权交给了 catch，接下来执行 catch 代码块中的代码。而在 main() 中打印了 after recover，说明程序已经恢复正常，继续往下执行直到结束。 Gee 的错误处理机制 对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。 我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。 例如下面的代码： func main() { r := gee.New() r.GET(\"/panic\", func(c *gee.Context) { names := []string{\"geektutu\"} c.String(http.StatusOK, names[100]) }) r.Run(\":9999\") } 在上面的代码中，我们为 gee 注册了路由 /panic，而这个路由的处理函数内部存在数组越界 names[100]，如果访问 localhost:9999/panic，Web 服务就会宕掉。 今天，我们将在 gee 中添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。 我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强 gee 框架的能力。 新增文件 gee/recovery.go，在这个文件中实现中间件 Recovery。 func Recovery() HandlerFunc { return func(c *Context) { defer func() { if err := recover(); err != nil { message := fmt.Sprintf(\"%s\", err) log.Printf(\"%s\\n\\n\", trace(message)) c.Fail(http.StatusInternalServerError, \"Internal Server Error\") } }() c.Next() } } Recovery 的实现非常简单，使用 defer 挂载上错误恢复的函数，在这个函数中调用 recover()，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 Internal Server Error。 你可能注意到，这里有一个 trace() 函数，这个函数是用来获取触发 panic 的堆栈信息，完整代码如下： day7-panic-recover/gee/recovery.go package gee import ( \"fmt\" \"log\" \"net/http\" \"runtime\" \"strings\" ) // print stack trace for debug func trace(message string) string { var pcs [32]uintptr n := runtime.Callers(3, pcs[:]) // skip first 3 caller var str strings.Builder str.WriteString(message + \"\\nTraceback:\") for _, pc := range pcs[:n] { fn := runtime.FuncForPC(pc) file, line := fn.FileLine(pc) str.WriteString(fmt.Sprintf(\"\\n\\t%s:%d\", file, line)) } return str.String() } func Recovery() HandlerFunc { return func(c *Context) { defer func() { if err := recover(); err != nil { message := fmt.Sprintf(\"%s\", err) log.Printf(\"%s\\n\\n\", trace(message)) c.Fail(http.StatusInternalServerError, \"Internal Server Error\") } }() c.Next() } } 在 trace() 中，调用了 runtime.Callers(3, pcs[:])，Callers 用来返回调用栈的程序计数器, 第 0 个 Caller 是 Callers 本身，第 1 个是上一层 trace，第 2 个是再上一层的 defer func。因此，为了日志简洁一点，我们跳过了前 3 个 Caller。 接下来，通过 runtime.FuncForPC(pc) 获取对应的函数，在通过 fn.FileLine(pc) 获取到调用该函数的文件名和行号，打印在日志中。 至此，gee 框架的错误处理机制就完成了。 使用 Demo day7-panic-recover/main.go package main import ( \"net/http\" \"gee\" ) func main() { r := gee.Default() r.GET(\"/\", func(c *gee.Context) { c.String(http.StatusOK, \"Hello Geektutu\\n\") }) // index out of range for testing Recovery() r.GET(\"/panic\", func(c *gee.Context) { names := []string{\"geektutu\"} c.String(http.StatusOK, names[100]) }) r.Run(\":9999\") } 接下来进行测试，先访问主页，访问一个有BUG的 /panic，服务正常返回。接下来我们再一次成功访问了主页，说明服务完全运转正常。 $ curl \"http://localhost:9999\" Hello Geektutu $ curl \"http://localhost:9999/panic\" {\"message\":\"Internal Server Error\"} $ curl \"http://localhost:9999\" Hello Geektutu 我们可以在后台日志中看到如下内容，引发错误的原因和堆栈信息都被打印了出来，通过日志，我们可以很容易地知道，在day7-panic-recover/main.go:47 的地方出现了 index out of range 错误。 2020/01/09 01:00:10 Route GET - / 2020/01/09 01:00:10 Route GET - /panic 2020/01/09 01:00:22 [200] / in 25.364µs 2020/01/09 01:00:32 runtime error: index out of range Traceback: /usr/local/Cellar/go/1.12.5/libexec/src/runtime/panic.go:523 /usr/local/Cellar/go/1.12.5/libexec/src/runtime/panic.go:44 /tmp/7days-golang/day7-panic-recover/main.go:47 /tmp/7days-golang/day7-panic-recover/gee/context.go:41 /tmp/7days-golang/day7-panic-recover/gee/recovery.go:37 /tmp/7days-golang/day7-panic-recover/gee/context.go:41 /tmp/7days-golang/day7-panic-recover/gee/logger.go:15 /tmp/7days-golang/day7-panic-recover/gee/context.go:41 /tmp/7days-golang/day7-panic-recover/gee/router.go:99 /tmp/7days-golang/day7-panic-recover/gee/gee.go:130 /usr/local/Cellar/go/1.12.5/libexec/src/net/http/server.go:2775 /usr/local/Cellar/go/1.12.5/libexec/src/net/http/server.go:1879 /usr/local/Cellar/go/1.12.5/libexec/src/runtime/asm_amd64.s:1338 2020/01/09 01:00:32 [500] /panic in 395.846µs 2020/01/09 01:00:38 [200] / in 6.985µs 参考 Package runtime - golang.org Is it possible get information about caller function in Golang? - StackOverflow "},"C++/基础/01-C++初识.html":{"url":"C++/基础/01-C++初识.html","title":"C++初始","keywords":"","body":"datetime:2022/08/15 14:02 author:nzb 1 C++初识 1.1 第一个C++程序 编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目 Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件 右键源文件，选择添加->新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码 #include using namespace std; int main() { cout 1.1.4 运行程序 1.2 注释 作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量 作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： #include using namespace std; int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量 作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 示例： //1、宏常量 #define day 7 int main() { cout 1.5 关键字 作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则 作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 "},"C++/基础/02-数据类型.html":{"url":"C++/基础/02-数据类型.html","title":"数据类型","keywords":"","body":"datetime:2022/08/15 14:02 author:nzb 2 数据类型 C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型 作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字 作用：利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： int main() { cout 整型结论：short 2.3 实型（浮点型） 作用：用于表示小数 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： int main() { float f1 = 3.14f; double d1 = 3.14; cout 2.4 字符型 作用：字符型变量用于显示单个字符 语法：char ch = 'a'; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： int main() { char ch = 'a'; cout ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 & 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 92 / 124 \\ 29 GS 61 = 93 ] 125 } 30 RS 62 > 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符 作用：用于表示一些不能显示出来的ASCII字符 现阶段我们常用的转义字符有：\\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符\"\\\" 092 \\' 代表一个单引号（撇号）字符 039 \\\" 代表一个双引号字符 034 \\? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围0~9，a~f，A~F 3位16进制 示例： int main() { cout 2.6 字符串型 作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = \"字符串值\" 示例： int main() { char str1[] = \"hello world\"; cout C++风格字符串： string 变量名 = \"字符串值\" 示例： int main() { string str = \"hello world\"; cout 注意：C风格的字符串要用双引号括起来注意：C++风格字符串，需要加入头文件#include 2.7 布尔类型 bool 作用：布尔数据类型代表真或假的值 bool类型只有两个值： true：真（本质是1） false： 假（本质是0） bool类型占1个字节大小 示例： int main() { bool flag = true; cout 2.8 数据的输入 作用：用于从键盘获取数据 关键字：cin 语法： cin >> 变量 示例： int main(){ //整型输入 int a = 0; cout > a; cout > d; cout > ch; cout > str; cout > flag; cout "},"C++/基础/03-运算符.html":{"url":"C++/基础/03-运算符.html","title":"运算符","keywords":"","body":"datetime:2022/08/15 15:52 author:nzb 3 运算符 作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符 作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; -- 前置递减 a=2; b=--a; a=1; b=1; -- 后置递减 a=2; b=a--; a=1; b=2; 示例1： //加减乘除 int main() { int a1 = 10; int b1 = 3; cout 总结：在除法运算中，除数不能为0 示例2： //取模 int main() { int a1 = 10; int b1 = 3; cout 总结：只有整型变量可以进行取模运算 示例3： //递增 int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符 作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： int main() { //赋值运算符 // = int a = 10; a = 100; cout 3.3 比较运算符 作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 小于 4 0 > 大于 4 > 3 1 小于等于 4 0 >= 大于等于 4 >= 1 1 示例： int main() { int a = 10; int b = 20; cout b) = b) 注意：C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。 3.4 逻辑运算符 作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 && 与 a && b 如果a和b都为真，则结果为真，否则为假。 ` ` 或 a ` ` b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 //逻辑运算符 --- 非 int main() { int a = 10; cout 总结： 真变假，假变真 示例2：逻辑与 //逻辑运算符 --- 与 int main() { int a = 10; int b = 10; cout 总结：逻辑与运算符，同真为真，其余为假 示例3：逻辑或 //逻辑运算符 --- 或 int main() { int a = 10; int b = 10; cout 总结：逻辑或运算符，同假为假，其余为真 "},"C++/基础/04-流程控制.html":{"url":"C++/基础/04-流程控制.html","title":"流程控制","keywords":"","body":"datetime:2022/08/15 16:02 author:nzb 4 程序流程结构 C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构 4.1.1 if语句 作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 - 1. 单行格式if语句：`if(条件){ 条件满足执行的语句 }` 示例： int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout > score; cout 600) { cout 注意：if条件表达式后不要加分号 - 2. 多行格式if语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };` 示例： int main() { int score = 0; cout > score; if (score > 600) { cout - 3. 多条件的if语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}` 示例： int main() { int score = 0; cout > score; if (score > 600) { cout 500) { cout 400) { cout 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： int main() { int score = 0; cout > score; if (score > 600) { cout 700) { cout 650) { cout 500) { cout 400) { cout 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符 作用：通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： int main() { int a = 10; int b = 20; int c = 0; c = a > b ? a : b; cout b ? a : b) = 100; cout 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句 作用：执行多条件分支语句 语法： switch(表达式) { case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; } 示例： int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout > score; switch (score) { case 10: case 9: cout 注意1：switch语句中表达式类型只能是整型或者字符型注意2：case里如果没有break，那么程序会一直向下执行总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构 4.2.1 while循环语句 作用：满足循环条件，执行循环语句 语法：while(循环条件){ 循环语句 } 解释： 只要循环条件的结果为真，就执行循环语句 示例： int main() { int num = 0; while (num 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：猜数字 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do...while循环语句 作用：满足循环条件，执行循环语句 语法：do{ 循环语句 } while(循环条件); 注意：与while的区别在于do...while会先执行一次循环语句，再判断循环条件 示例： int main() { int num = 0; do { cout 总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do...while语句，求出所有3位数中的水仙花数 int main() { // 1、先打印所有的三位数字 int num = 100; do { // 2、从所有三位数中找到水仙花 int a = 0; // 个位 int b = 0; // 十位 int c = 0; // 百位 a = num % 10; b = num / 10 % 10; c = num / 100 % 10; if (a * a * a + b * b * b + c * c * c == num) { cout 4.2.3 for循环语句 作用：满足循环条件，执行循环语句 语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： int main() { for (int i = 0; i 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do...while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 int main() { // 1、先输出1~100 for (int i = 1; i 4.2.4 嵌套循环 作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 int main() { for (int i = 1; i 4.3 跳转语句 4.3.1 break语句 作用: 用于跳出选择结构或者循环结构 break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： int main() { //1、在switch 语句中使用break cout > num; switch (num) { case 1: cout 示例2： int main() { //2、在循环语句中用break for (int i = 0; i 示例3： int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i 4.3.2 continue语句 作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： int main() { for (int i = 0; i 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句 作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： int main() { cout 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 "},"C++/基础/05-数组.html":{"url":"C++/基础/05-数组.html","title":"数组","keywords":"","body":"datetime:2022/08/19 14:07 author:nzb 5 数组 5.1 概述 所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个==数据元素都是相同的数据类型== 特点2：数组是由==连续的内存==位置组成的 5.2 一维数组 5.2.1 一维数组定义方式 一维数组定义的三种方式： 1、数据类型 数组名[ 数组长度 ]; 2、数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 3、数据类型 数组名[ ] = { 值1，值2 ...}; 示例 int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名 一维数组名称的用途： 1、 可以统计整个数组在内存中的长度 2、 可以获取数组在内存中的首地址 示例： int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述：：在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};找出并打印最重的小猪体重。 int main() { int arr[5] = {300,350,200,400,250}; int max = 0; for (int i = 0; i max){ max = arr[i]; } } cout 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置.(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); int main() { int arr[5] = {1,3,2,5,4}; cout 5.2.3 冒泡排序 作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i 5.3 二维数组 二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式 二维数组定义的四种方式： 1、 数据类型 数组名[ 行数 ][ 列数 ]; 2、 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 3、 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 4、 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性 示例： int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例 考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { \"张三\",\"李四\",\"王五\" }; for (int i = 0; i "},"Database/MySQL/计算机二级MySQL.html":{"url":"Database/MySQL/计算机二级MySQL.html","title":"计算机二级","keywords":"","body":"一、数据库基本概念 1、数据库设计的步骤 六个阶段：需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行与维护 二、MySQL编程语言 1、MySQL函数 1.1、聚合函数 count()：计数（对于除“*”以外的任何参数，返回所选集合中非null值的数目） sun()：求和 avg()：求平均数 max()：求最大值 min()：求最小值 1.2、数学函数 abs()：求绝对值 floor()：返回小于或等于参数的最大整数 rand()：返回0~1之间的随机数 truncate(x,y)：返回x保留到小数点后y为的值 sort(): 求参数的平方根 1.3、字符串函数 upper()和ucase()：把字符串所有字母变成大写字母 left(s,n)：返回字符串s的前n个字符 substring(s,n,len)：从字符串s的第n个位置开始获取长度为len的字符串 1.4、日期和时间函数 curdate()和current_date()：返回当前日期 curtime()和current_time()：获取当前时间 now()：获取当前日期和时间，current_timestamp()、localtime()、sysdate()、localtimestamp()同样可以获取当前日期和时间 1.5、其他函数 if(expr,v1,v2)：条件判断函数，如果表达式expr成立，则执行v1,否则执行v2 ifnull(v1,v2)：条件判断函数，如果表达式v1不为空，则显示v1的值,否则显示v2的值 version()：获取数据库的版本号 三、数据定义 1、定义数据库 1.1、创建数据库 create {database | schema} [if not exists] db_name [[default] character set [=] charset_name [[default] collate [=] collation_name]; 1.2、选择和查看数据库 use da_name; show {databases | schemas}; 1.3、修改数据库 alter {database | schema} [db_name] [[default] character set [=] charset_name [[default] collate [=] collation_name]; 数据库名可省略，表示修改当前数据库 1.4、删除数据库 drop {database | schema} [if exists] db_name; 2、定义表 2.1数据类型 2.1.1、数值类型 bit tinyint bool,boolean smallint mediumint int,integer bigint double decimal(m.d) 2.1.2、日期和时间类型 date:日期型，MySQL以“YYYY-MM-DD”格式显示date值 datetime:日期和时间类型，MySQL以“YYYY-MM-DD HH:MM:SS”格式显示datetime值 timestamp:时间戳 time:时间型,MySQL以“HH:MM:SS”格式显示time值 year两位或四位格式的年 2.1.3、字符串类型 char：定长字符串 varchar：可变长字符串 tinytext text 2.2、创建表 create table tbl_name ( 字段名1 数据类型 [列级完整性约束条件] [默认值] [,字段名2 数据类型 [列级完整性约束条件] [默认值] [,... ...] [,表级完整性约束条件] ) [engine=引擎类型]; 2.3、查看表 2.3.1、查看表名称 show tables [{from | in } db_name]; 2.3.2、查看数据表的基本结构 show columns {from | in } tb_name [from | in } db_name]; 或 desc tb_name; 2.3.3、查看数据表的详细结构 show create table tb_name; 2.4、修改表 2.4.1、添加字段 alter table tb_name add [column] 新字段名 数据类型 [约束条件] [first | after 已有字段名]; 2.4.2、修改字段 # 可改指定列的名称和数据类型，修改多个彼此用逗号分隔 alter table tb_name change [column] 原字段名 新字段名 数据类型 [约束条件]; # 修改或删除指定列的默认值 alter table tb_name alter [column] 字段名 {set | drop} default; # 修改列的数据类型，而不改名 alter table tb_name modify [column] 字段名 数据类型 [约束条件] [first | after 已有字段名]; 2.4.3、删除字段 alter table tb_name drop [column] 字段名; 2.5、重命名表 alter table 原表名 rename [to] 新表名; 或 rename table 原表名1 to 新表名1 [,原表名2 to 新表名2]......; 2.6、删除表 drop table [if exists] tb_name1 [,tb_name2]......; 3、数据的完整性约束 3.1、定义实体完整性 3.1.1、主键约束 一个表必须要有一个主键，且唯一不为空 3.2.2、完整性约束的命名 constraint {primary key(主键字段列表) | unique(候选键字段列表) |foreign key(外键字段列表) references tb_被参照的关系(表) (主键字段列表) | check(约束条件表达式)}; 3.2、定义参照完整性 外键需存在或为空 3.3、用户定义完整性 MySQL支持的几种用户定义完整性约束：非空约束，check约束和触发器 check约束： check(expr); 3.4、更新完整性约束 3.4.1、删除约束 alter table drop foreign key ; alter table drop primary key; alter table drop {约束名 | 候选键字段名}; 3.4.2、添加约束 alter table add [constraint ] primary key(主键字段); alter table add [constraint ] foreign key(外键字段名) references 被参照表(主键字段名); alter table add [constraint ] unique key(字段名); 四、数据查询 1、select语句 select [all | distinct | distinctrow] [,目标表达式2]... form [,] [group by [having ]] [order by [asc | desc]] [limit[m,]n] 2、单表查询 2.1、选择字段 select 目标表达式1, 目标表达式2,...,目标表达式n from 表名; select * form 表名; # 定义字段的别名 select 字段名 as 字段别名 from 表名; 2.2、选择指定的字段 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 查询条件; # 带between ...and... select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where expression [not] between expr1 and expr2; #带like关键字,换码字符也叫转义字符，如果字符串本身含有通配符_和%,就需要换码字符 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 字段名 [not] like ''[escape '']; #使用正则表达式查询 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 字段名 [not] [regexp | rlike] ; # 限制查询结果数目 limit 行数 offset 位置偏移数; 3、分组聚合查询 3.1、使用聚合函数 group by 字段列表 having ; 4、连接查询 4.1、交叉查询（笛卡尔积）:用得极少 select * from tb_name1 cross join tb_name2; 或 select * from tb_name1, tb_name2; 4.2、内连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 [inner] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1, table2 where 连接条件 [and 过滤条件]; 4.2.1、等值于非等值连接 [.] [.]; 4.2.2、自连接 使用自连接时，需要指定多个不同的别名，查询字段都有别名来限定 4.2.3、自然连接 两张表中的字段名都相同才可以使用，否则放回笛卡尔积结果 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 natural join table2 [as] 别名2; 4.3、外连接 # 左外连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 left [outer] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; # 右外连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 right [outer] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; 5、子查询 子查询关键字：in, any, all, [not]exists, 必要时为表名加上别名 6、联合查询 select -from-where union [all] select -from-where [...union [all] select -from-where] 多个表查询联合起来，不使用all关键字，执行的时候去重，返回的行都是唯一的，使用all则不去重。 五、数据更新 1、插入数据 1.1、插入一条或多条 insert into table(字段名列表) values(值列表1), [,值列表2], ... ,[值列表n]; replace into table(字段名列表) values(值列表1), [,值列表2], ... ,[值列表n]; 1.2、插入查询结果 insert into table1(字段名列表) select (字段名列表) from table2 where(conditions); 2、修改数据记录 update table set 字段名1=值1, 字段名2=值2, ... , 字段名n=值n [where ]; 3、删除数据记录 delete from table [where]; truncate [table] tb_name; 六、索引 1、什么时候需要创建索引 a.主键自动建立唯一索引 b.频繁作为查询条件的字段应该创建索引 c.查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找 d.查询中统计或者分组的字段； 2、什么时候不需要创建索引 a.频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件 b.where条件里用不到的字段，不创建索引； c.表记录太少，不需要创建索引； d.经常增删改的表； e.数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。 3、索引的分类： a.普通索引：最基本的索引，它没有任何限制 b.唯一索引：索引列的值必须唯一，且不能为空，如果是组合索引，则列值的组合必须唯一。 c.主键索引：特殊的索引，唯一的标识一条记录，不能为空，一般用primary key来约束。 d.联合索引：在多个字段上建立索引，能够加速查询到速度 1、查看数据表上的索引 show {index | indexes | keys} {fron | in } tb_name [{from | in } db_name]; 2、创建索引 2.1、建表时创建 create table(字段名, 字段类型...) [constrint index_name] [unique] [index | key] [index_name](字段列名[长度]) [asc | aesc]; 2.2、使用create index create [unique] index index_name on tb_name(字段名[(长度)] [asc | desc] , ...); 2.3、使用alter table alter table tb_name add [unique | fulltext] [index|key] index_name(字段名[(长度)][asc|desc],...) 3、删除索引 drop index index_name on tb_name; alter table tb_name drop index index_name; 七、视图 1、创建视图 create [or replace] view view_name[(column_list)] as select_statement [with [cascaded | local] check option]; 2、删除视图 drop view [if exists] view_name[,view_name]...; 3、修改视图 alter view view_name [(column_list)] as select_statement [with [cascaded | local] check option]; 4、查看视图定义 show create view view_name\\G 八、触发器 1、创建触发器 create trigger trigger_name trigger_time(before|after) trigger_event(insert|update|delete) on tb_name for each row trigger_body; # 查看已有的触发器 show triggers [{from | in} db_name]; 2、删除触发器 drop trigger [if exists] [schema_name.]trigger_name; 3、使用触发器 在insert触发器中可以引用名为new的虚拟表来访问被插入的行 在delete触发器中可以引用名为old的虚拟表来访问被删除的行 在delete触发器中可以引用名为new的虚拟表来访问更新后的值 在delete触发器中可以引用名为old的虚拟表来访问更新前的值 例子： create trigger tg1 after update on tb_name1 for each row set new.col1 = old.col2; 九、事件(临时触发器) 1、创建事件 create event [if not exists] event_name on schedule 时间调度 [enable|disable|disable on slave] do event_body; 时间调度语法格式： at timestamp [+ interval interval]... | every interval [starts timestamp [+ interval interval]...] [ends timestamp [+ interval interval]...] interval语法格式 quantity {year | quarter | month | day | hour | minute | week | second | year_month | day_hour | day_minute| day_second | hour_minute | hour_second | minute_second} 例子： 每个月向表tb_1插入一条数据，该事件开始于下个月并且结束于2019年12月31日。 首先改变结束符：delimiter $$ create event if not exists event_insert on schedule every 1 month starts curdate() + interval 1 month ends '2019-12-31' do begin if year(curdate()) 2、修改事件 alter event event_name [on schedule 时间调度] [rename to new_name] [enable | disable | disable on slave] [do event_body]; 3、删除事件 drop event [if exists] event_name; 十、存储过程和存储函数 1、存储过程 1.1、创建存储过程 create procedure sp_name ([proc_parameter[,...]]) [characteristic...]routine_body 其中proc_parameter格式为 [in | out | inout]param_name type 分别对应输入、输出和输入/输出参数 其中routine_body为存储过程主体： 也称存储过程体，其中包含了在过程调用的时候必须执行的sql语句，这个部分以关键字begin开始，以关键字end结束。如存储过程体中只有一条sql语句，可以省略begin-end标志，另外begin-end可以嵌套。 1.2、存储过程体 1.2.1、局部变量 声明： declare var_name [,...] type [defautl value] ps:局部变量不同意用户变量，区别：局部变量声明时，在其前面没有使用“@”符号，并且它只能在声明它的begin-end语句块中使用，而用户变量前面使用“@”符号，存在整个会话中。 1.2.2、赋值 set var_name = expr[, var_name = expr]... 或 select 字段名 into var_name[,...] 查询源及条件; 1.2.3、流程控制语句 条件 if search_condition then statement_list [elseif search_condition then statement_list]... [else statement_list] end if; 或 case case_vale when when_value then statement_list [when when_value then statement_list] [else statement_list] end case; 或 case when search_condition then statement_list [when search_condition then statement_list] [else statement_list] end case; 循环 [begin_label:]while search_condition do statement_list end while[end_label]; 或 [begin_label:]repeat statement_list until search_condition end repeat[end_label]; 或 [begin_label:]loop statement_list end loop[end_label]; 1.2.4、游标 # 声明游标 declare cursor_name cursor for select_statement; # select_statement为一条select语句注意不能有into子句。 # 打开游标 open cursor_name; # 读取游标 fetch cursor_name into var_name[,var_name]...; # 关闭游标 close cursor_name; # 例子:统计行数 delimiter $$ create procedure sp_sum(out rows int) begin declare sno char; declare found boolean default true; declare cur cursor for select studentNo from tb_students; declare continue handler for not found set found = false; set rows = 0; open cur; fetch cur into sno; while found do set rows = rows +1; fetch cur into sno; end while; close cur; end$$ 1.3、调用存储过程 call sp_name([parameter[,...]]); call sp_name[()]; 1.4、删除存储过程 drop procedure [if exists] sp_name; 2、存储函数 2.1、与存储过程的区别 # 存储函数不能有输出参数，因为存储函数本身就是输出参数，而存储过程可以有输出参数 # 可以直接对存储函数进行调用，不需要使用call # 存储函数必须包含一条return语句，而这条语句不允许包含于存储过程中 2.1、创建存储函数 create function sp_name ([func_parameter[,...]]) returns type routine_body # 例子：根据给定的学号返回学生性别，如果没有则返回“没有该学生” delimiter $$ create function fn_student(sno char(10)) returns char(2) begin declare ssex char(2); select sex into ssex from student where studentNo = sno; if ssex is null then return (select \"没有该学生\"); else if ssex=\"女\" then return (select \"女\"); else return (select \"男\"); end if; end$$ 2.2、调用存储函数 select sp_name([func_parameter[,...]]); 2.3、删除存储函数 drop function [if exists] sp_name; 十一、访问控制与安全管理 1、用户账号与管理 1.1、创建用户账号 create user user_specification [,user_specification]...; 其中user_specification格式： user [indentified by [password] 'password' | identified with 指定认证的插件名称 [as 'auth_string']]; # 例子： create user 'zhangsan@localhost' identified by '123','lisi@localhost' identified by password 'password(字符串)返回的散列值'; 1.2、删除用户 drop user user_name [,user_name]...; 1.3、修改用户账号 rename user old_name to new_name [,old_name to new_name]...; 1.4、修改用户密码 set password [for user] = {password('new_password') | 'encryted password(表示已被password加密的口令值)' } # 如果不加for 则表示给当前用户改密码 2、账号权限管理 2.1、权限的授予 grant priv_type [(column_list)] [,priv_type[(column_list)]]... on [object_type] priv_level to user_specification [,user_specifition]... [require {none|ssl_option[[and]ssl_option]...}] [with with_option...] # priv_type 如：select、update、delete # 其中object_type格式为： table | function | procedure # priv_level格式为： * | *.* | db_name.tb_name | tb_name | db_name.routine_name # user_specifition格式同上面 说明该语句同样可以用来创建用户 # with_option格式为： grant option | max_queries_per_hour count #每小时查询数据库的次数 | max_updates_per_hour count #每小时可以修改数据库的次数 | max_connections_per_hour count #每小时可以连接数据库的次数 | max_user_connections count #同时连接数据库的最大用户数 例子： grant select(studentNo, studentName) on db_school.tb_student to 'lisi@localhost' identifie by '123'; grant all on *.* to 'zhangsan@loclhost' identified by '123'; grant create user on *.* to 'zhangsan@loclhost' identified by '123'; 2.2、权限的转移与限制 2.2.1、转移 with 子句指定为with grant option时，表示to 子句中所指定的所以用户都具有把自己所拥有的权限授予其他用户。 例子： grant select, update on db_school.tb_student to 'lisi@localhost' identified by '123' with grant option; 2.2.2、限制 with子句后面跟关键字 例子： grant delete on db_school.* to 'zhangsan@localhost' identified by '123' with MAX_QUERIES_PER_HOUR 1; 2.3、权限的撤销 # 回收某些特定的权限 revoke priv_type [(column_list)] [,priv_type[(column_list)]]... on [object_type] priv_level form user [,user]...; 或 # 回收特定用户的所有权限 revoke all privileges, grant option form user [,user]; 十二、备份与恢复 1、使用sql语句备份和恢复表数据 1.1、select into ... outfile语句导出备份 select * into outfile 'file_name ' [character set charset_name ] export_options | into dumpfile 'file_name'; # export_options格式： [fields [terminated by 'string'] [[optionally] enclosed by 'char'] [escaped by 'char'] ] [lines terminated by 'string'] 1.2、load data ...infile语句导入恢复 load data [low_priority | concurrent] [local] infile 'file_name.txt' [replace | ignore] into table tb_name [fields [terminated by 'string'] [[optionally] enclosed by 'char'] [escaped by 'char'] ] [lines [starting by 'string'] [terminated by 'string'] ] [IGNORE number LINES] [(col_name_or_user_var,...)] [set col_name = expr, ...]] 例子： # 导出 select * from db_school.tb_student into outfile 'C:\\BACKUP\\backupfiel.txt' fields terminated by ','optionally enclosed by '\"' lines terminated by '?'; # 导出 load data infile 'C:\\BACKUP\\backupfiel.txt' into table db_school.tb_student_copy fields terminated by ',' optionally enclosed by '\"' lines terminated by '?' 2、使用MySQL客服端实用程序备份和恢复数据 2.1、备份表 # 备份数据表 mysqldump [option] database [tables] > filename; # 备份数据库 mysqldump [option] database --database [option] DB1 [DB2 DB3...] > filename; # 备份整个数据库系统 msyqldump [option] --all-database [option] > fielname; # 例子： mysqldump -hlocalhost -uroot -p123 db_school.tb_table > c:\\backup\\file.sql; msyqldump -hlocalhost -uroot -p123 --database db_school > c:\\backup\\data.sql; msyqldump -uroot -p123 --all-database > c:\\backup\\alldata.sql; 2.2、使用mysql命令恢复数据 mysql -uroot -p123 tb_student 3、二进制日志文件的使用 3.1、查看二进制日志文件 msyqlbinlog [option] log_file... [> c:\\backup\\bin_log000001.txt]; 3.2、使用二进制文件恢复数据 msyqlbinlog [option] log_file... | msyql [option] # 例子 msyqlbinlog bin_log0001 | mysql -uroot -p123; 3.3、删除二进制日志文件 # 清除所有日志文件 reset master; # 删除指定的日志文件 purge {master | binary| logs to 'log_name': #删除某个时间之前的所有日志文件 purge {master | binary| logs before 'date'; 十三、MySQL数据库的应用编程 1、使用PHP进行MySQL数据库应用编程 1.1、mysql连接 # 非持久连接 mysql_connect([servername[, username[,password]]]); # 持久连接 mysql_pconnect([servername[, username[,password]]]); ps：如果msyql函数成功执行后连接成功，函数mysql_errno()和mysql_error会分别返回数值0和空字符串。 1.2、选择数据库 msyql_select_db(database[,connection]) 1.3、执行数据库操作 msyql_query(query[,connection]) ps:sql语句是以字符串的形式提交，且不以分号作为结束符。 1.4、数据结果读取 mysql_fetch_array(data[,array_type]) # array_type有： MYSQL_NUM:表示数值数组，功能与mysql_fetch_row(data)一样 MYSQL_ASSOC:表示关联数组，功能与mysql_fetch_assoc(data)一样 MYSQL_BOTH:表示同时产生关联数组和数字数组 mysql_fetch_row(data) msyql_fetch_assoc(data) 1.5、读取结果数目 mysql_num_rows(data) 1.6、读取指定记录号的记录 # 在结果集中随意移动记录的指针，也就是将记录指针直接指向某个记录，其中0指示结果集中的第一条记录。 mysql_data_seek(data,row) 1.7、关闭数据库 msyql_close([content]) # 例子： ’); mysql_select_db('db01',$con) or die('数据库选择失败！‘); mysql_query(\"set names 'gbk'\"); $sql = \"select studentname from tb_student\"; $sql = $sql.\"where studentNo = 200120\"; $result = mysql_query($sql, $con); if ($result){ echo \"学生查询成功！\" $array = mysql_fetch_array($result,MYSQL_NUM); if ($array){ echo \"读取到学生信息！\"; echo \"所查询的学生姓名为：\".$array[0]; } else echo \"没有查询到学生信息！\"; } else echo \"学生信息查询失败！\"; ?> "},"Database/MySQL/数据库三大范式.html":{"url":"Database/MySQL/数据库三大范式.html","title":"数据库三大范式","keywords":"","body":"数据库三大范式 第一范式（1NF）（原子不可分性） 所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项， 而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。 在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。 不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。 第二范式（2NF）（消除非主键部分依赖） 在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。 例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。 在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复， 无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在， 那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列， 以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。 第三范式（3NF）（消除传递依赖） 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。 简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。 那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。 简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。 范式应用实例 第一范式（1NF） 数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。 因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。 首先我们确定一下要设计的内容包括那些。学号、学生姓名、年龄、性别、课程名称、课程学分、系别、学科成绩，系办地址、系办电话等信息。 为了简单我们暂时只考虑这些字段信息。我们对于这些信息，所关心的问题有如下几个方面。 学生有那些基本信息？ 学生选了那些课，成绩是什么？ 每个课的学分是多少？ 学生属于那个系，系的基本信息是什么？ 第二范式（2NF） 首先我们考虑，把所有这些信息放到一个表中（学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话）下面存在如下的依赖关系。 (学号, 课程名称) → (姓名, 年龄, 成绩, 学分) 问题分析 姓名和年龄不依于课程，即不完全依赖于主属性因此不满足第二范式的要求，会产生如下问题： 数据冗余：同一门课程由n个学生选修，\"学分\"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。 更新异常： 1）若调整了某门课程的学分，数据表中所有行的\"学分\"值都要更新，否则会出现同一门课程学分不同的情况。 2）假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有\"学号\"关键字，课程名称和学分也无法记录入数据库。 删除异常 ：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。 解决方案 把选课关系表SelectCourse改为如下三个表： 学生：Student（学号，姓名，年龄，性别，系别，系办地址、系办电话）； 课程：Course（课程名称,学分）； 选课关系：SelectCourse（学号，课程名称，成绩）。 第三范式（3NF） 接着看上面的学生表Student（学号，姓名，年龄，性别，系别，系办地址、系办电话），关键字为单一关键字\"学号\"，因为存在如下决定关系： （学号）→ （姓名，年龄，性别，系别，系办地址、系办电话 但是还存在下面的决定关系： （学号） → (系别）→（系办地点，系办电话） 即存在非关键字段\"系办地点\"、\"系办电话\"对关键字段\"学号\"的传递函数依赖。 它也会存在数据冗余、更新异常、插入异常和删除异常的情况。 根据第三范式把学生关系表分为如下两个表就可以满足第三范式了： 学生：（学号，姓名，年龄，性别，系别）； 系别：（系别，系办地址、系办电话）。 上面的数据库表就是符合I，Ⅱ，Ⅲ范式的，消除了数据冗余、更新异常、插入异常和删除异常。 "},"Database/MySQL/主从复制.html":{"url":"Database/MySQL/主从复制.html","title":"MySQL主从复制","keywords":"","body":"datetime:2019/9/5 10:01 author:nzb MySQL的主从复制 主从复制 两台数据库服务器(Linux服务器), IP分别为192.168.1.110和192.168.1.111,服务器上装上MySQL(版本为5.7) 打开主数据库配置文件：vim /etc/mysql/my.cnf, 加入以下内容后重启MySQL服务 [mysqld] log-bin=mysql-bin server-id=1 （默认为1，总之两台服务器要设置为不同的ID） 打开从数据库配置文件：vim /etc/mysql/my.cnf, 加入相同内容后将其中的 server-id 设为2（默认为1）然后重启MySQL服务 设192.168.1.110为主数据库, 在数据库中加入一个从服务器可以登录的用户, 语句如下： GRANT ALL PRIVILEGES ON *.* TO 'user'@'192.168.1.111' IDENTIFIED BY 'password' WITH GRANT OPTION;(或 GRANT REPLICATION SLAVE ON *.* TO 'username'@'192.168.1.111' IDENTIFIED BY 'password' WITH GRANT OPTION;) FLUSH PRIVILEGES; 完成后, 在192.168.1.111服务器上执行：mysql -h 192.168.1.110 -u用户名 -p密码, 查看连接是否成功 最后在主数据库中执行以下语句, 查询master状态：show master status; 可以看到以上结果，这儿只需要看 File 和 Position，其它的两个分别是白名单和黑名单，意思为同步哪几个数据库和不同步哪几个数据库，可自行根据需求进行设置。记录了前两个字段后，在从库上执行以下语句： CHANGE MASTER TO MASTER_HOST='192.168.1.110', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_PORT='3306', MASTER_LOG_FILE='mysql-bin.000020', MASTER_LOG_POS=1441; 执行完成后, 在从数据库上继续执行以下语句： start slava; show slave status\\G; 这样，查看从服务器的状态，如果状态中的用红线标出来两个参数的值都为YES，那证明配置已经成功，否则可以检查一下具体问题出现在什么地方。 这样，就算配置完成了。在主库中新建数据库，新建一张表，插几条数据，到从库上查询一下看是否已经同步过来。 PS:如果失败，可以从以下几个方面去排查问题：　　 1.首先试一下主从服务器相互之间是否 PING 得通 2.试一下远程连接是否正确，如果连不上，则有可能是网卡不一致、防火墙没有放行 3306 端口 3.server-id 是否配成一致 4.bin-log 的信息是否正确 主主复制 上面说了主从复制的配置方法，现在接着上面的配置继续，然后实现双主复制，让以上的两个服务器互为主从。 在主服务器上配置 /etc/mysql/my.cnf 文件，配置如下,配置之后重启MYSQL服务: auto_increment_increment=2 #步进值auto_imcrement。一般有n台主MySQL就填n auto_increment_offset=1 #起始值。一般填第n台主MySQL。此时为第一台主MySQL binlog-ignore=mysql #忽略mysql库【一般都不写】 binlog-ignore=information_schema #忽略information_schema库【一般都不写】 在从服务器上配置 /etc/mysql/my.cnf 文件，配置如下, 配置之后重启MYSQL服务: auto_increment_increment=2 #步进值auto_imcrement。一般有n台主MySQL就填n auto_increment_offset=2 #起始值。一般填第n台主MySQL。此时为第二台主MySQL binlog-ignore=mysql #忽略mysql库【一般都不写】 binlog-ignore=information_schema #忽略information_schema库【一般都不写】 在从服务器上添加一个主服务器可以访问的用户，命令如下： GRANT REPLICATION SLAVE ON *.* TO 'user'@'192.168.1.110' IDENTIFIED BY 'password' with grant option ; FLUSH PRIVILEGES 建好之后在192.168.1.110服务器上访问从数据库, 测试是否成功，如果可以连上，则进行下一步，连不上的话，参考上面进行问题排查。 因为要互为主从，所以现在从服务器也是master ，所以也要查看一下状态：show master status; 查到相应的信息后，在原来的主服务器上执行以下命令（因为现在它现在也是另一台的从服务器） CHANGE MASTER TO MASTER_HOST='192.168.1.111', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_LOG_FILE='mysql-bin.000021', MASTER_LOG_POS=1457; 执行完毕后，在原主库上继续执行如下语句： start slave; show slave status\\G; 同上，如果出现如下画面，则证明配置成功。 在两台服务器的MYSQL中分别进行一些建库、建表、插入、更新等操作，看一下另一台会不会进行同步，如果可以则证明主主配置成功，否则还是上面的排错方法，进行错误排查。 双主多从 现在已经是双主配置了，但是如果要进行读写分离，那么我们要再增加N台从库，如何做呢？非常简单，按如下操作即可： 新增加一台数据库服务器，192.168.1.112，数据库配置均与前两台相同 确定一下要将哪一台当作自己的主服务器，我们姑且设 192.168.1.110 为主服务器 在第三台服务器中编辑 /etc/mysql/my.cnf ，将其 server-id 设为 3（保证与前两个不一样即可），然后重启MYSQL服务 在主服务器中，增加一条用户记录，用于当前服务器对主库对的连接，代码如下： GRANT REPLICATION SLAVE ON *.* TO 'user'@'192.168.1.112' IDENTIFIED BY 'password'; FLUSH PRIVILEGES; 在 192.168.216.130 服务器上测试是否可以连接到主库: mysql -h 192.168.1.110 -u用户名 -p密码, 如果可以连上，则可以进行下一步，否则根据上面的提示排查问题。 在 192.168.216.130 服务器上查询 master 当前状态: show master status; 看到相关信息后，我们执行如下操作： CHANGE MASTER TO MASTER_HOST='192.168.1.110', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_LOG_FILE='mysql-bin.000020', MASTER_LOG_POS=1441; 执行完毕后，在原主库上继续执行如下语句： start slave; show slave status\\G; 同上，如果出现如下画面，则证明配置成功。如果此处有问题，参考上面所提排查并解决问题。 此时我们在 192.168.1.110 上建库、建表、插入、更新、删除数据，在 另外两台上分别进行查看，发现均已经同步。 但是如果我们在 192.168.1.111 上做相应的操作，则发现只有 192.168.1.110 上进行了相应的同步，而 192.168.1.112 上的数据并未同步。 这是为什么呢？因为我们设置的主库是 192.168.1.110，所以在 192.168.1.111 进行数据操作的时候并未同步，这显然不符合我们的需求， 那么，我们要怎么修改呢？非常简单，在互为主从的两台服务器的配置文件中均加入以下语句：log-slave-updates=on 加上后将两台服务器的MYSQL重启，然后再进行测试，发现数据已经可以同步了。如果要再多加一些从服务器，和以上类似，现在我们做的是双主一从，我们可以再加N台从服务器，配置也是一样的。 至此，MYSQL主从复制、主主复制、双主多从配置我们均已经搞定！ Docker配置MySQL主从复制 下面还是基于Docker来演示如何配置MySQL主从复制。我们事先准备好MySQL的配置文件以及保存MySQL数据和运行日志的目录，然后通过Docker的数据卷映射来指定容器的配置、数据和日志文件的位置。 root └── mysql ├── master │ ├── conf | └── data └── slave-1 | ├── conf | └── data └── slave-2 | ├── conf | └── data └── slave-3 ├── conf └── data MySQL的配置文件（master和slave的配置文件需要不同的server-id）。 [mysqld] pid-file=/var/run/mysqld/mysqld.pid socket=/var/run/mysqld/mysqld.sock datadir=/var/lib/mysql log-error=/var/log/mysql/error.log server-id=1 log-bin=/var/log/mysql/mysql-bin.log expire_logs_days=30 max_binlog_size=256M symbolic-links=0 # slow_query_log=ON # slow_query_log_file=/var/log/mysql/slow.log # long_query_time=1 创建和配置master。 docker run -d -p 3306:3306 --name mysql-master \\ -v /root/mysql/master/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/master/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker exec -it mysql-master /bin/bash mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 1 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> grant replication slave on *.* to 'slave'@'%' identified by 'iamslave'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) mysql> show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000003 | 590 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> quit Bye exit 上面创建Docker容器时使用的-v参数（--volume）表示映射数据卷，冒号前是宿主机的目录，冒号后是容器中的目录，这样相当于将宿主机中的目录挂载到了容器中。 创建和配置slave。 docker run -d -p 3308:3306 --name mysql-slave-1 \\ -v /root/mysql/slave-1/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-1/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3309:3306 --name mysql-slave-2 \\ -v /root/mysql/slave-2/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-2/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3310:3306 --name mysql-slave-3 \\ -v /root/mysql/slave-3/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-3/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker exec -it mysql-slave-1 /bin/bash mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> reset slave; Query OK, 0 rows affected (0.02 sec) mysql> change master to master_host='mysql-master', master_user='slave', master_password='iamslave', master_log_file='mysql-bin.000003', master_log_pos=590; Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql> start slave; Query OK, 0 rows affected (0.01 sec) mysql> show slave status\\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: mysql57 Master_User: slave Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 590 Relay_Log_File: f352f05eb9d0-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 590 Relay_Log_Space: 534 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: 30c38043-ada1-11e8-8fa1-0242ac110002 Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) mysql> quit Bye exit 接下来可以如法炮制配置出slave2和slave3，这样就可以搭建起一个“一主带三从”的主从复制环境。上面创建创建容器时使用的--link参数用来配置容器在网络上的主机名（网络地址别名）。 配置好主从复制后，写数据的操作应该master上执行，而读数据的操作应该在slave上完成。为此，在Django项目中需要配置DATABASE_ROUTERS并通过自定义的主从复制路由类来实现读写分离操作，如下所示： DATABASE_ROUTERS = [ # 此处省略其他配置 'common.routers.MasterSlaveRouter', ] class MasterSlaveRouter(object): \"\"\"主从复制路由\"\"\" @staticmethod def db_for_read(model, **hints): \"\"\" Attempts to read auth models go to auth_db. \"\"\" return random.choice(('slave1', 'slave2', 'slave3')) @staticmethod def db_for_write(model, **hints): \"\"\" Attempts to write auth models go to auth_db. \"\"\" return 'default' @staticmethod def allow_relation(obj1, obj2, **hints): \"\"\" Allow relations if a model in the auth app is involved. \"\"\" return None @staticmethod def allow_migrate(db, app_label, model_name=None, **hints): \"\"\" Make sure the auth app only appears in the 'auth_db' database. \"\"\" return True 上面的内容参考了Django官方文档的DATABASE_ROUTERS配置，对代码进行了适当的调整。 "},"Database/NoSQL/01-NoSql入门.html":{"url":"Database/NoSQL/01-NoSql入门.html","title":"NoSql入门","keywords":"","body":"datetime:2019/10/29 16:41 author:nzb NoSQL入门 NoSQL概述 如今，大多数的计算机系统（包括服务器、PC、移动设备等）都会产生庞大的数据量。其实，早在2012年的时候，全世界每天产生的数据量就达到了2.5EB（艾字节，$$1EB\\approx10^{18}B$$）。这些数据有很大一部分是由关系型数据库来存储和管理的。 早在1970年，E.F.Codd发表了论述关系型数据库的著名论文“A relational model of data for large shared data banks”，这篇文章奠定了关系型数据库的基础并在接下来的数十年时间内产生了深远的影响。实践证明，关系型数据库是实现数据持久化最为重要的方式，它也是大多数应用在选择持久化方案时的首选技术。 NoSQL是一项全新的数据库革命性运动，虽然它的历史可以追溯到1998年，但是NoSQL真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为NoSQL是更适合大数据存储的技术方案，这才使得NoSQL的发展达到了前所未有的高度。2012年《纽约时报》的一篇专栏中写到，大数据时代已经降临，在商业、经济及其他领域中，决策将不再基于经验和直觉而是基于数据和分析而作出。事实上，在天文学、气象学、基因组学、生物学、社会学、互联网搜索引擎、金融、医疗、社交网络、电子商务等诸多领域，由于数据过于密集和庞大，在数据的分析和处理上也遇到了前所未有的限制和阻碍，这一切都使得对大数据处理技术的研究被提升到了新的高度，也使得各种NoSQL的技术方案进入到了公众的视野。 NoSQL数据库按照其存储类型可以大致分为以下几类： 类型 部分代表 特点 列族数据库 HBaseCassandraHypertable 顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的I/O优势，适合于批量数据处理和即时查询。 文档数据库 MongoDBCouchDBElasticSearch 文档数据库一般用类JSON格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。 KV数据库 DynamoDBRedisLevelDB 可以通过key快速查询到其value，有基于内存和基于磁盘两种实现方案。 图数据库 Neo4JFlockDBJanusGraph 使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。 对象数据库 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 说明：想了解更多的NoSQL数据库，可以访问http://nosql-database.org/。 Redis概述 Redis是一种基于键值对的NoSQL数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis还支持键过期、地理信息运算、发布订阅、事务、管道、Lua脚本扩展等功能，总而言之，Redis的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给Redis就可以了。目前，国内外很多著名的企业和商业项目都使用了Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。 Redis简介 2008年，一个名为Salvatore Sanfilippo的程序员为他开发的LLOOGG项目定制了专属的数据库（因为之前他无论怎样优化MySQL，系统性能已经无法再提升了），这项工作的成果就是Redis的初始版本。后来他将Redis的代码放到了全球最大的代码托管平台Github，从那以后，Redis引发了大量开发者的好评和关注，继而有数百人参与了Redis的开发和维护，这使得Redis的功能越来越强大和性能越来越好。 Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： Redis的读写性能极高，并且有丰富的特性（发布/订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog等。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。 Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。 Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。 Redis的应用场景 高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀/投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。 Redis的安装和配置 可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 wget http://download.redis.io/releases/redis-5.0.4.tar.gz gunzip redis-5.0.4.tar.gz tar -xvf redis-5.0.4.tar cd redis-5.0.4 make && make install 在redis源代码目录下有一个名为redis.conf的配置文件，我们可以先查看一下该文件。 vim redis.conf 配置将Redis服务绑定到指定的IP地址和端口。 配置底层有多少个数据库。 配置Redis的持久化机制 - RDB。 配置Redis的持久化机制 - AOF。 配置访问Redis服务器的验证口令。 配置Redis的主从复制，通过主从复制可以实现读写分离。 配置慢查询。 上面这些内容就是Redis的基本配置，如果你对上面的内容感到困惑也没有关系，先把Redis用起来再回头去推敲这些内容就行了。如果想找一些参考书，《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。 Redis的服务器和客户端 接下来启动Redis服务器，下面的方式将以默认的配置启动Redis服务。 redis-server 如果希望修改Redis的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。 方式一：通过参数指定认证口令和AOF持久化方式。 redis-server --requirepass 1qaz2wsx --appendonly yes 方式二：通过指定的配置文件来修改Redis的配置。 redis-server /root/redis-5.0.4/redis.conf 下面我们使用第一种方式来启动Redis并将其置于后台运行，将Redis产生的输出重定向到名为redis.log的文件中。 redis-server --requirepass 1qaz2wsx > redis.log & 可以通过ps或者netstat来检查Redis服务器是否启动成功。 ps -ef | grep redis-server netstat -nap | grep redis-server 接下来，我们尝试用Redis客户端去连接服务器。 redis-cli 127.0.0.1:6379> auth 1qaz2wsx OK 127.0.0.1:6379> ping PONG 127.0.0.1:6379> Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis命令参考，在这个网站上，除了Redis的命令参考，还有Redis的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。 说明：上面的插图来自付磊和张益军先生编著的《Redis开发与运维》一书。 127.0.0.1:6379> set username admin OK 127.0.0.1:6379> get username \"admin\" 127.0.0.1:6379> set password \"123456\" ex 300 OK 127.0.0.1:6379> get password \"123456\" 127.0.0.1:6379> ttl username (integer) -1 127.0.0.1:6379> ttl password (integer) 286 127.0.0.1:6379> hset stu1 name hao (integer) 0 127.0.0.1:6379> hset stu1 age 38 (integer) 1 127.0.0.1:6379> hset stu1 gender male (integer) 1 127.0.0.1:6379> hgetall stu1 1) \"name\" 2) \"hao\" 3) \"age\" 4) \"38\" 5) \"gender\" 6) \"male\" 127.0.0.1:6379> hvals stu1 1) \"hao\" 2) \"38\" 3) \"male\" 127.0.0.1:6379> hmset stu2 name wang age 18 gender female tel 13566778899 OK 127.0.0.1:6379> hgetall stu2 1) \"name\" 2) \"wang\" 3) \"age\" 4) \"18\" 5) \"gender\" 6) \"female\" 7) \"tel\" 8) \"13566778899\" 127.0.0.1:6379> lpush nums 1 2 3 4 5 (integer) 5 127.0.0.1:6379> lrange nums 0 -1 1) \"5\" 2) \"4\" 3) \"3\" 4) \"2\" 5) \"1\" 127.0.0.1:6379> lpop nums \"5\" 127.0.0.1:6379> lpop nums \"4\" 127.0.0.1:6379> rpop nums \"1\" 127.0.0.1:6379> rpop nums \"2\" 127.0.0.1:6379> sadd fruits apple banana orange apple grape grape (integer) 4 127.0.0.1:6379> scard fruits (integer) 4 127.0.0.1:6379> smembers fruits 1) \"grape\" 2) \"orange\" 3) \"banana\" 4) \"apple\" 127.0.0.1:6379> sismember fruits apple (integer) 1 127.0.0.1:6379> sismember fruits durian (integer) 0 127.0.0.1:6379> sadd nums1 1 2 3 4 5 (integer) 5 127.0.0.1:6379> sadd nums2 2 4 6 8 (integer) 4 127.0.0.1:6379> sinter nums1 nums2 1) \"2\" 2) \"4\" 127.0.0.1:6379> sunion nums1 nums2 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" 6) \"6\" 7) \"8\" 127.0.0.1:6379> sdiff nums1 nums2 1) \"1\" 2) \"3\" 3) \"5\" 127.0.0.1:6379> zadd topsinger 5234 zhangxy 1978 chenyx 2235 zhoujl 3520 xuezq (integer) 4 127.0.0.1:6379> zrange topsinger 0 -1 withscores 1) \"chenyx\" 2) \"1978\" 3) \"zhoujl\" 4) \"2235\" 5) \"xuezq\" 6) \"3520\" 7) \"zhangxy\" 8) \"5234\" 127.0.0.1:6379> zrevrange topsinger 0 -1 1) \"zhangxy\" 2) \"xuezq\" 3) \"zhoujl\" 4) \"chenyx\" 127.0.0.1:6379> geoadd pois 116.39738549206541 39.90862689286386 tiananmen 116.27172936413572 39.99 135172904494 yiheyuan 117.27766503308104 40.65332064313784 gubeishuizhen (integer) 3 127.0.0.1:6379> geodist pois tiananmen gubeishuizhen km \"111.5333\" 127.0.0.1:6379> geodist pois tiananmen yiheyuan km \"14.1230\" 127.0.0.1:6379> georadius pois 116.86499108288572 40.40149669363615 50 km withdist 1) 1) \"gubeishuizhen\" 2) \"44.7408\" 在Python程序中使用Redis 可以使用pip安装redis模块。redis模块的核心是名为Redis的类，该类的对象代表一个Redis客户端，通过该客户端可以向Redis服务器发送命令并获取执行的结果。上面我们在Redis客户端中使用的命令基本上就是Redis对象可以接收的消息，所以如果了解了Redis的命令就可以在Python中玩转Redis。 pip3 install redis python3 >>> import redis >>> client = redis.Redis(host='1.2.3.4', port=6379, password='1qaz2wsx') >>> client.set('username', 'admin') True >>> client.hset('student', 'name', 'hao') 1 >>> client.hset('student', 'age', 38) 1 >>> client.keys('*') [b'username', b'student'] >>> client.get('username') b'admin' >>> client.hgetall('student') {b'name': b'hao', b'age': b'38'} MongoDB概述 MongoDB简介 MongoDB是2009年问世的一个面向文档的数据库管理系统，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB被认为是NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。 MongoDB将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB对JSON进行了二进制处理（能够更快的定位key和value），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章《JSON and BSON》。 目前，MongoDB已经提供了对Windows、MacOS、Linux、Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python当然是其中之一。 MongoDB的安装和配置 可以从MongoDB的官方下载链接下载MongoDB，官方为Windows系统提供了一个Installer程序，而Linux和MacOS则提供了压缩文件。下面简单说一下Linux系统如何安装和配置MongoDB。 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.6.5.tgz gunzip mongodb-linux-x86_64-amazon-3.6.5.tgz mkdir mongodb-3.6.5 tar -xvf mongodb-linux-x86_64-amazon-3.6.5.tar --strip-components 1 -C mongodb-3.6.5/ export PATH=$PATH:~/mongodb-3.6.5/bin mkdir -p /data/db mongod --bind_ip 172.18.61.250 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] MongoDB starting : pid=1163 port=27017 dbpath=/data/db 64-bit host=iZwz97tbgo9lkabnat2lo8Z 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] db version v3.6.5 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.0-fips29 Mar 2010 ... 2018-06-03T18:03:28.945+0800 I NETWORK [initandlisten] waiting for connections on port 27017 说明：上面的操作中，export命令是设置PATH环境变量，这样可以在任意路径下执行mongod来启动MongoDB服务器。MongoDB默认保存数据的路径是/data/db目录，为此要提前创建该目录。此外，在使用mongod启动MongoDB服务器时，--bind_ip参数用来将服务绑定到指定的IP地址，也可以用--port参数来指定端口，默认端口为27017。 MongoDB基本概念 我们通过与关系型数据库进行对照的方式来说明MongoDB中的一些概念。 SQL MongoDB 解释（SQL/MongoDB） database database 数据库/数据库 table collection 二维表/集合 row document 记录（行）/文档 column field 字段（列）/域 index index 索引/索引 table joins --- 表连接/嵌套文档 primary key primary key 主键/主键（_id字段） 通过Shell操作MongoDB 启动服务器后可以使用交互式环境跟服务器通信，如下所示。 mongo --host 172.18.61.250 MongoDB shell version v3.6.5 connecting to: mongodb://172.18.61.250:27017/ 查看、创建和删除数据库。 > // 显示所有数据库 > show dbs admin 0.000GB config 0.000GB local 0.000GB > // 创建并切换到school数据库 > use school switched to db school > // 删除当前数据库 > db.dropDatabase() { \"ok\" : 1 } > 创建、删除和查看集合。 > // 创建并切换到school数据库 > use school switched to db school > // 创建colleges集合 > db.createCollection('colleges') { \"ok\" : 1 } > // 创建students集合 > db.createCollection('students') { \"ok\" : 1 } > // 查看所有集合 > show collections colleges students > // 删除colleges集合 > db.colleges.drop() true > 说明：在MongoDB中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过创建文档来创建集合。 文档的CRUD操作。 > // 向students集合插入文档 > db.students.insert({stuid: 1001, name: '骆昊', age: 38}) WriteResult({ \"nInserted\" : 1 }) > // 向students集合插入文档 > db.students.save({stuid: 1002, name: '王大锤', tel: '13012345678', gender: '男'}) WriteResult({ \"nInserted\" : 1 }) > // 查看所有文档 > db.students.find() { \"_id\" : ObjectId(\"5b13c72e006ad854460ee70b\"), \"stuid\" : 1001, \"name\" : \"骆昊\", \"age\" : 38 } { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } > // 更新stuid为1001的文档 > db.students.update({stuid: 1001}, {'$set': {tel: '13566778899', gender: '男'}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > // 插入或更新stuid为1003的文档 > db.students.update({stuid: 1003}, {'$set': {name: '白元芳', tel: '13022223333', gender: '男'}}, upsert=true) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\") }) > // 查询所有文档 > db.students.find().pretty() { \"_id\" : ObjectId(\"5b13c72e006ad854460ee70b\"), \"stuid\" : 1001, \"name\" : \"骆昊\", \"age\" : 38, \"gender\" : \"男\", \"tel\" : \"13566778899\" } { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } { \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\"), \"stuid\" : 1003, \"gender\" : \"男\", \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询stuid大于1001的文档 > db.students.find({stuid: {'$gt': 1001}}).pretty() { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } { \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\"), \"stuid\" : 1003, \"gender\" : \"男\", \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询stuid大于1001的文档只显示name和tel字段 > db.students.find({stuid: {'$gt': 1001}}, {_id: 0, name: 1, tel: 1}).pretty() { \"name\" : \"王大锤\", \"tel\" : \"13012345678\" } { \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询name为“骆昊”或者tel为“13022223333”的文档 > db.students.find({'$or': [{name: '骆昊'}, {tel: '13022223333'}]}, {_id: 0, name: 1, tel: 1}).pretty() { \"name\" : \"骆昊\", \"tel\" : \"13566778899\" } { \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询学生文档跳过第1条文档只查1条文档 > db.students.find().skip(1).limit(1).pretty() { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } > // 对查询结果进行排序(1表示升序，-1表示降序) > db.students.find({}, {_id: 0, stuid: 1, name: 1}).sort({stuid: -1}) { \"stuid\" : 1003, \"name\" : \"白元芳\" } { \"stuid\" : 1002, \"name\" : \"王大锤\" } { \"stuid\" : 1001, \"name\" : \"骆昊\" } > // 在指定的一个或多个字段上创建索引 > db.students.ensureIndex({name: 1}) { \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1 } > 使用MongoDB可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于MongoDB更多的操作可以查阅官方文档 ，同时推荐大家阅读Kristina Chodorow写的《MongoDB权威指南》。 在Python程序中操作MongoDB 可以通过pip安装pymongo来实现对MongoDB的操作。 pip3 install pymongo python3 >>> from pymongo import MongoClient >>> client = MongoClient('mongodb://127.0.0.1:27017') >>> db = client.school >>> for student in db.students.find(): ... print('学号:', student['stuid']) ... print('姓名:', student['name']) ... print('电话:', student['tel']) ... 学号: 1001.0 姓名: 骆昊 电话: 13566778899 学号: 1002.0 姓名: 王大锤 电话: 13012345678 学号: 1003.0 姓名: 白元芳 电话: 13022223333 >>> db.students.find().count() 3 >>> db.students.remove() {'n': 3, 'ok': 1.0} >>> db.students.find().count() 0 >>> coll = db.students >>> from pymongo import ASCENDING >>> coll.create_index([('name', ASCENDING)], unique=True) 'name_1' >>> coll.insert_one({'stuid': int(1001), 'name': '骆昊', 'gender': True}) >>> coll.insert_many([{'stuid': int(1002), 'name': '王大锤', 'gender': False}, {'stuid': int(1003), 'name': '白元芳', 'gender': True}]) >>> for student in coll.find({'gender': True}): ... print('学号:', student['stuid']) ... print('姓名:', student['name']) ... print('性别:', '男' if student['gender'] else '女') ... 学号: 1001 姓名: 骆昊 性别: 男 学号: 1003 姓名: 白元芳 性别: 男 >>> 关于PyMongo更多的知识可以通过它的官方文档进行了解，也可以使用MongoEngine这样的库来简化Python程序对MongoDB的操作，除此之外，还有以异步I/O方式访问MongoDB的三方库motor都是不错的选择。 "},"Database/NoSQL/Redis/02-Redis安装与配置文件.html":{"url":"Database/NoSQL/Redis/02-Redis安装与配置文件.html","title":"Redis安装与配置文件","keywords":"","body":"datetime:2019/10/30 16:26 author:nzb Redis安装与配置文件 安装 Linux安装 可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 wget http://download.redis.io/releases/redis-5.0.4.tar.gz gunzip redis-5.0.4.tar.gz tar -xvf redis-5.0.4.tar cd redis-5.0.4 make && make install Docker安装 搜索镜像 docker search redis 拉取镜像 docker pull redis 创建redis容器 docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/data:/data redis --requirepass \"123456\" --appendonly yes 创建redis容器（指定配置文件） docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/config:/usr/local/redis/conf/redis.conf -v /usr/local/redis/data:/data redis redis-server /usr/local/redis/conf/redis.conf --requirepass \"123456\" --appendonly yes docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/data:/data redis --requirepass \"123456\" --appendonly yes 参数说明： -p 6379:6379　　//容器redis端口6379映射宿主主机6379 --name redis　　//容器名字为redis -v /usr/local/redis/conf:/usr/local/redis/conf/redis.conf//docker镜像redis默认无配置文件，在宿主主机/usr/local/redis/conf下创建redis.conf配置文件，会将宿主机的配置文件复制到docker中(加上这参数会报错) -v /root/redis/redis01/data:/data　　//容器/data映射到宿主机 /usr/local/redis/data下 -d redis 　　//后台模式启动redis redis-server /usr/local/redis/conf/redis.conf//redis将以/usr/local/redis/conf/redis.conf为配置文件启动(加上这参数会报错) --appendonly yes　　//开启redis的AOF持久化，默认为false，不持久化 redis.conf配置文件详解 # Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no # 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid # 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口， 因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 # 绑定的主机地址 bind 127.0.0.1 # 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 # 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning， 默认为verbose loglevel verbose # 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志 记录方式为标准输出，则日志将会发送给/dev/null logfile stdout # 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 # 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 # 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 # 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， 可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes # 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb # 指定本地数据库存放目录 dir ./ # 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof # 当master服务设置了密码保护时，slav服务连接master的密码 masterauth # 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared # 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数， 如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端 返回max number of clients reached错误信息 maxclients 128 # 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key， 当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存， Value会存放在swap区 maxmemory # 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no # 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof # 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec # 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上， 访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no # 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap # 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 # Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享， vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes； 如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 # 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 # 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的， 可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 # 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes # 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 # 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes # 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf ----------------------------------------------------------------------------- # daemonize no 默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes daemonize yes # 当 redis 在后台运行的时候， Redis 默认会把 pid 文件放在 /var/run/redis.pid ，你可以配置到其他地址。 # 当运行多个 redis 服务时，需要指定不同的 pid 文件和端口 pidfile /var/run/redis_6379.pid # 指定 redis 运行的端口，默认是 6379 port 6379 # 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志 tcp-backlog 511 # 指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求 # bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 # 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接 # 0 是关闭此设置 timeout 0 # TCP keepalive # 在 Linux 上，指定值（秒）用于发送 ACKs 的时间。注意关闭连接需要双倍的时间。默认为 0 。 tcp-keepalive 0 # 指定日志记录级别，生产环境推荐 notice # Redis 总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 verbose # debug 记录很多信息，用于开发和测试 # varbose 有用的信息，不像 debug 会记录那么多 # notice 普通的 verbose ，常用于生产环境 # warning 只有非常重要或者严重的信息会记录到日志 loglevel notice # 配置 log 文件地址 # 默认值为 stdout ，标准输出，若后台模式会输出到 /dev/null 。 logfile /var/log/redis/redis.log # 可用数据库数 # 默认值为 16 ，默认数据库为 0 ，数据库范围在 0- （ database-1 ）之间 databases 16 ################################ 快照################################# # 保存数据到磁盘，格式如下 : # save # 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件 rdb 。 # 相当于条件触发抓取快照，这个可以多个条件配合 # 比如默认配置文件中的设置，就设置了三个条件 # save 900 1 900 秒内至少有 1 个 key 被改变 # save 300 10 300 秒内至少有 300 个 key 被改变 # save 60 10000 60 秒内至少有 10000 个 key 被改变 save 900 1 save 300 10 save 60 10000 # 后台存储错误停止写。 stop-writes-on-bgsave-error yes # 存储至本地数据库时（持久化到 rdb 文件）是否压缩数据，默认为 yes rdbcompression yes # 对rdb数据进行校验,耗费CPU资源,默认为yes rdbchecksum yes # 本地持久化数据库文件名，默认值为 dump.rdb dbfilename dump.rdb # 工作目录 # 数据库镜像备份的文件放置的路径。 # 这里的路径跟文件名要分开配置是因为 redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成， # 再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。 # AOF文件也会存放在这个目录下面 # 注意这里必须制定一个目录而不是文件 dir /var/lib/redis-server/ ################################# 复制 ################################# # 主从复制 . 设置该数据库为其他数据库的从数据库 . # 设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 # slaveof # 当 master 服务设置了密码保护时 ( 用 requirepass 制定的密码 ) # slave 服务连接 master 的密码 # masterauth # 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式： # 1) 如果 slave-serve-stale-data 设置为 yes( 默认设置 ) ，从库会继续响应客户端的请求 # 2) 如果 slave-serve-stale-data 是指为 no ，出去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个 # 错误 \"SYNC with master in progress\" slave-serve-stale-data yes # 配置 slave 实例是否接受写。写 slave 对存储短暂数据（在同 master 数据同步后可以很容易地被删除）是有用的，但未配置的情况下，客户端写可能会发送问题。 # 从 Redis2.6 后，默认 slave 为 read-only slaveread-only yes # 从库会按照一个时间间隔向主库发送 PINGs. 可以通过 repl-ping-slave-period 设置这个时间间隔，默认是 10 秒 # repl-ping-slave-period 10 # repl-timeout 设置主库批量数据传输时间或者 ping 回复时间间隔，默认值是 60 秒 # 一定要确保 repl-timeout 大于 repl-ping-slave-period # repl-timeout 60 # 在 slave socket 的 SYNC 后禁用 TCP_NODELAY # 如果选择“ yes ” ,Redis 将使用一个较小的数字 TCP 数据包和更少的带宽将数据发送到 slave ， 但是这可能导致数据发送到 slave 端会有延迟 , 如果是 Linux kernel 的默认配置，会达到 40 毫秒 # 如果选择 \"no\" ，则发送数据到 slave 端的延迟会降低，但将使用更多的带宽用于复制 . repl-disable-tcp-nodelay no # 设置复制的后台日志大小。 # 复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。 # 后台日志在至少有一个 slave 连接时，仅仅分配一次。 # repl-backlog-size 1mb # 在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。 # 0 意味着从不释放后台日志 # repl-backlog-ttl 3600 # 如果 master 不能再正常工作，那么会在多个 slave 中，选择优先值最小的一个 slave 提升为 master ，优先值为 0 表示不能提升为 master 。 slave-priority 100 # 如果少于 N 个 slave 连接，且延迟时间 利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用 Least RecentlyUsed ) # allkeys-lru -> 利用 LRU 算法移除任何 key # volatile-random -> 移除设置过过期时间的随机 key # allkeys->random -> remove a randomkey, any key # volatile-ttl -> 移除即将过期的 key(minor TTL) # noeviction -> 不移除任何可以，只是返回一个写错误 # 注意：对于上面的策略，如果没有合适的 key 可以移除，当写的时候 Redis 会返回一个错误 # 默认是 : volatile-lru # maxmemory-policy volatile-lru # LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法 ( 为了节省内存 ) ，随意你可以选择样本大小进行检测。 # Redis 默认的灰选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置 # maxmemory-samples 3 ############################## AOF############################### # 默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。 # 所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。 # 开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到 appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。 # 但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对 appendonly.aof 进行重新整理。 # 你可以同时开启 asynchronous dumps 和 AOF appendonly no # AOF 文件名称 ( 默认 : \"appendonly.aof\") # appendfilename appendonly.aof # Redis 支持三种同步 AOF 文件的策略 : # no: 不进行同步，系统去操作 . Faster. # always: always 表示每次有写操作都进行同步 . Slow, Safest. # everysec: 表示对写操作进行累积，每秒同步一次 . Compromise. # 默认是 \"everysec\" ，按照速度和安全折中这是最好的。 # 如果想让 Redis 能更高效的运行，你也可以设置为 \"no\" ，让操作系统决定什么时候去执行 # 或者相反想让数据更安全你也可以设置为 \"always\" # 如果不确定就用 \"everysec\". # appendfsync always appendfsync everysec # appendfsync no # AOF 策略设置为 always 或者 everysec 时，后台处理进程 ( 后台保存或者 AOF 日志重写 ) 会执行大量的 I/O 操作 # 在某些 Linux 配置中会阻止过长的 fsync() 请求。注意现在没有任何修复，即使 fsync 在另外一个线程进行处理 # 为了减缓这个问题，可以设置下面这个参数 no-appendfsync-on-rewrite no-appendfsync-on-rewrite no # AOF 自动重写 # 当 AOF 文件增长到一定大小的时候 Redis 能够调用 BGREWRITEAOF 对日志文件进行重写 # 它是这样工作的： Redis 会记住上次进行些日志后文件的大小 ( 如果从开机以来还没进行过重写，那日子大小在开机的时候确定 ) # 基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动 # 同时需要指定一个最小大小用于 AOF 重写，这个用于阻止即使文件很小但是增长幅度很大也去重写 AOF 文件的情况 # 设置percentage 为 0 就关闭这个特性 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb ################################ LUASCRIPTING ############################# # 一个 Lua 脚本最长的执行时间为 5000 毫秒（ 5 秒），如果为 0 或负数表示无限执行时间。 lua-time-limit 5000 ################################LOW LOG################################ # Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括 I/O 计算比如连接客户端，返回结果等，只是命令执行时间 # 可以通过两个参数设置 slow log ：一个是告诉 Redis 执行超过多少时间被记录的参数 slowlog-log-slower-than( 微妙 ) ， # 另一个是 slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除 # 下面的时间以微妙为单位，因此 1000000 代表一秒。 # 注意指定一个负数将关闭慢日志，而设置为 0 将强制每个命令都会记录 slowlog-log-slower-than 10000 # 对日志长度没有限制，只是要注意它会消耗内存 # 可以通过 SLOWLOG RESET 回收被慢日志消耗的内存 # 推荐使用默认值 128 ，当慢日志超过 128 时，最先进入队列的记录会被踢出 slowlog-max-len 128 ################################ 事件通知 ############################# # 当事件发生时， Redis 可以通知 Pub/Sub 客户端。 # 可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识： # K Keyspace 事件，以 _keyspace@_ 的前缀方式发布 # E Keyevent 事件，以 _keysevent@_ 的前缀方式发布 # g 通用事件（不指定类型），像 DEL, EXPIRE, RENAME, … # $ String 命令 # s Set 命令 # h Hash 命令 # z 有序集合命令 # x 过期事件（每次 key 过期时生成） # e 清除事件（当 key 在内存被清除时生成） # A g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件 # notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。 # 例子：启用 list 和通用事件： # notify-keyspace-events Elg # 默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。 # 注意如果你不指定至少 K 或 E 之一，不会发送任何事件。 notify-keyspace-events “” ############################## 高级配置 ############################### # 当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时， # hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值 # Redis Hash 对应 Value 内部实际就是一个 HashMap ，实际这里会有 2 种不同实现， # 这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 valueredisObject 的 encoding 为 zipmap, # 当成员数量增大时会自动转成真正的 HashMap, 此时 encoding 为 ht 。 hash-max-zipmap-entries 512 hash-max-zipmap-value 64 # 和 Hash 一样，多个小的 list 以特定的方式编码来节省空间。 # list 数据类型节点值大小小于多少字节会采用紧凑存储格式。 list-max-ziplist-entries 512 list-max-ziplist-value 64 # set 数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。 set-max-intset-entries 512 # 和 hashe 和 list 一样 , 排序的 set 在指定的长度内以指定编码方式存储以节省空间 # zsort 数据类型节点值大小小于多少字节会采用紧凑存储格式。 zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash ，可以降低内存的使用 # 当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no 。 # 如果没有这么严格的实时性要求，可以设置为 yes ，以便能够尽可能快的释放内存 activerehashing yes # 客户端的输出缓冲区的限制，因为某种原因客户端从服务器读取数据的速度不够快， # 可用于强制断开连接（一个常见的原因是一个发布 / 订阅客户端消费消息的速度无法赶上生产它们的速度）。 # 可以三种不同客户端的方式进行设置： # normal -> 正常客户端 # slave -> slave 和 MONITOR 客户端 # pubsub -> 至少订阅了一个 pubsub channel 或 pattern 的客户端 # 每个 client-output-buffer-limit 语法 : # client-output-buffer-limit # 一旦达到硬限制客户端会立即断开，或者达到软限制并保持达成的指定秒数（连续）。 # 例如，如果硬限制为 32 兆字节和软限制为 16 兆字节 /10 秒，客户端将会立即断开 # 如果输出缓冲区的大小达到 32 兆字节，客户端达到 16 兆字节和连续超过了限制 10 秒，也将断开连接。 # 默认 normal 客户端不做限制，因为他们在一个请求后未要求时（以推的方式）不接收数据， # 只有异步客户端可能会出现请求数据的速度比它可以读取的速度快的场景。 # 把硬限制和软限制都设置为 0 来禁用该特性 client-output-buffer-limit normal 0 0 0 client-output-buffer-limit slave 256mb 64mb60 client-output-buffer-limit pubsub 32mb 8mb60 # Redis 调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除过期的 Key ，等等。 # 不是所有的任务都以相同的频率执行，但 Redis 依照指定的“ Hz ”值来执行检查任务。 # 默认情况下，“ Hz ”的被设定为 10 。 # 提高该值将在 Redis 空闲时使用更多的 CPU 时，但同时当有多个 key 同时到期会使 Redis 的反应更灵敏，以及超时可以更精确地处理。 # 范围是 1 到 500 之间，但是值超过 100 通常不是一个好主意。 # 大多数用户应该使用 10 这个预设值，只有在非常低的延迟的情况下有必要提高最大到 100 。 hz 10 # 当一个子节点重写 AOF 文件时，如果启用下面的选项，则文件每生成 32M 数据进行同步。 aof-rewrite-incremental-fsync yes "},"Database/NoSQL/Redis/01-Redis基础.html":{"url":"Database/NoSQL/Redis/01-Redis基础.html","title":"Redis基础","keywords":"","body":"datetime:2019/10/31 16:02 author:nzb Redis基础 应用场景 EXPIRE key seconds 限时的优惠活动信息 网站数据缓存(对于一些需要定时更新的数据,例如:积分排行榜) 手机验证码 限制网站访客访问频率(例如：1分钟最多访问10次) Redis键(key) DEL key 该命令用于在 key 存在时删除 key(所有类型都可以使用)。 DUMP key 序列化给定 key ，并返回被序列化的值。 EXISTS key 检查给定 key 是否存在。 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 KEYS pattern 查找所有符合给定模式( pattern)的 key 。 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。 示例： ```text # key 存在于当前数据库 redis> SELECT 0 # redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。 OK redis> SET song \"secret base - Zone\" OK redis> MOVE song 1 # 将 song 移动到数据库 1 (integer) 1 redis> EXISTS song # song 已经被移走 (integer) 0 redis> SELECT 1 # 使用数据库 1 OK redis:1> EXISTS song # 证实 song 被移到了数据库 1 (注意命令提示符变成了\"redis:1\"，表明正在使用数据库 1) (integer) 1 # 当 key 不存在的时候 redis:1> EXISTS fake_key (integer) 0 redis:1> MOVE fake_key 0 # 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败 (integer) 0 redis:1> select 0 # 使用数据库0 OK redis> EXISTS fake_key # 证实 fake_key 不存在 (integer) 0 # 当源数据库和目标数据库有相同的 key 时 redis> SELECT 0 # 使用数据库0 OK redis> SET favorite_fruit \"banana\" OK redis> SELECT 1 # 使用数据库1 OK redis:1> SET favorite_fruit \"apple\" OK redis:1> SELECT 0 # 使用数据库0，并试图将 favorite_fruit 移动到数据库 1 OK redis> MOVE favorite_fruit 1 # 因为两个数据库有相同的 key，MOVE 失败 (integer) 0 redis> GET favorite_fruit # 数据库 0 的 favorite_fruit 没变 \"banana\" redis> SELECT 1 OK redis:1> GET favorite_fruit # 数据库 1 的 favorite_fruit 也是 \"apple\" ``` PERSIST key 移除 key 的过期时间，key 将持久保持。 示例 redis> SET mykey \"Hello\" OK redis> EXPIRE mykey 10 # 为 key 设置生存时间 (integer) 1 redis> TTL mykey (integer) 10 redis> PERSIST mykey # 移除 key 的生存时间 (integer) 1 redis> TTL mykey (integer) -1 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 示例 ```text # 不存在的 key redis> FLUSHDB OK redis> TTL key (integer) -2 # key 存在，但没有设置剩余生存时间 redis> SET key value OK redis> TTL key (integer) -1 # 有剩余生存时间的 key redis> EXPIRE key 10086 (integer) 1 redis> TTL key (integer) 10084 ``` RANDOMKEY 从当前数据库中随机返回一个 key 。 RENAME key newkey 修改 key 的名称 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。 TYPE key 返回 key 所储存的值的类型。 key的命名规范 redis 单个key存入512M大小 key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且降低查找的效率 key也不要太短，太短的话，key的可读性会降低 在一个项目中，key最好使用统一的命名模式，例如：user:123:password(推荐\":\"，不建议\"_\"，因为程序里面有的变量是以下划线连接的) Redis 字符串(String) SET key value SET 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。 GET key Get 命令用于获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误。 SETNX key value只有在 key 不存在时设置 key 的值。应用于解决分布式锁方案之一 INCR key 将 key 中储存的数字值增一。 INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 DECR key 将 key 中储存的数字值减一。 DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 GETRANGE key start end 返回 key 中字符串值的子字符 GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 STRLEN key 返回 key 所储存的字符串值的长度。 MSET key value [key value ...] 同时设置一个或多个 key-value 对。 MSETNX key value [key value ...] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 应用场景 String通常应用于保存单个字符串或json字符串数据 因String是二进制安全的，所有完全可以把一个图片文件的内容作为字符串来存储 计算器(通常key-value缓存一样，常规计数：微博数，粉丝数) INCR等指令就具有原子操作的特性，所有完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。 Redis 哈希(Hash) Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 HDEL key field1 [field2] 删除一个或多个哈希表字段 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field 获取存储在哈希表中指定字段的值。 HGETALL key 获取在哈希表中指定 key 的所有字段和值 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 HKEYS key 获取所有哈希表中的字段 HLEN key 获取哈希表中字段的数量 HMGET key field1 [field2] 获取所有给定字段的值 HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HVALS key 获取哈希表中所有值 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 应用场景 常用与存储一个对象 为什么不用String存储一个对象？ 因为hash是最接近关系数据库结果的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中 Redis 列表(List) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 LINDEX key index 通过索引获取列表中的元素 LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素 LLEN key 获取列表长度 LPOP key 移出并获取列表的第一个元素 LPUSH key value1 [value2] 将一个或多个值插入到列表头部 LPUSHX key value 将一个值插入到已存在的列表头部 LRANGE key start stop 获取列表指定范围内的元素 LREM key count value 移除列表元素 LSET key index value 通过索引设置列表元素的值 LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 RPOP key 移除列表的最后一个元素，返回值为移除的元素。 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 RPUSH key value1 [value2] 在列表中添加一个或多个值 RPUSHX key value 为已存在的列表添加值 应用场景(1、对数据量大的集合数据删减 2、任务队列 ) 对数据量大的集合数据删减：列表数据显示、关注列表、粉丝列表、留言评价等...分页、热点新闻(top)等。利用LANGE还可以很方便的实现分页的功能，在博客系统中，每片博文的评论也可以存入一个单独的list中。 任务队列(list通常用来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样需要通过ORDER BY 来进行排序) 任务队列介绍(生产者和消费者模式) 在处理Web客服端发送的命令请求时，某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理，用户可以推迟执行那些需要一段时间才能完成的操作，这种将工作交给任务处理器来执行的做法被称为任务队列(task queue) 常用案例：订单系统的下单流程、用户系统登录注册短信等。 Redis 集合(Set) Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 SADD key member1 [member2] 向集合添加一个或多个成员 SCARD key 获取集合的成员数 SDIFF key1 [key2] 返回给定所有集合的差集 SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中 SINTER key1 [key2] 返回给定所有集合的交集 SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 SMEMBERS key 返回集合中的所有成员 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 SPOP key 移除并返回集合中的一个随机元素 SRANDMEMBER key [count] 返回集合中一个或多个随机数 SREM key member1 [member2] 移除集合中一个或多个成员 SUNION key1 [key2] 返回所有给定集合的并集 SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中 SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素 应用场景 常应用于：对两个集合间的数据[计算]进行交集、并集、差集运算 1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。 2、利用唯一性，可以统计访问网站的所有独立 IP Redis 有序集合(sorted set) Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间分数的成员数 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment ZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员 ZRANK key member 返回有序集合中指定成员的索引 ZREM key member [member ...] 移除有序集合中的一个或多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZSCORE key member 返回有序集中，成员的分数值 ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） 应用场景 常应用于：排行榜 比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。 还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 Redis 发布订阅 PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。 SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。 PUBLISH channel message 将信息发送到指定的频道。 PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。 UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。 应用场景 这一功能最明显的用法就是构建实时消息系统，比如普通的即时聊天，群聊等功能 在一个博客网站中，有100个粉丝订阅了你，当你发布新文章，就可以推送消息给粉丝们。 微信公众号模式 Redis多数据库 Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。 redis配置文件中下面的参数来控制数据库总数： database 16 //(从0开始 1 2 3 …15) select 数据库//数据库的切换 移动数据（将当前key移动另个库) move key名称 数据库 数据库清空： flushdb //清除当前数据库的所有key flushall //清除整个Redis的数据库所有key Redis 事务 Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 DISCARD 取消事务，放弃执行事务块内的所有命令。 EXEC 执行所有事务块内的命令。 MULTI 标记一个事务块的开始。 UNWATCH 取消 WATCH 命令对所有 key 的监视。 WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 Redis数据淘汰策略redis.conf Redis官方给的警告，当内存不足时，Redis会根据配置的缓存策略淘汰部分Keys，以保证写入成功。当无淘汰策略时或没有找到适合淘汰的Key时，Redis直接返回out of memory错误。 最大缓存配置 在 redis 中，允许用户设置最大使用内存大小 maxmemory 512G redis 提供6种数据淘汰策略： volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-lfu：从已设置过期的Keys中，删除一段时间内使用次数最少使用的 volatile-ttl：从已设置过期时间的数据集中挑选最近将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集中随机选择数据淘汰 allkeys-lru：从数据集中挑选最近最少使用的数据淘汰 allkeys-lfu：从所有Keys中，删除一段时间内使用次数最少使用的 allkeys-random：从数据集中随机选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据(不采用任何淘汰策略。默认即为此配置),针对写操作，返回错误信息 建议：了解了Redis的淘汰策略之后，在平时使用时应尽量主动设置/更新key的expire时间，主动剔除不活跃的旧数据，有助于提升查询性能 Redis持久化 数据存放于： 内存：高效、断电（关机）内存数据会丢失 硬盘：读写速度慢于内存，断电数据不会丢失 RDB RDB：是redis的默认持久化机制。 RDB相当于照快照，保存的是一种状态。 几十G数据 --> 几KB快照 快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。 优点： 快照保存数据极快、还原数据极快 适用于灾难备份 缺点：小内存机器不适合使用,RDB机制符合要求就会照快照 快照条件： 1、服务器正常关闭时 ./bin/redis-cli shutdown 2、key满足一定条件，会进行快照 save 900 1 //每900秒（15分钟）至少1个key发生变化，产生快照 save 300 10 //每300秒（5分钟）至少10个key发生变化，产生快照 save 60 10000 //每60秒（1分钟）至少10000个key发生变化，产生快照 AOF 由于快照方式是在一定间隔时间做一次的，所以如果redis 意外down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof 持久化方式。 Append-only file:aof 比快照方式有更好的持久化性，是由于在使用aof 持久化方式时,redis 会将每一个收到的写命令都通过write 函数追加到文件中(默认是appendonly.aof)。当redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 有三种方式如下（默认是：每秒 fsync 一次） appendonly yes //启用 aof 持久化方式 appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化 appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中 appendfsync no //完全依赖 os，性能最好,持久化没保证 产生的问题： aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。 redis缓存与数据库(MySQL)一致性方案 一、实时同步 对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。 @Cacheable：查询时使用，注意Long类型需转换为Sting类型，否则会抛异常 @CachePut：更新时使用，使用此注解，一定会从DB上查询数据 @CacheEvict：删除时使用； @Caching：组合用法 二、异步队列 对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。 三、使用阿里的同步工具canal canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) 四、采用UDF自定义函数的方式 面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。 总结： 穿透 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决办法： 持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回， 注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间） 雪崩 雪崩：缓存大量失效的时候，引发大量查询数据库。 解决办法： 用锁/分布式锁或者队列串行访问 缓存失效时间均匀分布 热点key 热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。 解决办法： 使用锁，单机用synchronized,lock等，分布式用分布式锁。 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。 在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。 设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存 "},"Database/NoSQL/Redis/03-Redis开发规范.html":{"url":"Database/NoSQL/Redis/03-Redis开发规范.html","title":"Redis开发规范","keywords":"","body":"datetime:2022/06/30 author:nzb Redis开发规范 一、键值设计 1. key名设计 (1)【建议】: 可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id ugc:video:1 因为很多Redis客户端是根据冒号分类的。比如有几个Key：apps:app:1、apps:app:2和apps:app:3。Redis Desktop Manager能自动归类到apps目录下。如下图所示： (2)【建议】：简洁性 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如： user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。 (3)【强制】：不要包含特殊字符 反例：包含空格、换行、单双引号以及其他转义字符 详细解析 2. value设计 (1)【强制】：拒绝bigkey(防止网卡流量、慢查询) string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。 这是因为Redis随着Value不断增长，在超过10KB后，有一个非常奇妙的性能拐点，如下图所示（图片来自Redis官网) 反例：一个包含200万个元素的list。 非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法。 详细解析 (2)【推荐】：选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡) 反例： set user:1:name tom set user:1:age 19 set user:1:favor football 正例: hmset user:1 name tom age 19 favor football 3.【推荐】：控制key的生命周期，redis不是垃圾桶。 建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。 二、命令使用 1.【推荐】 O(N)命令关注N的数量 例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。 2.【推荐】：禁用命令 禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。 3.【推荐】合理使用select redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。 4.【推荐】使用批量操作提高效率 原生命令：例如mget、mset。 非原生命令：可以使用pipeline提高效率。 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。 注意两者不同： 原生是原子操作，pipeline是非原子操作。 pipeline可以打包不同的命令，原生做不到 pipeline需要客户端和服务端同时支持。 5.【建议】Redis事务功能较弱，不建议过多使用 Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决) 6.【建议】Redis集群版本在使用Lua上有特殊要求： 1.所有key都应该由 KEYS 数组来传递redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，\"-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array\" 2.所有key，必须在1个slot上，否则直接返回error, \"-ERR eval/evalsha command keys must in same slot\" 7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。 monitor命令一般是用来观察redis服务端都在执行哪些命令并实时输出。例如在其他redis-cli中执行两个set命令，在monitor中监控结果如下： $ redis-cli -h 172.31.239.79 monitor OK 1638616687.781190 [15 172.19.0.3:55276] \"COMMAND\" 1638616687.781277 [15 172.19.0.3:55276] \"set\" \"name\" \"Charles\" 1638616687.789198 [15 172.19.0.3:55276] \"publish\" \"socket.io…..\" 之所以规范建议控制monitor命令的使用时间，是因为随着monitor命令执行时间越来越长，会导致越来越多的数据积压在输出缓冲区，从而导致输出缓冲区占用内存越来越大。而且，这种影响会由于Redis并发越高，而更加放大。 三、客户端使用 1.【推荐】避免多个应用使用一个Redis实例 正例：不相干的业务拆分，公共数据做服务化。 2.【推荐】使用带有连接池的数据库，可以有效控制连接，同时提高效率 3.【建议】高并发下建议客户端添加熔断功能 例如netflix hystrix 4.【推荐】设置合理的密码 如有必要可以使用SSL加密访问（阿里云Redis支持） 5.【建议】最大内存淘汰策略 根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。 其他策略如下： allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random：随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息 \"(error) OOM command not allowed when used memory\"，此时Redis只响应读操作。 四、相关工具 1.【推荐】数据同步 redis间数据同步可以使用：redis-port 2.【推荐】big key搜索 3.【推荐】热点key寻找 内部实现使用monitor，所以建议短时间使用 五 附录：删除 bigkey 下面操作可以使用pipeline加速。 redis 4.0已经支持key的异步删除，欢迎使用。 1. Hash删除: hscan + hdel 2. List删除: ltrim 3. Set删除: sscan + srem 4. SortedSet删除: zscan + zrem "},"MachineLearning/MatplotlibNumpyPandas/numpy基础.html":{"url":"MachineLearning/MatplotlibNumpyPandas/numpy基础.html","title":"numpy基础","keywords":"","body":"datetime:2020/8/1 13:28 author:nzb numpy基础 幕布numpy基础 幕布numpy方法 numpy用于数组计算 中文文档 import numpy as np import random 创建数组 a1 = np.array([1,2,3]) a2 = np.array(range(5)) a3 = np.arange(8) a4 = np.array(range(4), dtype='f4') a5 = np.array([1,0,1,0,1,0], dtype=bool) print(a1, a2, a3, sep='\\n') print(type(a1), type(a2), type(a3)) print(\"a3:dtype:\", a3.dtype) print(\"a4:dtype:\", a4.dtype) print(\"a5:dtype:\", a5.dtype) print(\"a1调整dtype前\",a1.dtype ) # a1.dtype = 'f2' a1 = a1.astype('float32') print(\"a1调整dtype后\",a1.dtype ) print(\"\\n\") # 保留小数点 a6 = np.array([random.random() for _ in range(10)]) print(a6) print(np.round(a6, 3)) [1 2 3] [0 1 2 3 4] [0 1 2 3 4 5 6 7] a3:dtype: int32 a4:dtype: float32 a5:dtype: bool a1调整dtype前 int32 a1调整dtype后 float32 [0.67067085 0.2306847 0.25868171 0.71041073 0.53141459 0.40654488 0.62679249 0.51855766 0.30907571 0.63072732] [0.671 0.231 0.259 0.71 0.531 0.407 0.627 0.519 0.309 0.631] 数据类型 形状 a7 = np.array([[1,2,3],[4,5,6]]) a8 = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[4,5,6]] ]) print(a3, a7, a8, sep='\\n') print(a3.shape, a7.shape, a8.shape) [0 1 2 3 4 5 6 7] [[1 2 3] [4 5 6]] [[[1 2 3] [4 5 6]] [[7 8 9] [4 5 6]]] (8,) (2, 3) (2, 2, 3) a9 = np.arange(12) # 转换为2维， print(a9.reshape((3,4)), a9.reshape((2,6)), a9.reshape((2,2,3)), a9.reshape((2,3,2)), sep='\\n\\n\\n') [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[[ 0 1] [ 2 3] [ 4 5]] [[ 6 7] [ 8 9] [10 11]]] print(a9.reshape((12,)),a9.reshape((1,12)), a9.reshape((12,1)), sep='\\n\\n\\n') [ 0 1 2 3 4 5 6 7 8 9 10 11] [[ 0 1 2 3 4 5 6 7 8 9 10 11]] [[ 0] [ 1] [ 2] [ 3] [ 4] [ 5] [ 6] [ 7] [ 8] [ 9] [10] [11]] a10 = np.arange(12).reshape((2,2,3)) print(a10, a10.flatten(), sep='\\n\\n\\n') [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [ 0 1 2 3 4 5 6 7 8 9 10 11] 计算 a11 = np.arange(12).reshape((3,-1)) # nan：没有的意思 # infinity：无限，无穷的意思，所以这里是无限大的意思 print(a11, a11/2, a11/0, sep='\\n\\n\\n') [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[0. 0.5 1. 1.5] [2. 2.5 3. 3.5] [4. 4.5 5. 5.5]] [[nan inf inf inf] [inf inf inf inf] [inf inf inf inf]] C:\\Users\\Admin\\Anaconda3\\lib\\site-packages\\ipykernel_launcher.py:4: RuntimeWarning: divide by zero encountered in true_divide after removing the cwd from sys.path. C:\\Users\\Admin\\Anaconda3\\lib\\site-packages\\ipykernel_launcher.py:4: RuntimeWarning: invalid value encountered in true_divide after removing the cwd from sys.path. 维度相同 a12 = np.arange(1,13).reshape((3,4)) a13 = np.arange(11, 23).reshape((3,4)) print(a12, a13, sep='\\n'*3) [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] [[11 12 13 14] [15 16 17 18] [19 20 21 22]] print(\"加：\", a12 + a13, end=\"\\n\"*3) print(\"减：\", a12 - a13, end=\"\\n\"*3) print(\"乘：\", a12 * a13, end=\"\\n\"*3) print(\"除：\", a12 / a13, end=\"\\n\"*3) 加： [[12 14 16 18] [20 22 24 26] [28 30 32 34]] 减： [[-10 -10 -10 -10] [-10 -10 -10 -10] [-10 -10 -10 -10]] 乘： [[ 11 24 39 56] [ 75 96 119 144] [171 200 231 264]] 除： [[0.09090909 0.16666667 0.23076923 0.28571429] [0.33333333 0.375 0.41176471 0.44444444] [0.47368421 0.5 0.52380952 0.54545455]] 维度不相同 需要有一个维度的相同 广播原则 如果两个数组的后缘维度（即从末尾开始算起的维度）的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的，广播会在缺失和（或）长度为1的维度上进行 a14 = np.arange(6) a15 = np.arange(24).reshape((4,6)) a16 = np.arange(4).reshape((4,1)) a17 = np.arange(10) print(a14, a15, a16, a17, sep=\"\\n\"*3) [0 1 2 3 4 5] [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[0] [1] [2] [3]] [0 1 2 3 4 5 6 7 8 9] # 维度不一样时会计算对应位置 print(a15-a14, a15-a16, sep='\\n'*3) [[ 0 0 0 0 0 0] [ 6 6 6 6 6 6] [12 12 12 12 12 12] [18 18 18 18 18 18]] [[ 0 1 2 3 4 5] [ 5 6 7 8 9 10] [10 11 12 13 14 15] [15 16 17 18 19 20]] # 维度不一样时会计算对应位置不一样也不一定可以计算 print(a15-a14, a15-a16, a15-a17, sep='\\n'*3) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) in 1 # 维度不一样时会计算对应位置不一样也不一定可以计算 ----> 2 print(a15-a14, a15-a16, a15-a17, sep='\\n'*3) ValueError: operands could not be broadcast together with shapes (4,6) (10,) 轴 二维 axis=0：行 axis=1：列 三维 axis=0：行 aixs=1：列（每一行的每一列） aixs=2：块（每一行的每一列的每个元素） print(a10, np.sum(a10, axis=0), np.sum(a10, axis=1), np.sum(a10, axis=2), sep='\\n'*3) [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[ 6 8 10] [12 14 16]] [[ 3 5 7] [15 17 19]] [[ 3 12] [21 30]] 转置 a18 = np.arange(24).reshape((4,6)) print(a18, a18.transpose(), a18.T, a18.swapaxes(1,0), sep='\\n'*3) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] 索引与切片 中文文档 # 一维（前闭后开） print(a2, a2[0], a2[2:5],a2[::-1], sep='\\n'*2) [0 1 2 3 4] 0 [2 3 4] [4 3 2 1 0] 三个点（ ... ）表示产生完整索引元组所需的冒号。例如，如果 x 是rank为5的数组（即，它具有5个轴），则： x[1,2,...] 相当于 x[1,2,:,:,:] x[...,3] 等效于 x[:,:,:,:,3] x[4,...,5,:] 等效于 x[4,:,:,5,:] # 多维 print(\"二维\",a12,a12[:2,:2], a12[:, 1:3],a12[[0, 1,2],[1,2,0]], sep='\\n'*2) print(\"三维\",a10, a10[:,:2,:2], a10[1,...],sep='\\n'*3) 二维 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] [[1 2] [5 6]] [[ 2 3] [ 6 7] [10 11]] [2 7 9] 三维 [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[[ 0 1] [ 3 4]] [[ 6 7] [ 9 10]]] [[ 6 7 8] [ 9 10 11]] index = np.where(a12 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] (array([0, 0, 0, 0], dtype=int64), array([0, 1, 2, 3], dtype=int64)) [1 2 3 4] # 小于5的赋值为1，,大于等于5的赋值为0 # 三目运算符 print(np.where(a12 [[1 1 1 1] [0 0 0 0] [0 0 0 0]] 数据拼接 a1 = np.arange(12).reshape((2,6)) a2 = np.arange(12, 24).reshape((2,6)) # 竖直拼接 a3 = np.vstack((a1, a2)) # 水平拼接 a4 = np.hstack((a1, a2)) print(a3, a4, sep=\"\\n\"*3) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[ 0 1 2 3 4 5 12 13 14 15 16 17] [ 6 7 8 9 10 11 18 19 20 21 22 23]] 行列交换 a3 array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) # 行交换 a3[[1,2], :] = a3[[2,1], :] print(\"行交换\",a3, sep='\\n') # 列交换 a3[:, [0,2]] = a3[:,[2,0]] print(\"行交换\",a3, sep='\\n') 行交换 [[ 0 1 2 3 4 5] [12 13 14 15 16 17] [ 6 7 8 9 10 11] [18 19 20 21 22 23]] 行交换 [[ 2 1 0 3 4 5] [14 13 12 15 16 17] [ 8 7 6 9 10 11] [20 19 18 21 22 23]] import matplotlib.pyplot as plt %matplotlib inline a1 = np.random.rand(100) plt.scatter(range(100), a1) plt.show() nan和inf print(type(np.nan),np.nan == np.nan, np.nan is np.nan, sep=\"\\n\"*2) False True a1 = np.array([1,2,np.nan]) print(a1 != a1, np.count_nonzero(a1 != a1), sep=\"\\n\") print(np.isnan(a1)) print(\"求和：\", np.sum(a1)) a1[np.isnan(a1)]=0 print(a1) [False False True] 1 [False False True] 求和： nan [1. 2. 0.] np.isnan(a1) array([False, False, False]) a1 = np.array([1,2,np.nan]) a2 = np.arange(12).reshape((3,4)).astype(\"float\") a2[[1], 2:] = np.nan # 使用了 ~（取补运算符）来过滤 NaN。 a = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)]) [1. 2. 3. 4. 5.] "},"MachineLearning/MatplotlibNumpyPandas/Pandas快速入门.html":{"url":"MachineLearning/MatplotlibNumpyPandas/Pandas快速入门.html","title":"pandas基础","keywords":"","body":"Pandas 中文文档 英文文档 Pandas概览 Pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为最强大、最灵活、可以支持任何语言的开源数据分析工具。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。 Pandas 适用于处理以下类型的数据： 与 SQL 或 Excel 表类似的，含异构列的表格数据; 有序和无序（非固定频率）的时间序列数据; 带行列标签的矩阵数据，包括同构或异构型数据; 任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。 Pandas 的主要数据结构是 Series（一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、- 社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。 Pandas 就像一把万能瑞士军刀，下面仅列出了它的部分优势 ： 处理浮点与非浮点数据里的缺失数据，表示为 NaN； 大小可变：插入或删除 DataFrame 等多维对象的列； 自动、显式数据对齐：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame 计算时自动与数据对齐； 强大、灵活的分组（group by）功能：拆分-应用-组合数据集，聚合、转换数据； 把 Python 和 NumPy 数据结构里不规则、不同索引的数据轻松地转换为 DataFrame 对象； 基于智能标签，对大型数据集进行切片、花式索引、子集分解等操作； 直观地合并（merge）、连接（join）数据集； 灵活地重塑（reshape）、透视（pivot）数据集； 轴支持结构化标签：一个刻度支持多个标签； 成熟的 IO 工具：读取文本文件（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，利用超快的 HDF5 格式保存 / 加载数据； 时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。 这些功能主要是为了解决其它编程语言、科研环境的痛点。处理数据一般分为几个阶段：数据整理与清洗、数据分析与建模、数据可视化与制表，Pandas 是处理数据的理想工具。 其它说明： Pandas 速度很快。Pandas 的很多底层算法都用 Cython 优化过。然而，为了保持通用性，必然要牺牲一些性能，如果专注某一功能，完全可以开发出比 Pandas 更快的专用工具。 Pandas 是 statsmodels 的依赖项，因此，Pandas 也是 Python 中统计计算生态系统的重要组成部分。 Pandas 已广泛应用于金融领域。 数据结构 维数 名称 描述 1 Series 带标签的一维同构数组 2 DataFrame 带标签的，大小可变的，二维异构表格 为什么有多个数据结构？ Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。 此外，通用 API 函数的默认操作要顾及时间序列与截面数据集的方向。多维数组存储二维或三维数据时，编写函数要注意数据集的方向，这对用户来说是一种负担；如果不考虑 C 或 Fortran 中连续性对性能的影响，一般情况下，不同的轴在程序里其实没有什么区别。Pandas 里，轴的概念主要是为了给数据赋予更直观的语义，即用“更恰当”的方式表示数据集的方向。这样做可以让用户编写数据转换函数时，少费点脑子。 处理 DataFrame 等表格数据时，index（行）或 columns（列）比 axis 0 和 axis 1 更直观。用这种方式迭代 DataFrame 的列，代码更易读易懂： for col in df.columns: series = df[col] # do something with series 大小可变与数据复制 Pandas 所有数据结构的值都是可变的，但数据结构的大小并非都是可变的，比如，Series 的长度不可改变，但 DataFrame 里就可以插入列。 Pandas 里，绝大多数方法都不改变原始的输入数据，而是复制数据，生成新的对象。 一般来说，原始输入数据不变更稳妥。 十分钟入门Pandas 本节是帮助 Pandas 新手快速上手的简介。烹饪指南里介绍了更多实用案例。 本节以下列方式导入 Pandas 与 NumPy： import numpy as np import pandas as pd 生成对象 详见数据结构简介文档。 用值列表生成 Series 时，Pandas 默认自动生成整数索引： s = pd.Series([1,2,3,4,5,np.nan, 6,8]) s 0 1.0 1 2.0 2 3.0 3 4.0 4 5.0 5 NaN 6 6.0 7 8.0 dtype: float64 用含日期时间索引与标签的Numpy数组生成DataFrame df1 = pd.date_range(start='20150101', periods=6) df1 DatetimeIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04', '2015-01-05', '2015-01-06'], dtype='datetime64[ns]', freq='D') df2 = pd.DataFrame(np.random.randn(6,4), index=df1, columns=list('ABCD')) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 用Series字典对象生成DataFrame df3 = pd.DataFrame({ 'A': 1., 'B': pd.Timestamp('20150101'), 'C': pd.Series(1, index=list(range(4)), dtype='float32'), 'D': np.array([3]* 4, dtype='int32'), 'E': pd.Categorical(['test', 'train','test', 'train']), 'F':'foo' }) df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E F 0 1.0 2015-01-01 1.0 3 test foo 1 1.0 2015-01-01 1.0 3 train foo 2 1.0 2015-01-01 1.0 3 test foo 3 1.0 2015-01-01 1.0 3 train foo DataFrame 的列有不同数据类型。 df3.dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object IPython支持 tab 键自动补全列名与公共属性。下面是部分可自动补全的属性： df3. # df2.A df2.bool # df2.abs df2.boxplot # df2.add df2.C # df2.add_prefix df2.clip # df2.add_suffix df2.clip_lower # df2.align df2.clip_upper # df2.all df2.columns # df2.any df2.combine # df2.append df2.combine_first # df2.apply df2.compound # df2.applymap df2.consolidate # df2.D # 列 A、B、C、D 和 E 都可以自动补全；为简洁起见，此处只显示了部分属性。 File \"\", line 1 df3. ^ SyntaxError: invalid syntax 查看数据 详见基础用法文档。 下列代码说明如何查看 DataFrame 头部和尾部数据： df2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 df2.tail(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 显示索引与列名 df2.index DatetimeIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04', '2015-01-05', '2015-01-06'], dtype='datetime64[ns]', freq='D') df2.columns Index(['A', 'B', 'C', 'D'], dtype='object') DataFrame.to_numpy() 输出底层数据的 NumPy 对象。注意，DataFrame 的列由多种数据类型组成时，该操作耗费系统资源较大，这也是 Pandas 和 NumPy 的本质区别：NumPy 数组只有一种数据类型，DataFrame 每列的数据类型各不相同。调用 DataFrame.to_numpy() 时，Pandas 查找支持 DataFrame 里所有数据类型的 NumPy 数据类型。还有一种数据类型是 object，可以把 DataFrame 列里的值强制转换为 Python 对象。 下面的 df2 这个 DataFrame 里的值都是浮点数，DataFrame.to_numpy() 的操作会很快，而且不复制数据。 df2.to_numpy() array([[ 0.49577653, -0.5242963 , -0.08997072, 1.64004361], [ 2.01445165, -0.42293604, 0.99104484, -0.28133103], [ 0.88359618, -1.79480302, 0.57597891, -1.85652831], [ 0.56512531, 0.85877834, 0.13837606, 0.20131605], [-1.85407664, 0.36895609, -1.26782639, -2.46488774], [-0.22499319, -1.25311828, -0.19571662, -0.62379678]]) df3 这个 DataFrame 包含了多种类型，DataFrame.to_numpy() 操作就会耗费较多资源。 df3.to_numpy() array([[1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'train', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object) 提醒： DataFrame.to_numpy() 的输出不包含行索引和列标签。 describe() 可以快速查看数据的统计摘要： df2.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D count 6.000000 6.000000 6.000000 6.000000 mean 0.313313 -0.461237 0.025314 -0.564197 std 1.288654 0.984132 0.772400 1.470442 min -1.854077 -1.794803 -1.267826 -2.464888 25% -0.044801 -1.070913 -0.169280 -1.548345 50% 0.530451 -0.473616 0.024203 -0.452564 75% 0.803978 0.170983 0.466578 0.080654 max 2.014452 0.858778 0.991045 1.640044 转置数据： print(df2) print(\"\\n-------------------转置后-------------------------\") df2.T A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 -------------------转置后------------------------- .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2015-01-01 2015-01-02 2015-01-03 2015-01-04 2015-01-05 2015-01-06 A 0.495777 2.014452 0.883596 0.565125 -1.854077 -0.224993 B -0.524296 -0.422936 -1.794803 0.858778 0.368956 -1.253118 C -0.089971 0.991045 0.575979 0.138376 -1.267826 -0.195717 D 1.640044 -0.281331 -1.856528 0.201316 -2.464888 -0.623797 按轴排序： df2.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } D C B A 2015-01-01 1.640044 -0.089971 -0.524296 0.495777 2015-01-02 -0.281331 0.991045 -0.422936 2.014452 2015-01-03 -1.856528 0.575979 -1.794803 0.883596 2015-01-04 0.201316 0.138376 0.858778 0.565125 2015-01-05 -2.464888 -1.267826 0.368956 -1.854077 2015-01-06 -0.623797 -0.195717 -1.253118 -0.224993 按值排序： df2.sort_values(by='B') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-04 0.565125 0.858778 0.138376 0.201316 选择 提醒： 选择、设置标准 Python / Numpy 的表达式已经非常直观，交互也很方便，但对于生产代码，我们还是推荐优化过的 Pandas 数据访问方法：.at、.iat、.loc 和 .iloc。 详见索引与选择数据、多层索引与高级索引文档。 获取数据 选择单列，产生Series，与df2.A等效： df2['A'] 2015-01-01 0.495777 2015-01-02 2.014452 2015-01-03 0.883596 2015-01-04 0.565125 2015-01-05 -1.854077 2015-01-06 -0.224993 Freq: D, Name: A, dtype: float64 用[]切片行： df2[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 df2['20150102': '20150103'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 按标签选择 详见按标签选择 用标签提取一行数据： df2.loc[df1[0]] A 0.495777 B -0.524296 C -0.089971 D 1.640044 Name: 2015-01-01 00:00:00, dtype: float64 用标签选择多列数据： df2.loc[:,['A', 'B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-01 0.495777 -0.524296 2015-01-02 2.014452 -0.422936 2015-01-03 0.883596 -1.794803 2015-01-04 0.565125 0.858778 2015-01-05 -1.854077 0.368956 2015-01-06 -0.224993 -1.253118 用标签切片，包含行与列结束点： df2.loc['20150102': '20150104', ['A','B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-02 2.014452 -0.422936 2015-01-03 0.883596 -1.794803 2015-01-04 0.565125 0.858778 返回对象降维： df2.loc['20150102', ['A','B']] A 2.014452 B -0.422936 Name: 2015-01-02 00:00:00, dtype: float64 提取标量值： df2.loc[df1[0],'A'] 0.4957765303321702 快速访问标量，与上述方法等效 df2.at[df1[0], 'A'] 0.4957765303321702 按位置选择 详见按位置选择 用整数位置选择： df2.iloc[3] A 0.565125 B 0.858778 C 0.138376 D 0.201316 Name: 2015-01-04 00:00:00, dtype: float64 类似Numpy/Python，用整数切片 df2.iloc[3:5,0:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-04 0.565125 0.858778 2015-01-05 -1.854077 0.368956 类型Numpy/Python，用整数列表按位置切片： df2.iloc[[1,2,4], [0,2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A C 2015-01-02 2.014452 0.991045 2015-01-03 0.883596 0.575979 2015-01-05 -1.854077 -1.267826 显式整行切片 df2.iloc[1:3, :] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 显式整列切片： df2.iloc[:,1:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } B C 2015-01-01 -0.524296 -0.089971 2015-01-02 -0.422936 0.991045 2015-01-03 -1.794803 0.575979 2015-01-04 0.858778 0.138376 2015-01-05 0.368956 -1.267826 2015-01-06 -1.253118 -0.195717 显式提取值： df2.iloc[1,1] -0.4229360414145462 快速访问标量，与上述方法等效： df2.iat[1,1] -0.4229360414145462 布尔索引 用单列的值选择数据： df2[df2.A > 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 选择DataFrame里满足条件的值： df2[df2 > 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 NaN NaN 1.640044 2015-01-02 2.014452 NaN 0.991045 NaN 2015-01-03 0.883596 NaN 0.575979 NaN 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 NaN 0.368956 NaN NaN 2015-01-06 NaN NaN NaN NaN 用isin()筛选： df4 = df2.copy() df4['E'] = ['one', 'two', 'three', 'four', 'three', 'one'] df4 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 one 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 two 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 three 2015-01-04 0.565125 0.858778 0.138376 0.201316 four 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 three 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 one df4[df4['E'].isin(['two', 'four'])] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 two 2015-01-04 0.565125 0.858778 0.138376 0.201316 four 赋值 用索引自动对齐新增列的数据： s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20150101', periods=6)) df2['F'] = s1 print(df2) A B C D F 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按标签赋值： df2.at[df1[0], 'A'] = 0 df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 -0.524296 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按位置赋值： df2.iat[0,1] = 0 df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按Numpy数组赋值： df2.loc[:,\"D\"] = np.array([5]* len(df2)) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 5 1 2015-01-02 2.014452 -0.422936 0.991045 5 2 2015-01-03 0.883596 -1.794803 0.575979 5 3 2015-01-04 0.565125 0.858778 0.138376 5 4 2015-01-05 -1.854077 0.368956 -1.267826 5 5 2015-01-06 -0.224993 -1.253118 -0.195717 5 6 用where条件赋值： 签名DataFrame.where()不同于numpy.where()。大致相当于。df1.where(m, df2)``````np.where(m, df1, df2) df5 = df2.copy() df5[df5 > 0] = -df5 df5 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 -5 -1 2015-01-02 -2.014452 -0.422936 -0.991045 -5 -2 2015-01-03 -0.883596 -1.794803 -0.575979 -5 -3 2015-01-04 -0.565125 -0.858778 -0.138376 -5 -4 2015-01-05 -1.854077 -0.368956 -1.267826 -5 -5 2015-01-06 -0.224993 -1.253118 -0.195717 -5 -6 缺失值 Pandas 主要用 np.nan 表示缺失数据。 计算时，默认不包含空值。详见缺失数据。 重建索引（reindex）可以更改、添加、删除指定轴的索引，并返回数据副本，即不更改原数据。 df6 = df2.reindex(index=df1[0:4], columns=list(df2.columns) + ['E']) df6.loc[df1[0]:df1[1], 'E'] = 1 df6 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 2015-01-03 0.883596 -1.794803 0.575979 5 3 NaN 2015-01-04 0.565125 0.858778 0.138376 5 4 NaN 删除所有含缺失值得行： df6.dropna(how='any') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 填充缺失值： df6.fillna(value=4) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 2015-01-03 0.883596 -1.794803 0.575979 5 3 4.0 2015-01-04 0.565125 0.858778 0.138376 5 4 4.0 提取nan值得布尔掩码： pd.isna(df6) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 False False False False False False 2015-01-02 False False False False False False 2015-01-03 False False False False False True 2015-01-04 False False False False False True 运算 详见二进制操作 统计 一般情况下，运算时排除缺失值。 描述性统计： df2.mean() A 0.230684 B -0.373854 C 0.025314 D 5.000000 F 3.500000 dtype: float64 在另一个轴(即,行)上执行同样的操作： df2.mean(1) 2015-01-01 1.182006 2015-01-02 1.916512 2015-01-03 1.532954 2015-01-04 2.112456 2015-01-05 1.449411 2015-01-06 1.865234 Freq: D, dtype: float64 不同维度对象运算时，要先对齐。此外，Pandas自动沿指定维度广播。 s2 = pd.Series([1,3,5, np.nan, 6, 8], index=df1).shift(2) s2 2015-01-01 NaN 2015-01-02 NaN 2015-01-03 1.0 2015-01-04 3.0 2015-01-05 5.0 2015-01-06 NaN Freq: D, dtype: float64 df2.sub(s2, axis='index') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 NaN NaN NaN NaN NaN 2015-01-02 NaN NaN NaN NaN NaN 2015-01-03 -0.116404 -2.794803 -0.424021 4.0 2.0 2015-01-04 -2.434875 -2.141222 -2.861624 2.0 1.0 2015-01-05 -6.854077 -4.631044 -6.267826 0.0 0.0 2015-01-06 NaN NaN NaN NaN NaN Apply函数 Apply函数处理数据 df2.apply(np.cumsum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 5 1 2015-01-02 2.014452 -0.422936 0.901074 10 3 2015-01-03 2.898048 -2.217739 1.477053 15 6 2015-01-04 3.463173 -1.358961 1.615429 20 10 2015-01-05 1.609096 -0.990005 0.347603 25 15 2015-01-06 1.384103 -2.243123 0.151886 30 21 df2.apply(lambda x: x.max() - x.min()) A 3.868528 B 2.653581 C 2.258871 D 0.000000 F 5.000000 dtype: float64 直方图 详见直方图与离散化。 s3 = pd.Series(np.random.randint(0, 7, size=10)) s3 0 6 1 3 2 4 3 0 4 2 5 3 6 1 7 6 8 4 9 3 dtype: int32 s3.value_counts() 3 3 6 2 4 2 2 1 1 1 0 1 dtype: int64 字符串方法 Series 的 str 属性包含一组字符串处理功能，如下列代码所示。注意，str 的模式匹配默认使用正则表达式。详见矢量字符串方法。 s4 = pd.Series(['A','B', 'C', 'Aaba','Baca', np.nan, 'CABA', 'dog', 'cat']) s4.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object 合并（Merge） 结合（Concat） Pandas 提供了多种将 Series、DataFrame 对象组合在一起的功能，用索引与关联代数功能的多种设置逻辑可执行连接（join）与合并（merge）操作。 详见合并。 concat() 用于连接 Pandas 对象： df7 = pd.DataFrame(np.random.randn(10, 4)) df7 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.510118 1.297539 -0.226940 -1.298777 1 -0.156357 -0.501054 -0.884452 -0.642022 2 -0.084234 0.522088 0.559494 0.614627 3 -1.877422 1.173498 -0.590322 1.283285 4 0.599235 -0.459644 -0.991115 0.602145 5 -0.918474 1.273175 0.391105 1.760057 6 1.454607 0.301366 0.569512 -0.853014 7 0.533967 2.432820 -0.116690 -1.042676 8 0.788732 0.988278 -0.317310 -0.555627 9 0.717240 -0.003718 2.191069 1.661000 # 分解为多组 pieces = [df7[:3], df7[3:7],df7[7:]] pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.510118 1.297539 -0.226940 -1.298777 1 -0.156357 -0.501054 -0.884452 -0.642022 2 -0.084234 0.522088 0.559494 0.614627 3 -1.877422 1.173498 -0.590322 1.283285 4 0.599235 -0.459644 -0.991115 0.602145 5 -0.918474 1.273175 0.391105 1.760057 6 1.454607 0.301366 0.569512 -0.853014 7 0.533967 2.432820 -0.116690 -1.042676 8 0.788732 0.988278 -0.317310 -0.555627 9 0.717240 -0.003718 2.191069 1.661000 连接（join） SQL 风格的合并。 详见数据库风格连接。 left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1,2]}) right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4,5]}) print(left) print('-------------------') print(right) key lval 0 foo 1 1 foo 2 ------------------- key rval 0 foo 4 1 foo 5 pd.merge(left, right, on='key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 还有一个例子： left = pd.DataFrame({'key': ['foo', 'bar'], 'lval': [1,2]}) right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4,5]}) print(left) print('-------------------') print(right) key lval 0 foo 1 1 bar 2 ------------------- key rval 0 foo 4 1 bar 5 pd.merge(left, right, on='key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 bar 2 5 追加（Append） 为 DataFrame 追加行。详见追加文档。 df = pd.DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D']) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.288486 0.071832 -0.573014 -0.740909 1 -0.437346 -0.341157 0.652473 1.647469 2 -0.041598 1.400381 0.034764 0.030222 3 0.269048 0.363632 1.939811 0.371858 4 1.135352 -1.729701 1.319469 0.695883 5 0.024442 0.259727 -0.255833 -1.128733 6 1.310012 1.068041 -0.961124 0.513195 7 -0.811828 2.385519 -0.211693 -1.799050 s = df.iloc[3] df.append(s, ignore_index=True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.288486 0.071832 -0.573014 -0.740909 1 -0.437346 -0.341157 0.652473 1.647469 2 -0.041598 1.400381 0.034764 0.030222 3 0.269048 0.363632 1.939811 0.371858 4 1.135352 -1.729701 1.319469 0.695883 5 0.024442 0.259727 -0.255833 -1.128733 6 1.310012 1.068041 -0.961124 0.513195 7 -0.811828 2.385519 -0.211693 -1.799050 8 0.269048 0.363632 1.939811 0.371858 分组（Grouping） “group by” 指的是涵盖下列一项或多项步骤的处理流程： 分割：按条件把数据分割成多组； 应用：为每组单独应用函数； 组合：将处理结果组合成一个数据结构。 详见中文文档 官方 df = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'], 'B': ['one', 'one', 'two', 'three','two', 'two', 'one', 'three'], 'C': np.random.randn(8), 'D': np.random.randn(8)}) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 1.039872 0.388262 1 bar one -0.512593 1.288747 2 foo two 2.751863 -0.549265 3 bar three 1.826074 -0.152341 4 foo two 0.565190 1.234779 5 bar two -0.544772 -1.006594 6 foo one -0.232166 0.317457 7 foo three 1.150941 0.672226 先分组，再用sum函数计算每组的汇总数据 df.groupby('A').sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A bar 0.768709 0.129812 foo 5.275699 2.063459 多列分组后，生成多层索引，也可以应用 sum 函数： df.groupby(['A', 'B']).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A B bar one -0.512593 1.288747 three 1.826074 -0.152341 two -0.544772 -1.006594 foo one 0.807705 0.705719 three 1.150941 0.672226 two 3.317053 0.685514 重塑（Reshaping） 详见多层索引与重塑。 堆叠（Stack） tuples = list(zip(*[['bar', 'bar', 'baz', 'baz','foo', 'foo', 'qux', 'qux'], ....: ['one', 'two', 'one', 'two','one', 'two', 'one', 'two']])) index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second']) df = pd.DataFrame(np.random.randn(8,2), index=index, columns=['A', 'B']) df2 = df[:4] print(df, df2, sep='\\n'*3) A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 foo one 0.495192 -1.072288 two 0.447279 -1.292418 qux one -0.317342 -0.857073 two 0.452839 0.217488 A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 # stack()方法把 DataFrame 列压缩至一层 stacked = df2.stack() stacked first second bar one A 1.192086 B -1.617945 two A -0.541903 B -0.763716 baz one A 0.002802 B -0.073066 two A 1.086178 B 0.505617 dtype: float64 # 压缩后的 DataFrame 或 Series 具有多层索引， stack() 的逆操作是 unstack()，默认为拆叠最后一层： stacked.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 stacked.unstack(1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } second one two first bar A 1.192086 -0.541903 B -1.617945 -0.763716 baz A 0.002802 1.086178 B -0.073066 0.505617 stacked.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } first bar baz second one A 1.192086 0.002802 B -1.617945 -0.073066 two A -0.541903 1.086178 B -0.763716 0.505617 数据透视表（Pivot Tables） 详见数据透视表。 df = pd.DataFrame({'A': ['one', 'one', 'two', 'three'] * 3, .....: 'B': ['A', 'B', 'C'] * 4, .....: 'C': ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, .....: 'D': np.random.randn(12), .....: 'E': np.random.randn(12)}) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 0 one A foo 0.310437 0.596380 1 one B foo 1.015415 -0.658475 2 two C foo 0.526326 1.851567 3 three A bar 1.502380 -1.316516 4 one B bar -1.752622 0.461646 5 one C bar 0.888497 0.703693 6 two A foo -0.629228 0.718748 7 three B foo 2.389784 0.049419 8 one C foo -0.890217 0.858487 9 one A bar -0.261845 -1.190759 10 two B bar -0.040979 -0.877174 11 three C bar -0.216170 -0.865147 pd.pivot_table(df, values='D', index=['A','B'], columns=['C']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C bar foo A B one A -0.261845 0.310437 B -1.752622 1.015415 C 0.888497 -0.890217 three A 1.502380 NaN B NaN 2.389784 C -0.216170 NaN two A NaN -0.629228 B -0.040979 NaN C NaN 0.526326 时间序列(TimeSeries) Pandas 为频率转换时重采样提供了虽然简单易用，但强大高效的功能， 如，将秒级的数据转换为 5 分钟为频率的数据。这种操作常见于财务应用程序，但又不仅限于此。详见时间序列。 rng = pd.date_range('1/1/2020', periods=10, freq='S') ts = pd.Series(np.random.randint(0, 20, len(rng)), index=rng) print(rng, ts, sep='\\n'*2) DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 00:00:01', '2020-01-01 00:00:02', '2020-01-01 00:00:03', '2020-01-01 00:00:04', '2020-01-01 00:00:05', '2020-01-01 00:00:06', '2020-01-01 00:00:07', '2020-01-01 00:00:08', '2020-01-01 00:00:09'], dtype='datetime64[ns]', freq='S') 2020-01-01 00:00:00 17 2020-01-01 00:00:01 0 2020-01-01 00:00:02 7 2020-01-01 00:00:03 12 2020-01-01 00:00:04 1 2020-01-01 00:00:05 15 2020-01-01 00:00:06 0 2020-01-01 00:00:07 10 2020-01-01 00:00:08 14 2020-01-01 00:00:09 8 Freq: S, dtype: int32 ts.resample('5Min').sum() 2020-01-01 84 Freq: 5T, dtype: int32 # 时区表示 rng = pd.date_range('2020/8/1', periods=5, freq='D') ts = pd.Series(np.random.randn(len(rng)), rng) ts_UTC = ts.tz_localize('UTC') print(ts, ts_UTC, sep='\\n'*3) 2020-08-01 -0.938967 2020-08-02 0.056395 2020-08-03 -1.249805 2020-08-04 -0.300962 2020-08-05 -1.635329 Freq: D, dtype: float64 2020-08-01 00:00:00+00:00 -0.938967 2020-08-02 00:00:00+00:00 0.056395 2020-08-03 00:00:00+00:00 -1.249805 2020-08-04 00:00:00+00:00 -0.300962 2020-08-05 00:00:00+00:00 -1.635329 Freq: D, dtype: float64 # 转换成其他时区 ts_UTC.tz_convert('US/Eastern') 2020-07-31 20:00:00-04:00 -0.938967 2020-08-01 20:00:00-04:00 0.056395 2020-08-02 20:00:00-04:00 -1.249805 2020-08-03 20:00:00-04:00 -0.300962 2020-08-04 20:00:00-04:00 -1.635329 Freq: D, dtype: float64 # 转换时间段 rng = pd.date_range('2020/8/1', periods=5, freq='M') ts = pd.Series(np.random.randn(len(rng)), rng) ps = ts.to_period() pts = ps.to_timestamp() print(ts, ps, pts, sep='\\n'*3) 2020-08-31 2.606606 2020-09-30 1.631934 2020-10-31 1.167378 2020-11-30 -0.376675 2020-12-31 -0.196782 Freq: M, dtype: float64 2020-08 2.606606 2020-09 1.631934 2020-10 1.167378 2020-11 -0.376675 2020-12 -0.196782 Freq: M, dtype: float64 2020-08-01 2.606606 2020-09-01 1.631934 2020-10-01 1.167378 2020-11-01 -0.376675 2020-12-01 -0.196782 Freq: MS, dtype: float64 可视化 详见可视化文档。 ts = pd.Series(np.random.randn(1000), index=pd.date_range('2020/1/1', periods=1000)) ts = ts.cumsum() ts.plot() DataFrame 的 plot() 方法可以快速绘制所有带标签的列： import matplotlib.pyplot as plt df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=['A', 'B', 'C', 'D']) df = df.cumsum() plt.figure(figsize=(30,10),dpi=80) df.plot() plt.legend(loc='best') "},"MachineLearning/MatplotlibNumpyPandas/Pandas_merge_concat_append.html":{"url":"MachineLearning/MatplotlibNumpyPandas/Pandas_merge_concat_append.html","title":"pandas连接合并追加","keywords":"","body":"Pandas 连接合并追加操作 concat concat(objs, axis=0, join='outer', ignore_index: bool = False, keys = None, levels = None, names = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) 连接 2 个Series s1 = pd.DataFrame([1,2,3]) s2 = pd.DataFrame([4,6,5]) s1 0 0 1 1 2 2 3 s2 0 0 4 1 6 2 5 pd.concat([s1, s2]) 0 0 1 1 2 2 3 0 4 1 6 2 5 # 忽略索引 pd.concat([s1, s2], ignore_index=True) 0 0 1 1 2 2 3 3 4 4 6 5 5 连接 2个 DataFrame # 普通连接(行) df1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number']) df2 = pd.DataFrame([['c', 3], ['d', 4]], columns=['letter', 'number']) df1 letter number 0 a 1 1 b 2 df2 letter number 0 c 3 1 d 4 pd.concat([df1, df2]) letter number 0 a 1 1 b 2 0 c 3 1 d 4 # 普通连接(列) pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 c 3 1 b 2 d 4 # 如果字段不相同，填充 `Nan` df3 = pd.DataFrame([['c', 3, 'cat'], ['d', 4, 'dog']], columns=['letter', 'number', 'animal']) df3 letter number animal 0 c 3 cat 1 d 4 dog pd.concat([df1, df3], sort=False) letter number animal 0 a 1 NaN 1 b 2 NaN 0 c 3 cat 1 d 4 dog # 内连接(只连接相同字段) pd.concat([df1, df3], join='inner') letter number 0 a 1 1 b 2 0 c 3 1 d 4 # 排序后，列拼接 pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 c 3 1 b 2 d 4 df2.sort_values('number', ascending=False, inplace=True) # 这一步至关重要 df2.reset_index(drop=True, inplace=True) pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 d 4 1 b 2 c 3 merge merge(left, right, how: str = 'inner', on = None, left_on = None, right_on = None, left_index: bool = False, right_index: bool = False, sort: bool = False, suffixes = ('_x', '_y'), copy: bool = True, indicator: bool = False, validate = None) 普通合并 df1 = pd.DataFrame({'lkey': ['foo', 'bar', 'baz', 'foo'], 'value': [1, 2, 3, 5]}) df2 = pd.DataFrame({'rkey': ['foo', 'bar', 'baz', 'foo'], 'value': [5, 6, 7, 8]}) df1 lkey value 0 foo 1 1 bar 2 2 baz 3 3 foo 5 df2 rkey value 0 foo 5 1 bar 6 2 baz 7 3 foo 8 df1.merge(df2, left_on='lkey', right_on='rkey') lkey value_x rkey value_y 0 foo 1 foo 5 1 foo 1 foo 8 2 foo 5 foo 5 3 foo 5 foo 8 4 bar 2 bar 6 5 baz 3 baz 7 df1.merge(df2, left_on='lkey', right_on='rkey',suffixes=('_left', '_right')) lkey value_left rkey value_right 0 foo 1 foo 5 1 foo 1 foo 8 2 foo 5 foo 5 3 foo 5 foo 8 4 bar 2 bar 6 5 baz 3 baz 7 内、左、右连接 df1 = pd.DataFrame({'a': ['foo', 'bar'], 'b': [1, 2]}) df2 = pd.DataFrame({'a': ['foo', 'baz'], 'c': [3, 4]}) df1 a b 0 foo 1 1 bar 2 df2 a c 0 foo 3 1 baz 4 df1.merge(df2, how='inner', on='a') a b c 0 foo 1 3 df1.merge(df2, how='left', on='a') a b c 0 foo 1 3.0 1 bar 2 NaN df1.merge(df2, how='right', on='a') a b c 0 foo 1.0 3 1 baz NaN 4 # 相同值，但是不同的字段名，左连接 df3 = pd.DataFrame({'d': ['foo', 'baz'], 'c': [3, 4]}) df3 d c 0 foo 3 1 baz 4 df1.merge(df3, how='left', left_on='a', right_on='d') a b d c 0 foo 1 foo 3.0 1 bar 2 NaN NaN 笛卡尔积 df1 = pd.DataFrame({'left': ['foo', 'bar']}) df2 = pd.DataFrame({'right': [7, 8]}) df1 left 0 foo 1 bar df2 right 0 7 1 8 df1.merge(df2, how='cross') left right 0 foo 7 1 foo 8 2 bar 7 3 bar 8 append append(other, ignore_index=False, verify_integrity=False, sort=False) 普通追加 df = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB')) df A B 0 1 2 1 3 4 df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB')) df2 A B 0 5 6 1 7 8 df.append(df2) A B 0 1 2 1 3 4 0 5 6 1 7 8 df.append(df2, ignore_index=True) A B 0 1 2 1 3 4 2 5 6 3 7 8 # 通过 for 循环追加 df = pd.DataFrame(columns=['A']) for i in range(5): df = df.append({'A': i}, ignore_index=True) df A 0 0 1 1 2 2 3 3 4 4 # 等价于 concat 连接，如下 pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)],ignore_index=True) A 0 0 1 1 2 2 3 3 4 4 "},"MachineLearning/MatplotlibNumpyPandas/matplotlib基础.html":{"url":"MachineLearning/MatplotlibNumpyPandas/matplotlib基础.html","title":"matplotlib基础","keywords":"","body":"matplotlib基础 中文文档 import matplotlib.pyplot as plt import random import pandas as pd from matplotlib import font_manager as fm %matplotlib inline matplotlib设置中文字体 # 配置中文字体： my_font = fm.FontProperties(fname=r\"C:\\Users\\Admin\\AppData\\Local\\Microsoft\\FontCache\\CloudFonts\\TTC\\107373335009.ttc\") x = range(2, 26, 2) # x轴数据 y = list(range(22, 46, 2)) # y轴数据 random.shuffle(y) 基本用法 双击可查看大图 # 基本用法 plt.plot(x, y) # 绘制 plt.grid(alpha=0.5) # 绘制网格（会根据x和y轴的刻度间隔绘制） alpha:透明度：0-1 plt.show() # 展示 设置图标大小和分辨率 # 设置图标大小 # figure图形图标的意思，在这里指的是我们画的图 # 通过实例化一个figure并且传递参数，能够在后台自动使用该figure实例 # 在图形模糊的时候可以传入dpi参数，让图形更清晰（每一英寸上的像素点） fig = plt.figure(figsize=(20, 8), dpi=100) plt.plot(x, y) # 图片保存(还可以保存为svg这种矢量图格式，放大不会有锯齿) # plt.savefig(\"./t1.png\") plt.show() 设置x轴和y轴刻度间隔 # 设置x轴和y轴刻度间隔 # 当刻度太密集时候使用列表的步长（间隔取值）来取值，matplotlib会自动帮我们对应 plt.figure(figsize=(25, 15)) plt.subplot(3,3,1) plt.plot(x, y) plt.xticks(x) plt.grid() # 设置y的刻度 plt.yticks(range(min(y),max(y)+1)[::2]) plt.subplot(3,3,2) plt.plot(x, y) plt.xticks(range(2, 26)) plt.subplot(3,3,3) plt.plot(x, y) plt.xticks(range(2, 26, 3)) plt.subplot(3,3,4) plt.plot(x, y) _xtick_labels = [i+0.5 for i in range(2,26)] plt.xticks(_xtick_labels) plt.subplot(3,3,5) plt.plot(x, y) _xtick_labels = [i+0.5 for i in range(2,26)] plt.xticks(_xtick_labels[::3]) plt.subplot(3,3,6) plt.plot(x, y) # 需注意x绘制的是2到26的值，超过了就没有可以绘制了 plt.xticks(range(26, 50, 2)) plt.show() # 绘制11点到1点每一分钟的气温变化 tmp = [random.randint(20, 45) for _ in range(120)] minus = pd.date_range('2020-07-28 11:00:00', '2020-07-28 13:00:00', freq='T') minus DatetimeIndex(['2020-07-28 11:00:00', '2020-07-28 11:01:00', '2020-07-28 11:02:00', '2020-07-28 11:03:00', '2020-07-28 11:04:00', '2020-07-28 11:05:00', '2020-07-28 11:06:00', '2020-07-28 11:07:00', '2020-07-28 11:08:00', '2020-07-28 11:09:00', ... '2020-07-28 12:51:00', '2020-07-28 12:52:00', '2020-07-28 12:53:00', '2020-07-28 12:54:00', '2020-07-28 12:55:00', '2020-07-28 12:56:00', '2020-07-28 12:57:00', '2020-07-28 12:58:00', '2020-07-28 12:59:00', '2020-07-28 13:00:00'], dtype='datetime64[ns]', length=121, freq='T') x轴和y轴添加描述信息 plt.figure(figsize=(30, 10)) plt.plot(tmp) # x = range(120)[::2] # _xtick_labels = [\"a{0}\".format(i) for i in x] # plt.xticks(x ,_xtick_labels) # 刻度字符串映射 # 刻度数据长度和x轴数据长度需对应 # rotation=90旋转90度 plt.xticks(range(120)[::2], minus[::2], rotation=45, fontsize=15) plt.yticks(fontsize=20) plt.xlabel(\"时间\", fontproperties=my_font, fontsize=50) plt.ylabel(\"温度\", fontproperties=my_font, fontsize=50) plt.title(\"11点到1点每一分钟的气温变化\",fontproperties=my_font, fontsize=50) plt.show() 绘制多次图像很不同图像的差异 绘制的时候指定 color：颜色 linestyle：线条风格 linewidth：线条粗细 alpha：透明度 颜色字符 风格字符 r红色 -实线 g绿色 --虚线，破折线 b蓝色 -.点划线 w白色 :点虚线，虚线 ''留空或空格，无线条 c青色 m洋红 y黄色 k黑色 #00ff0016进制 0.8灰度值字符串 y_1 = [random.randint(1,50) for _ in range(25)] y_2 = [random.randint(1,50) for _ in range(25)] plt.figure(figsize=(20,10)) plt.plot(y_1, label=\"y1的线\", linestyle='-.') plt.plot(y_2, label=\"y2的线\", color='r') plt.grid(linestyle=\"--\") # 添加图例(展示上面的label) # prop：字体 # loc：位置 plt.legend(prop=my_font, loc=\"best\") plt.show() 散点图 y1 = [random.randint(20, 45) for _ in range(30)] y2 = [random.randint(20, 45) for _ in range(30)] x1 = range(1, 31) x2 = range(51, 81) plt.figure(figsize=(20,10),dpi=80) #散点图 plt.scatter(x1, y1, label=\"3月份\") plt.scatter(x2, y2, label=\"10月份\") # 修改x轴刻度 _x = list(x1) + list(x2) _xtick_label = [\"3月{0}日\".format(i) for i in x1] _xtick_label += [\"10月{0}日\".format(i-50) for i in x2] plt.xticks(_x[::2], _xtick_label[::2], fontproperties=my_font, rotation=45, fontsize=10) # 添加描述信息 plt.xlabel(\"时间\", fontproperties=my_font, fontsize=20) plt.ylabel(\"温度\", fontproperties=my_font, fontsize=20) # t添加图例 plt.legend(prop=my_font, handlelength=5, handleheight=5, fontsize=50) plt.show() 条形图 a = [\"战狼2\",\"速度与激情8\",\"功夫瑜伽\",\"西游伏妖篇\",\"变形金刚5：最后的骑士\",\"摔跤吧！爸爸\",\"加勒比海盗5：死无对证\",\"金刚：骷髅岛\",\"极限特工：终极回归\",\"生化危机6：终章\",\"乘风破浪\",\"神偷奶爸3\",\"智取威虎山\",\"大闹天竺\",\"金刚狼3：殊死一战\",\"蜘蛛侠：英雄归来\",\"悟空传\",\"银河护卫队2\",\"情圣\",\"新木乃伊\",] b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] x = range(len(a)) plt.figure(figsize=(20,10)) # width：宽度 plt.bar(x, b, width=0.5) # 修改x轴信息 plt.xticks(x, a, fontproperties=my_font, fontsize=15, rotation=90) plt.show() 横条形图 a = [\"战狼2\",\"速度与激情8\",\"功夫瑜伽\",\"西游伏妖篇\",\"变形金刚5：最后的骑士\",\"摔跤吧！爸爸\",\"加勒比海盗5：死无对证\",\"金刚：骷髅岛\",\"极限特工：终极回归\",\"生化危机6：终章\",\"乘风破浪\",\"神偷奶爸3\",\"智取威虎山\",\"大闹天竺\",\"金刚狼3：殊死一战\",\"蜘蛛侠：英雄归来\",\"悟空传\",\"银河护卫队2\",\"情圣\",\"新木乃伊\",] b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] x = range(len(a)) plt.figure(figsize=(20,10)) # height：宽度(因为是横条形图，所以是高度) plt.barh(x, b, height=0.5, color='orange') # 修改y轴信息(横条形图) plt.yticks(x, a, fontproperties=my_font, fontsize=20) # 网格 plt.grid() plt.show() 绘制多次条形图 a = [\"猩球崛起3：终极之战\",\"敦刻尔克\",\"蜘蛛侠：英雄归来\",\"战狼2\"] b_16 = [15746,312,4497,319] b_15 = [12357,156,2045,168] b_14 = [2358,399,2358,362] bar_width = 0.2 plt.figure(figsize=(20,10)) x16 = list(range(len(a))) x15 = [i+bar_width for i in x16] # 移动2个宽度 x14 = [i+bar_width*2 for i in x16] plt.bar(x16, b_16, width=bar_width, label=\"16日票房\") plt.bar(x15, b_15, width=bar_width, label=\"15日票房\") plt.bar(x14, b_14, width=bar_width, label=\"14日票房\") # 设置x刻度(因为刻度是在黄色上，即x15对应一下即可，x16和x14对应也可以就是标注会左右移动一点) plt.xticks(x15, a,fontproperties=my_font, fontsize=25) plt.grid() plt.legend(prop=my_font) plt.show() 直方图 组数：将数据分组，如果数据在100个以内，按数据多少分为5-12组 组距：指每个小组的两个端点的距离 组数 = 极值 / 组距 = (max(a) - min(a)) / bin_width 原始数据 如果是统计之后的数据，需要用条形图绘制 a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150] plt.figure(figsize=(20, 15)) # 计算组数 bin_width = 3 num_bins = (max(a) - min(a)) // bin_width # 频数分布直方图 plt.subplot(2,1,1) # 也可以传一个列表，长度为组数，值为分组依据，当组距不均匀的时候使用 plt.hist(a, num_bins) # 设置x刻度 plt.xticks(range(min(a), max(a) + bin_width, bin_width)) plt.xlabel(\"电影时长(分钟)\", fontproperties=my_font, fontsize=20) plt.ylabel(\"频数\", fontproperties=my_font, fontsize=30) plt.title(\"频数分布直方图\", fontproperties=my_font, fontsize=30) plt.grid() # 频率分布直方图（density=1） plt.subplot(2,1,2) plt.hist(a, num_bins, density=1) plt.xticks(range(min(a), max(a) + bin_width, bin_width)) plt.xlabel(\"电影时长(分钟)\", fontproperties=my_font, fontsize=20) plt.ylabel(\"频率\", fontproperties=my_font, fontsize=30) plt.title(\"频率分布直方图\", fontproperties=my_font, fontsize=30) plt.grid() plt.show() 统计后数据 在美国2004年人口普查发现有124 million的人在离家相对较远的地方工作。根据他们从家到上班地点所需要的时间,通过抽样统计(最后一列)出了下表的数据,这些数据能够绘制成直方图么? # 还有些疑问 interval = [0,5,10,15,20,25,30,35,40,45,60,90] width = [5,5,5,5,5,5,5,5,5,15,30,60] quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47] plt.figure(figsize=(20,10), dpi=80) plt.bar(interval, quantity, width=width) x = interval _xtick_label = interval.append(150) plt.xticks(x, _xtick_label) # plt.grid() plt.show() "},"Web/Web前端概述.html":{"url":"Web/Web前端概述.html","title":"Web前端入门","keywords":"","body":"datetime:2019/5/17 17:12 author:nzb Web前端概述 说明：本文使用的部分插图来自Jon Duckett先生的HTML and CSS: Design and Build Websites一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。 HTML简史 1991年10月：一个非正式CERN（欧洲核子研究中心）文件首次公开18个HTML标签，这个文件的作者是物理学家蒂姆·伯纳斯-李，因此他是万维网的发明者，也是万维网联盟的主席。 1995年11月：HTML 2.0标准发布（RFC 1866）。 1997年1月：HTML 3.2作为W3C推荐标准发布。 1997年12月：HTML 4.0作为W3C推荐标准发布。 1999年12月：HTML4.01作为W3C推荐标准发布。 2008年1月：HTML5由W3C作为工作草案发布。 2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。 2012年12月：W3C指定HTML5作为“候选推荐”阶段。 2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。 HTML5新特性 引入原生多媒体支持（audio和video标签） 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持 使用标签承载内容 结构 head title meta body 文本 标题和段落 h1 ~ h6 p 上标和下标 sup sub 空白（白色空间折叠） 折行和水平标尺 br hr 语义化标签 加粗和强调 - strong 引用 - blockquote 缩写词和首字母缩写词 - abbr / acronym 引文 - cite 所有者联系信息 - address 内容的修改 - ins / del 列表（list） 有序列表（ordered list）- ol / li 无序列表（unordered list）- ul / li 定义列表（definition list）- dl / dt / dd 链接（anchor） 页面链接 锚链接 功能链接 图像（image） 图像存储位置 图像及其宽高 选择正确的图像格式 JPEG GIF PNG 矢量图 语义化标签 - figure / figcaption 表格（table） 基本的表格结构 - table / tr / td 表格的标题 - caption 跨行和跨列 - rowspan属性 / colspan属性 长表格 - thead / tbody / tfoot 表单（form） 重要属性 - action / method 表单控件（input）- type属性 文本框 - text / 密码框 - password / 数字框 - number 邮箱 - email / 电话 - tel / 日期 - date / 滑条 - range / URL - url / 搜索 - search 单选按钮 - radio / 复选按钮 - checkbox 文件上传 - file / 隐藏域（埋点）- hidden 提交按钮 - submit / 图像按钮 - image / 重置按钮 - reset 下拉列表 - select / option 文本域（多行文本）- textarea 组合表单元素 - fieldset / legend 音视频（audio / video） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster 其他 文档类型 注释 属性 id class 块级元素 / 行级元素 内联框架（internal frame） 字符实体（实体替换符） 使用CSS渲染页面 简介 CSS的作用 CSS的工作原理 规则、属性和值 常用选择器 颜色（color） 如何指定颜色 颜色术语和颜色对比 背景色 文本（text / font） 文本的大小和字型(font-size / font-family) 粗细、样式、拉伸和装饰(font-weight / font-style / font-stretch / text-decoration) 行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing) 对齐(text-align)方式和缩进(text-ident) 链接样式（:link / :visited / :active / :hover） CSS3新属性 阴影效果 - text-shadow 首字母和首行文本(:first-letter / :first-line) 响应用户 盒子（box model） 盒子大小的控制（width / height） 盒子的边框、外边距和内边距（border / margin / padding） 盒子的显示和隐藏（display / visibility） CSS3新属性 边框图像（border-image） 投影（border-shadow） 圆角（border-radius） 列表、表格和表单 列表的项目符号（list-style） 表格的边框和背景（border-collapse） 表单控件的外观 表单控件的对齐 浏览器的开发者工具 图像 控制图像的大小（display: inline-block） 对齐图像 背景图像（background / background-image / background-repeat / background-position） 布局 控制元素的位置（position / z-index） 普通流 相对定位 绝对定位 固定定位 浮动元素（float / clear） 网站布局 HTML5布局 适配屏幕尺寸 固定宽度布局 流体布局 布局网格 使用JavaScript控制行为 JavaScript基本语法 语句和注释 变量和数据类型 声明和赋值 简单数据类型和复杂数据类型 变量的命名规则 表达式和运算符 赋值运算符 算术运算符 比较运算符 逻辑运算符 分支结构 if...else... switch...cas...default... 循环结构 for循环 while循环 do...while循环 数组 创建数组 操作数组中的元素 函数 声明函数 调用函数 参数和返回值 匿名函数 立即调用函数 面向对象 对象的概念 创建对象的字面量语法 访问成员运算符 创建对象的构造函数语法 this关键字 添加和删除属性 delete关键字 标准对象 Number / String / Boolean / Symbol / Array / Function Date / Error / Math / RegEx / Object / Map / Set JSON / Promise / Generator / Reflect / Proxy BOM window对象的属性和方法 history对象 forward() / back() / go() location对象 navigator对象 screen对象 DOM DOM树 访问元素 getElementById() / querySelector() getElementsByClassName() / getElementsByTagName() / querySelectorAll() parentNode / previousSibling / nextSibling / children / firstChild / lastChild 操作元素 nodeValue innerHTML / textContent / createElement() / createTextNode() / appendChild() / insertBefore() / removeChild() className / id / hasAttribute() / getAttribute() / setAttribute() / removeAttribute() 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement） type cancelable preventDefault() stopPropagation()（低版本IE中的cancelBubble） 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload JavaScript API 客户端存储 - localStorage和sessionStorage localStorage.colorSetting = '#a4509b'; localStorage['colorSetting'] = '#a4509b'; localStorage.setItem('colorSetting', '#a4509b'); 获取位置信息 - geolocation navigator.geolocation.getCurrentPosition(function(pos) { console.log(pos.coords.latitude) console.log(pos.coords.longitude) }) 从服务器获取数据 - Fetch API 绘制图形 - 的API 音视频 - 和的API 使用jQuery jQuery概述 Write Less Do More（用更少的代码来完成更多的工作） 使用CSS选择器来查找元素（更简单更方便） 使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法） 引入jQuery 下载jQuery的开发版和压缩版 从CDN加载jQuery window.jQuery || document.write('') 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent>child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains('…') / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute='value'] / [attribute!='value'] / [attribute^='value'] / [attribute$='value'] / [attribute|='value'] / [attribute~='value'] 表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 链式操作 检测页面是否可用 $(document).ready(function() { }); $(function() { }); jQuery插件 jQuery Validation jQuery Treeview jQuery Autocomplete jQuery UI 避免和其他库的冲突 先引入其他库再引入jQuery的情况。 jQuery.noConflict(); jQuery(function() { jQuery('div').hide(); }); 先引入jQuery再引入其他库的情况。 jQuery(function() { jQuery('div').hide(); }); 使用Ajax Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 原生的Ajax 基于jQuery的Ajax 加载内容 提交表单 前端框架 渐进式框架 - Vue.js 前后端分离开发（前端渲染）必选框架。 快速上手 引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。 数据绑定（声明式渲染 ）。 库存信息 const app = new Vue({ el: '#app', data: { product: 'iPhone X' } }); 条件与循环。 库存信息 - 已经售罄 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] } }); 计算属性。 库存信息 - 已经售罄 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 处理事件。 库存信息 - 已经售罄 增加库存 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 用户输入。 库存信息 - 已经售罄 增加库存 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 通过网络加载JSON数据。 库存信息 - 已经售罄 const app = new Vue({ el: '#app', data: { products: [] }， created() { fetch('https://jackfrued.top/api/products') .then(response => response.json()) .then(json => { this.products = json }); } }); 使用脚手架 - vue-cli Vue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。 安装脚手架。 创建项目。 安装依赖包。 运行项目。 UI框架 - Element 基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。 引入Element的CSS和JavaScript文件。 一个简单的例子。 点我 开始使用Element吧 new Vue({ el: '#app', data: { visible: false, } }) 使用组件。 new Vue({ el: '#app', data: { tableData: [ { date: '2016-05-02', name: '王一霸', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '刘二狗', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '杨三萌', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '陈四吹', address: '上海市普陀区金沙江路 1516 弄' } ] } }) 报表框架 - ECharts 百度出品的开源可视化库，常用于生成各种类型的报表。 基于弹性盒子的CSS框架 - Bulma Bulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。 Bulma div { margin-top: 10px; } .column { color: #fff; background-color: #063; margin: 10px 10px; text-align: center; } 1 2 3 4 Primary Link Info Success Warning Danger 60% One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve 响应式布局框架 - Bootstrap 用于快速开发Web应用程序的前端框架，支持响应式布局。 特点 支持主流的浏览器和移动设备 容易上手 响应式设计 内容 网格系统 封装的CSS 现成的组件 JavaScript插件 可视化 "},"Web/HTML5/HTML5.html":{"url":"Web/HTML5/HTML5.html","title":"HTML5","keywords":"","body":"datetime:2019/7/1 9:43 author:nzb HTML5元素 元素指的是从开始标签到结束标签的所有代码 开始标签 元素内容 结束标签 this is my web page HTML元素语法： 元素的内容是开始标签与结束标签之间的内容 空元素在开始标签进行关闭 大多数HTML元素拥有属性 嵌套HTML元素 HTML5属性使用方法 标签可以拥有属性为元素提供更多的信息 属性以键值对的形式出现。 如：href=\"www.baidu.com\" 常用标签属性： :align对齐方式 :bgcolor背景颜色 :target规定在何处打开链接 通用属性 class：规定元素的类名 id：规定元素唯一id style：规定元素的样式 title：规定元素的额外信息 HTML5格式化 标签 描述 定义粗体文本 定义大号字,在HTML5取消采用CSS代替 定义着重文字 定义斜体字 定义小号字 定义加重语气 定义下标字 定义上标字 定义插入字 定义删除字 HTML5样式 标签： ：样式定义 ：资源引用 属性： rel=\"stylesheet\"：外部样式表 type=\"text/css\"：引入文档的类型 margin-left：边距 三种样式表插入方法： 外部样式表： 内部样式表： body{background-color: red} p{margin-left: 20px;} 内联样式表： HTML5链接 链接数据： 文本链接 图片链接 属性： href属性：指向另一个文档的链接 name属性：创建文档内的链接 img标签属性： alt：替换文本属性 width：宽 height：高 HTML5表格 标签 描述 定义表格 定义表格标题 定义表格的表头 定义表格的行 定义表格的单元 定义表格的页眉 定义表格的主体 定义表格的页脚 定义表格的列属性 没有边框的表格：不加border属性 表格中的表头：表头 空单元格：不书写内容即可 带有标题的表格：标题 表格内的标签： 单元4 单元5 苹果 香蕉 桃子 单元格边距：cellpadding=\"20\" 单元格间距：cellspacing=\"10\" 表格内背景颜色和图像：bgcolor=\"red\" HTML5列表 标签 描述 有序列表 无序列表 列表项 列表 列表项 描述 无序列表 使用标签：、 属性：disc、circle、square 有序列表 使用标签：、 属性：A、a、I、i、start 嵌套列表 使用标签：、、 自定义列表 使用标签：、、 HTML5块 HTML块元素 块元素在显示时，通常会以新行开始。 如：、、 HTML内联元素 内联元素通常不会以新行开始。 如：、、 HTML元素 元素也被称为块元素，其主要是组合HTML元素的容器 HTML元素 元素是内联元素，可作为文本的容器 HTML5布局 使用元素布局 div布局 body{ margin: 0px; } #container{ width: 100%; height: 950px; background-color: gray; } #heading{ width: 100%; height: 10%; background-color: #1b6d85; } #content_menu{ width: 30%; height: 80%; background-color: #5cb85c; /*从左到右浮动*/ float: left; } #content_body{ width: 70%; height: 80%; background-color: #8a6d3b; float: left; } #footing{ width: 100%; height: 10%; background-color: #985f0d; /*清除浮动*/ clear: both; } 头部 内容菜单 内容主体 底部 使用元素布局 table布局 这是头部 view code other 主体 右菜单 底部 HTML5表单 表单用于获取不同类型的用户输入 常用表单标签 表单 输入域 文本域 控制标签 定义域 域的标题 选择列表 选项组 下拉列表中的选项 按钮 HTML5框架 框架标签(frame):(HTML5已过时) 框架对于页面的设计有着很大的作用 框架集标签():(HTML5中已过时) 框架集标签定义如何将窗口分隔为框架 每一个frameset定义一系列行或列 rows/cols的值规定了每行或每列占据屏幕的面积 常用标签： noresize：固定框架大小 cols：列 rows：行 内联框架(HTML5主要使用的) iframe target属性： _self：当前frame打开 _blank：新窗口打开 _parent：父级frame打开 _top：当前窗口打开 frame.html frame 百度--> framea.html Title framea 百度一下 --> frameb.html Title frameb framec.html Title framec HTML5背景 背景标签： Background 背景颜色 Bgcolor 颜色： 颜色是由一个十六进制符号来定义，这个符号由红色、蓝色和绿色的值组成(RGB) 颜色值最小值：0(#00) 颜色值最大值：255(#FF) 红色：#FF0000 绿色：#00FF00 蓝色：#0000FF HTML5实体 实体 HTML中预留字符串必须被替换成字符实体。如：、& XHTML的规范化 什么是XHTML? XHTML指的是可扩展超文本标记语言 XHTML与HTML4.01几乎是相同的 XHTML是更严格更纯净的HTML版本 XHTML是以XML应用的方式定义的HTML XHTML得到所有主流浏览器的支持 为什么使用XHTML? 为了代码的完整性和良好性 文档声明： DTD：规定了使用通用标记语言的网页语法 三种XHTML文档类型 STRICT(严格类型) TRANSITIONAL(过度类型) FRAMESET(框架类型) XHTML元素语法： XHTML元素必须嵌套 XHTML元素必须始终关闭 XHTML元素必须小写 XHTML文档必须有一个根元素 XHTML属性语法规则： XHTML属性必须使用小写 XHTML属性值必须用引号包围 XHTML属性最小化也是禁止的 HTML5新特性 引入原生多媒体支持（audio和video标签） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持 HTML5新增的主体结构元素 article元素 article元素代表文档、页面或应用程序中独立的、完整的、可以独立被外部引用的内容。它可以是一篇博客或者报刊中的一篇文章，一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。 article元素可以嵌套使用，也可以用来表示插件。 article元素 英雄联盟 欢迎来到英雄联盟 作者 评论 time 这是底部 这是一个内嵌页面 section元素 section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由其内容及标题组成。但section元素并非一个普通的容器元素；当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section元素。 section元素 苹果 这是一个苹果 苹果 这是一个苹果 红富士 这是苹果的一种 国光 这是苹果的一种 水果 苹果 内容 苹果 内容 苹果 内容 section与article的区别 section的作用强调对文章或页面进行分段、分块，而article元素强调独立性 section使用总结：1、不要将section元素作为设置样式的页面容器，那是div的工作。2、如果使用article、aside、nav元素更符合使用条件，那就不要使用section元素。3、没有标题内容，不要使用section元素。 nav元素 nav元素是一个可以用作页面导航的连接组，其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的连接组都要被放进nav元素，只需要将主要的、基本的连接组放进nav元素即可。nav的应用场景：传统导航栏、侧边导航栏、页内导航、翻页操作。 nav元素 主页 开发文档 html5与css3的历史 html5历史 css3历史 css3的历史 ... 删除 修改 版权声明 HTML5中不能使用menu元素代替nav元素 aside元素 -aside元素用来表示当前页面或文章的附属信息部分，它可以包含于当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有区别于主要内容的部分。 aside元素 js入门 语法 文章的正文。。。 名词解释 语法：。。。。。。。 评论 2019-7-1 好好学习 time元素和微格式 time元素 2019-7-1 2019-7-1 2019-7-1 2019-7-1 苹果 发布时间 2019-7-1 舞会事件 2019-7-2 HTML5新增的非主体结构元素 header元素 Header元素是一种具有引导和导航作用的结构元素，通常放置整个页面或页面内的一个内容区域的标题，但是也可以包含其他内容列如数据表格，搜索表单或相关Logo图片！ header元素 it最新技术 信息 信息1 信息2 footer元素 footer元素可作为上层父级内容区块或是一个根区块的脚注。footer通常包括相关区块的脚注信息，如作者，相关阅读连接及其版权信息等。 footer元素 --> 版权信息 版权信息 版权信息 版权信息 --> 这是文章的底部 这是块底部 hgroup元素(已废除) hgroup元素是将标题及其子标题进行分组的元素。 hgroup元素通常被分为H1~H6元素进行分组，如一个内容区块的标题及其子元素算一组。 hgroup元素 这是文章标题 这是一个子标题 2019-7-1 这是内容 这是底部 address元素 address元素用来存放文档中呈现的联系信息，文档作者，等等的名字 网站链接 电子邮箱 真实地址 电话号码 等 address元素 a b c 百度一下 2019-7-1 网页编排规则 网页标题 文章主标题 文章子标题 文章正文 评论标题 评论正文 版权所有：hawen 表单新增元素与属性 表单内元素的form属性 在Html4中，表单内的从属元素必须写在表单内部，而在HTML5中，可以把它们书写在页面的任何地方，然后为该元素指定一个form属性，属性值为该表单的id。 这样九可以声明该元素从属于指定表单了。 表单内元素的formaction属性 在HTML4中，一个表单内的所有元素只能通过表单的action属性统一提交到另一个页面，而在HTML5中可以为所有的提交按钮。 表单内元素的formmethod属性 在HTML4中，一个表单内只有一个action属性用来对表单内所有元素统一指定提交页面，所以每个表单内也只有一个method属性来统一指定提交方法。 在HTML5中，可以使用formmethod属性来对每个表单元素分别指定不同的提交方法。 表单内元素的formenctype属性 在HTML4中，表单元素具有一个enctype属性，该属性用于指定在表单发送到服务器之前应该如何对表单内的数据进行编码。 application/x-www-from-urlencoded：编码方式把表单数据转换成一个字符串形式?a=value1&b=value2&c=value3,然后把这个字符串价到提交的目标URL地址后面。 该属性为表单enctype属性的默认属性值。 multipart/form-data:不对字符编码,在使用包含文件上传控件的表单时，必须使用该值。 text/plain:对表单数据中的空格被转换为\"+\",但不对表单数据中的特殊字符进行编码。 在HTML5中，可以使用formenctype属性对表单元素分别指定不同的编码方式。 文件: 表单内元素的formtarget属性 在HTML4中，表单元素具有一个target属性，该属性用于指定在何处打开表单提交后，所需要加载的页面。 _blank:在新的浏览器窗口中打开。 _self:默认值，在相同的框架中打开。 _parent:在当前框架的父框架中打开。 _top:在当前浏览器窗口中打开。 framename:在指定的框架中打开。 在HTML5中，可以对多个提交按钮分别使用formtarget属性来指定提交后在何处打开所需要加载的页面。 表单内元素的autofocus属性 文本框、选择框或按钮加上autofocus属性，当页面打开时，该控件自动获取光标焦点。一个页面上只能有一个控件具有autofocus属性。 表单内元素的required属性 HTML5中新增的required属性可以应用在大多数输入元素上，在提交时，将验证输入内容是否合法，如果不合法则不允许提交，同时在浏览器显示相应的提示信息。 表单内元素的labels属性 在HTML5中，为所有可使用label的表单元素，定义一个labels属性，属性值为一个NodeList对象，代表该元素所绑定的标签元素构成的集合。 var TxtName=document.getElementById(\"txt_name\"); alert(TxtName.labels.length); 名字: 标签的control属性 在HTML5中，可以在标签内部放置一个表单元素，并且通过该标签的control属性来访问该表单元素。 邮编: 请输入六位数字 function setValue(){ var label = document.getElementById('label'); var textbox = label.control; textbox.value='10010'; } 文本框的placeholder属性 placeholder是指当文本框处于微输入状态时显示的输入提示。 文本框的list属性 HTML5中,为增加了一个list属性，该属性的值为某个datalist的id。 datalist元素也是HTML5中新增的元素，该元素类似于选择框(Select元素),但是当用户想要设定的值不在选择列表之内时，允许自行输入。 datalist元素本身并不显示，而是当文本框获取焦点时以提示输入的方式显示。 你好 早上 文本框的AutoComplete属性 辅助输入所用的自动完成功能，时一个即节省输入时间又十分方便的功能。在HTML5之前，因为谁都可以看见输入的值，所以在安全方面存在缺陷。 对于autocomplete属性，可以指定\"on\"、\"off\"与\"\"(不指定)这三种值。在不进行指定时，使用浏览器的默认值。把该属性设为on时， 可以显示指定候补输入的数据列表。使用datalist元素与list属性提供候补输入的数据列表，在执行自动完成时， 可以将该datalist元素中的数据作为候补输入的数据在文本框中自动显示。 文本框的pattern属性 在HTML5中，对input元素使用pattern属性，并且将属性值设置某个格式的正则表达式时，在提交时会对这些进行检查，检查其内容是否符合给定格式。 文本框的SelectDirection属性 对input 元素和textarea 元素，HTML5增加了SelectionDirection属性。当用户在这两个元素中用户鼠标选取部分文字时， 可以使用属性来获取选取方向。正向选取:forward,反向选取为:backward。 复选框的indeterminate属性 对复选框checkbox元素来说，过去只有选取与非选取两种状态。在HTML5中，可以在Javascript脚本代码中对该元素使用indeterminate属性， 以说明复选框处于\"尚未明确是否选取的状态\"。indeterminate属性为boolean 类型 当为true 时，浏览器中的复选框将显示为不明状态。 需要注意的时，indeterminate属性与checked属性时两种不同的属性。因此，在判断复选框时，应该现判断indeterminate属性值，然后在判断checked属性值。 var cb = document.getElementById('cb'); cb.indeterminate = true; image提交按钮的height属性与width属性 针对类型为image的input元素，HTML5新增了两个属性，height、width分别用来指定图片的高、宽。 "},"Web/CSS/CSS.html":{"url":"Web/CSS/CSS.html","title":"CSS","keywords":"","body":"datetime:2019/7/2 9:40 author:nzb CSS基础语法 `selector { property:value }` 例：h1{color:red;font-size:14px;} 属性大于1个之后，属性之间用分号隔开，如果值大于一个单词，则需要加上引号：p{font-family:\"sans serif\"} 浏览器读取 CSS 的顺序是从上到下，这意味着，在发生冲突时，浏览器会使用最后的 CSS 声明。后面的会覆盖前面的。 id 声明都会覆盖 class 声明。行内样式会覆盖其他声明。 多情况下，你会使用 CSS 库，这些库可能会意外覆盖掉你自己的 CSS。所以当你需要确保某元素具有指定的 CSS 时，你可以使用 !important。 CSS高级语法 选择器分组： h1,h2,h3,h4,h5{color:red;} 继承：body{color:green} 派生选择器 通过依据元素在其位置的上下文关系来定义样式 address元素 li strong{ color: red; } strong{ color: gray; } 文章1 文章2 id选择器 id选择器可以为标有id的HTML元素指定特定的样式 id选择器以\"#\"来定义 目前比较常用的方式是id选择器常常用于建立派生选择器 address元素 #div1{ color: red; } #div1 a{ color: blue; } 这是一个div 这是超链接 类选择器 类选择器以一个点显示 class也可以作为派生选择器 address元素 .dclass p{ color: red; } 这是一个p标签 属性选择器 属性选择器：对带有指定属性的HTML元素设置样式 属性和值选择器 address元素 [title]{ color:red; } [title=te]{ color: blue; } 这是一个p标签 这是一个p标签 CSS背景 CSS允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果 属性 描述 backgroud-attachment 背景图是否或者随着页面的其余部分滚动 backgroud-color 设置元素的背景颜色 backgroud-image 把图片设置为背景 backgroud-position 设置背景图片的起始位置 backgroud-repeat 设置背景图片是否及如何重复 backgroud-size 规定背景图片的尺寸 backgroud-origin 规定背景图片的定位区域 backgroud-clip 规定背景的绘制区域 CSS文本 属性 描述 color 文本颜色 direction 文本方向 line-height 行高 letter-spacing 字符间距 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-transform 元素中的字母 unicode-bidi 设置文本方向 white-space 元素中空白的处理方式 word-spacing 字间距 CSS3文本效果 属性 描述 text-shadow 向文本添加阴影 word-wrap 规定文本的换行规则 CSS 字体 CSS字体属性定义文本的字体系列、大小、加粗、风格和变形 属性 描述 font-family 设置字体系列 font-size 设置字体的尺寸 font-style 设置字体风格 font-variant 以小型大写字体或正常字体显示文本 font-weight 设置字体的粗细 CSS链接 CSS链接的四种状态 a:link 普通的、未被访问的链接 a:visited 用户已访问的链接 a:hover 鼠标指针位于链接的上方 a:active 链接被点击的时刻 常见的链接方式 text-decoration 属性大多用于去掉链接中的下划线 设置背景颜色 -backgroud-color CSS列表 CSS列表属性允许你放置、改变列表标志，或者将图像作为列表项标志 属性 描述 list-style 简写列表项 list-style-image 列表项图像 list-style-position 列表标志位置 list-style-type 列表类型 CSS表格 指定CSS表格边框，使用border属性。 border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开： Width和height属性定义表格的宽度和高度。 表格中的文本对齐和垂直对齐属性。text-align属性设置水平对齐方式，向左，右，或中心： 表格填充：padding 表格颜色：color CSS轮廓 属性 描述 outline 设置轮廓属性 outline-color 设置轮廓的颜色 outline-style 设置轮廓的样式 outline-width 设置轮廓的宽度 CSS定位 CSS定位 改变元素在页面上的位置 CSS定位机制 普通流：元素按照其在HTML中的位置顺序决定排布的过程 浮动 绝对布局 CSS定位属性 属性 描述 position 把元素放在一个静态的、相对的、绝对的、或固定的位置中 top 元素向上的偏移量 left 元素向左的偏移量 right 元素向右的偏移量 bottom 元素向下的偏移量 overflow 设置元素溢出其区域发生的事情 clip 设置元素显示的形状 vertical-align 设置元素垂直对齐方式 z-index 设置元素的堆叠顺序 position 属性的五个值： static：HTML 元素的默认值，即没有定位，遵循正常的文档流对象。静态定位的元素不会受到 top, bottom, left, right影响。 relative：元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动： fixed：相对定位元素的定位是相对其正常位置。移动相对定位元素，但它原本所占的空间不会改变。相对定位元素经常被用来作为绝对定位元素的容器块。 absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。absolute 定位的元素和其他元素重叠。 sticky：sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。position: sticky; 基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 重叠的元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） 一个元素可以有正数或负数的堆叠顺序： 具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。 注意： 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。 CSS浮动 浮动： float属性可用的值： left：元素向左浮动 right：元素向右浮动 none：元素不浮动 inherit：从父级继承浮动属性 clear属性： 去掉浮动属性(包括继承来的属性) clear属性值： left、right：去掉元素向左、向右浮动 both：左右两侧去掉浮动 inherit：从父级继承来clear的值 盒子模型 概述 margin、border、padding、content部分组成 内边距 padding padding-top padding-bottom padding-right padding-left 边框 CSS边框 我们可以创建出效果出色的边框，并且可以应用于任何元素 边框的样式： boder-style：定义了10个不同的非继承样式，包括none none: 默认无边框 dotted: 定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 单边框样式 border-top-style border-right-style border-bottom-style border-left-style 边框宽度 border-width：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。 单边框宽度 border-top-width border-right-width border-bottom-width border-left-width 边框颜色 border-color 单边框颜色 border-top-color border-right-color border-bottom-color border-left-color CSS3边框 border-image：设置所有边框图像的速记属性。 border-radius ：一个用于设置所有四个边框-*-半径属性的速记属性 box-shadow：附加一个或多个下拉框的阴影 外边距 属性 描述 margin 简写属性。在一个声明中设置所有外边距属性, 如margin：上下，左右。也可以auto自适应会居中 margin-bottom 设置元素的下外边距 margin-left 设置元素的左外边距 margin-right 设置元素的右外边距 margin-top 设置元素的上外边距 外边距合并 外边距合并就是第一个叠加的概念 盒子模型应用 盒子模型 *{ margin: 0px; padding: 0px; } .top{ width: 100%; height: 50px; background-color: black; } .top_content{ width: 75%; height: 50px; background-color: #8a6d3b; margin: 0px auto; } .body{ margin: 20px auto; width: 75%; height: 1500px; background-color: #9d9d9d; } .body_img{ width: 100%; height: 500px; background-color: #5bc0de; } .body_content{ width: 100%; height: 1000px; background-color: #985f0d; } .body_no{ width: 100%; height: 40px; background-color: #23527c; } .footing{ width: 75%; height: 400px; background-color: #a6e1ec; margin: 0 auto; } .footing_content{ width: 100%; height: 300px; background-color: #245269; } .footing_subnav{ width: 100%; height: 100px; background-color: #555555; } CSS对齐-水平&垂直对齐 元素居中对齐 要水平居中对齐一个元素(如 ), 可以使用 margin: auto;。 设置到元素的宽度将防止它溢出到容器的边缘。 元素通过指定宽度，并将两边的空外边距平均分配： 注意: 如果没有设置 width 属性(或者设置 100%)，居中对齐将不起作用。 文本居中对齐 如果仅仅是为了文本在元素内居中对齐，可以使用 text-align: center; 图片居中对齐 要让图片居中对齐, 可以使用 margin: auto; 并将它放到 块 元素中: 左右对齐 - 使用定位方式 我们可以使用 position: absolute; 属性来对齐元素: .right { position: absolute; right: 0px; width: 300px; border: 3px solid #73AD21; padding: 10px; } 注释：绝对定位元素会被从正常流中删除，并且能够交叠元素。 提示: 当使用 position 来对齐元素时, 通常 元素会设置 margin 和 padding 。 这样可以避免在不同的浏览器中出现可见的差异。 body { margin: 0; padding: 0; } .container { position: relative; width: 100%; } .right { position: absolute; right: 0px; width: 300px; background-color: #b0e0e6; } 左右对齐 - 使用 float 方式 我们也可以使用 float 属性来对齐元素 垂直居中对齐 - 使用 padding CSS 中有很多方式可以实现垂直居中对齐。 一个简单的方式就是头部顶部使用 padding 如果要水平和垂直都居中，可以使用 padding 和 text-align: center: 垂直居中 - 使用 line-height 垂直居中 - 使用 position 和 transform CSS尺寸 属性 描述 height 设置元素的高度 line-height 设置行高 max-height 设置元素的最大高度 max-width 设置元素的最大宽度 min-height 设置元素的最小高度 min-width 设置元素的最小宽度 width 设置元素的宽度 CSS分类 属性 描述 clear 设置一个元素的侧面是否允许其他的浮动元素 cursor 规定当指向某元素之上时显示的指针类型 display 设置是否及如何显示元素 float 定义元素在那个方向浮动 position 把元素放置到一个静态的、相对的、绝对的、固定的位置 visibility 设置元素是否看见或不可见 CSS中块级、内联元素的应用： 利用CSS我们可以摆脱上面表格里HTML标签归类的限制，自由地在不同标签/元素上应用我们需要的属性。 主要用的CSS样式有以下三个： display:block -- 显示为块级元素 display:inline -- 显示为内联元素 display:inline-block -- 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性 我们常将元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。 导航栏 导航栏=链接列表 作为标准的HTML基础一个导航栏是必须的。在我们的例子中我们将建立一个标准的HTML列表导航栏。 导航条基本上是一个链接列表，所以使用 和 元素非常有意义 ul { list-style-type: none; margin: 0; padding: 0; width: 200px; background-color: #f1f1f1; } /*垂直导航栏*/ li a { display: block; color: #000; padding: 8px 16px; text-decoration: none; } /* 鼠标移动到选项上修改背景颜色 */ li a:hover { background-color: #555; color: white; } /*激活/当前导航条实例*/ .active { background-color: #4CAF50; color: white; } 主页 新闻 联系 关于 示例说明： display:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度 width:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度 水平导航栏 有两种方法创建横向导航栏。使用内联(inline)或浮动(float)的列表项。 这两种方法都很好，但如果你想链接到具有相同的大小，你必须使用浮动的方法。 CSS图片 圆角图片：border-radius: 8px; 椭圆形图片：border-radius: 50%; 缩略图：我们使用 border 属性来创建缩略图。 透明度：opacity。 Opacity属性值从0.0 - 1.0。值越小，使得元素更加透明。 选择器详解 元素选择器 选择器分组(以逗号分隔) 通配符：* 一般这样设置： `*{ margin:0px padding:0px }` 类选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点\".\"号显示： ID选择器 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 \"#\" 来定义 ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。 属性选择器 属性选择器： `[title] { color:blue; }` 属性和值选择器： `[title=runoob] { border:5px solid green; }` 属性和值的选择器 - 多值： [title~=hello] { color:blue; } 后代选择器(以空格分隔) 选取所有 元素插入到 元素中： `div p { background-color:yellow; }` 子元素选择器(以大于号分隔) 选择了元素中所有直接子元素 ： `div>p { background-color:yellow; }` 相邻兄弟选择器(以加号分隔) 选取了所有位于 元素后的第一个 元素： `div+p { background-color:yellow; }` 后续兄弟选择器 选取了所有 元素之后的所有相邻兄弟元素 ： `div~p { background-color:yellow; }` 2D、3D转换(transform) 2D 转换： 移动：translate()：根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。 旋转：rotate()：在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 div { transform: rotate(30deg); /*浏览器支持*/ -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ } 缩放：scale()：该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数。 倾斜：skew()： 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。 skewX();表示只在X轴(水平方向)倾斜。 skewY();表示只在Y轴(垂直方向)倾斜。 matrix()： matrix()方法和2D变换方法合并成一个。 matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 3D转换： rotateX()：围绕其在一个给定度数X轴旋转的元素。 rotateY()：围绕其在一个给定度数Y轴旋转的元素 过渡 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性 transition-property 规定应用过渡的 CSS 属性的名称 transition-duration 定义过渡效果花费的时间。默认是 0 transition-timing-function 规定过渡效果的时间曲线。默认是 \"ease\" transition-delay 规定过渡效果何时开始。默认是 0 /*在一个例子中使用所有过渡属性：*/ div { transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; /* Safari */ -webkit-transition-property:width; -webkit-transition-duration:1s; -webkit-transition-timing-function:linear; -webkit-transition-delay:2s; } /*与上面的例子相同的过渡效果，但是使用了简写的 transition 属性：*/ div { transition: width 1s linear 2s; /* Safari */ -webkit-transition:width 1s linear 2s; } 动画 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了 animation-play-state 属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0 animation-timing-function 规定动画的速度曲线。默认是 \"ease\" animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式 animation-delay 规定过渡效果何时开始。默认是 0 animation-iteration-count 规定动画被播放的次数。默认是 1 animation-direction 规定动画是否在下一周期逆向地播放。默认是 \"normal\" animation-play-state 规定动画是否正在运行或暂停。默认是 \"running\" 菜鸟教程(runoob.com) div { width:100px; height:100px; background:red; position:relative; animation-name:myfirst; animation-duration:5s; animation-timing-function:linear; animation-delay:2s; animation-iteration-count:infinite; animation-direction:alternate; animation-play-state:running; /* Safari and Chrome: */ -webkit-animation-name:myfirst; -webkit-animation-duration:5s; -webkit-animation-timing-function:linear; -webkit-animation-delay:2s; -webkit-animation-iteration-count:infinite; -webkit-animation-direction:alternate; -webkit-animation-play-state:running; } /*与上面的动画相同，但是使用了简写的动画 animation 属性：*/ div { width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate; } @keyframes myfirst { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } @-webkit-keyframes myfirst /* Safari and Chrome */ { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } 注意: 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。 多列 column-count：指定了需要分割的列数。 column-fill： 指定如何填充列。 column-gap：指定了列与列间的间隙。 column-rule-style：指定了列与列间的边框样式。 column-rule-width：指定了两列的边框厚度 column-rule-color：指定了两列的边框颜色 column-rule：是 column-rule-* 所有属性的简写 column-span：指定元素要跨越多少列。 column-width：指定了列的宽度。 columns：设置 column-width 和 column-count 的简写 瀑布流 waterfall .container{ column-width: 200px; -webkit-column-width: 200px; -webkit-column-gap: 5px; } .container div{ width: 200px; margin: 5px; } .container p{ text-align: center; } 标签 标签 标签 标签 标签 标签 "},"Web/JavaScript/JavaScript基础.html":{"url":"Web/JavaScript/JavaScript基础.html","title":"JavaScript基础","keywords":"","body":"datetime:2019/7/3 15:48 author:nzb 语法与注释 JavaScript语句 JavaScript语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。 分号： 语句之间的分割是分号(;) 注意：分号是可选项，有时候看到不以分号隔开的。 JavaScript代码： 按照编写顺序依次执行 标识符： JavaScript标识符必须以字母、下划线或美元符号开始 JavaScript关键字 JavaScript对大小写敏感 空格 JavaScript会忽略多余的空格 代码换行 保留字 单行注释 // 多行注释 /**/ 变量和数据类型 变量是用来存储信息的“容器”，使用var来声明 例: var x=10; var y=10.1; var z=\"hello\"; 数据类型 字符串(String) 数字(Number) 布尔(Boolean) 数组(Array) var arr=['hello',1,2]; var arr=new Array('world',2,3); var arr=new Array(); arr[0]=4; arr[1]=5; arr[2]=6; 对象(Object) 空(null) 未定义 可以通过赋值为null的方式清除变量 运算符 赋值运算符 =、+=、-=、*=、/=、%= 算术运算符 +、-、*、/、++、-- 比较运算符 ==、===、!=、!==、>、=、 逻辑运算符 &&、||、！ 条件(三目)运算符 例：x 字符串操作 相加就是拼接，任何类型相加字符串都会转化为字符串然后拼接 分支结构 if...else... var i = 10; if(i>=10){ document.write(\"i大于等于10\"); }else{ document.write(\"i小于10\"); } // 可以无限嵌套 if(i>10){ document.write(\"i大于10\"); }else if(i switch...cas...default... var i = 5; switch (i){ case 1: document.write(\"i为1\"); break; case 2: document.write(\"i为2\"); break; default: document.write(\"条件不满足\"); }; 循环结构 for循环 var i=[1,2,3,4,5,6]; for(var j=0;j while循环 var i = 1; while (i do...while循环 var i = 1; do{ document.write(\"i\"); i++; }while (i 跳转语句 break continue return 函数 定义函数 定义函数： function 函数名(){ 函数体; (代码块) } 注意： JavaScript对大小写十分敏感，所以这里的function必须小写。在函数调用时，也必须按照函数的相同名称来调用函数。 调用函数 function demo() { var a = 10; var b = 20; var sum = a+b; alert(sum); } // 第一种调用方式 demo(); // 第二种调用方式 按钮 带参数的函数 参数的个数可以为任意多，每个参数通过\",\"隔开 function demo(a,b) { var sum = a+b; alert(sum); } demo(10,20); 带返回值的函数 function demo(a,b) { var sum = a+b; return sum; } var sum = demo(10,20); alert(sum) 局部变量和全局变量 局部变量：函数内部声明 全局变量：函数外部声明 var n = 10; m = 10; //全局变量 任何地方都可以使用 function demo() { var i = 10; //局部变量 只能在当前函数中使用 x = 10; // 全局变量 只要调用了该函数任何地方都可以使用 } demo(); alert(x); 异常捕获 异常 当JavaScript引擎执行JavaScript代码时，发生了错误，导致程序停止运行 异常抛出 当异常产生，并且将这个异常生成一个错误信息 异常捕获 try{ 发生异常的代码块; }catch(err){ 错误信息处理; } Throw语句： 通过throw语句创建一个自定义错误 提交 function demo() { try{ var e = document.getElementById(\"txt\").value; if(e==\"\"){ throw \"请输入\"; } }catch (e) { alert(e) } } 事件 什么是事件 事件是可以被JavaScript侦测到的行为 | 事件 | 描述 | |------|-----| | onClick | 单击事件 | | onMouseOver | 鼠标经过事件 | | onMouseOut | 鼠标移出事件 | | onChange | 文本内容改变事件 | | onSelect | 文本框选中事件 | | onFocus | 光标聚集事件 | | onBlur | 移开光标事件 | | onLoad | 网页加载事件 | | onUnload | 关闭网页事件 | 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement）获取事件目标 type：获取事件类型 cancelable： preventDefault()：阻止事件默认行为 stopPropagation()（低版本IE中的cancelBubble）：阻止时间冒泡 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload DOM HTML DOM 当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model) DOM操作HTML JavaScript能够改变页面中的所有HTML元素 JavaScript能够改变页面中的所有HTML属性 JavaScript能够改变页面中的所有CSS样式 JavaScript能够改变页面中的所有事件作出反应 DOM操作HTML 改变 HTML 输出流 注意：绝对不要在文档加载完成之后使用document.write()。这会覆盖该文档 寻找元素： 通过id找到HTML元素 通过标签名找到HTML元素 改变 HTML 内容 使用属性：innerHTML document.getElementById(id).innerHTML=新的 HTML 改变 HTML 属性 使用属性：attribute document.getElementById(id).attribute=新属性值 document.getElementById(id).href=\"https://www.baidu.com\" document.getElementById(id).src=\"https://www.baidu.com\" DOM操作CSS 改变 HTML 样式 如需改变 HTML 元素的样式，请使用这个语法： document.getElementById(id).style.property=新样式 菜鸟教程(runoob.com) Hello World! Hello World! document.getElementById(\"p2\").style.color=\"blue\"; document.getElementById(\"p2\").style.fontFamily=\"Arial\"; document.getElementById(\"p2\").style.fontSize=\"larger\"; 以上段落通过脚本修改。 DOM EventListener addEventListener() addEventListener() 方法用于向指定元素添加事件句柄。 addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。 你可以向一个元素添加多个事件句柄。 你可以向同个元素添加多个同类型的事件句柄，如：两个 \"click\" 事件。 你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。 当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 你可以使用 removeEventListener() 方法来移除事件的监听。 语法：element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 \"click\" 或 \"mousedown\"). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 注意：不要使用 \"on\" 前缀。 例如，使用 \"click\" ,而不是使用 \"onclick\"。 例：在用户点击按钮时触发监听事件： document.getElementById(\"myBtn\").addEventListener(\"click\", displayDate); removeEventListener() removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄: element.removeEventListener(\"mousemove\", myFunction); 事件冒泡或事件捕获？ 事件传递有两种方式：冒泡与捕获。 事件传递定义了元素事件触发的顺序。 如果你将 元素插入到 元素中，用户点击 元素, 哪个元素的 \"click\" 事件先被触发呢？ 在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： 元素的点击事件先触发 ，然后再触发 元素的点击事件。 addEventListener() 方法可以指定 \"useCapture\" 参数来设置传递类型： addEventListener(event, function, useCapture); 默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。 浏览器支持 IE 8 及更早 IE 版本，Opera 7.0及其更早版本不支持 addEventListener() 和 removeEventListener() 方法。但是，对于这类浏览器版本可以使用 detachEvent() 方法来移除事件句柄: element.attachEvent(event, function); element.detachEvent(event, function); 例： var x = document.getElementById(\"myBtn\"); if (x.addEventListener) { // 所有主流浏览器，除了 IE 8 及更早版本 x.addEventListener(\"click\", myFunction); } else if (x.attachEvent) { // IE 8 及更早版本 x.attachEvent(\"onclick\", myFunction); } "},"Web/JavaScript/JavaScript对象.html":{"url":"Web/JavaScript/JavaScript对象.html","title":"JavaScript对象","keywords":"","body":"datetime:2019/7/4 15:38 author:nzb 对象 JavaScript 中的所有事物都是对象：字符串、数值、数组、函数... 对象只是一种特殊的数据。对象拥有属性和方法。 此外，JavaScript 允许自定义对象。 访问对象的属性 属性是与对象相关的值。 访问对象属性的语法是： objectName.propertyName 下面这个例子使用了 String 对象的 length 属性来获得字符串的长度： var message=\"Hello World!\"; var x=message.length; 在以上代码执行后，x 的值将是：12 访问对象的方法 方法是能够在对象上执行的动作。 您可以通过以下语法来调用方法： objectName.methodName() 下面这个例子使用了 String 对象的 toUpperCase() 方法来将文本转换为大写： var message=\"Hello world!\"; var x=message.toUpperCase(); 在以上代码执行后，x 的值将是：HELLO WORLD! 创建 JavaScript 对象 通过 JavaScript，您能够定义并创建自己的对象。 创建新对象有两种不同的方法： 定义并创建对象的实例 person=new Object(); person.firstname=\"John\"; person.lastname=\"Doe\"; person.age=50; person.eyecolor=\"blue\"; // 或 person={firstname:\"John\",lastname:\"Doe\",age:50,eyecolor:\"blue\"}; 使用函数来定义对象，然后创建新的对象实例 function person(firstname,lastname,age,eyecolor) { this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; } 在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时） 创建 JavaScript 对象实例 一旦您有了对象构造器，就可以创建新的对象实例，就像这样： var myFather=new person(\"John\",\"Doe\",50,\"blue\"); var myMother=new person(\"Sally\",\"Rally\",48,\"green\"); 把属性添加到 JavaScript 对象 person.firstname=\"John\"; person.lastname=\"Doe\"; person.age=30; person.eyecolor=\"blue\"; x=person.firstname; 在以上代码执行后，x 的值将是：John 把方法添加到 JavaScript 对象 function person(firstname,lastname,age,eyecolor) { this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; this.changeName=changeName; function changeName(name) { this.lastname=name; } } String对象 String 对象用于处理已有的字符块。 一个字符串可以使用单引号或双引号。 字符串（String）使用长度属性length来计算字符串的长度。 字符串使用 indexOf() 来定位字符串中某一个指定的字符首次出现的位置。 var str=\"Hello world, welcome to the universe.\"; var n=str.indexOf(\"welcome\"); 如果没找到对应的字符函数返回-1 lastIndexOf() 方法在字符串末尾开始查找字符串出现的位置。 内容匹配：match()函数用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符。 替换内容：replace() 方法在字符串中用某些字符替换另一些字符。 字符串大小写转换：字符串大小写转换使用函数 toUpperCase() / toLowerCase() 字符串转为数组：字符串使用split()函数转为数组。 特殊字符：Javascript 中可以使用反斜线（\\）插入特殊符号，如：撇号,引号等其他特殊符号。 | 代码 | 输出 | |------|-----| | \\' | 单引号 | | \\\" | 双引号 | | \\ | 斜杆 | | \\n | 换行 | | \\r | 回车 | | \\t | tab | | \\b | 空格 | | \\f | 换页 | 字符串属性和方法 属性: | 属性 | 描述 | |------|-----| | constructor | 对创建该对象的函数的引用 | | length | 字符串的长度 | | prototype | 允许您向对象添加属性和方法 | 方法: | 方法 | 描述 | |-----|------| | charAt() | 返回在指定位置的字符 | | charCodeAt() | 返回在指定的位置的字符的 Unicode 编码 | | concat() | 连接两个或更多字符串，并返回新的字符串 | | fromCharCode() | 将 Unicode 编码转为字符 | | indexOf() | 返回某个指定的字符串值在字符串中首次出现的位置 | | includes() | 查找字符串中是否包含指定的子字符串 | | lastIndexOf() | 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置 | | match() | 查找找到一个或多个正则表达式的匹配 | | repeat() | 复制字符串指定次数，并将它们连接在一起返回 | | replace() | 在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串 | | search() | 查找与正则表达式相匹配的值 | | slice() | 提取字符串的片断，并在新的字符串中返回被提取的部分 | | split() | 把字符串分割为字符串数组 | | startsWith() | 查看字符串是否以指定的子字符串开头 | | substr() | 从起始索引号提取字符串中指定数目的字符 | | substring() | 提取字符串中两个指定的索引号之间的字符 | | toLowerCase() | 把字符串转换为小写 | | toUpperCase() | 把字符串转换为大写 | | trim() | 去除字符串两边的空白 | | toLocaleLowerCase() | 根据本地主机的语言环境把字符串转换为小写 | | toLocaleUpperCase() | 根据本地主机的语言环境把字符串转换为大写 | | valueOf() | 返回某个字符串对象的原始值 | | toString() | 返回一个字符串 | Date日期对象 Date() 方法获得当日的日期。 getFullYear() 获取年份。 getTime() 返回从 1970 年 1 月 1 日至今的毫秒数。 setFullYear() 设置具体的日期。 toUTCString() 将当日的日期（根据 UTC）转换为字符串。 getDay() 和数组来显示星期，而不仅仅是数字。 创建日期 Date 对象用于处理日期和时间。 可以通过 new 关键词来定义 Date 对象。以下代码定义了名为 myDate 的 Date 对象： 有四种方式初始化日期: new Date() // 当前日期和时间 new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数 new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) 上面的参数大多数都是可选的，在不指定的情况下，默认参数是0。 实例化一个日期的一些例子： var today = new Date() var d1 = new Date(\"October 13, 1975 11:13:00\") var d2 = new Date(79,5,24) var d3 = new Date(79,5,24,11,33,0) 设置日期 通过使用针对日期对象的方法，我们可以很容易地对日期进行操作。 在下面的例子中，我们为日期对象设置了一个特定的日期 (2010 年 1 月 14 日)： var myDate=new Date(); myDate.setFullYear(2010,0,14); 在下面的例子中，我们将日期对象设置为 5 天后的日期： var myDate=new Date(); myDate.setDate(myDate.getDate()+5); 注意: 如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。 两个日期比较 日期对象也可用于比较两个日期。 下面的代码将当前日期与 2100 年 1 月 14 日做了比较： var x=new Date(); x.setFullYear(2100,0,14); var today = new Date(); if (x>today) { alert(\"今天是2100年1月14日之前\"); } else { alert(\"今天是2100年1月14日之后\"); } 字符串属性和方法 属性: | 属性 | 描述 | |------|-----| | constructor | 返回对创建此对象的 Date 函数的引用 | | prototype | 使您有能力向对象添加属性和方法 | 方法: | 方法 | 描述 | |-----|------| | getDate() | 从 Date 对象返回一个月中的某一天 (1 ~ 31) | | getDay() | 从 Date 对象返回一周中的某一天 (0 ~ 6) | | getFullYear() | 从 Date 对象以四位数字返回年份 | | getHours() | 返回 Date 对象的小时 (0 ~ 23) | | getMilliseconds() | 返回 Date 对象的毫秒(0 ~ 999) | | getMinutes() | 返回 Date 对象的分钟 (0 ~ 59) | | getMonth() | 从 Date 对象返回月份 (0 ~ 11) | | getSeconds() | 返回 Date 对象的秒数 (0 ~ 59) | | getTime() | 返回 1970 年 1 月 1 日至今的毫秒数 | | getTimezoneOffset() | 返回本地时间与格林威治标准时间 (GMT) 的分钟差 | | getUTCDate() | 根据世界时从 Date 对象返回月中的一天 (1 ~ 31) | | getUTCDay() | 根据世界时从 Date 对象返回周中的一天 (0 ~ 6) | | getUTCFullYear() | 根据世界时从 Date 对象返回四位数的年份 | | getUTCHours() | 根据世界时返回 Date 对象的小时 (0 ~ 23) | | getUTCMilliseconds() | 根据世界时返回 Date 对象的毫秒(0 ~ 999) | | getUTCMinutes() | 根据世界时返回 Date 对象的分钟 (0 ~ 59) | | getUTCMonth() | 根据世界时从 Date 对象返回月份 (0 ~ 11) | | getUTCSeconds() | 根据世界时返回 Date 对象的秒钟 (0 ~ 59) | | getYear() | 已废弃。 请使用 getFullYear() 方法代替 | | parse() | 返回1970年1月1日午夜到指定日期（字符串）的毫秒数 | | setDate() | 设置 Date 对象中月的某一天 (1 ~ 31) | | setFullYear() | 设置 Date 对象中的年份（四位数字） | | setHours() | 设置 Date 对象中的小时 (0 ~ 23) | | setMilliseconds() | 设置 Date 对象中的毫秒 (0 ~ 999) | | setMinutes() | 设置 Date 对象中的分钟 (0 ~ 59) | | setMonth() | 设置 Date 对象中月份 (0 ~ 11) | | setSeconds() | 设置 Date 对象中的秒钟 (0 ~ 59) | | setTime() setTime() | 方法以毫秒设置 Date 对象 | | setUTCDate() | 根据世界时设置 Date 对象中月份的一天 (1 ~ 31) | | setUTCFullYear() | 根据世界时设置 Date 对象中的年份（四位数字） | | setUTCHours() | 根据世界时设置 Date 对象中的小时 (0 ~ 23) | | setUTCMilliseconds() | 根据世界时设置 Date 对象中的毫秒 (0 ~ 999) | | setUTCMinutes() | 根据世界时设置 Date 对象中的分钟 (0 ~ 59) | | setUTCMonth() | 根据世界时设置 Date 对象中的月份 (0 ~ 11) | | setUTCSeconds() | setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段 | | setYear() | 已废弃。请使用 setFullYear() 方法代替。 | toDateString() | 把 Date 对象的日期部分转换为字符串 | | toGMTString() | 已废弃。请使用 toUTCString() 方法代替 | | toISOString() | 使用 ISO 标准返回字符串的日期格式 | | toJSON() | 以 JSON 数据格式返回日期字符串 | | toLocaleDateString() | 根据本地时间格式，把 Date 对象的日期部分转换为字符串 | | toLocaleTimeString() | 根据本地时间格式，把 Date 对象的时间部分转换为字符串 | | toLocaleString() | 据本地时间格式，把 Date 对象转换为字符串 | | toString() | 把 Date 对象转换为字符串 | | toTimeString() | 把 Date 对象的时间部分转换为字符串 | | toUTCString() | 根据世界时，把 Date 对象转换为字符串 | | UTC() | 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数 | | valueOf() | 返回 Date 对象的原始值 | Array对象 数组对象是使用单独的变量名来存储一系列的值。 数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。 数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到。 创建一个数组 常规方式: var myCars=new Array(); myCars[0]=\"Saab\"; myCars[1]=\"Volvo\"; myCars[2]=\"BMW\"; 简洁方式: var myCars=new Array(\"Saab\",\"Volvo\",\"BMW\"); 字面: var myCars=[\"Saab\",\"Volvo\",\"BMW\"]; 访问数组 通过指定数组名以及索引号码，你可以访问某个特定的元素。 在一个数组中你可以有不同的对象 所有的JavaScript变量都是对象。数组元素是对象。函数是对象。 因此，你可以在数组中有不同的变量类型。 你可以在一个数组中包含对象元素、函数、数组 数组方法和属性 属性: | 属性 | 描述 | |------|-----| | constructor | 返回创建数组对象的原型函数 | | length | 设置或返回数组元素的个数 | | prototype | 允许你向数组对象添加属性或方法 | 方法: | 方法 | 描述 | |-----|------| | concat() | 连接两个或更多的数组，并返回结果 | | copyWithin() | 从数组的指定位置拷贝元素到数组的另一个指定位置中 | | entries() | 返回数组的可迭代对象 | | every() | 检测数值元素的每个元素是否都符合条件 | | fill() | 使用一个固定值来填充数组 | | filter() | 检测数值元素，并返回符合条件所有元素的数组 | | find() | 返回符合传入测试（函数）条件的数组元素 | | findIndex() | 返回符合传入测试（函数）条件的数组元素索引 | | forEach() | 数组每个元素都执行一次回调函数 | | from() | 通过给定的对象中创建一个数组 | | includes() | 判断一个数组是否包含一个指定的值 | | indexOf() | 搜索数组中的元素，并返回它所在的位置 | | isArray() | 判断对象是否为数组 | | join() | 把数组的所有元素放入一个字符串 | | keys() | 返回数组的可迭代对象，包含原始数组的键(key) | | lastIndexOf() | 搜索数组中的元素，并返回它最后出现的位置 | | map() | 通过指定函数处理数组的每个元素，并返回处理后的数组 | | pop() | 删除数组的最后一个元素并返回删除的元素 | | push() | 向数组的末尾添加一个或更多元素，并返回新的长度 | | reduce() | 将数组元素计算为一个值（从左到右） | | reduceRight() | 将数组元素计算为一个值（从右到左） | | reverse() | 反转数组的元素顺序 | | shift() | 删除并返回数组的第一个元素 | | slice() | 选取数组的的一部分，并返回一个新数组 | | some() | 检测数组元素中是否有元素符合指定条件 | | sort() | 对数组的元素进行排序 | | splice() | 从数组中添加或删除元素 | | toString() | 把数组转换为字符串，并返回结果 | | unshift() | 向数组的开头添加一个或更多元素，并返回新的长度 | | valueOf() | 返回数组对象的原始值 | Math对象 Math方法和属性 属性: | 属性 | 描述 | |------|-----| | E | 返回算术常量 e，即自然对数的底数（约等于2.718） | | LN2 | 返回 2 的自然对数（约等于0.693） | | LN10 | 返回 10 的自然对数（约等于2.302） | | LOG2E | 返回以 2 为底的 e 的对数（约等于 1.4426950408889634） | | LOG10E | 返回以 10 为底的 e 的对数（约等于0.434） | | PI | 返回圆周率（约等于3.14159） | | SQRT1_2 | 返回 2 的平方根的倒数（约等于 0.707） | | SQRT2 | 返回 2 的平方根（约等于 1.414） | 方法: | 方法 | 描述 | |-----|------| | abs(x) | 返回 x 的绝对值 | | acos(x) | 返回 x 的反余弦值 | | asin(x) | 返回 x 的反正弦值 | | atan(x) | 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 | | atan2(y,x) | 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） | | ceil(x) | 对数进行上舍入 | | cos(x) | 返回数的余弦 | | exp(x) | 返回 Ex 的指数 | | floor(x) | 对 x 进行下舍入 | | log(x) | 返回数的自然对数（底为e） | | max(x,y,z,...,n) | 返回 x,y,z,...,n 中的最高值 | | min(x,y,z,...,n) | 返回 x,y,z,...,n中的最低值 | | pow(x,y) | 返回 x 的 y 次幂 | | random() | 返回 0 ~ 1 之间的随机数 | | round(x) | 四舍五入 | | sin(x) | 返回数的正弦 | | sqrt(x) | 返回数的平方根 | | tan(x) | 返回角的正切 | DOM对象 HTML DOM 节点 在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 文档是一个文档节点。 所有的HTML元素都是元素节点。 所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。are text nodes。 注释是注释节点。 Document 对象 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 Document 对象属性和方法 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | document.activeElement | 返回当前获取焦点元素 | | document.addEventListener() | 向文档添加句柄 | | document.adoptNode(node) | 从另外一个文档返回 adapded 节点到当前文档 | | document.anchors | 返回对文档中所有 Anchor 对象的引用 | | document.applets | 返回对文档中所有 Applet 对象的引用。注意: HTML5 已不支持 元素 | | document.baseURI | 返回文档的绝对基础 URI | | document.body | 返回文档的body元素 | | document.close() | 关闭用 document.open() 方法打开的输出流，并显示选定的数据 | | document.cookie | 设置或返回与当前文档有关的所有 cookie | | document.createAttribute() | 创建一个属性节点 | | document.createComment() | createComment() 方法可创建注释节点 | | document.createDocumentFragment() | 创建空的 DocumentFragment 对象，并返回此对象 | | document.createElement() | 创建元素节点 | | document.createTextNode() | 创建文本节点 | | document.doctype | 返回与文档相关的文档类型声明 (DTD) | | document.documentElement | 返回文档的根节点 | | document.documentMode | 返回用于通过浏览器渲染文档的模式 | | document.documentURI | 设置或返回文档的位置 | | document.domain | 返回当前文档的域名 | | document.domConfig | 已废弃。返回 normalizeDocument() 被调用时所使用的配置 | | document.embeds | 返回文档中所有嵌入的内容（embed）集合 | | document.forms | 返回对文档中所有 Form 对象引用 | | document.getElementsByClassName() | 返回文档中所有指定类名的元素集合，作为 NodeList 对象 | | document.getElementById() | 返回对拥有指定 id 的第一个对象的引用 | | document.getElementsByName() | 返回带有指定名称的对象集合 | | document.getElementsByTagName() | 返回带有指定标签名的对象集合 | | document.images | 返回对文档中所有 Image 对象引用 | | document.implementation | 返回处理该文档的 DOMImplementation 对象 | | document.importNode() | 把一个节点从另一个文档复制到该文档以便应用 | | document.inputEncoding | 返回用于文档的编码方式（在解析时） | | document.lastModified | 返回文档被最后修改的日期和时间 | | document.links | 返回对文档中所有 Area 和 Link 对象引用 | | document.normalize() | 删除空文本节点，并连接相邻节点 | | document.normalizeDocument() | 删除空文本节点，并连接相邻节点的 | | document.open() | 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出 | | document.querySelector() | 返回文档中匹配指定的CSS选择器的第一元素 | | document.querySelectorAll() | document.querySelectorAll() 是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 | | document.readyState | 返回文档状态 (载入中……) | | document.referrer | 返回载入当前文档的文档的 URL | | document.removeEventListener() | 移除文档中的事件句柄(由 addEventListener() 方法添加) | | document.renameNode() | 重命名元素或者属性节点 | | document.scripts | 返回页面中所有脚本的集合 | | document.strictErrorChecking | 设置或返回是否强制进行错误检查 | | document.title | 返回当前文档的标题 | | document.URL | 返回文档完整的URL | | document.write() | 向文档写 HTML 表达式 或 JavaScript 代码 | | document.writeln() | 等同于 write() 方法，不同的是在每个表达式之后写一个换行符 | 警告 !!! 在 W3C DOM核心，文档对象 继承节点对象的所有属性和方法。 很多属性和方法在文档中是没有意义的。 HTML 文档对象可以避免使用这些节点对象和属性： | 属性 / 方法 | 避免的原因 | |-------|----------------| | document.attributes | 文档没有该属性 | | document.hasAttributes() | 文档没有该属性 | | document.nextSibling | 文档没有下一节点 | | document.nodeName | 这个通常是 #document | | document.nodeType | 这个通常是 9(DOCUMENT_NODE) | | document.nodeValue | 文档没有一个节点值 | | document.ownerDocument | 文档没有主文档 | | document.ownerElement | 文档没有自己的节点 | | document.parentNode | 文档没有父节点 | | document.previousSibling | 文档没有兄弟节点 | | document.textContent | 文档没有文本节点 | 元素对象 在 HTML DOM 中, 元素对象代表着一个 HTML 元素。 元素对象 的 子节点可以是, 可以是元素节点，文本节点，注释节点。 NodeList 对象 代表了节点列表，类似于 HTML元素的子节点集合。 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | element.accessKey | 设置或返回accesskey一个元素 | | element.addEventListener() | 向指定元素添加事件句柄 | | element.appendChild() | 为元素添加一个新的子元素 | | element.attributes | 返回一个元素的属性数组 | | element.childNodes | 返回元素的一个子节点的数组 | | element.children | 返回元素的子元素的集合 | | element.classList | 返回元素的类名，作为 DOMTokenList 对象。 | | element.className | 设置或返回元素的class属性 | | element.clientHeight | 在页面上返回内容的可视高度（不包括边框，边距或滚动条） | | element.clientWidth | 在页面上返回内容的可视宽度（不包括边框，边距或滚动条） | | element.cloneNode() | 克隆某个元素 | | element.compareDocumentPosition() | 比较两个元素的文档位置。 | | element.contentEditable | 设置或返回元素的内容是否可编辑 | | element.dir | 设置或返回一个元素中的文本方向 | | element.firstChild | 返回元素的第一个子节点 | | element.focus() | 设置文档或元素获取焦点 | | element.getAttribute() | 返回指定元素的属性值 | | element.getAttributeNode() | 返回指定属性节点 | | element.getElementsByTagName() | 返回指定标签名的所有子元素集合。 | | element. getElementsByClassName() | 返回文档中所有指定类名的元素集合，作为 NodeList 对象。 | | element.getFeature() | 返回指定特征的执行APIs对象。 | | element.getUserData() | 返回一个元素中关联键值的对象。 | | element.hasAttribute() | 如果元素中存在指定的属性返回 true，否则返回false。 | | element.hasAttributes() | 如果元素有任何属性返回true，否则返回false。 | | element.hasChildNodes() | 返回一个元素是否具有任何子元素 | | element.hasFocus() | 返回布尔值，检测文档或元素是否获取焦点 | | element.id | 设置或者返回元素的 id。 | | element.innerHTML | 设置或者返回元素的内容。 | | element.insertBefore() | 现有的子元素之前插入一个新的子元素 | | element.isContentEditable | 如果元素内容可编辑返回 true，否则返回false | | element.isDefaultNamespace() | 如果指定了namespaceURI 返回 true，否则返回 false。 | | element.isEqualNode() | 检查两个元素是否相等 | | element.isSameNode() | 检查两个元素所有有相同节点。 | | element.isSupported() | 如果在元素中支持指定特征返回 true。 | | element.lang | 设置或者返回一个元素的语言。 | | element.lastChild | 返回的最后一个子元素 | | element.namespaceURI | 返回命名空间的 URI。 | | element.nextSibling | 返回该元素紧跟的一个节点 | | element.nextElementSibling | 返回指定元素之后的下一个兄弟元素（相同节点树层中的下一个元素节点）。 | | element.nodeName | 返回元素的标记名（大写） | | element.nodeType | 返回元素的节点类型 | | element.nodeValue | 返回元素的节点值 | | element.normalize() | 使得此成为一个\"normal\"的形式，其中只有结构（如元素，注释，处理指令，CDATA节和实体引用）隔开Text节点，即元素（包括属性）下面的所有文本节点，既没有相邻的文本节点也没有空的文本节点 | | element.offsetHeight | 返回任何一个元素的高度包括边框和填充，但不是边距 | | element.offsetWidth | 返回元素的宽度，包括边框和填充，但不是边距 | | element.offsetLeft | 返回当前元素的相对水平偏移位置的偏移容器 | | element.offsetParent | 返回元素的偏移容器 | | element.offsetTop | 返回当前元素的相对垂直偏移位置的偏移容器 | | element.ownerDocument | 返回元素的根元素（文档对象） | | element.parentNode | 返回元素的父节点 | | element.previousSibling | 返回某个元素紧接之前元素 | | element.previousElementSibling | 返回指定元素的前一个兄弟元素（相同节点树层中的前一个元素节点）。 | | element.querySelector() | 返回匹配指定 CSS 选择器元素的第一个子元素 | | document.querySelectorAll() | 返回匹配指定 CSS 选择器元素的所有子元素节点列表 | | element.removeAttribute() | 从元素中删除指定的属性 | | element.removeAttributeNode() | 删除指定属性节点并返回移除后的节点。 | | element.removeChild() | 删除一个子元素 | | element.removeEventListener() | 移除由 addEventListener() 方法添加的事件句柄 | | element.replaceChild() | 替换一个子元素 | | element.scrollHeight | 返回整个元素的高度（包括带滚动条的隐蔽的地方） | | element.scrollLeft | 返回当前视图中的实际元素的左边缘和左边缘之间的距离 | | element.scrollTop | 返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离 | | element.scrollWidth | 返回元素的整个宽度（包括带滚动条的隐蔽的地方） | | element.setAttribute() | 设置或者改变指定属性并指定值。 | | element.setAttributeNode() | 设置或者改变指定属性节点。 | | element.setIdAttribute() | | | element.setIdAttributeNode() | | | element.setUserData() | 在元素中为指定键值关联对象。 | | element.style | 设置或返回元素的样式属性 | | element.tabIndex | 设置或返回元素的标签顺序。 | | element.tagName | 作为一个字符串返回某个元素的标记名（大写） | | element.textContent | 设置或返回一个节点和它的文本内容 | | element.title | 设置或返回元素的title属性 | | element.toString() | 一个元素转换成字符串 | | nodelist.item() | 返回某个元素基于文档树的索引 | | nodelist.length | 返回节点列表的节点数目。 | Attr(属性) 对象 在 HTML DOM 中, Attr 对象 代表一个 HTML 属性。 HTML属性总是属于HTML元素。 NamedNodeMap 对象 在 HTML DOM 中, the NamedNodeMap 对象 表示一个无顺序的节点列表。 我们可通过节点名称来访问 NamedNodeMap 中的节点。 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | attr.isId | 如果属性是 ID 类型，则 isId 属性返回 true，否则返回 false。 | | attr.name | 返回属性名称 | | attr.value | 设置或者返回属性值 | | attr.specified | 如果属性被指定返回 true ，否则返回 false | | nodemap.getNamedItem() | 从节点列表中返回的指定属性节点。 | | nodemap.item() | 返回节点列表中处于指定索引号的节点。 | | nodemap.length | 返回节点列表的节点数目。 | | nodemap.removeNamedItem() | 删除指定属性节点 | | nodemap.setNamedItem() | 设置指定属性节点(通过名称) | DOM 4 警告 !!! 在 W3C DOM 内核中, Attr (属性) 对象继承节点对象的所有属性和方法 。 在 DOM 4 中, Attr (属性) 对象不再从节点对象中继承。 从长远的代码质量来考虑，在属性对象中你需要避免使用节点对象属性和方法: | 属性 / 方法 | 避免原因 | |------|------------| | attr.appendChild() | 属性没有子节点 | | attr.attributes | 属性没有属性 | | attr.baseURI | 使用 document.baseURI 替代 | | attr.childNodes | 属性没有子节点 | | attr.cloneNode() | 使用 attr.value 替代 | | attr.firstChild | 属性没有子节点 | | attr.hasAttributes() | 属性没有属性 | | attr.hasChildNodes | 属性没有子节点 | | attr.insertBefore() | 属性没有子节点 | | attr.isEqualNode() | 没有意义 | | attr.isSameNode() | 没有意义 | | attr.isSupported() | 通常为 true | | attr.lastChild | 属性没有子节点 | | attr.nextSibling | 属性没有兄弟节点 | | attr.nodeName | 使用 attr.name 替代 | | attr.nodeType | 通常为 2 (ATTRIBUTE-NODE) | | attr.nodeValue | 使用 attr.value 替代 | | attr.normalize() | 属性没有规范 | | attr.ownerDocument | 通常为你的 HTML 文档 | | attr.ownerElement | 你用来访问属性的 HTML 元素 | | attr.parentNode | 你用来访问属性的 HTML 元素 | | attr.previousSibling | 属性没有兄弟节点 | | attr.removeChild | 属性没有子节点 | | attr.replaceChild | 属性没有子节点 | | attr.textContent | 使用 attr.value 替代 | Console 对象 Console 对象提供了访问浏览器调试模式的信息到控制台。 方法 描述 assert() 如果断言为 false，则在信息到控制台输出错误信息。 clear() 清除控制台上的信息。 count() 记录 count() 调用次数，一般用于计数。 error() 输出错误信息到控制台 group() 在控制台创建一个信息分组。 一个完整的信息分组以 console.group() 开始，console.groupEnd() 结束 groupCollapsed() 在控制台创建一个信息分组。 类似 console.group() ，但它默认是折叠的。 groupEnd() 设置当前信息分组结束 info() 控制台输出一条信息 log() 控制台输出一条信息 table() 以表格形式显示数据 time() 计时器，开始计时间，与 timeEnd() 联合使用，用于算出一个操作所花费的准确时间。 timeEnd() 计时结束 trace() 显示当前执行的代码在堆栈中的调用路径。 warn() 输出警告信息，信息最前面加一个黄色三角，表示警告 CSS 样式声明对象(CSSStyleDeclaration) CSSStyleDeclaration 对象 CSSStyleDeclaration 对象表示一个 CSS 属性-值（property-value）对的集合。 CSSStyleDeclaration 对象属性 | 属性 | 描述 | |------|------------| | cssText | 设置或返回样式声明文本，cssText 对应的是 HTML 元素的 style 属性。 | | length | 返回样式中包含多少条声明。 | | parentRule | 返回包含当前规则的规则。 | CSSStyleDeclaration 对象方法 | 属性 | 描述 | |------|------------| | getPropertyPriority() | 返回指定的 CSS 属性是否设置了 \"important!\" 属性。 | | getPropertyValue() | 返回指定的 CSS 属性值。 | | item() | 通过索引方式返回 CSS 声明中的 CSS 属性名。 | | removeProperty() | 移除 CSS 声明中的 CSS 属性。 | | setProperty() | 在 CSS 声明块中新建或者修改 CSS 属性。 | DOM 事件 DOM： 指明使用的 DOM 属性级别。 鼠标事件 属性 描述 DOM onclick 当用户点击某个对象时调用的事件句柄。 2 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 2 onmousedown 鼠标按钮被按下。 2 onmouseenter 当鼠标指针移动到元素上时触发。 2 onmouseleave 当鼠标指针移出元素时触发 2 onmousemove 鼠标被移动。 2 onmouseover 鼠标移到某元素之上。 2 onmouseout 鼠标从某元素移开。 2 onmouseup 鼠标按键被松开。 2 键盘事件 属性 描述 DOM onkeydown 某个键盘按键被按下。 2 onkeypress 某个键盘按键被按下并松开。 2 onkeyup 某个键盘按键被松开。 2 框架/对象（Frame/Object）事件 属性 描述 DOM onabort 图像的加载被中断。 ( ) 2 onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2 onerror 在加载文档或图像时发生错误。 ( , 和 ) onhashchange 该事件在当前 URL 的锚部分发生修改时触发。 onload 一张页面或一幅图像完成加载。 2 onpageshow 该事件在用户访问页面时触发 onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 onresize 窗口或框架被重新调整大小。 2 onscroll 当文档被滚动时发生的事件。 2 onunload 用户退出页面。 ( 和 ) 2 表单事件 属性 描述 DOM onblur 元素失去焦点时触发 2 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) 2 onfocus 元素获取焦点时触发 2 onfocusin 元素即将获取焦点时触发 2 onfocusout 元素即将失去焦点时触发 2 oninput 元素获取用户输入时触发 3 onreset 表单重置时触发 2 onsearch 用户向搜索域输入文本时触发 ( ) onselect 用户选取文本时触发 ( 和 ) 2 onsubmit 表单提交时触发 2 剪贴板事件 属性 描述 DOM oncopy 该事件在用户拷贝元素内容时触发 oncut 该事件在用户剪切元素内容时触发 onpaste 该事件在用户粘贴元素内容时触发 打印事件 属性 描述 DOM onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 onbeforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 描述 DOM ondrag 该事件在元素正在拖动时触发 ondragend 该事件在用户完成元素的拖动时触发 ondragenter 该事件在拖动的元素进入放置目标时触发 ondragleave 该事件在拖动元素离开放置目标时触发 ondragover 该事件在拖动元素在放置目标上时触发 ondragstart 该事件在用户开始拖动元素时触发 ondrop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 描述 DOM onabort 事件在视频/音频（audio/video）终止加载时触发。 oncanplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 oncanplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 ondurationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 onemptied 当期播放列表为空时触发 onended 事件在视频/音频（audio/video）播放结束时触发。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 onloadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 onloadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 onloadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 onpause 事件在视频/音频（audio/video）暂停时触发。 onplay 事件在视频/音频（audio/video）开始播放时触发。 onplaying 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 onprogress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 onratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 onseeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 onseeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 onstalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 onsuspend 事件在浏览器读取媒体数据中止时触发。 ontimeupdate 事件在当前的播放位置发送改变时触发。 onvolumechange 事件在音量发生改变时触发。 onwaiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 事件 描述 DOM animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 描述 DOM transitionend 该事件在 CSS 完成过渡后触发。 其他事件 事件 描述 DOM onmessage 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 onmousewheel 已废弃。 使用 onwheel 事件替代 ononline 该事件在浏览器开始在线工作时触发。 onoffline 该事件在浏览器开始离线工作时触发。 onpopstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 onshow 该事件当 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 ontoggle 该事件在用户打开或关闭 元素时触发 onwheel 该事件在鼠标滚轮在元素上下滚动时触发 事件对象 常量 | 静态变量 | 描述 | DOM | |------|------|------| | CAPTURING-PHASE | 当前事件阶段为捕获阶段(1) | 1 | | AT-TARGET | 当前事件是目标阶段,在评估目标事件(1) | 2 | | BUBBLING-PHASE | 当前的事件为冒泡阶段 (3) | 3 | 属性 | 属性 | 描述 | DOM | |------|------|------| | bubbles | 返回布尔值，指示事件是否是起泡事件类型。 | 2 | | cancelable | 返回布尔值，指示事件是否可拥可取消的默认动作。 | 2 | | currentTarget | 返回其事件监听器触发该事件的元素。 | 2 | | eventPhase | 返回事件传播的当前阶段。 | 2 | | target | 返回触发此事件的元素（事件的目标节点）。 | 2 | | timeStamp | 返回事件生成的日期和时间。 | 2 | | type | 返回当前 Event 对象表示的事件的名称。 | 2 | 方法 | 方法 | 描述 | DOM | |------|------|------| | initEvent() | 初始化新创建的 Event 对象的属性。 | 2 | | preventDefault() | 通知浏览器不要执行与事件关联的默认动作。 | 2 | | stopPropagation() | 不再派发事件。 | 2 | 目标事件对象 方法 | 方法 | 描述 | DOM | |------|------|------| | addEventListener() | 允许在目标事件中注册监听事件(IE8 = attachEvent()) | 2 | | dispatchEvent() | 允许发送事件到监听器上 (IE8 = fireEvent()) | 2 | | removeEventListener() | 运行一次注册在事件目标上的监听事件(IE8 = detachEvent()) | 2 | 事件监听对象 方法 | 方法 | 描述 | DOM | |------|------|------| | handleEvent() | 把任意对象注册为事件处理程序 | 2 | 文档事件对象 方法 | 方法 | 描述 | DOM | |------|------|------| | createEvent() | | 2 | 鼠标/键盘事件对象 属性 | 属性 | 描述 | DOM | |------|------|------| | altKey | 返回当事件被触发时，\"ALT\" 是否被按下。 | 2 | | button | 返回当事件被触发时，哪个鼠标按钮被点击。 | 2 | | clientX | 返回当事件被触发时，鼠标指针的水平坐标。 | 2 | | clientY | 返回当事件被触发时，鼠标指针的垂直坐标。 | 2 | | ctrlKey | 返回当事件被触发时，\"CTRL\" 键是否被按下。 | 2 | | Location | 返回按键在设备上的位置 | 3 | | charCode | 返回onkeypress事件触发键值的字母代码。 | 2 | | key | 在按下按键时返回按键的标识符。 | 3 | | keyCode | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 | 2 | | which | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 | 2 | | metaKey | 返回当事件被触发时，\"meta\" 键是否被按下。 | 2 | | relatedTarget | 返回与事件的目标节点相关的节点。 | 2 | | screenX | 返回当某个事件被触发时，鼠标指针的水平坐标。 | 2 | | screenY | 返回当某个事件被触发时，鼠标指针的垂直坐标。 | 2 | | shiftKey | 返回当事件被触发时，\"SHIFT\" 键是否被按下。 | 2 | 方法 | 方法 | 描述 | DOM | |------|------|------| | initMouseEvent() | 初始化鼠标事件对象的值 | 2 | | initKeyboardEvent() | 初始化键盘事件对象的值 | 3 | 浏览器对象 Window对象 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（ 或 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 注意： 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。 Window 对象属性 | 属性 | 描述 | |------|------------| | closed | 返回窗口是否已被关闭。 | | defaultStatus | 设置或返回窗口状态栏中的默认文本。 | | document | 对 Document 对象的只读引用。(请参阅对象) | | frames | 返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。 | | history | 对 History 对象的只读引用。请参数 History 对象。 | | innerHeight | 返回窗口的文档显示区的高度。 | | innerWidth | 返回窗口的文档显示区的宽度。 | | localStorage | 在浏览器中存储 key/value 对。没有过期时间。 | | length | 设置或返回窗口中的框架数量。 | | location | 用于窗口或框架的 Location 对象。请参阅 Location 对象。 | | name | 设置或返回窗口的名称。 | | navigator | 对 Navigator 对象的只读引用。请参数 Navigator 对象。 | | opener | 返回对创建此窗口的窗口的引用。 | | outerHeight | 返回窗口的外部高度，包含工具条与滚动条。 | | outerWidth | 返回窗口的外部宽度，包含工具条与滚动条。 | | pageXOffset | 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 | | pageYOffset | 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 | | parent | 返回父窗口。 | | screen | 对 Screen 对象的只读引用。请参数 Screen 对象。 | | screenLeft | 返回相对于屏幕窗口的x坐标 | | screenTop | 返回相对于屏幕窗口的y坐标 | | screenX | 返回相对于屏幕窗口的x坐标 | | sessionStorage | 在浏览器中存储 key/value 对。 在关闭窗口或标签页之后将会删除这些数据。 | | screenY | 返回相对于屏幕窗口的y坐标 | | self | 返回对当前窗口的引用。等价于 Window 属性。 | | status | 设置窗口状态栏的文本。 | | top | 返回最顶层的父窗口。 | Window 对象方法 | 方法 | 描述 | |------|------------| | alert() | 显示带有一段消息和一个确认按钮的警告框。 | | atob() | 解码一个 base-64 编码的字符串。 | | btoa() | 创建一个 base-64 编码的字符串。 | | blur() | 把键盘焦点从顶层窗口移开。 | | clearInterval() | 取消由 setInterval() 设置的 timeout。 | | clearTimeout() | 取消由 setTimeout() 方法设置的 timeout。 | | close() | 关闭浏览器窗口。 | | confirm() | 显示带有一段消息以及确认按钮和取消按钮的对话框。 | | createPopup() | 创建一个 pop-up 窗口。 | | focus() | 把键盘焦点给予一个窗口。 | | getSelection() | 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。 | | getComputedStyle() | 获取指定元素的 CSS 样式。 | | matchMedia() | 该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。 | | moveBy() | 可相对窗口的当前坐标把它移动指定的像素。 | | moveTo() | 把窗口的左上角移动到一个指定的坐标。 | | open() | 打开一个新的浏览器窗口或查找一个已命名的窗口。 | | print() | 打印当前窗口的内容。 | | prompt() | 显示可提示用户输入的对话框。 | | resizeBy() | 按照指定的像素调整窗口的大小。 | | resizeTo() | 把窗口的大小调整到指定的宽度和高度。 | | scroll() | 已废弃。 该方法已经使用了 scrollTo() 方法来替代。 | | scrollBy() | 按照指定的像素值来滚动内容。 | | scrollTo() | 把内容滚动到指定的坐标。 | | setInterval() | 按照指定的周期（以毫秒计）来调用函数或计算表达式。 | | setTimeout() | 在指定的毫秒数后调用函数或计算表达式。 | | stop() | 停止页面载入。 | 计时器 计时事件 通过使用JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行，我们称之为计时事件 计时方法： setInterval()：间隔指定的毫秒数不停地执行指定的代码 clearInterval()：用于停止setInterval()方法执行的函数代码 setTimeout()：暂停指定的毫秒数后执行指定的代码 clearTimeout()：用于停止执行setTimeout()方法的函数代码 History 对象 Histor对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 注意： 没有应用于History对象的公开标准，不过所有浏览器都支持该对象。 History 对象属性 | 属性 | 描述 | |------|------------| | length | 返回历史列表中的网址数 | History 对象方法 | 方法 | 描述 | |------|------------| | back() | 加载 history 列表中的前一个 URL | | forward() | 加载 history 列表中的下一个 URL | | go() | 加载 history 列表中的某个具体页面 | Location 对象 Location 对象包含有关当前 URL 的信息。 Location 对象是 window 对象的一部分，可通过 window.Location 属性对其进行访问。 注意： 没有应用于Location对象的公开标准，不过所有浏览器都支持该对象。 Location 对象属性 | 属性 | 描述 | |------|------------| | hash | 返回一个URL的锚部分 | | host | 返回一个URL的主机名和端口 | | hostname | 返回URL的主机名 | | href | 返回完整的URL | | pathname | 返回的URL路径名。 | | port | 返回一个URL服务器使用的端口号 | | protocol | 返回一个URL协议 | | search | 返回一个URL的查询部分 | Location 对象方法 | 方法 | 描述 | |------|------------| | assign() | 载入一个新的文档 | | reload() | 重新载入当前文档 | | replace() | 用新的文档替换当前文档 | Screen 对象 Screen 对象包含有关客户端显示屏幕的信息。 注意： 没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。 Screen 对象属性 | 属性 | 描述 | |------|------------| | availHeight | 返回屏幕的高度（不包括Windows任务栏） | | availWidth | 返回屏幕的宽度（不包括Windows任务栏） | | colorDepth | 返回目标设备或缓冲器上的调色板的比特深度 | | height | 返回屏幕的总高度 | | pixelDepth | 返回屏幕的颜色分辨率（每象素的位数） | | width | 返回屏幕的总宽度 | "},"Web/JavaScript/JavaScript瀑布流.html":{"url":"Web/JavaScript/JavaScript瀑布流.html","title":"JavaScript瀑布流","keywords":"","body":"datetime:2019/7/5 11:40 author:nzb JavaScript实现瀑布流效果 滚动条到底可以一直加载 warterfall.html js瀑布流效果 myjs.js window.onload = function () { // window.onload() 方法用于在网页加载完毕后立刻执行的操作 imgLocation(\"container\", 'box'); var imgData = {\"data\":[{\"src\":\"../../res/waterfall1.jpg\"},{\"src\":\"../../res/waterfall2.jpg\"},{\"src\":\"../../res/waterfall3.jpg\"}, {\"src\":\"../../res/waterfall4.jpg\"},{\"src\":\"../../res/waterfall5.jpg\"}]}; // 模拟数据 window.onscroll = function () { if(checkFlag()){ //是否到底部 var cparent = document.getElementById(\"container\"); // 获取父级 (优化：因为很多地方用到可以分装成一个函数) for(var i=0;i mystyle.css *{ margin: 0px; padding: 0px; } #container{ position: relative; } .box{ padding: 5px; float: left; } .box_img{ padding: 5px; border: 1px solid #cccccc; box-shadow: 0 0 5px #cccccc; } .box_img img{ width: 150px; height: auto; } "},"Web/JavaScript/JavaScript面向对象.html":{"url":"Web/JavaScript/JavaScript面向对象.html","title":"JavaScript面向对象","keywords":"","body":"datetime:2019/7/5 16:23 author:nzb 面向对象编程 面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式。它使用先前建立的范例，包括模块化，多态和封装几种技术。今天，许多流行的编程语言（如Java，JavaScript，C＃，C+ +，Python，PHP，Ruby和Objective-C）都支持面向对象编程（OOP）。 相对于「一个程序只是一些函数的集合，或简单的计算机指令列表。」的传统软件设计观念而言，面向对象编程可以看作是使用一系列对象相互协作的软件设计。 在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。 面向对象程序设计的目的是在编程中促进更好的灵活性和可维护性，在大型软件工程中广为流行。凭借其对模块化的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 1, 它能更直接地分析, 编码和理解复杂的情况和过程。 术语 Namespace 命名空间 允许开发人员在一个独特，应用相关的名字的名称下捆绑所有功能的容器。 Class 类 定义对象的特征。它是对象的属性和方法的模板定义。 Object 对象 类的一个实例。 Property 属性 对象的特征，比如颜色。 Method 方法 对象的能力，比如行走。 Constructor 构造函数 对象初始化的瞬间，被调用的方法。通常它的名字与包含它的类一致。 Inheritance 继承 一个类可以继承另一个类的特征。 Encapsulation 封装 一种把数据和相关的方法绑定在一起使用的方法。 Abstraction 抽象 结合复杂的继承，方法，属性的对象能够模拟现实的模型。 Polymorphism 多态 多意为「许多」，态意为「形态」。不同类可以定义相同的方法或属性。 更多关于面向对象编程的描述，请参照维基百科的 面向对象编程 。 JavaScript面向对象编程 命名空间 命名空间是一个容器，它允许开发人员在一个独特的，特定于应用程序的名称下捆绑所有的功能。 在JavaScript中，命名空间只是另一个包含方法，属性，对象的对象。 注意：需要认识到重要的一点是：与其他面向对象编程语言不同的是，Javascript中的普通对象和命名空间在语言层面上没有区别。这点可能会让JavaScript初学者感到迷惑。 创造的JavaScript命名空间背后的想法很简单：一个全局对象被创建，所有的变量，方法和功能成为该对象的属性。使用命名空间也最大程度地减少应用程序的名称冲突的可能性。 我们来创建一个全局变量叫做 MYAPP // 全局命名空间 var MYAPP = MYAPP || {}; 在上面的代码示例中，我们首先检查MYAPP是否已经被定义（是否在同一文件中或在另一文件）。如果是的话，那么使用现有的MYAPP全局对象，否则，创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象。 我们也可以创建子命名空间： // 子命名空间 MYAPP.event = {}; 下面是用于创建命名空间和添加变量，函数和方法的代码写法： // 给普通方法和属性创建一个叫做MYAPP.commonMethod的容器 MYAPP.commonMethod = { regExForName: \"\", // 定义名字的正则验证 regExForPhone: \"\", // 定义电话的正则验证 validateName: function(name){ // 对名字name做些操作，你可以通过使用“this.regExForname” // 访问regExForName变量 }, validatePhoneNo: function(phoneNo){ // 对电话号码做操作 } } // 对象和方法一起申明 MYAPP.event = { addListener: function(el, type, fn) { // 代码 }, removeListener: function(el, type, fn) { // 代码 }, getEvent: function(e) { // 代码 } // 还可以添加其他的属性和方法 } //使用addListener方法的写法: MYAPP.event.addListener(\"yourel\", \"type\", callback); 标准内置对象 JavaScript有包括在其核心的几个对象，例如，Math，Object，Array和String对象。下面的例子演示了如何使用Math对象的random()方法来获得一个随机数。 console.log(Math.random()); 注意：这里和接下来的例子都假设名为 console.log 的方法全局有定义。console.log 实际上不是 JavaScript 自带的。 查看 JavaScript 参考：全局对象 了解 JavaScript 内置对象的列表。 JavaScript 中的每个对象都是 Object 对象的实例且继承它所有的属性和方法。 自定义对象 类 JavaScript是一种基于原型的语言，它没类的声明语句，比如C+ +或Java中用的。这有时会对习惯使用有类申明语句语言的程序员产生困扰。相反，JavaScript可用方法作类。定义一个类跟定义一个函数一样简单。在下面的例子中，我们定义了一个新类Person。 function Person() { } // 或 var Person = function(){ } 对象（类的实例） 我们使用 new obj 创建对象 obj 的新实例, 将结果（obj 类型）赋值给一个变量方便稍后调用。 在下面的示例中，我们定义了一个名为Person的类，然后我们创建了两个Person的实例(person1 and person2). function Person() { } var person1 = new Person(); var person2 = new Person(); 注意：有一种新增的创建未初始化实例的实例化方法，请参考 Object.create 。 构造器 在实例化时构造器被调用 (也就是对象实例被创建时)。构造器是对象中的一个方法。 在JavaScript中函数就可以作为构造器使用，因此不需要特别地定义一个构造器方法，每个声明的函数都可以在实例化后被调用执行。 构造器常用于给对象的属性赋值或者为调用函数做准备。 在本文的后面描述了类中方法既可以在定义时添加，也可以在使用前添加。 在下面的示例中, Person类实例化时构造器调用一个 alert函数。 function Person() { alert('Person instantiated'); } var person1 = new Person(); var person2 = new Person(); 属性 (对象属性) 属性就是 类中包含的变量;每一个对象实例有若干个属性. 为了正确的继承，属性应该被定义在类的原型属性 (函数)中。 可以使用 关键字 this调用类中的属性, this是对当前对象的引用。 从外部存取(读/写)其属性的语法是: InstanceName.Property; 这与C++，Java或者许多其他语言中的语法是一样的 (在类中语法 this.Property 常用于set和get属性值) 在下面的示例中，我们为定义Person类定义了一个属性 firstName 并在实例化时赋初值。 function Person(firstName) { this.firstName = firstName; alert('Person instantiated'); } var person1 = new Person('Alice'); var person2 = new Person('Bob'); // Show the firstName properties of the objects alert('person1 is ' + person1.firstName); // alerts \"person1 is Alice\" alert('person2 is ' + person2.firstName); // alerts \"person2 is Bob\" 方法（对象属性） 方法与属性很相似， 不同的是：一个是函数，另一个可以被定义为函数。 调用方法很像存取一个属性, 不同的是add () 在方法名后面很可能带着参数. 为定义一个方法, 需要将一个函数赋值给类的 prototype 属性; 这个赋值给函数的名称就是用来给对象在外部调用它使用的。 在下面的示例中，我们给Person类定义了方法 sayHello()，并调用了它. function Person(firstName) { this.firstName = firstName; } Person.prototype.sayHello = function() { alert(\"Hello, I'm \" + this.firstName); }; var person1 = new Person(\"Alice\"); var person2 = new Person(\"Bob\"); // call the Person sayHello method. person1.sayHello(); // alerts \"Hello, I'm Alice\" person2.sayHello(); // alerts \"Hello, I'm Bob\" 在JavaScript中方法通常是一个绑定到对象中的普通函数, 这意味着方法可以在其所在context之外被调用。 思考下面示例中的代码: function Person(firstName) { this.firstName = firstName; } Person.prototype.sayHello = function() { alert(\"Hello, I'm \" + this.firstName); }; var person1 = new Person(\"Alice\"); var person2 = new Person(\"Bob\"); var helloFunction = person1.sayHello; person1.sayHello(); // alerts \"Hello, I'm Alice\" person2.sayHello(); // alerts \"Hello, I'm Bob\" helloFunction(); // alerts \"Hello, I'm undefined\" (or fails // with a TypeError in strict mode) console.log(helloFunction === person1.sayHello); // logs true console.log(helloFunction === Person.prototype.sayHello); // logs true helloFunction.call(person1); // logs \"Hello, I'm Alice\" 如上例所示, 所有指向sayHello函数的引用 ，包括 person1, Person.prototype, 和 helloFunction 等， 均引用了相同的函数. 在调用函数的过程中，this的值取决于我们怎么样调用函数. 在通常情况下，我们通过一个表达式person1.sayHello()来调用函数：即从一个对象的属性中得到所调用的函数。此时this被设置为我们取得函数的对象（即person1）。这就是为什么person1.sayHello() 使用了姓名“Alice”而person2.sayHello()使用了姓名“bob”的原因。 然而我们使用不同的调用方法时, this的值也就不同了。当从变量 helloFunction()中调用的时候， this就被设置成了全局对象 (在浏览器中即window)。由于该对象 (非常可能地) 没有firstName 属性, 我们得到的结果便是\"Hello, I'm undefined\". (这是松散模式下的结果， 在 严格模式中，结果将不同（此时会产生一个error）。 但是为了避免混淆，我们在这里不涉及细节) 。另外，我们可以像上例末尾那样，使用Function#call (或者Function#apply)显式的设置this的值。 更多有关信息请参考 Function#call and Function#apply 继承 创建一个或多个类的专门版本类方式称为继承（Javascript只支持单继承）。 创建的专门版本的类通常叫做子类，另外的类通常叫做父类。 在Javascript中，继承通过赋予子类一个父类的实例并专门化子类来实现。在现代浏览器中你可以使用 Object.create 实现继承. JavaScript 并不检测子类的 prototype.constructor (见 Object.prototype), 所以我们必须手动申明它. 在下面的例子中, 我们定义了 Student类作为 Person类的子类. 之后我们重定义了sayHello() 方法并添加了 sayGoodBye() 方法. // 定义Person构造器 function Person(firstName) { this.firstName = firstName; } // 在Person.prototype中加入方法 Person.prototype.walk = function(){ alert(\"I am walking!\"); }; Person.prototype.sayHello = function(){ alert(\"Hello, I'm \" + this.firstName); }; // 定义Student构造器 function Student(firstName, subject) { // 调用父类构造器, 确保(使用Function#call)\"this\" 在调用过程中设置正确 Person.call(this, firstName); // 初始化Student类特有属性 this.subject = subject; }; // 建立一个由Person.prototype继承而来的Student.prototype对象. // 注意: 常见的错误是使用 \"new Person()\"来建立Student.prototype. // 这样做的错误之处有很多, 最重要的一点是我们在实例化时 // 不能赋予Person类任何的FirstName参数 // 调用Person的正确位置如下，我们从Student中来调用它 Student.prototype = Object.create(Person.prototype); // See note below // 设置\"constructor\" 属性指向Student Student.prototype.constructor = Student; // 更换\"sayHello\" 方法 Student.prototype.sayHello = function(){ console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\"); }; // 加入\"sayGoodBye\" 方法 Student.prototype.sayGoodBye = function(){ console.log(\"Goodbye!\"); }; // 测试实例: var student1 = new Student(\"Janet\", \"Applied Physics\"); student1.sayHello(); // \"Hello, I'm Janet. I'm studying Applied Physics.\" student1.walk(); // \"I am walking!\" student1.sayGoodBye(); // \"Goodbye!\" // Check that instanceof works correctly console.log(student1 instanceof Person); // true console.log(student1 instanceof Student); // true 对于“Student.prototype = Object.create(Person.prototype);”这一行，在不支持 Object.create方法的老JavaScript引擎中，可以使用一个\"polyfill\"（又名\"shim\"，查看文章链接），或者使用一个function来获得相同的返回值，就像下面： function createObject(proto) { function ctor() { } ctor.prototype = proto; return new ctor(); } // Usage: Student.prototype = createObject(Person.prototype); 封装 在上一个例子中，Student类虽然不需要知道Person类的walk()方法是如何实现的，但是仍然可以使用这个方法；Student类不需要明确地定义这个方法，除非我们想改变它。 这就叫做封装，对于所有继承自父类的方法，只需要在子类中定义那些你想改变的即可。 抽象 抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。 JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。 JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。 var foo = function(){}; console.log( 'foo is a Function: ' + (foo instanceof Function) ); // logs \"foo is a Function: true\" console.log( 'foo.prototype is an Object: ' + (foo.prototype instanceof Object) ); // logs \"foo.prototype is an Object: true\" 多态 就像所有定义在原型属性内部的方法和属性一样，不同的类可以定义具有相同名称的方法;方法是作用于所在的类中。并且这仅在两个类不是父子关系时成立（继承链中，一个类不是继承自其他类）。 注意 本文中所展示的面向对象编程技术不是唯一的实现方式，在JavaScript中面向对象的实现是非常灵活的。 同样的，文中展示的技术没有使用任何语言hacks，它们也没有模仿其他语言的对象理论实现。 JavaScript中还有其他一些更加先进的面向对象技术，但这些都超出了本文的介绍范围。 "},"Web/JavaScript/框架/Promise.html":{"url":"Web/JavaScript/框架/Promise.html","title":"Promise","keywords":"","body":"datetime:2019/12/5 15:03 author:nzb 接口调用方式 原生ajax 基于jQuery的ajax fetch axios 异步 JavaScript的执行环境是「单线程」 所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程 异步模式可以一起执行多个任务 JS中常见的异步调用 定时任何 ajax 事件函数 promise 主要解决异步深层嵌套的问题 promise 提供了简洁的API 使得异步操作更加容易 /* 1. Promise基本使用 我们使用new来构建一个Promise Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数 */ var p = new Promise(function(resolve, reject){ //2. 这里用于实现异步任务 setTimeout setTimeout(function(){ var flag = false; if(flag) { //3. 正常情况 resolve('hello'); }else{ //4. 异常情况 reject('出错了'); } }, 100); }); // 5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 // 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 p.then(function(data){ console.log(data) },function(info){ console.log(info) }); 基于Promise发送Ajax请求 JavaScript /* 基于Promise发送Ajax请求 */ function queryData(url) { # 1.1 创建一个Promise实例 var p = new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 && xhr.status == 200) { # 1.2 处理正常的情况 resolve(xhr.responseText); }else{ # 1.3 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); return p; } # 注意： 这里需要开启一个服务 # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 queryData('http://localhost:3000/data') .then(function(data){ console.log(data) # 1.4 想要继续链式编程下去 需要 return return queryData('http://localhost:3000/data1'); }) .then(function(data){ console.log(data); return queryData('http://localhost:3000/data2'); }) .then(function(data){ console.log(data) }); Jquery jquery中的promise $(function () { $(\"#btn\").on(\"click\", function () { $.ajax({ url: './data.json', type: 'get', dataType: 'json', //常见用法 // success: function (data) { // console.log(data) // } }) //promise用法 .then(function (data) { console.log(\"promise后数据\", data) }) }) }) Promise 基本API 实例方法 .then() 得到异步任务正确的结果 .catch() 获取异常信息 .finally() 成功与否都会执行（不是正式标准） /* Promise常用API-实例方法 */ // console.dir(Promise); function foo() { return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject('error'); }, 100); }) } // foo() // .then(function(data){ // console.log(data) // }) // .catch(function(data){ // console.log(data) // }) // .finally(function(){ // console.log('finished') // }); // -------------------------- // 两种写法是等效的 foo() .then(function(data){ # 得到异步任务正确的结果 console.log(data) },function(data){ # 获取异常信息 console.log(data) }) # 成功与否都会执行（不是正式标准） .finally(function(){ console.log('finished') }); 静态方法 .all() Promise.all方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定 .race() Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数 ​ /* Promise常用API-对象方法 */ // console.dir(Promise) function queryData(url) { return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 && xhr.status == 200) { // 处理正常的情况 resolve(xhr.responseText); }else{ // 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); } var p1 = queryData('http://localhost:3000/a1'); var p2 = queryData('http://localhost:3000/a2'); var p3 = queryData('http://localhost:3000/a3'); Promise.all([p1,p2,p3]).then(function(result){ // all 中的参数 [p1,p2,p3] 和 返回的结果一 一对应[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] console.log(result) //[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] }) Promise.race([p1,p2,p3]).then(function(result){ // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。 console.log(result) // \"HELLO TOM\" }) fetch Fetch API是新的ajax解决方案 Fetch会返回Promise fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch(url, options).then(） /* Fetch API 基本用法 fetch(url).then() 第一个参数请求的路径 Fetch会返回Promise 所以我们可以使用then 拿到请求成功的结果 */ fetch('http://localhost:3000/fdata').then(function(data){ // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data){ // 在这个then里面我们能拿到最终的数据 console.log(data); }) fetch API 中的 HTTP 请求 fetch(url, options).then(） HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT 默认的是 GET 请求 需要在 options 对象中 指定对应的 method method:请求使用的方法 post 和 普通 请求的时候 需要在options 中 设置 请求头 headers 和 body /* Fetch API 调用接口传递参数 */ #1.1 GET参数传递 - 传统URL 通过url ？ 的形式传参 fetch('http://localhost:3000/books?id=123', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { # 它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data) { # 在这个then里面我们能拿到最终的数据 console.log(data) }); #1.2 GET参数传递 restful形式的URL 通过/ 的形式传递参数 即 id = 456 和id后台的配置有关 fetch('http://localhost:3000/books/456', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #2.1 DELETE请求方式参数传递 删除id 是 id=789 fetch('http://localhost:3000/books/789', { method: 'delete' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #3 POST请求传参 fetch('http://localhost:3000/books', { method: 'post', # 3.1 传递数据 body: 'uname=lisi&pwd=123', # 3.2 设置请求头 headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # POST请求传参 fetch('http://localhost:3000/books', { method: 'post', body: JSON.stringify({ uname: '张三', pwd: '456' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # PUT请求传参 修改id 是 123 的 fetch('http://localhost:3000/books/123', { method: 'put', body: JSON.stringify({ uname: '张三', pwd: '789' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); fetchAPI 中 响应格式 用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如JSON，BLOB或者TEXT等等 /* Fetch响应结果的数据格式 */ fetch('http://localhost:3000/json').then(function(data){ // return data.json(); // 将获取到的数据使用 json 转换对象 return data.text(); // // 将获取到的数据 转换成字符串 }).then(function(data){ // console.log(data.uname) // console.log(typeof data) var obj = JSON.parse(data); console.log(obj.uname,obj.age,obj.gender) }) axios 基于promise用于浏览器和node.js的http客户端 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 能转换请求和响应数据 axios基础用法 get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params 形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 # 1. 发送get 请求 axios.get('http://localhost:3000/adata').then(function(ret){ # 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret) }) # 2. get 请求传递参数 # 2.1 通过传统的url 以 ? 的形式传递参数 axios.get('http://localhost:3000/axios?id=123').then(function(ret){ console.log(ret.data) }) # 2.2 restful 形式传递参数 axios.get('http://localhost:3000/axios/123').then(function(ret){ console.log(ret.data) }) # 2.3 通过params 形式传递参数 axios.get('http://localhost:3000/axios', { params: { id: 789 } }).then(function(ret){ console.log(ret.data) }) #3 axios delete 请求传参 传参的形式和 get 请求一样 axios.delete('http://localhost:3000/axios', { params: { id: 111 } }).then(function(ret){ console.log(ret.data) }) # 4 axios 的 post 请求 # 4.1 通过选项传递参数 axios.post('http://localhost:3000/axios', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) }) # 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams(); params.append('uname', 'zhangsan'); params.append('pwd', '111'); axios.post('http://localhost:3000/axios', params).then(function(ret){ console.log(ret.data) }) #5 axios put 请求传参 和 post 请求一样 axios.put('http://localhost:3000/axios/123', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) }) axios 全局配置 # 配置公共的请求头 axios.defaults.baseURL = 'https://api.example.com'; # 配置 超时时间 axios.defaults.timeout = 2500; # 配置公共的请求头 axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; # 配置公共的 post 的 Content-Type axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; axios 拦截器 请求拦截器 请求拦截器的作用是在请求发送前进行一些操作 例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易 响应拦截器 响应拦截器的作用是在接收到响应后进行一些操作 例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页 # 1. 请求拦截器 axios.interceptors.request.use(function(config) { console.log(config.url) # 1.1 任何请求都会经过这一步 在发送请求之前做些什么 config.headers.mytoken = 'nihao'; # 1.2 这里一定要return 否则配置不成功 return config; }, function(err){ #1.3 对请求错误做点什么 console.log(err) }) #2. 响应拦截器 axios.interceptors.response.use(function(res) { #2.1 在接收响应做些什么 var data = res.data; return data; }, function(err){ #2.2 对响应错误做点什么 console.log(err) }) async 和 await async作为一个关键字放到函数前面 任何一个async函数都会隐式返回一个promise await关键字只能在使用async定义的函数中使用 ​ await后面可以直接跟一个 Promise实例对象 ​ await函数不能单独使用 async/await 让异步代码看起来、表现起来更像同步代码 # 1. async 基础用法 # 1.1 async作为一个关键字放到函数前面 async function queryData() { # 1.2 await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 var ret = await new Promise(function(resolve, reject){ setTimeout(function(){ resolve('nihao') },1000); }) // console.log(ret.data) return ret; } # 1.3 任何一个async函数都会隐式返回一个promise 我们可以使用then 进行链式编程 queryData().then(function(data){ console.log(data) }) #2. async 函数处理多个异步函数 axios.defaults.baseURL = 'http://localhost:3000'; async function queryData() { # 2.1 添加await之后 当前的await 返回结果之后才会执行后面的代码 var info = await axios.get('async1'); #2.2 让异步代码看起来、表现起来更像同步代码 var ret = await axios.get('async2?info=' + info.data); return ret.data; } queryData().then(function(data){ console.log(data) }) 图书列表案例 1. 基于接口案例-获取图书列表 导入axios 用来发送ajax 把获取到的数据渲染到页面上 编号 名称 时间 操作 { {item.id} } { {item.name} } { {item.date } } 修改 | 删除 1. 导入axios /* 图书管理-添加图书 */ # 2 配置公共的url地址 简化后面的调用方式 axios.defaults.baseURL = 'http://localhost:3000/'; axios.interceptors.response.use(function(res) { return res.data; }, function(error) { console.log(error) }); var vm = new Vue({ el: '#app', data: { flag: false, submitFlag: false, id: '', name: '', books: [] }, methods: { # 3 定义一个方法 用来发送 ajax # 3.1 使用 async 来 让异步的代码 以同步的形式书写 queryData: async function() { // 调用后台接口获取图书列表数据 // var ret = await axios.get('books'); // this.books = ret.data; # 3.2 发送ajax请求 把拿到的数据放在books 里面 this.books = await axios.get('books'); } }, mounted: function() { # 4 mounted 里面 DOM已经加载完毕 在这里调用函数 this.queryData(); } }); 2 添加图书 获取用户输入的数据 发送到后台 渲染最新的数据到页面上 methods: { handle: async function(){ if(this.flag) { // 编辑图书 // 就是根据当前的ID去更新数组中对应的数据 this.books.some((item) => { if(item.id == this.id) { item.name = this.name; // 完成更新操作之后，需要终止循环 return true; } }); this.flag = false; }else{ # 1.1 在前面封装好的 handle 方法中 发送ajax请求 # 1.2 使用async 和 await 简化操作 需要在 function 前面添加 async var ret = await axios.post('books', { name: this.name }) # 1.3 根据后台返回的状态码判断是否加载数据 if(ret.status == 200) { # 1.4 调用 queryData 这个方法 渲染最新的数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, } 3 验证图书名称是否存在 添加图书之前发送请求验证图示是否已经存在 如果不存在 往后台里面添加图书名称 图书存在与否只需要修改submitFlag的值即可 watch: { name: async function(val) { // 验证图书名称是否已经存在 // var flag = this.books.some(function(item){ // return item.name == val; // }); var ret = await axios.get('/books/book/' + this.name); if(ret.status == 1) { // 图书名称存在 this.submitFlag = true; }else{ // 图书名称不存在 this.submitFlag = false; } } }, 4. 编辑图书 根据当前书的id 查询需要编辑的书籍 需要根据状态位判断是添加还是编辑 methods: { handle: async function(){ if(this.flag) { #4.3 编辑图书 把用户输入的信息提交到后台 var ret = await axios.put('books/' + this.id, { name: this.name }); if(ret.status == 200){ #4.4 完成添加后 重新加载列表数据 this.queryData(); } this.flag = false; }else{ // 添加图书 var ret = await axios.post('books', { name: this.name }) if(ret.status == 200) { // 重新加载列表数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, toEdit: async function(id){ #4.1 flag状态位用于区分编辑和添加操作 this.flag = true; #4.2 根据id查询出对应的图书信息 页面中可以加载出来最新的信息 # 调用接口发送ajax 请求 var ret = await axios.get('books/' + id); this.id = ret.id; this.name = ret.name; }, 5 删除图书 把需要删除的id书籍 通过参数的形式传递到后台 deleteBook: async function(id){ // 删除图书 var ret = await axios.delete('books/' + id); if(ret.status == 200) { // 重新加载列表数据 this.queryData(); } } "},"Web/JavaScript/框架/Vue.js基础.html":{"url":"Web/JavaScript/框架/Vue.js基础.html","title":"Vue.Js基础","keywords":"","body":"datetime:2019/7/15 10:09 author:nzb Vue.js Vue.js 是什么 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时， Vue 也完全能够为复杂的单页应用提供驱动。 简单示例 Vue基础 { { msg } } // 2.创建一个Vue示例 // 当我们导入包后，浏览器的内存中就多了一个Vue的构造函数 // 这个new出来的vm对象就是MVVM中的VM调度者 var vm = new Vue({ el: '#app', // 表示element, 网页上需要控制的区域 // 这里的data就是MVVM中的M，用于保存页面的数据 data: { // 存储需要的数据。 msg: \"Hello world, I'm Vue.js!!!\" // 通过Vue指令，把数据渲染到页面，不需要再操作DOM元素。 // (前端Vue之类的框架，不提倡我们去手动操作DOM元素了) } }) 模板语法 Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。 插值 文本 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： Message: { { msg } } Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 这个将不会改变: { { msg } } 原始HTML 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： Using mustaches: { { rawHtml } } Using v-html directive: 这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板， 因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 特性 Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中： Button 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 元素中。 使用 JavaScript 表达式 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 { { number + 1 } } { { ok ? 'YES' : 'NO' } } { { message.split('').reverse().join('') } } 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 { { var a = 1 } } { { if (ok) { return message } } } 注意：模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 指令 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子： 现在你看到我了 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 元素。 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性： ... 在这里 href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件： ... 在这里参数是监听的事件名。我们也会更详细地讨论事件处理。 动态参数 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： ... 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 \"href\"，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： ... 同样地，当 eventName 的值为 \"focus\" 时，v-on:[eventName] 将等价于 v-on:focus。 对动态参数的值的约束 注意：动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在 HTML 特性名里是无效的。同样，在 DOM 中使用模板时你需要回避大写键名。 例如，下面的代码是无效的： ... 变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。 另外，如果你在 DOM 中使用模板 (直接在一个 HTML 文件里撰写模板)，需要留意浏览器会把特性名全部强制转为小写： ... 修饰符 修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： ... 事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 例子 百度一下 var vm = new Vue({ el: '#app', data: {}, methods: { divclick(){ console.log('div'); }, btnclick(){ console.log('btn') }, noredirect(){ console.log('a') } }, }); 归纳常见指令 v-cloak：解决闪烁问题 当网速较慢时，vue加载较慢，插值表达式渲染的数据就会产生闪烁，使用v-cloak指令加上如上样式可以解决该问题 v-text：插入文本字符串 v-text默认就没有闪烁，但是会以文本字符串的方式覆盖所在元素的文本 v-html：插入html v-html与v-text的不同在于插入的是html。 v-bind：绑定属性 在vue中想要让属性如title等于data对象中的一个变量（键），会被直接当作字符串显示出来，这时就要用到v-bind，v-bind可以将绑定的属性值当作变量对待，在data对象中去找。 v-bind的三种用法： 直接使用指令v-bind 使用简化指令\":\" 在绑定的时候，拼接绑定内容：:title=\"btnTitle + ', 这是追加的内容'\" v-on：绑定方法,缩写：\"@\" 示例 +++++{ { msg } }----- ====== 123123 var vm = new Vue({ el: '#app', data: { msg: 'hello', msg2: '我是h1', mytitle: '这是一个自定义title', }, methods: { // 这个methods属性中定义了当前vue实例所有可用的方法 show: function () { alert(\"Hello!!!\") } } }) v-model：、实现双向数据绑定： { { message } } new Vue({ el: '#app', data: { message: 'Runoob!' } }) 注意：v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 缩写 v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时， v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。 同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。 因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写 ... ... v-on 缩写 ... ... 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于特性名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。 在Vue中使用样式 使用class样式 数组 这是一个邪恶的H1 数组中使用三元表达式 这是一个邪恶的H1 数组中嵌套对象(对象就是键值对) 这是一个邪恶的H1 直接使用对象 这是一个邪恶的H1 var vm = new Vue({ el: '#app', data: { flag: true, classObj: {red:true, thin:true, italic:true, active:false}, }, methods: {}, }); 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 这是一个善良的H1 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 这是一个善良的H1 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }, h1StyleObj2: { fontStyle: 'italic' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 这是一个善良的H1 条件渲染 v-if 条件判断使用 v-if 指令： 现在你看到我了 菜鸟教程 学的不仅是技术，更是梦想！ 哈哈哈，打字辛苦啊！！！ new Vue({ el: '#app', data: { seen: true, ok: true } }) 你可以使用 v-else 指令来表示 v-if 的“else 块”： 0.5\"> Now you see me Now you don't v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： A B C Not A/B/C 注意：v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 v-show Hello! 注意，v-show 不支持 元素，也不支持 v-else。 v-if vs v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换， 则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 与 v-for 一起使用 不推荐同时使用 v-if 和 v-for。请查阅风格指南以获取更多信息。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。请查阅列表渲染指南 以获取详细信息。 列表渲染-循环 v-for迭代数组 { { parentMessage } } - { { index } } - { { item.message } } var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [ { message: 'Foo' }, { message: 'Bar' } ] } }) 第二个参数为当前项的索引。 v-for迭代对象中的属性 { { value } } new Vue({ el: '#v-for-object', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }) 你也可以提供第二个的参数为 property 名称 (也就是键名)： { { name } }: { { value } } 还可以用第三个参数作为索引： { { index } }. { { name } }: { { value } } v-for迭代数字 { { n } } 注意事项 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=\"$index\"。 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。 注意：不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。 过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： { { message | capitalize } } 你可以在一个组件的选项中定义本地的过滤器： filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } 或者在创建 Vue 实例之前全局定义过滤器： Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) new Vue({ // ... }) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 过滤器可以串联： { { message | filterA | filterB } } 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数： { { message | filterA('arg1', arg2) } } 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 事件处理 监听事件 可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 示例： Add 1 The button above has been clicked { { counter } } times. var example1 = new Vue({ el: '#example-1', data: { counter: 0 } }) 事件处理方法 然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。 示例： Greet var example2 = new Vue({ el: '#example-2', data: { name: 'Vue.js' }, // 在 `methods` 对象中定义方法 methods: { greet: function (event) { // `this` 在方法里指向当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) { alert(event.target.tagName) } } } }) // 也可以用 JavaScript 直接调用方法 example2.greet() // => 'Hello Vue.js!' 内联处理器中的方法 除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： Say hi Say what new Vue({ el: '#example-3', methods: { say: function (message) { alert(message) } } }) 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： Submit // ... methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) } } 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive ... ... 注意：使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 2.3.0 新增 Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。 ... 这个 .passive 修饰符尤其能够提升移动端的性能。 注意：不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 按键修饰符 在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 按键码 keyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持。 使用 keyCode 特性也是允许的： 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。 你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名： // 可以使用 v-on:keyup.f1 Vue.config.keyCodes.f1 = 112 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 例如： Do something 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 A A A 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 为什么在 HTML 中监听事件? 你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 自定义指令 简介 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。 然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子。 当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容， 这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能： // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 如果想注册局部指令，组件中也接受一个 directives 的选项： directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 钩子函数 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。 但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 钩子函数参数 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注意：除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 这是一个使用了这些属性的自定义钩子样例： Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' } }) 结果： name: \"demo\" value: \"hello!\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 动态指令参数 指令的参数可以是动态的。例如，在 v-mydirective:[argument]=\"value\"中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。 例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令： Scroll down the page Stick me 200px from the top of the page Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' el.style.top = binding.value + 'px' } }) new Vue({ el: '#baseexample' }) 这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。 Scroll down inside this section ↓ I am pinned onto the page at 200px to the left. Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' } }) new Vue({ el: '#dynamicexample', data: function () { return { direction: 'left' } } }) 这样这个自定义指令现在的灵活性就足以支持一些不同的用例了。 函数简写 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: Vue.directive('color-swatch', function (el, binding) { el.style.backgroundColor = binding.value }) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // => \"white\" console.log(binding.value.text) // => \"hello!\" }) vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器 vue-resource 实现 get, post, jsonp请求 除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； const http = require('http'); // 导入解析 URL 地址的核心模块 const urlModule = require('url'); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on('request', (req, res) => { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] }; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `${cbName}(${JSON.stringify(data)})`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end('404'); } }); server.listen(3000, () => { console.log('server running at http://127.0.0.1:3000'); Vue.js Ajax(axios) Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Github开源地址： https://github.com/axios/axios 安装方法 使用 cdn: 或 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 yarn: $ yarn add axios GET方法 我们可以简单的读取 JSON 数据： new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .get('https://www.runoob.com/try/ajax/json_demo.json') .then(response => (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) 使用 response.data 读取 JSON 数据： 网站列表 { { site.name } } new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .get('https://www.runoob.com/try/ajax/json_demo.json') .then(response => (this.info = response.data.sites)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) GET 方法传递参数格式如下： // 直接在 URL 上添加参数 ID=12345 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 也可以通过 params 设置参数： axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); POST方法 示例 new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .post('https://www.runoob.com/try/ajax/demo_axios_post.php') .then(response => (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) POST 方法传递参数格式如下： axios.post('/user', { firstName: 'Fred', // 参数 firstName lastName: 'Flintstone' // 参数 lastName }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 示例 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); axios API 可以通过向axios传递相关配置来创建请求 axios(config) // 发送 POST 请求 axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }); // GET 请求远程图片 axios({ method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); 请求方法的别名 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 可以使用自定义配置创建一个axios实例： axios.create([config]) const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: {'X-Custom-Header': 'foobar'} }); 实例方法 以下是可以的实例方法，指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置项 下面是创建请求时可用的配置选项，注意只有url是必需的。如果没有指定method，请求将默认使用get方法。 { // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {\"X-Requested-With\": \"XMLHttpRequest\"}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: \"brackets\"}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: \"Fred\" }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求花费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: \"janedoe\", password: \"s00pers3cret\" }, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: \"127.0.0.1\", port: 9000, auth: : { username: \"mikeymike\", password: \"rapunz3l\" } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 axios请求的响应包含以下信息 { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: \"OK\", // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用then时，会接收下面这样的响应： axios.get(\"/user/12345\") .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。 配置的默认值 你可以指定将被用在各个请求的配置默认值。 全局的axios默认值 axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: 'https://api.example.com' }); // 在实例已创建后修改默认值 instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 `0` var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get('/longRequest', { timeout: 5000 }); 拦截器 在请求或响应被 then 或 catch 处理前拦截它们。 // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器。 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理： axios.get('/user/12345') .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log('Error', error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get('/user/12345', { validateStatus: function (status) { return status 取消 使用 cancel token 取消请求。 Axios 的 cancel token API 基于cancelable promises proposal 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： var CancelToken = axios.CancelToken; var source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }); // 取消请求（message 参数是可选的） source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get('/user/12345', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); 注意：可以使用同一个 cancel token 取消多个请求。 请求时使用 application/x-www-form-urlencoded axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。 浏览器 在浏览器环境，你可以使用 URLSearchParams API： const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); URLSearchParams 不是所有的浏览器均支持。 除此之外，你可以使用 qs 库来编码数据: const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); // Or in another way (ES6), import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); Node.js 环境 在 node.js里, 可以使用 querystring 模块: const querystring = require('querystring'); axios.post('http://something.com/', querystring.stringify({ foo: 'bar' })); 当然，同浏览器一样，你还可以使用 qs 库。 Promises axios 依赖原生的 ES6 Promise 实现而被支持。 如果你的环境不支持 ES6 Promise，你可以使用 polyfill。 TypeScript支持 axios 包含 TypeScript 的定义。 import axios from \"axios\"; axios.get(\"/user?ID=12345\"); 案例 跑马灯 简易计算器 品牌管理案例 "},"Web/JavaScript/框架/Vue.js组件.html":{"url":"Web/JavaScript/框架/Vue.js组件.html","title":"Vue.Js组件","keywords":"","body":"datetime:2019/11/27 16:40 author:nzb Vue.js组件 基础 基本示例 简单示例 // 定义一个名为 button-counter 的新组件 Vue.component('button-counter', { data: function () { return { count: 0 } }, template: 'You clicked me { { count } } times.' }) new Vue({ el: '#components-demo' }) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 组件的复用 你可以将组件进行任意次数的复用： 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 data必须是一个函数 当我们定义这个 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象： data: { count: 0 } 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： data: function f() { return { count: 0 } } 组件的注册 通常一个应用会以一颗嵌套的组件树的形式来组织 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。 组件名 在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了： Vue.component('my-component-name', { /* ... */ }) 该组件名就是 Vue.component 的第一个参数。 你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 你可以在风格指南中查阅到关于组件名的其它建议。 组件名大小写 使用kebab-case Vue.component('my-component-name', { /* ... */ }) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 。 使用 PascalCase Vue.component('MyComponentName', { /* ... */ }) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 和 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册 到目前为止，我们只用过 Vue.component 来创建组件： Vue.component('my-component-name', { // ... 选项 ... }) 这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如： Vue.component('component-a', { /* ... */ }) Vue.component('component-b', { /* ... */ }) Vue.component('component-c', { /* ... */ }) new Vue({ el: '#app' }) 在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。 局部注册 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件： var ComponentA = { /* ... */ } var ComponentB = { /* ... */ } var ComponentC = { /* ... */ } 然后在 components 选项中定义你想要使用的组件： new Vue({ el: '#app', components: { 'component-a': ComponentA, 'component-b': ComponentB } }) 对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 注意局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写： var ComponentA = { /* ... */ } var ComponentB = { components: { 'component-a': ComponentA }, // ... } 或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像： import ComponentA from './ComponentA.vue' export default { components: { ComponentA }, // ... } 注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是： 用在模板中的自定义元素的名称 包含了这个组件选项的变量名 通过 Prop 向子组件传递数据 早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 prop 的由来。 Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中： Vue.component('blog-post', { props: ['title'], template: '{ { title } }' }) 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 一个 prop 被注册之后，你就可以像这样把数据作为一个自定义特性传递进来： 然而在一个典型的应用中，你可能在 data 里有一个博文的数组： new Vue({ el: '#blog-post-demo', data: { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } }) 并想要为每篇博文渲染一个组件： 如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。 到目前为止，关于 prop 你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把 prop 读完。 单个根元素 当构建一个 组件时，你的模板最终会包含的东西远不止一个标题： { { title } } 最最起码，你会包含这篇博文的正文： { { title } } 然而如果你在模板中尝试这样写，Vue 会显示一个错误，并解释道 every component must have a single root element (每个组件必须只有一个根元素)。你可以将模板的内容包裹在一个父元素内，来修复这个问题，例如： { { title } } 看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦： 所以是时候重构一下这个 组件了，让它变成接受一个单独的 post prop： Vue.component('blog-post', { props: ['post'], template: ` { { post.title } } ` }) 注意：上述的这个和一些接下来的示例使用了 JavaScript 的模板字符串来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之。 现在，不论何时为 post 对象添加一个新的属性，它都会自动地在 内可用。 动态组件(组件切换) 有点时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 元素加一个特殊的 is 特性来实现： 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 你可以在这里查阅并体验完整的代码，或在这个版本了解绑定组件选项对象，而不是已注册组件名的示例。 到目前为止，关于动态组件你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把动态和异步组件读完。 多个组件的过渡动画 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件。 其中mode=\"out-in\"属性是先出后进 new Vue({ el: '#transition-components-demo', data: { view: 'v-a' }, components: { 'v-a': { template: 'Component A' }, 'v-b': { template: 'Component B' } } }) .component-fade-enter-active, .component-fade-leave-active { transition: opacity .3s ease; } .component-fade-enter, .component-fade-leave-to /* .component-fade-leave-active for below version 2.1.8 */ { opacity: 0; } 父组件向子组件传值 Document var vm = new Vue({ el: '#app', data:{ msg: '123父组件中的数据' }, methods: { }, components:{ 'com1':{ //子组件中，默认无法访问到父组件中的data和methods template: ' 这是子组件 { {parentmsg} }', //注意，组件中的所有props中的数据都是通过父组件传递给子组件的 //propes中的数据是只可读 props: ['parentmsg'] ,// 把父组件传递过来的parentmsg属性， 数组中，定义一下，这样才能用这个数据, //注意子组件中的data数据，并不是通过父组件传递过来的，而是子组件字有的，比如：子组件通过Ajax请求回来的值，可以放到data中 //dat a中的数据可读可写 data(){ return { title: '123', content: 'qqq' } }, methods: { change(){ this.parentmsg='被修改' } }, } } }) 父组件把方法传递给子组件 Document 子组件 //定义了一个字面类型的组件模板对象 var com2 = { template: '#temp1' , methods: { myclick(){ //当点击子组件方法的时候，如何拿到父组件传递过来的func方法 //emit是触发的意思 this.$emit('func', this.sonmsg) } }, data() { return { sonmsg: { name: 'aaa', age: 6 } } } } var vm = new Vue({ el: '#app', data: { datamsgFromSon: null }, methods: { show(data){ // console.log('调用了父组件身上的show方法'+data) console.log(data) this.datamsgFromSon = data }, }, components:{ com2 }, }) ref获取DOM元素和组件 Document 哈哈哈 拉拉 var login = { template: ' 登陆组件 ', data(){ return { msg: 'template msg' } }, methods: { show(){ console.log('调用了子组件的方法') } }, } var vm = new Vue({ el: '#app', data: { }, methods: { getElement(){ console.log(this.$refs.myh3.innerText) console.log(this.$refs.myLogin.msg) this.$refs.myLogin.show() } }, components:{ login } }) "},"Web/JavaScript/框架/Vue.js路由.html":{"url":"Web/JavaScript/框架/Vue.js路由.html","title":"Vue.Js路由","keywords":"","body":"datetime:2019/12/3 14:13 author:nzb Vue.js路由 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 基本示例 Document .router-link-active, .myactive{ color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } .v-enter, .v-leave-to{ opacity: 0; transform: translateX(140px); } .v-enter-active, .v-leave-active{ transition: all 0.5s ease; } 登陆 注册 登陆 注册 var login = { template: 'login' } var register = { template: '注册' } /* 1 创建一个路由对象， 当导入vue-router之后，在windows 全局对象中，就有了一个路由的构造函数叫做VueRouter 在new路由对象的时候，可以为构造函数传递一个配置对象 */ var routerObj = new VueRouter({ routes:[ //路由匹配规则 /* 每个路由规则都是一个对象，这个规则的对象必须有两个必须的属性 属性1：path 表示监听哪个路由链接地址 属性2：component，表示如果路由是前面匹配到的path，则展示component属性对应的组件 */ //注意：component的属性值必须是一个组件的模板对象 不能是组件的引用名称 //{ path: '/', component: login}, { path:'/', redirect: '/login'}, { path: '/login', component: login}, { path: '/register', component: register} ], linkActiveClass: 'myactive' }) var vm = new Vue({ el: '#app', data: { }, methods: { }, //将路由规则对象， 注册到vm实例上，用来舰艇URL地址的变化，然后展示对应的组件 router: routerObj }) 重定向和别名 重定向// 重定向也是通过 `routes` 配置来完成，下面例子是从 `/a` 重定向到 `/b`： const router = new VueRouter({ routes: [ { path: '/a', redirect: '/b' } ] }) //重定向的目标也可以是一个命名的路由： const router = new VueRouter({ routes: [ { path: '/a', redirect: { name: 'foo' } } ] }) // 甚至是一个方法，动态返回重定向目标： const router = new VueRouter({ routes: [ { path: '/a', redirect: to => { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 } } ] }) 注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。 其它高级用法，请参考例子。 别名 “重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，那么“别名”又是什么呢？ /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。 上面对应的路由配置为： const router = new VueRouter({ routes: [ { path: '/a', component: A, alias: '/b' } ] }) “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。更多高级用法，请查看例子。 高亮，过渡动画，重定向示例 在路由规则中定义参数 在规则中定义参数：{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数： ```javascript var register = Vue.extend({template: '注册组件 --- { {this.$route.params.id} }' }); ### [路由嵌套](https://router.vuejs.org/zh/guide/essentials/nested-routes.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1) 实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： ![](../../res/vue-路由嵌套.png) 借助 `vue-router`，使用嵌套路由配置，就可以很简单地表达这种关系。 接着上节创建的 app： ```html 这里的 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 。例如，在 User 组件的模板添加一个 ： const User = { template: ` User { { $route.params.id } } ` } 要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置： const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, children: [ { // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 中 path: 'profile', component: UserProfile }, { // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 中 path: 'posts', component: UserPosts } ] } ] }) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。 你会发现，children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。 此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 中 { path: '', component: UserHome }, // ...其他子路由 ] } ] }) 命名视图 示例实现经典布局 名称拼接案例 案例1：使用keyup 案例2：使用watch监听 使用watch监听路由变化 案例3：computed计算属性 watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； "},"Web/JavaScript/框架/Vue.js过渡和动画.html":{"url":"Web/JavaScript/框架/Vue.js过渡和动画.html","title":"Vue.Js过渡和动画","keywords":"","body":"datetime:2019/11/26 9:19 author:nzb Vue.js过渡和动画 Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡 简单例子 Toggle hello new Vue({ el: '#demo', data: { show: true } }) .fade-enter-active, .fade-leave-active { transition: opacity .5s; } .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } 过渡的类名 过渡其实就是一个淡入淡出的效果。Vue在元素显示与隐藏的过渡中，提供了 6 个 class 来切换： v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 ，则 v- 是这些类名的默认前缀。如果你使用了 ，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。 自定义过渡的类名-使用第三方类库animate.css 我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 示例： Toggle render hello new Vue({ el: '#example-3', data: { show: true } }) JavaScript钩子 // ... methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... }, enterCancelled: function (el) { // ... }, // -------- // 离开时 // -------- beforeLeave: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) { // ... done() }, afterLeave: function (el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) { // ... } } 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 注意： 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 一个使用 Velocity.js 的简单例子： Toggle Demo new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } } }) 初始渲染的过渡 可以通过 appear 特性设置节点在初始渲染的过渡 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。 自定义 JavaScript 钩子： 在上面的例子中，无论是 appear 特性还是 v-on:appear 钩子都会生成初始渲染过渡。 多个元素/组件过渡 列表过渡 目前为止，关于过渡我们已经讲到： 单个节点 同一时间渲染多个节点中的一个 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用 组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 ，它会以一个真实元素呈现：默认为一个 。你也可以通过 tag 特性更换为其他元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素 总是需要 提供唯一的 key 属性值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。 列表的进入/离开过渡 Add Remove { { item } } new Vue({ el: '#list-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } }) .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s; } .list-enter, .list-leave-to /* .list-leave-active for below version 2.1.8 */ { opacity: 0; transform: translateY(30px); } 这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。 列表的排序过渡 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。 v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： Shuffle { { item } } new Vue({ el: '#flip-list-demo', data: { items: [1,2,3,4,5,6,7,8,9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } }) .flip-list-move { transition: transform 1s; } 列表的交错过渡 "},"Web/JavaScript/框架/jQuery-UI.html":{"url":"Web/JavaScript/框架/jQuery-UI.html","title":"JQuery UI","keywords":"","body":"datetime:2019/7/12 9:47 author:nzb 特效（Effects） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 百叶窗特效（Blind Effect） 百叶窗特效（Blind Effect）通过将元素包裹在一个容器内，采用\"拉百叶窗\"效果来隐藏或显示元素。 反弹特效（Bounce Effect） 反弹特效（Bounce Effect）反弹一个元素。当与隐藏或显示一起使用时，最后一次或第一次反弹会呈现淡入/淡出效果。 剪辑特效（Clip Effect） 剪辑特效（Clip Effect）通过垂直或水平方向夹剪元素来隐藏或显示一个元素。 颜色动画（Color Animation） 使用 .animate() 实现颜色动画效果。 降落特效（Drop Effect） 降落特效（Drop Effect）通过单个方向滑动的淡入淡出来隐藏或显示一个元素。 Easing Easing函数指定动画在不同点上的行进速度。 .effect() 对一个元素应用动画特效。 特效核心（Effects Core） | 方法（Method） 爆炸特效（Explode Effect） 爆炸特效（Explode Effect）通过把元素裂成碎片来隐藏或显示一个元素。 淡入淡出特效（Fade Effect） 淡入淡出特效（Fade Effect）通过淡入淡出元素来隐藏或显示一个元素。 折叠特效（Fold Effect） 折叠特效（Fold Effect）通过折叠元素来隐藏或显示一个元素。 .hide() 使用自定义效果来隐藏匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） 突出特效（Highlight Effect） 突出特效（Highlight Effect）通过首先改变背景颜色来隐藏或显示一个元素。 膨胀特效（Puff Effect） 通过在缩放元素的同时隐藏元素来创建膨胀特效（Puff Effect）。 跳动特效（Pulsate Effect） 跳动特效（Pulsate Effect）通过跳动来隐藏或显示一个元素。 .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 缩放特效（Scale Effect） 按照某个百分比缩放元素。 震动特效（Shake Effect） 垂直或水平方向多次震动元素。 .show() 使用自定义效果来显示匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） 尺寸特效（Size Effect） 调整元素尺寸到指定宽度和高度。 滑动特效（Slide Effect） 把元素滑动出视区。 .switchClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加和移除指定的 Class。 特效核心（Effects Core） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 转移特效（Transfer Effect） 把一个元素的轮廓转移到另一个元素。 特效核心（Effects Core） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效（Effects） | 方法重载（Method Overrides） 颜色动画（Color Animation） 使用 .animate() 实现颜色动画效果。 .effect() 对一个元素应用动画特效。 特效（Effects） | 方法（Method） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效（Effects） | 方法重载（Method Overrides） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .switchClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加和移除指定的 Class。 特效（Effects） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效（Effects） | 方法重载（Method Overrides） 交互（Interactions） API 描述 也属于类别 可拖拽小部件（Draggable Widget） 允许使用鼠标移动元素。 可放置小部件（Droppable Widget） 为可拖拽小部件创建目标。 鼠标交互（Mouse Interaction） 基本交互层。 实用工具（Utilities） 可调整尺寸小部件（Resizable Widget） 使用鼠标改变元素的尺寸。 可选择小部件（Selectable Widget） 使用鼠标选择单个元素或一组元素。 可排序小部件（Sortable Widget） 使用鼠标调整列表中或者网格中元素的排序。 方法重载（Method Overrides） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效（Effects） | 特效核心（Effects Core） .focus() 异步聚焦到一个元素。 方法（Method） | UI 核心（UI Core） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .position() 相对另一个元素定位一个元素。 方法（Method） | 实用工具（Utilities） .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效（Effects） | 特效核心（Effects Core） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效（Effects） | 特效核心（Effects Core） 方法（Methods） API 描述 也属于类别 .disableSelection() 禁用选择匹配的元素集合内的文本内容。 UI 核心（UI Core） .effect() 对一个元素应用动画特效。 特效（Effects） | 特效核心（Effects Core） .enableSelection() 启用选择匹配的元素集合内的文本内容。 UI 核心（UI Core） .focus() 异步聚焦到一个元素。 方法重载（Method Overrides） | UI 核心（UI Core） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .position() 相对另一个元素定位一个元素。 方法重载（Method Overrides） | 实用工具（Utilities） .removeUniqueId() 为匹配的元素集合移除由 .uniqueId() 设置的 Id。 UI 核心（UI Core） .scrollParent() 获取最近的可滚动的祖先。 UI 核心（UI Core） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .uniqueId() 为匹配的元素集合生成并申请一个唯一的 Id。 UI 核心（UI Core） .zIndex() 为元素获取 z-index。 UI 核心（UI Core） 选择器（Selectors） API 描述 也属于类别 :data() Selector 选择数据已存储在指定的键下的元素。 UI 核心（UI Core） :focusable Selector 选择可被聚焦的元素。 UI 核心（UI Core） :tabbable Selector 选择用户可通过 tab 键聚焦的元素。 UI 核心（UI Core） 主题（Theming） API 描述 CSS 框架（CSS Framework） jQuery UI 使用的允许组件主题化的 Class 名称列表。 图标（Icons） jQuery UI 提供的图标列表。 堆叠元素（Stacking Elements） 一种处理 z-index 和堆叠元素的模式。 UI 核心（UI Core） API 描述 也属于类别 :data() Selector 选择数据已存储在指定的键下的元素。 选择器（Selectors） .disableSelection() 禁用选择匹配的元素集合内的文本内容。 方法（Methods） .enableSelection() 启用选择匹配的元素集合内的文本内容。 方法（Methods） .focus() 异步聚焦到一个元素。 方法重载（Method Overrides） 方法（Methods） :focusable Selector 选择可被聚焦的元素。 选择器（Selectors） jQuery.ui.keyCode 一个相对于数字值的关键代码描述的映射。 .removeUniqueId() 为匹配的元素集合移除由 .uniqueId() 设置的 Id。 方法（Methods） .scrollParent() 获取最近的可滚动的祖先。 方法（Methods） :tabbable Selector 选择用户可通过 tab 键聚焦的元素。 选择器（Selectors） .uniqueId() 为匹配的元素集合生成并申请一个唯一的 Id。 方法（Methods） .zIndex() 为元素获取 z-index。 方法（Methods） 实用工具（Utilities） API 描述 也属于类别 Easings Easing 函数指定动画在不同点上的行进速度。 部件库（Widget Factory） 使用与所有 jQuery UI 小部件相同的抽象化来创建有状态的 jQuery 插件。 小部件（Widgets） 插件桥（Widget Plugin Bridge） jQuery.widget.bridge() 方法是 jQuery 部件库（Widget Factory）的一部分。它扮演着由 $.widget() 创建的对象和 jQuery API 之间的中介。 小部件（Widgets） 鼠标交互（Mouse Interaction） 基本交互层。 交互（Interactions） .position() 相对另一个元素定位一个元素。 方法重载（Method Overrides） | 方法（Method） 小部件（Widgets） API 描述 也属于类别 折叠面板部件（Accordion Widget） 把一对标题和内容面板转换成折叠面板。 自动完成部件（Autocomplete Widget） 自动完成功能根据用户输入值进行搜索和过滤，让用户快速找到并从预设值列表中选择。 按钮部件（Button Widget） 可主题化的按钮和按钮集合。 日期选择器部件（Datepicker Widget） 从弹出框或在线日历选择一个日期。 对话框部件（Dialog Widget） 在一个交互覆盖层中打开内容。 部件库（Widget Factory） 使用与所有 jQuery UI 小部件相同的抽象化来创建有状态的 jQuery 插件。 实用工具（Utilities） 插件桥（Widget Plugin Bridge） jQuery.widget.bridge() 方法是 jQuery 部件库（Widget Factory）的一部分。它扮演着由 $.widget() 创建的对象和 jQuery API 之间的中介。 实用工具（Utilities） 菜单部件（Menu Widget） 带有鼠标和键盘交互的用于导航的可主题化菜单。 进度条部件（Progressbar Widget） 显示一个确定的或不确定的进程状态。 滑块部件（Slider Widget） 拖动手柄可以选择一个数值。 旋转器部件（Spinner Widget） 通过向上/向下按钮和箭头键处理，为输入数值增强文本输入功能。 标签页部件（Tabs Widget） 一种多面板的单内容区，每个面板与列表中的标题相关。 工具提示框部件（Tooltip Widget） 可自定义的、可主题化的工具提示框，替代原生的工具提示框。 "},"Web/JavaScript/框架/jQuery基础.html":{"url":"Web/JavaScript/框架/jQuery基础.html","title":"JQuery基础","keywords":"","body":"datetime:2019/7/10 13:43 author:nzb jQuery简介 jQuery 库可以通过一行简单的标记被添加到网页中。 什么是 jQuery ？ jQuery是一个JavaScript函数库。 jQuery是一个轻量级的\"写的少，做的多\"的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）\"查询\"和\"查找\" HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(\"p\").hide() - 隐藏所有 元素 $(\"p.test\").hide() - 隐藏所有 class=\"test\" 的 元素 $(\"#test\").hide() - 隐藏所有 id=\"test\" 的元素 文档就绪事件 您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： $(document).ready(function(){ // 开始写 jQuery 代码... }); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 提示：简洁写法（与以上写法效果相同）: $(function(){ // 开始写 jQuery 代码... }); 以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。 JavaScript 入口函数: window.onload = function () { // 执行代码 } jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 中所有选择器都以美元符号开头：$()。 元素选择器 用户点击按钮后，所有 元素都隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(); }); }); #id 选择器 当用户点击按钮后，有 id=\"test\" 属性的元素将被隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); .class 选择器 用户点击按钮后所有带有 class=\"test\" 属性的元素都隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 更多实例 语法 描述 $(\"*\") 选取所有元素 $(this) 选取当前 HTML 元素 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"[href]\") 选取带有 href 属性的元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 $(\"#id\", \".class\") 复合选择器 $(div p span) 层级选择器 //div下的p元素中的span元素 $(div>p) 父子选择器 //div下的所有p元素 $(div+p) 相邻元素选择器 //div后面的p元素(仅一个p) $(div~p) 兄弟选择器 //div后面的所有p元素(同级别) $(.p:last) 类选择器 加 过滤选择器 第一个和最后一个（first 或者 last） $(\"#mytable td:odd\") 层级选择 加 过滤选择器 奇偶（odd 或者 even） $(\"div p:eq(2)\") 索引选择器 div下的第三个p元素（索引是从0开始） $(\"a[href='www.baidu.com']\") 属性选择器 $(\"p:contains(test)\") // 内容过滤选择器，包含text内容的p元素 $(\":emtyp\") //内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反 $(\":hidden\") //所有隐藏元素 visible $(\"input:enabled\") //选取所有启用的表单元素 $(\":disabled\") //所有不可用的元素 $(\"input:checked\") //获取所有选中的复选框单选按钮等 $(\"select option:selected\") //获取选中的选项元素 关于 : 和 [] 这两个符号的理解 “：”：可以理解为种类的意思，如：p:first，p 的种类为第一个。 “[]” ：很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。 $(\":button\") 为 jQuery 中表单选择器（貌似与过滤选择器同级），旨在选择所有的按钮，所以会找到 、 元素；而 $(\"button\") 则为基本选择器，旨在选择为 的标签。 : 即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；其过滤选择器大概可以分为基本过滤（p:first 之类）、内容过滤（:empty）、子元素过滤(:first-child)和属性过滤 [href] 选择器。 事件 页面对不同访问者的响应叫做事件。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 实例： 在元素上移动鼠标。 选取单选按钮 点击元素 在事件中经常使用术语\"触发\"（或\"激发\"）例如： \"当您按下按键时触发 keypress 事件\"。 常用的 jQuery 事件方法 $(document).ready() $(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在 jQuery 语法 章节中已经提到过。 click() click() 方法是当按钮点击事件被触发时会调用一个函数。 dblclick() 当双击元素时，会发生 dblclick 事件。 mouseenter() 当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave() 当鼠标指针离开元素时，会发生 mouseleave 事件。 mousedown() 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mouseup() 当在元素上松开鼠标按钮时，会发生 mouseup 事件。 hover() hover()方法用于模拟光标悬停事件。 当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus() 当元素获得焦点时，发生 focus 事件。 当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。 blur() 当元素失去焦点时，发生 blur 事件。 on() 和 off() 绑定事件和解除绑定事件 笔记 一.keypress,keydown,keyup的区别: 1.keydown：在键盘上按下某键时发生,一直按着则会不断触发（opera浏览器除外）, 它返回的是键盘代码; 2.keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效 ,换句话说, 只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。 3.keyup：用户松开某一个按键时触发, 与keydown相对, 返回键盘代码. 二.两种常用用法举例 案例1:获取按键代码或字符的ASCII码 $(window).keydown( function(event){ // 通过event.which可以拿到按键代码. 如果是keypress事件中,则拿到ASCII码. } ); 案例2:传递数据给事件处理函数 语法: jQueryObject.keypress( [[ data ,] handler ] ); data: 通过event.data传递给事件处理函数的任意数据; handler: 指定的事件处理函数; 举例: // 只允许按下的字母键生效, 65~90是所有大写字母的键盘代码范围. var validKeys = { start: 65, end: 90 }; $(\"#keys\").keypress( validKeys, function(event){ var keys = event.data; //拿到validKeys对象. return event.which >= keys.start && event.which 三.关于获取触发事件的说明： 1.获取事件对象 $(document).ready(function(){ $(window).keypress(function(event){ //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which); }); }); 2.keypress事件获取键入字符 $(window).keypress(function(event){ //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为\"Enter\"，空白键还是空白\" \"。 console.log(event.key); }); jQuery - noConflict() 方法 正如您已经了解到的，jQuery 使用 $ 符号作为 jQuery 的简写。 如果其他 JavaScript 框架也使用 $ 符号作为简写怎么办？ 其他一些 JavaScript 框架包括：MooTools、Backbone、Sammy、Cappuccino、Knockout、JavaScript MVC、Google Web Toolkit、Google Closure、Ember、Batman 以及 Ext JS。 其中某些框架也使用 $ 符号作为简写（就像 jQuery），如果您在用的两种不同的框架正在使用相同的简写符号，有可能导致脚本停止运行。 jQuery 的团队考虑到了这个问题，并实现了 noConflict() 方法。 noConflict() 方法会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。 当然，您仍然可以通过全名替代简写的方式来使用 jQuery： $.noConflict(); jQuery(document).ready(function(){ jQuery(\"button\").click(function(){ jQuery(\"p\").text(\"jQuery 仍然在工作!\"); }); }); 您也可以创建自己的简写。noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用。请看这个例子： var jq = $.noConflict(); jq(document).ready(function(){ jq(\"button\").click(function(){ jq(\"p\").text(\"jQuery 仍然在工作!\"); }); }); 如果你的 jQuery 代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 \"jQuery\"： $.noConflict(); jQuery(document).ready(function($){ $(\"button\").click(function(){ $(\"p\").text(\"jQuery 仍然在工作!\"); }); }); HTML 获取内容和属性 获得内容： text()、html() 以及 val() 三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 $(\"#btn1\").click(function(){ alert(\"Text: \" + $(\"#test\").text()); }); $(\"#btn2\").click(function(){ alert(\"HTML: \" + $(\"#test\").html()); }); $(\"#btn1\").click(function(){ alert(\"值为: \" + $(\"#test\").val()); }); 获取属性 - attr()：用于获取属性值。 $(\"button\").click(function(){ alert($(\"#runoob\").attr(\"href\")); }); 设置内容和属性 设置内容： text()、html() 以及 val() 我们将使用前一章中的三个相同的方法来设置内容： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 $(\"#btn1\").click(function(){ $(\"#test1\").text(\"Hello world!\"); }); $(\"#btn2\").click(function(){ $(\"#test2\").html(\"Hello world!\"); }); $(\"#btn3\").click(function(){ $(\"#test3\").val(\"RUNOOB\"); }); text()、html() 以及 val() 的回调函数 上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 text() 和 html()： $(\"#btn1\").click(function(){ $(\"#test1\").text(function(i,origText){ return \"旧文本: \" + origText + \" 新文本: Hello world! (index: \" + i + \")\"; }); }); $(\"#btn2\").click(function(){ $(\"#test2\").html(function(i,origText){ return \"旧 html: \" + origText + \" 新 html: Hello world! (index: \" + i + \")\"; }); }); 设置属性 - attr()：用于设置/改变属性值。 $(\"button\").click(function(){ $(\"#runoob\").attr(\"href\",\"http://www.runoob.com/jquery\"); }); attr() 方法也允许您同时设置多个属性。 下面的例子演示如何同时设置 href 和 title 属性： $(\"button\").click(function(){ $(\"#runoob\").attr({ \"href\" : \"http://www.runoob.com/jquery\", \"title\" : \"jQuery 教程\" }); }); attr() 的回调函数 jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 attr() 方法： $(\"button\").click(function(){ $(\"#runoob\").attr(\"href\", function(i,origValue){ return origValue + \"/jquery\"; }); }); 添加元素 添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 append() 方法 jQuery append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。 $(\"p\").append(\"追加文本\"); prepend() 方法 jQuery prepend() 方法在被选元素的开头插入内容。 $(\"p\").prepend(\"在开头追加文本\"); 通过 append() 和 prepend() 方法添加若干新元素 在上面的例子中，我们只在被选元素的开头/结尾插入文本/HTML。 不过，append() 和 prepend() 方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。 在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() 方法把这些新元素追加到文本中（对 prepend() 同样有效）： function appendText() { var txt1=\"文本。\"; // 使用 HTML 标签创建文本 var txt2=$(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3=document.createElement(\"p\"); txt3.innerHTML=\"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"body\").append(txt1,txt2,txt3); // 追加新元素 } jQuery after() 和 before() 方法 $(\"img\").after(\"在后面添加文本\"); $(\"img\").before(\"在前面添加文本\"); 通过 after() 和 before() 方法添加若干新元素 after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。 在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）： function afterText() { var txt1=\"I \"; // 使用 HTML 创建元素 var txt2=$(\"\").text(\"love \"); // 使用 jQuery 创建元素 var txt3=document.createElement(\"big\"); // 使用 DOM 创建元素 txt3.innerHTML=\"jQuery!\"; $(\"img\").after(txt1,txt2,txt3); // 在图片后添加文本 } append/prepend和after/before有什么区别？ append s1 $(\"p\").append('s2'); 结果是这样的: s1 s2 after s1 $(\"p\").after('s2'); 结果是这样的: s1 s2 总结： append/prepend 是在选择元素内部嵌入。 after/before 是在元素外面追加。 删除元素 使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 jQuery remove() 方法：删除被选元素及其子元素。 $(\"#div1\").remove(); jQuery empty() 方法：删除被选元素的子元素。 $(\"#div1\").empty(); 过滤被删除的元素 jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=\"italic\" 的所有 元素： $(\"p\").remove(\".italic\"); CSS CSS类和方法 jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些： addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 实例样式表 .important { font-weight:bold; font-size:xx-large; } .blue { color:blue; } addClass() 方法 $(\"button\").click(function(){ $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important\"); }); // 或规定多个类： $(\"button\").click(function(){ $(\"body div:first\").addClass(\"important blue\"); }); removeClass() 方法 $(\"button\").click(function(){ $(\"h1,h2,p\").removeClass(\"blue\"); }); toggleClass() 方法 该方法对被选元素进行添加/删除类的切换操作： $(\"button\").click(function(){ $(\"h1,h2,p\").toggleClass(\"blue\"); }); css() 方法 设置或返回被选元素的一个或多个样式属性。 返回 CSS 属性 如需返回指定的 CSS 属性的值，请使用如下语法： css(\"propertyname\"); // 例 $(\"p\").css(\"background-color\"); 设置 CSS 属性 如需设置指定的 CSS 属性，请使用如下语法： css(\"propertyname\",\"value\"); // 例 $(\"p\").css(\"background-color\",\"yellow\"); 设置多个 CSS 属性 如需设置多个 CSS 属性，请使用如下语法： css({\"propertyname\":\"value\",\"propertyname\":\"value\",...}); // 例 $(\"p\").css({\"background-color\":\"yellow\",\"font-size\":\"200%\"}); CSS盒子模型(尺寸) jQuery 提供多个处理尺寸的重要方法： width() height() innerWidth() innerHeight() outerWidth() outerHeight() jQuery尺寸 width() 和 height() 方法 width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 的宽度是: \" + $(\"#div1\").width() + \"\"; txt+=\"div 的高度是: \" + $(\"#div1\").height(); $(\"#div1\").html(txt); }); innerWidth() 和 innerHeight() 方法 innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 宽度，包含内边距: \" + $(\"#div1\").innerWidth() + \"\"; txt+=\"div 高度，包含内边距: \" + $(\"#div1\").innerHeight(); $(\"#div1\").html(txt); }); outerWidth() 和 outerHeight() 方法 outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 宽度，包含内边距和边框: \" + $(\"#div1\").outerWidth() + \"\"; txt+=\"div 高度，包含内边距和边框: \" + $(\"#div1\").outerHeight(); $(\"#div1\").html(txt); }); 效果 隐藏和显示 hide() 和 show() 使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： $(\"#hide\").click(function(){ $(\"p\").hide(); }); $(\"#show\").click(function(){ $(\"p\").show(); }); 语法: $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 对于可选的 callback 参数，有以下两点说明： 1.$(selector)选中的元素的个数为n个，则callback函数会执行n次；当 callback 函数加上括号时，函数立即执行，只会调用一次， 如果不加括号，元素显示或隐藏后调用函数，才会调用多次。 2.callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行； 3.callback既可以是函数名，也可以是匿名函数； 下面的例子演示了带有 speed 参数的 hide() 方法： $(\"button\").click(function(){ $(\"p\").hide(1000); }); 下面的例子演示了带有 speed 参数的 hide() 方法，并使用回调函数： $(document).ready(function(){ $(\".hidebtn\").click(function(){ $(\"div\").hide(1000,\"linear\",function(){ alert(\"Hide() 方法已完成!\"); }); }); }); 第二个参数是一个字符串，表示过渡使用哪种缓动函数。（译者注：jQuery自身提供\"linear\" 和 \"swing\"，其他可以使用相关的插件）。 toggle() 使用 toggle() 方法来切换 hide() 和 show() 方法。显示被隐藏的元素，并隐藏已显示的元素： $(\"button\").click(function(){ $(\"p\").toggle(); }); 语法: $(selector).toggle(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 淡入淡出 jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() fadeIn() 方法：用于淡入已隐藏的元素。 语法: $(selector).fadeIn(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。. 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeIn() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000); }); fadeOut() 方法：用于淡出可见元素。 语法: $(selector).fadeOut(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeOut() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000); }); fadeToggle() 方法： jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。 如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 语法: $(selector).fadeToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeToggle() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000); }); fadeTo() 方法 jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。 语法: 必需的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。 可选的 callback 参数是该函数完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeTo() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeTo(\"slow\",0.15); $(\"#div2\").fadeTo(\"slow\",0.4); $(\"#div3\").fadeTo(\"slow\",0.7); }); 滑动 jQuery 拥有以下滑动方法： slideDown() slideUp() slideToggle() slideDown() 方法 jQuery slideDown() 方法用于向下滑动元素。 语法: $(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideDown() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideDown(); }); slideUp() 方法 jQuery slideUp() 方法用于向上滑动元素。 语法: $(selector).slideUp(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideUp() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideUp(); }); slideToggle() 方法 jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。 如果元素向下滑动，则 slideToggle() 可向上滑动它们。 如果元素向上滑动，则 slideToggle() 可向下滑动它们。 $(selector).slideToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideToggle() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideToggle(); }); 动画 animate() 方法 用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 下面的例子演示 animate() 方法的简单应用。它把 元素往右边移动了 250 像素： $(\"button\").click(function(){ $(\"div\").animate({left:'250px'}); }); 默认情况下，所有 HTML 元素都有一个静态位置，且无法移动。 如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！ 操作多个属性 生成动画的过程中可同时使用多个属性： 实例 $(\"button\").click(function(){ $(\"div\").animate({ left:'250px', opacity:'0.5', height:'150px', width:'150px' }); }); 使用相对值 也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=： $(\"button\").click(function(){ $(\"div\").animate({ left:'250px', height:'+=150px', width:'+=150px' }); }); 使用预定义的值 甚至可以把属性的动画值设置为 \"show\"、\"hide\" 或 \"toggle\"： $(\"button\").click(function(){ $(\"div\").animate({ height:'toggle' }); }); 使用队列功能 默认地，jQuery 提供针对动画的队列功能。 这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的\"内部\"队列。然后逐一运行这些 animate 调用。 $(\"button\").click(function(){ var div=$(\"div\"); div.animate({height:'300px',opacity:'0.4'},\"slow\"); div.animate({width:'300px',opacity:'0.8'},\"slow\"); div.animate({height:'100px',opacity:'0.4'},\"slow\"); div.animate({width:'100px',opacity:'0.8'},\"slow\"); }); // 下面的例子把 元素往右边移动了 100 像素，然后增加文本的字号： $(\"button\").click(function(){ var div=$(\"div\"); div.animate({left:'100px'},\"slow\"); div.animate({fontSize:'3em'},\"slow\"); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jquery.com 下载 颜色动画 插件。 停止动画 stop() 方法 用于停止动画或效果，在它们完成之前。 stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法: $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 下面的例子演示 stop() 方法，不带参数： $(\"#stop\").click(function(){ $(\"#panel\").stop(); }); 动画队列停止动画测试，只停止当前正在进行的动画，停止当前动画后，队列中的下一个动画开始进行： $(document).ready(function(){ $(\"#flip\").click(function(){ $(\"#panel\").slideDown(5000); $(\"#panel\").slideUp(5000); }); $(\"#stop\").click(function(){ $(\"#panel\").stop(); }); }); 可以在 stop() 中设置 stopAll 的参数为 true，这样就可以停止所有动画效果而不是只停止当前动画： $(document).ready(function(){ $(\"#flip\").click(function(){ $(\"#panel\").slideDown(5000); $(\"#panel\").slideUp(5000); }); $(\"#stop\").click(function(){ $(\"#panel\").stop(true); }); }); Callback(回调) 方法 Callback 函数在当前动画 100% 完成之后执行。 jQuery 动画的问题 许多 jQuery 函数涉及动画。这些函数也许会将 speed 或 duration 作为可选参数。 例子：$(\"p\").hide(\"slow\") speed 或 duration 参数可以设置许多不同的值，比如 \"slow\", \"fast\", \"normal\" 或毫秒。 实例 以下实例在隐藏效果完全实现后回调函数: $(\"button\").click(function(){ $(\"p\").hide(\"slow\",function(){ alert(\"段落现在被隐藏了\"); }); }); 以下实例没有回调函数，警告框会在隐藏效果完成前弹出： $(\"button\").click(function(){ $(\"p\").hide(1000); alert(\"段落现在被隐藏了\"); }); 被立即停止的动画不会触发回调，被立即完成的动画会触发回调。 $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(3000,function(){ alert(\"段落现在被隐藏了\"); }); }); $(\"#happy\").click(function(){ $(\"p\").stop(false,true); }); }); 如果动画有队列的话，想实现其快速完成所有动画并停止，就要相应的与队列数对应条数的停止语句。 $(document).ready(function(){ $(\"#start\").click(function(){ $(\"div\").animate({left:'300px'},5000); $(\"div\").animate({fontSize:'3em'},5000); }); $(\"#stop1\").click(function(){ $(\"div\").stop(); }); $(\"#stop2\").click(function(){ $(\"div\").stop(true); }); $(\"#stop3\").click(function(){ $(\"div\").stop(false,true); $(\"div\").stop(false,true); }); }); 链(Chaining) 通过 jQuery，可以把动作/方法链接在一起。 Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）。 直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。 不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。 提示： 这样的话，浏览器就不必多次查找相同的元素。 如需链接一个动作，您只需简单地把该动作追加到之前的动作上。 下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。\"p1\" 元素首先会变为红色，然后向上滑动，再然后向下滑动： $(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000); 如果需要，我们也可以添加多个方法调用。 提示：当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。 如下书写也可以很好地运行： $(\"#p1\").css(\"color\",\"red\") .slideUp(2000) .slideDown(2000); jQuery - AJAX 简介 AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。 什么是 AJAX？ AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。 您可以在 jQuery Ajax 参考手册学会 jQuery Ajax 的具体应用。 您可以在菜鸟教程中的 AJAX 教程中学到更多有关 AJAX 的知识。 关于 jQuery 与 AJAX jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 如果没有 jQuery，AJAX 编程还是有些难度的。 编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着您必须编写额外的代码对浏览器进行测试。不过，jQuery 团队为我们解决了这个难题，我们只需要一行简单的代码，就可以实现 AJAX 功能。 AJAX load() 方法 jQuery load() 方法 jQuery load() 方法是简单但强大的 AJAX 方法。 load() 方法从服务器加载数据，并把返回的数据放入被选元素中。 语法: $(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是 load() 方法完成后所执行的函数名称。 这是示例文件（\"demo_test.txt\"）的内容： jQuery AJAX 是个非常棒的功能！ 这是段落的一些文本。 下面的例子会把文件 \"demo_test.txt\" 的内容加载到指定的 元素中： $(\"#div1\").load(\"demo_test.txt\"); 也可以把 jQuery 选择器添加到 URL 参数。 下面的例子把 \"demo_test.txt\" 文件中 id=\"p1\" 的元素的内容，加载到指定的 元素中： 实例 $(\"#div1\").load(\"demo_test.txt #p1\"); 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示\"外部内容加载成功！\"，而如果失败，则显示错误消息： $(\"button\").click(function(){ $(\"#div1\").load(\"demo_test.txt\",function(responseTxt,statusTxt,xhr){ if(statusTxt==\"success\") alert(\"外部内容加载成功!\"); if(statusTxt==\"error\") alert(\"Error: \"+xhr.status+\": \"+xhr.statusText); }); }); 为了避免多页面情形下的代码重复，可以利用 load() 方法，将重复的部分（例如导航栏）放入单独的文件，使用下列方法进行导入： //1.当前文件中要插入的地方使用此结构： //2.***.html中放入内容，用html格式仅仅因为会有编辑器的书写辅助。。 //3.代码： $(\".include\").each(function() { if (!!$(this).attr(\"file\")) { var $includeObj = $(this); $(this).load($(this).attr(\"file\"), function(html) { $includeObj.after(html).remove(); //加载的文件内容写入到当前标签后面并移除当前标签 }) } }); 或者在index文件里只写重复部分，剩下的一股脑放各自单独文件 load() 进来~ AJAX get() 和 post() 方法 jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 HTTP 请求：GET vs. POST 两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。 GET - 从指定的资源请求数据 POST - 向指定的资源提交要处理的数据 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 $.get() 方法 通过 HTTP GET 请求从服务器上请求数据。 语法： $.get(URL,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据： $(\"button\").click(function(){ $.get(\"demo_test.php\",function(data,status){ alert(\"数据: \" + data + \"\\n状态: \" + status); }); }); $.get() 的第一个参数是我们希望请求的 URL（\"demo_test.php\"）。 第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 $.post() 方法 通过 HTTP POST 请求向服务器提交数据。 语法: $.post(URL,data,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 data 参数规定连同请求发送的数据。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.post() 连同请求一起发送数据： $(\"button\").click(function(){ $.post(\"/try/ajax/demo_test_post.php\", { name:\"菜鸟教程\", url:\"http://www.runoob.com\" }, function(data,status){ alert(\"数据: \\n\" + data + \"\\n状态: \" + status); }); }); $.post() 的第一个参数是我们希望请求的 URL (\"demo_test_post.php\")。 然后我们连同请求（name 和 url）一起发送数据。 \"demo_test_post.php\" 中的 PHP 脚本读取这些参数，对它们进行处理，然后返回结果。 第三个参数是回调函数。第一个回调参数存有被请求页面的内容，而第二个参数存有请求的状态。 遍历 祖先 这些 jQuery 方法很有用，它们用于向上遍历 DOM 树： parent() parents() parentsUntil() parent() 方法 parent() 方法返回被选元素的直接父元素。 该方法只会向上一级对 DOM 树进行遍历。 下面的例子返回每个 元素的的直接父元素： $(document).ready(function(){ $(\"span\").parent(); }); parents() 方法 parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。 下面的例子返回所有 元素的所有祖先： $(document).ready(function(){ $(\"span\").parents(); }); 您也可以使用可选参数来过滤对祖先元素的搜索。 下面的例子返回所有 元素的所有祖先，并且它是 元素： $(document).ready(function(){ $(\"span\").parents(\"ul\"); }); parentsUntil() 方法 parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 下面的例子返回介于 与 ` 元素之间的所有祖先元素： $(document).ready(function(){ $(\"span\").parentsUntil(\"div\"); }); 后代 下面是两个用于向下遍历 DOM 树的 jQuery 方法： children() find() children() 方法 children() 方法返回被选元素的所有直接子元素。 该方法只会向下一级对 DOM 树进行遍历。 下面的例子返回每个 元素的所有直接子元素： $(document).ready(function(){ $(\"div\").children(); }); 您也可以使用可选参数来过滤对子元素的搜索。 下面的例子返回类名为 \"1\" 的所有 元素，并且它们是 的直接子元素： $(document).ready(function(){ $(\"div\").children(\"p.1\"); }); find() 方法 find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。 下面的例子返回属于 后代的所有 元素： $(document).ready(function(){ $(\"div\").find(\"span\"); }); 下面的例子返回 的所有后代： $(document).ready(function(){ $(\"div\").find(\"*\"); }); 同胞(siblings) 有许多有用的方法让我们在 DOM 树进行水平遍历： siblings() next() nextAll() nextUntil() prev() prevAll() prevUntil() siblings() 方法 siblings() 方法返回被选元素的所有同胞元素。 下面的例子返回 h2> 的所有同胞元素： $(document).ready(function(){ $(\"h2\").siblings(); }); 您也可以使用可选参数来过滤对同胞元素的搜索。 下面的例子返回属于 的同胞元素的所有 元素： $(document).ready(function(){ $(\"h2\").siblings(\"p\"); }); next() 方法 next() 方法返回被选元素的下一个同胞元素。 该方法只返回一个元素。 下面的例子返回 的下一个同胞元素： $(document).ready(function(){ $(\"h2\").next(); }); nextAll() 方法 nextAll() 方法返回被选元素的所有跟随的同胞元素。 下面的例子返回 的所有跟随的同胞元素： $(document).ready(function(){ $(\"h2\").nextAll(); }); nextUntil() 方法 nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。 下面的例子返回介于 与 元素之间的所有同胞元素： $(document).ready(function(){ $(\"h2\").nextUntil(\"h6\"); }); prev(), prevAll() & prevUntil() 方法 prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。 过滤 缩小搜索元素的范围 三个最基本的过滤方法是：first(), last() 和 eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。 其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。 first() 方法 first() 方法返回被选元素的首个元素。 下面的例子选取首个 元素内部的第一个 元素： $(document).ready(function(){ $(\"div p\").first(); }); last() 方法 last() 方法返回被选元素的最后一个元素。 下面的例子选择最后一个 元素中的最后一个 元素： $(document).ready(function(){ $(\"div p\").last(); }); eq() 方法 eq() 方法返回被选元素中带有指定索引号的元素。 索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。下面的例子选取第二个 元素（索引号 1）： $(document).ready(function(){ $(\"p\").eq(1); }); filter() 方法 filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 下面的例子返回带有类名 \"url\" 的所有 元素： $(document).ready(function(){ $(\"p\").filter(\".url\"); }); not() 方法 not() 方法返回不匹配标准的所有元素。 提示：not() 方法与 filter() 相反。 下面的例子返回不带有类名 \"url\" 的所有 元素： $(document).ready(function(){ $(\"p\").not(\".url\"); }); "},"Web/JavaScript/框架/jQuery方法大全.html":{"url":"Web/JavaScript/框架/jQuery方法大全.html","title":"JQuery方法大全","keywords":"","body":"datetime:2019/7/10 15:29 author:nzb 选择器 选择器 实例 选取 * $(\"*\") 所有元素 #id $(\"#lastname\") id=\"lastname\" 的元素 .class $(\".intro\") class=\"intro\" 的所有元素 .class,.class $(\".intro,.demo\") class 为 \"intro\" 或 \"demo\" 的所有元素 element $(\"p\") 所有 元素 el1,el2,el3 $(\"h1,div,p\") 所有 、 和 元素 :first $(\"p:first\") 第一个 元素 :last $(\"p:last\") 最后一个 元素 :even $(\"tr:even\") 所有偶数 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :odd $(\"tr:odd\") 所有奇数 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :first-child $(\"p:first-child\") 属于其父元素的第一个子元素的所有 元素 :first-of-type $(\"p:first-of-type\") 属于其父元素的第一个 元素的所有 元素 :last-child $(\"p:last-child\") 属于其父元素的最后一个子元素的所有 元素 :last-of-type $(\"p:last-of-type\") 属于其父元素的最后一个 元素的所有 元素 :nth-child(n) $(\"p:nth-child(2)\") 属于其父元素的第二个子元素的所有 元素 :nth-last-child(n) $(\"p:nth-last-child(2)\") 属于其父元素的第二个子元素的所有 元素，从最后一个子元素开始计数 :nth-of-type(n) $(\"p:nth-of-type(2)\") 属于其父元素的第二个 元素的所有 元素 :nth-last-of-type(n) $(\"p:nth-last-of-type(2)\") 属于其父元素的第二个 元素的所有 元素，从最后一个子元素开始计数 :only-child $(\"p:only-child\") 属于其父元素的唯一子元素的所有 元素 :only-of-type $(\"p:only-of-type\") 属于其父元素的特定类型的唯一子元素的所有 元素 parent > child $(\"div > p\") 元素的直接子元素的所有 元素 parent descendant $(\"div p\") 元素的后代的所有 元素 element + next $(\"div + p\") 每个 元素相邻的下一个 元素 element ~ siblings $(\"div ~ p\") 元素同级的所有 元素 :eq(index) $(\"ul li:eq(3)\") 列表中的第四个元素（index 值从 0 开始） :gt(no) $(\"ul li:gt(3)\") 列举 index 大于 3 的元素 :lt(no) $(\"ul li:lt(3)\") 列举 index 小于 3 的元素 :not(selector) $(\"input:not(:empty)\") 所有不为空的输入元素 :header $(\":header\") 所有标题元素 , ... :animated $(\":animated\") 所有动画元素 :focus $(\":focus\") 当前具有焦点的元素 :contains(text) $(\":contains('Hello')\") 所有包含文本 \"Hello\" 的元素 :has(selector) $(\"div:has(p)\") 所有包含有 元素在其内的 元素 :empty $(\":empty\") 所有空元素 :parent $(\":parent\") 匹配所有含有子元素或者文本的父元素。 :hidden $(\"p:hidden\") 所有隐藏的 元素 :visible $(\"table:visible\") 所有可见的表格 :root $(\":root\") 文档的根元素 :lang(language) $(\"p:lang(de)\") 所有 lang 属性值为 \"de\" 的 元素 [attribute] $(\"[href]\") 所有带有 href 属性的元素 [attribute=value] $(\"[href='default.htm']\") 所有带有 href 属性且值等于 \"default.htm\" 的元素 [attribute!=value] $(\"[href!='default.htm']\") 所有带有 href 属性且值不等于 \"default.htm\" 的元素 [attribute$=value] $(\"[href$='.jpg']\") 所有带有 href 属性且值以 \".jpg\" 结尾的元素 [attribute|=value] $(\"[title|='Tomorrow']\") 所有带有 title 属性且值等于 'Tomorrow' 或者以 'Tomorrow' 后跟连接符作为开头的字符串 [attribute^=value] $(\"[title^='Tom']\") 所有带有 title 属性且值以 \"Tom\" 开头的元素 [attribute~=value] $(\"[title~='hello']\") 所有带有 title 属性且值包含单词 \"hello\" 的元素 [attribute*=value] $(\"[title*='hello']\") 所有带有 title 属性且值包含字符串 \"hello\" 的元素 [name=value]、[name2=value2] $(\"input[id][name$='man']\") 带有 id 属性，并且 name 属性以 man 结尾的输入框 :input $(\":input\") 所有 input 元素 :text $(\":text\") 所有带有 type=\"text\" 的 input 元素 :password $(\":password\") 所有带有 type=\"password\" 的 input 元素 :radio $(\":radio\") 所有带有 type=\"radio\" 的 input 元素 :checkbox $(\":checkbox\") 所有带有 type=\"checkbox\" 的 input 元素 :submit $(\":submit\") 所有带有 type=\"submit\" 的 input 元素 :reset $(\":reset\") 所有带有 type=\"reset\" 的 input 元素 :button $(\":button\") 所有带有 type=\"button\" 的 input 元素 :image $(\":image\") 所有带有 type=\"image\" 的 input 元素 :file $(\":file\") 所有带有 type=\"file\" 的 input 元素 :enabled $(\":enabled\") 所有启用的元素 :disabled $(\":disabled\") 所有禁用的元素 :selected $(\":selected\") 所有选定的下拉列表元素 :checked $(\":checked\") 所有选中的复选框选项 .selector $(selector).selector 在jQuery 1.7中已经不被赞成使用。返回传给jQuery()的原始选择器 :target $( \"p:target\" ) 选择器将选中ID和URI中一个格式化的标识符相匹配的元素 jQuery 事件方法 方法 描述 bind() 向元素添加事件处理程序 blur() 添加/触发失去焦点事件 change() 添加/触发 change 事件 click() 添加/触发 click 事件 dblclick() 添加/触发 double click 事件 delegate() 向匹配元素的当前或未来的子元素添加处理程序 die() 在版本 1.9 中被移除。移除所有通过 live() 方法添加的事件处理程序 error() 在版本 1.8 中被废弃。添加/触发 error 事件 event.currentTarget 在事件冒泡阶段内的当前 DOM 元素 event.data 包含当前执行的处理程序被绑定时传递到事件方法的可选数据 event.delegateTarget 返回当前调用的 jQuery 事件处理程序所添加的元素 event.isDefaultPrevented() 返回指定的 event 对象上是否调用了 event.preventDefault() event.isImmediatePropagationStopped() 返回指定的 event 对象上是否调用了 event.stopImmediatePropagation() event.isPropagationStopped() 返回指定的 event 对象上是否调用了 event.stopPropagation() event.namespace 返回当事件被触发时指定的命名空间 event.pageX 返回相对于文档左边缘的鼠标位置 event.pageY 返回相对于文档上边缘的鼠标位置 event.preventDefault() 阻止事件的默认行为 event.relatedTarget 返回当鼠标移动时哪个元素进入或退出 event.result 包含由被指定事件触发的事件处理程序返回的最后一个值 event.stopImmediatePropagation() 阻止其他事件处理程序被调用 event.stopPropagation() 阻止事件向上冒泡到 DOM 树，阻止任何父处理程序被事件通知 event.target 返回哪个 DOM 元素触发事件 event.timeStamp 返回从 1970 年 1 月 1 日到事件被触发时的毫秒数 event.type 返回哪种事件类型被触发 event.which 返回指定事件上哪个键盘键或鼠标按钮被按下 event.metaKey 事件触发时 META 键是否被按下 focus() 添加/触发 focus 事件 focusin() 添加事件处理程序到 focusin 事件 focusout() 添加事件处理程序到 focusout 事件 hover() 添加两个事件处理程序到 hover 事件 keydown() 添加/触发 keydown 事件 keypress() 添加/触发 keypress 事件 keyup() 添加/触发 keyup 事件 live() 在版本 1.9 中被移除。添加一个或多个事件处理程序到当前或未来的被选元素 load() 在版本 1.8 中被废弃。添加一个事件处理程序到 load 事件 mousedown() 添加/触发 mousedown 事件 mouseenter() 添加/触发 mouseenter 事件 mouseleave() 添加/触发 mouseleave 事件 mousemove() 添加/触发 mousemove 事件 mouseout() 添加/触发 mouseout 事件 mouseover() 添加/触发 mouseover 事件 mouseup() 添加/触发 mouseup 事件 off() 移除通过 on() 方法添加的事件处理程序 on() 向元素添加事件处理程序 one() 向被选元素添加一个或多个事件处理程序。该处理程序只能被每个元素触发一次 $.proxy() 接受一个已有的函数，并返回一个带特定上下文的新的函数 ready() 规定当 DOM 完全加载时要执行的函数 resize() 添加/触发 resize 事件 scroll() 添加/触发 scroll 事件 select() 添加/触发 select 事件 submit() 添加/触发 submit 事件 toggle() 在版本 1.9 中被移除。添加 click 事件之间要切换的两个或多个函数 trigger() 触发绑定到被选元素的所有事件 triggerHandler() 触发绑定到被选元素的指定事件上的所有函数 unbind() 从被选元素上移除添加的事件处理程序 undelegate() 从现在或未来的被选元素上移除事件处理程序 unload() 在版本 1.8 中被废弃。添加事件处理程序到 unload 事件 contextmenu() 添加事件处理程序到 contextmenu 事件 $.holdReady() 用于暂停或恢复.ready() 事件的执行 jQuery 效果方法 方法 描述 animate() 对被选元素应用\"自定义\"的动画 clearQueue() 对被选元素移除所有排队函数（仍未运行的） delay() 对被选元素的所有排队函数（仍未运行）设置延迟 dequeue() 移除下一个排队函数，然后执行函数 fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见 fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏 fadeTo() 把被选元素逐渐改变至给定的不透明度 fadeToggle() 在 fadeIn() 和 fadeOut() 方法之间进行切换 finish() 对被选元素停止、移除并完成所有排队动画 hide() 隐藏被选元素 queue() 显示被选元素的排队函数 show() 显示被选元素 slideDown() 通过调整高度来滑动显示被选元素 slideToggle() slideUp() 和 slideDown() 方法之间的切换 slideUp() 通过调整高度来滑动隐藏被选元素 stop() 停止被选元素上当前正在运行的动画 toggle() hide() 和 show() 方法之间的切换 jQuery HTML / CSS 方法 方法 描述 addClass() 向被选元素添加一个或多个类名 after() 在被选元素后插入内容 append() 在被选元素的结尾插入内容 appendTo() 在被选元素的结尾插入 HTML 元素 attr() 设置或返回被选元素的属性/值 before() 在被选元素前插入内容 clone() 生成被选元素的副本 css() 为被选元素设置或返回一个或多个样式属性 detach() 移除被选元素（保留数据和事件） empty() 从被选元素移除所有子节点和内容 hasClass() 检查被选元素是否包含指定的 class 名称 height() 设置或返回被选元素的高度 html() 设置或返回被选元素的内容 innerHeight() 返回元素的高度（包含 padding，不包含 border） innerWidth() 返回元素的宽度（包含 padding，不包含 border） insertAfter() 在被选元素后插入 HTML 元素 insertBefore() 在被选元素前插入 HTML 元素 offset() 设置或返回被选元素的偏移坐标（相对于文档） offsetParent() 返回第一个定位的祖先元素 outerHeight() 返回元素的高度（包含 padding 和 border） outerWidth() 返回元素的宽度（包含 padding 和 border） position() 返回元素的位置（相对于父元素） prepend() 在被选元素的开头插入内容 prependTo() 在被选元素的开头插入 HTML 元素 prop() 设置或返回被选元素的属性/值 remove() 移除被选元素（包含数据和事件） removeAttr() 从被选元素移除一个或多个属性 removeClass() 从被选元素移除一个或多个类 removeProp() 移除通过 prop() 方法设置的属性 replaceAll() 把被选元素替换为新的 HTML 元素 replaceWith() 把被选元素替换为新的内容 scrollLeft() 设置或返回被选元素的水平滚动条位置 scrollTop() 设置或返回被选元素的垂直滚动条位置 text() 设置或返回被选元素的文本内容 toggleClass() 在被选元素中添加/移除一个或多个类之间切换 unwrap() 移除被选元素的父元素 val() 设置或返回被选元素的属性值（针对表单元素） width() 设置或返回被选元素的宽度 wrap() 在每个被选元素的周围用 HTML 元素包裹起来 wrapAll() 在所有被选元素的周围用 HTML 元素包裹起来 wrapInner() 在每个被选元素的内容周围用 HTML 元素包裹起来 $.escapeSelector() 转义CSS选择器中有特殊意义的字符或字符串 $.cssHooks 提供了一种方法通过定义函数来获取和设置特定的CSS值 jQuery 遍历方法 方法 描述 add() 把元素添加到匹配元素的集合中 addBack() 把之前的元素集添加到当前集合中 andSelf() 在版本 1.8 中被废弃。addBack() 的别名 children() 返回被选元素的所有直接子元素 closest() 返回被选元素的第一个祖先元素 contents() 返回被选元素的所有直接子元素（包含文本和注释节点） each() 为每个匹配元素执行函数 end() 结束当前链中最近的一次筛选操作，并把匹配元素集合返回到前一次的状态 eq() 返回带有被选元素的指定索引号的元素 filter() 把匹配元素集合缩减为匹配选择器或匹配函数返回值的新元素 find() 返回被选元素的后代元素 first() 返回被选元素的第一个元素 has() 返回拥有一个或多个元素在其内的所有元素 is() 根据选择器/元素/jQuery 对象检查匹配元素集合，如果存在至少一个匹配元素，则返回 true last() 返回被选元素的最后一个元素 map() 把当前匹配集合中的每个元素传递给函数，产生包含返回值的新 jQuery 对象 next() 返回被选元素的后一个同级元素 nextAll() 返回被选元素之后的所有同级元素 nextUntil() 返回介于两个给定参数之间的每个元素之后的所有同级元素 not() 从匹配元素集合中移除元素 offsetParent() 返回第一个定位的父元素 parent() 返回被选元素的直接父元素 parents() 返回被选元素的所有祖先元素 parentsUntil() 返回介于两个给定参数之间的所有祖先元素 prev() 返回被选元素的前一个同级元素 prevAll() 返回被选元素之前的所有同级元素 prevUntil() 返回介于两个给定参数之间的每个元素之前的所有同级元素 siblings() 返回被选元素的所有同级元素 slice() 把匹配元素集合缩减为指定范围的子集 jQuery AJAX 方法 方法 描述 $.ajax() 执行异步 AJAX 请求 $.ajaxPrefilter() 在每个请求发送之前且被 $.ajax() 处理之前，处理自定义 Ajax 选项或修改已存在选项 $.ajaxSetup() 为将来的 AJAX 请求设置默认值 $.ajaxTransport() 创建处理 Ajax 数据实际传送的对象 $.get() 使用 AJAX 的 HTTP GET 请求从服务器加载数据 $.getJSON() 使用 HTTP GET 请求从服务器加载 JSON 编码的数据 $.getScript() 使用 AJAX 的 HTTP GET 请求从服务器加载并执行 JavaScript $.param() 创建数组或对象的序列化表示形式（可用于 AJAX 请求的 URL 查询字符串） $.post() 使用 AJAX 的 HTTP POST 请求从服务器加载数据 ajaxComplete() 规定 AJAX 请求完成时运行的函数 ajaxError() 规定 AJAX 请求失败时运行的函数 ajaxSend() 规定 AJAX 请求发送之前运行的函数 ajaxStart() 规定第一个 AJAX 请求开始时运行的函数 ajaxStop() 规定所有的 AJAX 请求完成时运行的函数 ajaxSuccess() 规定 AJAX 请求成功完成时运行的函数 load() 从服务器加载数据，并把返回的数据放置到指定的元素中 serialize() 编码表单元素集为字符串以便提交 serializeArray() 编码表单元素集为 names 和 values 的数组 jQuery 杂项方法 jQuery 杂项方法 方法 描述 data() 向被选元素附加数据，或者从被选元素获取数据 each() 为每个匹配元素执行函数 get() 获取由选择器指定的 DOM 元素 index() 从匹配元素中搜索给定元素 $.noConflict() 释放变量 $ 的 jQuery 控制权 $.param() 创建数组或对象的序列化表示形式（可在生成 AJAX 请求时用于 URL 查询字符串中） removeData() 移除之前存放的数据 size() 在版本 1.8 中被废弃。返回被 jQuery 选择器匹配的 DOM 元素的数量 toArray() 以数组的形式检索所有包含在 jQuery 集合中的所有 DOM 元素 pushStack() 将一个DOM元素集合加入到jQuery栈 $.when() 提供一种方法来执行一个或多个对象的回调函数 jQuery 实用工具 方法 描述 $.boxModel 在版本 1.8 中被废弃。检测浏览器是否使用W3C的CSS盒模型渲染当前页面 $.browser 在版本 1.9 中被废弃。返回用户当前使用的浏览器的相关信息 $.contains() 判断另一个DOM元素是否是指定DOM元素的后代 $.each() 遍历指定的对象和数组 $.extend() 将一个或多个对象的内容合并到目标对象 $.fn.extend() 为jQuery扩展一个或多个实例属性和方法 $.globalEval() 全局性地执行一段JavaScript代码 $.grep() 过滤并返回满足指定函数的数组元素 $.inArray() 在数组中查找指定值并返回它的索引值（如果没有找到，则返回-1） $.isArray() 判断指定参数是否是一个数组 $.isEmptyObject() 检查对象是否为空（不包含任何属性） $.isFunction() 判断指定参数是否是一个函数 $.isNumeric() 判断指定参数是否是一个数字值 $.isPlainObject() 判断指定参数是否是一个纯粹的对象 $.isWindow() 判断指定参数是否是一个窗口 $.isXMLDoc() 判断一个DOM节点是否位于XML文档中，或者其本身就是XML文档 $.makeArray() 将一个类似数组的对象转换为真正的数组对象 $.map() 指定函数处理数组中的每个元素(或对象的每个属性)，并将处理结果封装为新的数组返回 $.merge() 合并两个数组内容到第一个数组 $.noop() 一个空函数 $.now() 返回当前时间 $.parseHTML() 将HTML字符串解析为对应的DOM节点数组 $.parseJSON() 将符合标准格式的JSON字符串转为与之对应的JavaScript对象 $.parseXML() 将字符串解析为对应的XML文档 $.trim() 去除字符串两端的空白字符 $.type() 确定JavaScript内置对象的类型 $.unique() 在jQuery 3.0中被弃用。对DOM元素数组进行排序，并移除重复的元素 $.uniqueSort() 对DOM元素数组进行排序，并移除重复的元素 $.data() 在指定的元素上存取数据，并返回设置值 $.hasData() 确定一个元素是否有相关的jQuery数据 $.sub() 创建一个新的jQuery副本，其属性和方法可以修改，而不会影响原来的jQuery对象 $.speed 创建一个包含一组属性的对象用来定义自定义动画 $.htmlPrefilter() 通过jQuery操作方法修改和过滤HTML字符串 $.readyException() 处理包裹在jQuery()中函数同步抛出的错误 jQuery 回调对象 方法 描述 $.Callbacks() 一个多用途的回调列表对象，用来管理回调函数列表 callbacks.add() 在回调列表中添加一个回调或回调的集合 callbacks.disable() 禁用回调列表中的回调函数 callbacks.disabled() 确定回调列表是否已被禁用 callbacks.empty() 从列表中清空所有的回调 callbacks.fire() 传入指定的参数调用所有的回调 callbacks.fired() 确定回调是否至少已经调用一次 callbacks.firewith() 给定的上下文和参数访问列表中的所有回调 callbacks.has() 判断回调列表中是否添加过某回调函数 callbacks.lock() 锁定当前状态的回调列表 callbacks.locked() 判断回调列表是否被锁定 callbacks.remove() 从回调列表中的删除一个回调或回调集合 jQuery 延迟对象 方法 描述 $.Deferred() 返回一个链式实用对象方法来注册多个回调 deferred.always() 当Deferred（延迟）对象被受理或被拒绝时，调用添加的处理程序 deferred.done() 当Deferred（延迟）对象被受理时，调用添加的处理程序 deferred.fail() 当Deferred（延迟）对象被拒绝时，调用添加的处理程序 deferred.isRejected() 从jQuery1.7开始已经过时，确定 Deferred 对象是否已被拒绝 deferred.isResolved() 从jQuery1.7开始已经过时，确定 Deferred 对象是否已被解决 deferred.notify() 给定一个参数，调用正在延迟对象上进行的回调函数( progressCallbacks ) deferred.notifyWith() 给定上下文和参数，调用正在延迟对象上进行的回调函数( progressCallbacks ) deferred.pipe() 过滤 and/or 链式延迟对象的工具方法 deferred.progress() 当Deferred（延迟）对象生成进度通知时，调用添加处理程序 deferred.promise() 返回 Deferred(延迟)的 Promise 对象 deferred.reject() 拒绝 Deferred（延迟）对象，并根据给定的参数调用任何 failCallbacks 回调函数 deferred.rejectWith() 拒绝 Deferred（延迟）对象，并根据给定的 context 和 args 参数调用任何 failCallbacks 回调函数 deferred.resolve() 解决Deferred（延迟）对象，并根据给定的参数调用任何 doneCallbacks 回调函数 deferred.resolveWith() 解决Deferred（延迟）对象，并根据给定的context 和 args 参数调用任何 doneCallbacks 回调函数 deferred.state() 确定一个Deferred（延迟）对象的当前状态 deferred.then() 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序 .promise() 返回一个 Promise 对象，观察某种类型被绑定到集合的所有行动，是否已被加入到队列中 jQuery 属性 方法 描述 context 在版本 1.10 中被废弃。包含被传递到 jQuery 的原始上下文 jquery 包含 jQuery 的版本号 jQuery.fx.interval 改变以毫秒计的动画运行速率 jQuery.fx.off 对所有动画进行全局禁用或启用 jQuery.support 包含表示不同浏览器特性或漏洞的属性集（主要用于 jQuery 的内部使用） length 包含 jQuery 对象中元素的数目 jQuery.cssNumber 包含所有可以不使用单位的CSS属性的对象 "},"Web/RESTful.html":{"url":"Web/RESTful.html","title":"RESTful规范","keywords":"","body":"restful api设计（规范，建议） 1、API与用户的通信协议，总是使用HTTPs协议（推荐使用）。 2、域名 --https://api.example.com 尽量将API部署在专用域名（会存在跨域问题） --https://example.org/api/ API很简单 3、版本 --URL，如：https://api.example.com/v1/、https://example.org/api/v1/ --请求头 跨域时，引发发送多次请求 4、路径，视网络上任何东西都是资源，均使用名词表示（可复数） --https://api.example.com/v1/zoos --https://api.example.com/v1/animals --https://api.example.com/v1/employees 5、method --GET ：从服务器取出资源（一项或多项） --POST ：在服务器新建一个资源 --PUT ：在服务器更新资源（客户端提供改变后的完整资源） --PATCH ：在服务器更新资源（客户端提供改变的属性） --DELETE ：从服务器删除资源 6、过滤，通过在url上传参的形式传递搜索条件 --https://api.example.com/v1/zoos?limit=10：指定返回记录的数量 --https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置 --https://api.example.com/v1/zoos?page=2&per_page=100：指定第几页，以及每页的记录数 --https://api.example.com/v1/zoos?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序 --https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件 7、状态码 + 自定义code --200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 --201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 --202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） --204 NO CONTENT - [DELETE]：用户删除数据成功。 --400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 --401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 --403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 --404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 --406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 --410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 --422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 --500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 8、错误处理，状态码是4xx时，应返回错误信息，error当做key。 { error: \"Invalid API key\" } 9、返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 10、Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 {\"link\": { \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\" }} "},"ROS/基础/01-什么是ROS.html":{"url":"ROS/基础/01-什么是ROS.html","title":"什么是ROS","keywords":"","body":"datetime:2022/04/23 18:00 author:nzb 什么是ROS? 中间件/类操作系统 硬件抽象 底层设备控制 常用函数的实现 进程间消息传递 包管理 官方的定义：ROS = 框架 + 工具 + 功能 + 社区 框架 分布式 节点(进程)管理 节点(进程)间通信 工具 仿真 数据可视化 图形界面 数据记录 功能 控制 规划 视觉 建图 社区 软件包管理 文档 教程 ROS 安装和配置 主要使用官方提供的网站按步骤安装就可以了： kinetic/Installation/Ubuntu - ROS Wiki 重德智能开源库（此视频开源库）： 链接1 链接2 开发环境使用：roboware studio sdn.net/lxj362343/article/details/118885315 "},"ROS/基础/02-Catkin工作空间与编译系统.html":{"url":"ROS/基础/02-Catkin工作空间与编译系统.html","title":"Catkin工作空间编译系统","keywords":"","body":"datetime:2022/04/23 18:00 author:nzb Catkin工作空间和编译系统 上图文件夹及文件说明 src：package 源代码(该文件就是我们写代码的所在的文件夹) build：cmake&catkin 缓存和中间文件 devel：目标文件 catkin：ROS 定制的编译构建系统，对 cmake 的扩展。 catkin 工作空间：组织和管理功能包的文件夹，以 catkin 工具编译 $ source /opt/ros/noetic/setup.bash # 建立工作站 $ mkdir -p ~/catkin_ws/src $ cd ~/catkin_ws/ # 回到工作站 $ catkin_make # 编译 //$ catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 $ source devel/setup.bash # 编译完成后要 source 刷新环境 $ echo $ROS_PACKAGE_PATH /home/youruser/catkin_ws/src:/opt/ros/kinetic/share 编译后结构目录 package ROS 软件的基本组织形式 catkin 编译的基本单元 一个 package 可以包含多个可执行文件（节点） cmake简单介绍 CMakeLists.txt：规定 catkin 编译的规则，例如：源文件、依赖项、目标文件 如果没有cmake基础的可以去看《cmake实践》 ，好像和《CMake Practice》是同一本书只是不同叫法或者是中英文叫法而已。 package.xml简单介绍 package.xml：定义 package 的属性，例如：包名、版本号、作者、依赖等 manifest.xml：rosbuild 编译采用的包信息清单，类似 catkin 的 package.xml 代码文件 一般代码文件可以是脚本（shell、Python）或者C++文件。 package结构示意图： package还有有自定义通信格式的文件，包括消息（msg），服务（srv），动作（action）等 这时候package结构就像下面这样了 package还有launch文件，配置文件（yaml）。launch用于每次可以运行多个可执行文件。 这时候package结构图如下 总体框架（视频缺少config文件，我添加上去了） 常用命令 Metapackage 把一系列包组织起来，安装使用方便 "},"ROS/基础/03-ROS通信架构上.html":{"url":"ROS/基础/03-ROS通信架构上.html","title":"ROS通信架构上","keywords":"","body":"datetime:2022/04/24 10:04 author:nzb ROS 通信架构(上) Master 和 Node Node 在ROS的世界里，最小的进程单元就是节点（node）。一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做节点。 从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中；从功能角度来说，通常一个node负责者机器人的某一个单独的功能。由于机器人的功能模块非常复杂，我们往往不会把所有功能都集中到一个node上，而会采用分布式的方式，把鸡蛋放到不同的篮子里。例如有一个node来控制底盘轮子的运动，有一个node驱动摄像头获取图像，有一个node驱动激光雷达，有一个node根据传感器信息进行路径规划……这样做可以降低程序发生崩溃的可能性，试想一下如果把所有功能都写到一个程序中，模块间的通信、异常处理将会很麻烦。 节点(node)相当一个个程序 ROS 的进程 pkg 里的可执行文件运行的实例 node启动命令 rosrun [--prefix cmd] [--debug] pkg_name node_name [ARGS] rosrun将会寻找PACKAGE下的名为EXECUTABLE的可执行程序，将可选参数ARGS传入。 例如在GDB下运行ros程序： rosrun --prefix 'gdb -ex run --args' pkg_name node_name 常用命令 rosnode命令 作用 rosnode list 列出当前运行的node信息 rosnode info node_name 显示出node的详细信息 rosnode kill node_name 结束某个node rosnode ping 测试连接节点 rosnode machine 列出在特定机器或列表机器上运行的节点 rosnode cleanup 清除不可到达节点的注册信息 以上命令中常用的为前三个，在开发调试时经常会需要查看当前node以及node信息，所以请记住这些常用命令。如果你想不起来，也可以通过rosnode help来查看rosnode命令的用法。 Master 由于机器人的元器件很多，功能庞大，因此实际运行时往往会运行众多的node，负责感知世界、控制运动、决策和计算等功能。那么如何合理的进行调配、管理这些node？这就要利用ROS提供给我们的节点管理器master, master在整个网络通信架构里相当于管理中心，管理着各个node。node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。node之间的通信也是先由master进行“牵线”，才能两两的进行点对点通信。当ROS程序启动时，第一步首先启动master，由节点管理器处理依次启动node。 master相当一个管家，用来管理各个节点 每个 node 启动时都要想 master 注册 管理 node 之间的通信 启动 roscore roscore：启动 ros master master：节点管理器 rosout：日志输出 parameter server：参数服务器 通常我们运行ROS，就是按照这样的顺序启动，有时候节点太多，我们会选择用launch文件来启动，下一小节会有介绍。 Master、Node之间以及Node之间的关系如下图所示： launch文件 简介 机器人是一个系统工程，通常一个机器人运行操作时要开启很多个node，对于一个复杂的机器人的启动操作应该怎么做呢？当然，我们并不需要每个节点依次进行rosrun，ROS为我们提供了一个命令能一次性启动master和多个node。该命令是： roslaunch pkg_name file_name.launch roslaunch命令首先会自动进行检测系统的roscore有没有运行，也即是确认节点管理器是否在运行状态中，如果master没有启动，那么roslaunch就会首先启动master，然后再按照launch的规则执行。launch文件里已经配置好了启动的规则。 所以roslaunch就像是一个启动工具，能够一次性把多个节点按照我们预先的配置启动起来，减少我们在终端中一条条输入指令的麻烦。 写法与格式 launch文件同样也遵循着xml格式规范，是一种标签文本，它的格式包括以下标签： 参考链接 示例 launch文件的写法和格式看起来内容比较复杂，我们先来介绍一个最简单的例子如下： 这是官网给出的一个最小的例子，文本中的信息是，它启动了一个单独的节点talker,该节点是包rospy_tutorials软件包中的节点。 然而实际中的launch文件要复杂很多，我们以Ros-Academy-for-Beginners中的robot_sim_demo为例： 这个launch文件相比上一个简单的例子来说，内容稍微有些复杂，它的作用是：启动gazebo模拟器，导入参数内容，加入机器人模型。 小结对于初学者，我们不要求掌握每一个标签是什么作用，但至少应该有一个印象。如果我们要进行自己写launch文件，可以先从改launch文件的模板入手，基本可以满足普通项目的要求。 pr2机器人要启动的节点 Topic 简介 ROS的通信方式是ROS最为核心的概念，ROS系统的精髓就在于它提供的通信架构。ROS的通信方式有以下四种： Topic 主题 Service 服务 Parameter Service 参数服务器 Actionlib 动作库 Topic ROS中的通信方式中，topic是常用的一种。对于实时性、周期性的消息，使用topic来传输是最佳的选择。topic是一种点对点的单向通信方式，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息。topic要经历下面几步的初始化过程：首先，publisher节点和subscriber节点都要到节点管理器进行注册，然后publisher会发布topic，subscriber在master的指挥下会订阅该topic，从而建立起sub-pub之间的通信。注意整个过程是单向的。其结构示意图如下： Subscriber接收消息会进行处理，一般这个过程叫做回调(Callback)。所谓回调就是提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。 上图就是ROS的topic通信方式的流程示意图。topic通信属于一种异步的通信方式。下面我们通过一个示例来了解下如何使用topic通信。 通信示例 参考下图，我们以摄像头画面的发布、处理、显示为例讲讲topic通信的流程。在机器人上的摄像头拍摄程序是一个node（圆圈表示,我们记作node1），当node1运行启动之后，它作为一个Publisher就开始发布topic。比如它发布了一个topic（方框表示），叫做/camera_rgb，是rgb颜色信息，即采集到的彩色图像。同时，node2假如是图像处理程序,它订阅了/camera_rgb这个topic，经过节点管理器的介绍，它就能建立和摄像头节点（node1）的连接。 那么怎么样来理解“异步”这个概念呢？在node1每发布一次消息之后，就会继续执行下一个动作，至于消息是什么状态、被怎样处理，它不需要了解；而对于node2图像处理程序，它只管接收和处理/camera_rgb上的消息，至于是谁发来的，它不会关心。所以node1、node2两者都是各司其责，不存在协同工作，我们称这样的通信方式是异步的。 ROS是一种分布式的架构，一个topic可以被多个节点同时发布，也可以同时被多个节点接收。比如在这个场景中用户可以再加入一个图像显示的节点，我们在想看看摄像头节点的画面，则可以用自己的笔记本连接到机器人上的节点管理器，然后在自己的电脑上启动图像显示节点。 这就体现了分布式系统通信的好处：扩展性好、软件复用率高。 总结三点： topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。 subscriber通过回调函数的方式来处理消息。 topic可以同时有多个subscribers，也可以同时有多个publishers。ROS中这样的例子有：/rosout、/tf等等。 操作命令 在实际应用中，我们应该熟悉topic的几种使用命令，下表详细的列出了各自的命令及其作用。 命令 作用 rostopic list 列出当前所有的topic rostopic info topic_name 显示某个topic的属性信息 rostopic echo topic_name 显示某个topic的内容 rostopic pub topic_name ... 向某个topic发布内容 rostopic bw topic_name 查看某个topic的带宽 rostopic hz topic_name 查看某个topic的频率 rostopic find topic_type 查找某个类型的topic rostopic type topic_name 查看某个topic的类型(msg) 如果你一时忘记了命令的写法，可以通过rostopic help或rostopic command -h查看具体用法。 Message 简介topic有很严格的格式要求，比如上节的摄像头进程中的rgb图像topic，它就必然要遵循ROS中定义好的rgb图像格式。这种数据格式就是Message。Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准。这里和我们平常用到的Massage直观概念有所不同，这里的Message不单单指一条发布或者订阅的消息，也指定为topic的格式标准。 结构与类型基本的msg包括bool、int8、int16、int32、int64(以及uint)、float、float64、string、time、duration、header、可变长数组array[]、固定长度数组array[C]。那么具体的一个msg是怎么组成的呢？我们用一个具体的msg来了解，例如上例中的msg sensor_msg/image,位置存放在sensor_msgs/msg/image.msg里,它的结构如下： std_msg/Header header uint32 seq time stamp string frame_id uint32 height uint32 width string encoding uint8 is_bigendian uint32 step uint8[] data 观察上面msg的定义，是不是很类似C语言中的结构体呢？通过具体的定义图像的宽度，高度等等来规范图像的格式。所以这就解释了Message不仅仅是我们平时理解的一条一条的消息，而且更是ROS中topic的格式规范。或者可以理解msg是一个“类”，那么我们每次发布的内容可以理解为“对象”，这么对比来理解可能更加容易。 我们实际通常不会把Message概念分的那么清，通常说Message既指的是类，也是指它的对象。而msg文件则相当于类的定义了。 操作命令rosmsg的命令相比topic就比较少了，只有两个如下： | rosmsg命令 | 作用 | | ----- | ----- | | rosmsg list | 列出系统上所有的msg | | rosmsg show msg_name | 显示某个msg的内容 | 小结 topic的通信方式是ROS中比较常见的单向异步通信方式，它在很多时候的通信是比较易用且高效的。但是有些需要交互的通信时该方式就显露出自己的不足之处了，后续我们会介绍双向同步的通信方式service。 常见message 本小节主要介绍常见的message类型，包括std_msgs, sensor_msgs, nav_msgs, geometry_msgs等 Vector3.msg #文件位置:geometry_msgs/Vector3.msg float64 x float64 y float64 z Accel.msg #定义加速度项，包括线性加速度和角加速度 #文件位置:geometry_msgs/Accel.msg Vector3 linear Vector3 angular Header.msg #定义数据的参考时间和参考坐标 #文件位置:std_msgs/Header.msg uint32 seq #数据ID time stamp #数据时间戳 string frame_id #数据的参考坐标系 Echos.msg #定义超声传感器 #文件位置:自定义msg文件 Header header uint16 front_left uint16 front_center uint16 front_right uint16 rear_left uint16 rear_center uint16 rear_right Quaternion.msg ```text 消息代表空间中旋转的四元数 文件位置:geometry_msgs/Quaternion.msg float64 x float64 y float64 z float64 w - Imu.msg ```text #消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s #如果所有的测量协方差已知，则需要全部填充进来如果只知道方差，则 #只填充协方差矩阵的对角数据即可 #位置：sensor_msgs/Imu.msg Header header Quaternion orientation float64[9] orientation_covariance Vector3 angular_velocity float64[9] angular_velocity_covariance Vector3 linear_acceleration float64[] linear_acceleration_covariance LaserScan.msg ```text平面内的激光测距扫描数据，注意此消息类型仅仅适配激光测距设备 如果有其他类型的测距设备(如声呐)，需要另外创建不同类型的消息 位置：sensor_msgs/LaserScan.msg Header header #时间戳为接收到第一束激光的时间 float32 angle_min #扫描开始时的角度(单位为rad) float32 angle_max #扫描结束时的角度(单位为rad) float32 angle_increment #两次测量之间的角度增量(单位为rad) float32 time_increment #两次测量之间的时间增量(单位为s) float32 scan_time #两次扫描之间的时间间隔(单位为s) float32 range_min #距离最小值(m) float32 range_max #距离最大值(m) float32[] ranges #测距数据(m,如果数据不在最小数据和最大数据之间，则抛弃) float32[] intensities #强度，具体单位由测量设备确定，如果仪器没有强度测量，则数组为空即可 - Point.msg ```text #空间中的点的位置 #文件位置:geometry_msgs/Point.msg float64 x float64 y float64 z Pose.msg ```text消息定义自由空间中的位姿信息，包括位置和指向信息 文件位置:geometry_msgs/Pose.msg Point position Quaternion orientation - PoseStamped.msg ```text #定义有时空基准的位姿 #文件位置：geometry_msgs/PoseStamped.msg Header header Pose pose PoseWithCovariance.msg ```text表示空间中含有不确定性的位姿信息 文件位置：geometry_msgs/PoseWithCovariance.msg Pose pose float64[36] covariance - Power.msg ```text #表示电源状态，是否开启 #文件位置：自定义msg文件 Header header bool power ###################### bool ON = 1 bool OFF = 0 Twist.msg ```text定义空间中物体运动的线速度和角速度 文件位置：geometry_msgs/Twist.msg Vector3 linear Vector3 angular - TwistWithCovariance.msg ```text #消息定义了包含不确定性的速度量，协方差矩阵按行分别表示： #沿x方向速度的不确定性，沿y方向速度的不确定性，沿z方向速度的不确定性 #绕x转动角速度的不确定性，绕y轴转动的角速度的不确定性，绕z轴转动的 #角速度的不确定性 #文件位置：geometry_msgs/TwistWithCovariance.msg Twist twist float64[36] covariance #分别表示[x; y; z; Rx; Ry; Rz] Odometry.msg ```text消息描述了自由空间中位置和速度的估计值 文件位置：nav_msgs/Odometry.msg Header header string child_frame_id PoseWithCovariance pose TwistWithCovariance twist ``` "},"ROS/基础/04-ROS通信架构下.html":{"url":"ROS/基础/04-ROS通信架构下.html","title":"ROS通信架构下","keywords":"","body":"datetime:2022/04/24 10:04 author:nzb ROS 通信架构(下) Service 上一章我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。然而有些时候单向的通信满足不了通信要求，比如当一些节点只是临时而非周期性的需要某些数据，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。 这种情况下，就需要有另外一种请求-查询式的通信模型。这节我们来介绍ROS通信中的另一种通信方式——service(服务)。 工作原理 简介 为了解决以上问题，service方式在通信模型上与topic做了区别。Service通信是双向的，它不仅可以发送消息，同时还会有反馈。所以service包括两部分，一部分是请求方（Clinet），另一部分是应答方/服务提供方（Server）。这时请求方（Client）就会发送一个request，要等待server处理，反馈回一个reply，这样通过类似“请求-应答”的机制完成整个服务通信。 这种通信方式的示意图如下： Node B是server（应答方），提供了一个服务的接口，叫做/Service，我们一般都会用string类型来指定service的名称，类似于topic。Node A向Node B发起了请求，经过处理后得到了反馈。 过程 Service是同步通信方式，所谓同步就是说，此时Node A发布请求后会在原地等待reply，直到Node B处理完了请求并且完成了reply，Node A才会继续执行。Node A等待过程中，是处于阻塞状态的成通信。这样的通信模型没有频繁的消息传递，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。 topic VS service 我们对比一下这两种最常用的通信方式，加深我们对两者的理解和认识，具体见下表： 名称 Topic Service 通信方式 异步通信 同步通信 实现原理 TCP/IP TCP/IP 通信模型 Publish-Subscribe Request-Reply 映射关系 Publish-Subscribe(多对多) Request-Reply（多对一） 特点 接受者收到数据会回调（Callback） 远程过程调用（RPC）服务器端的服务 应用场景 连续、高频的数据发布 偶尔使用的功能/具体的任务 举例 激光雷达、里程计发布数据 开关传感器、拍照、逆解计算 注意：远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。 操作命令 在实际应用中，service通信方式的命令时rosservice，具体的命令参数如下表： rosservice 命令 作用 rosservice list 显示服务列表 rosservice info 打印服务信息 rosservice type 打印服务类型 rosservice uri 打印服务ROSRPC uri rosservice find 按服务类型查找服务 rosservice call 使用所提供的args调用服务 rosservice args 打印服务参数 小结 本节我们详细介绍了service通信方式，建议与topic通信方式进行对比记忆，这样我们能更深的理解这两种通信方式，也能在以后的学习工作中更加合理使用每个通信方式，获得更高的效率。 Srv 简介 类似msg文件，srv文件是用来描述服务（service数据类型的，service通信的数据格式定义在*.srv中。它声明了一个服务，包括请求(request)和响应（reply）两部分。其格式声明如下： 举例： msgs_demo/srv/DetectHuman.srv bool start_detect --- my_pkg/HumanPose[] pose_data msgs_demo/msg/HumanPose.msg std_msgs/Header header string uuid int32 number_of_joints my_pkg/JointPose[]joint_data msgs_demo/msg/JointPose.msg string joint_name geometry_msgs/Pose pose floar32 confidence 以DetectHUman.srv文件为例，该服务例子取自OpenNI的人体检测ROS软件包。它是用来查询当前深度摄像头中的人体姿态和关节数的。srv文件格式很固定，第一行是请求的格式，中间用---隔开，第三行是应答的格式。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态（HumanPose）。而对于人的姿态，其实是一个msg，所以srv可以嵌套msg在其中，但它不能嵌套srv。 操作命令 具体的操作指令如下表： rossrv 命令 作用 rossrv show 显示服务描述 rossrv list 列出所有服务 rossrv md5 显示服务md5sum rossrv package 列出包中的服务 rossrv packages 列出包含服务的包 修改部分文件 定义完了msg、srv文件，还有重要的一个步骤就是修改package.xml和修改CMakeList.txt。这些文件需要添加一些必要的依赖等，例如： ** message_generation ** ** message_runtime ** 上述文本中“**”所引就是新添加的依赖。又例如： find_package(...roscpp rospy std_msgs ** message_generation **) catkin_package( ... CATJIN_DEPENDS ** message_runtime ** ... ...) add_message_file( FILES ** DetectHuman.srv ** ** HumanPose.msg ** ** JointPos.msg **) ** generate_messages(DEPENDENCIES std_msgs) ** 添加的这些内容指定了srv或者msg在编译或者运行中需要的依赖。具体的作用我们初学者可不深究，我们需要了解的是，无论我们自定义了srv,还是msg，修改上述部分添加依赖都是必不可少的一步。 常见srv类型 本小节介绍常见的srv类型及其定义 srv类型相当于两个message通道，一个发送，一个接收 AddTwoInts.srv #对两个整数求和，虚线前是输入量，后是返回量 #文件位置：自定义srv文件 int32 a int32 b --- int32 sum Empty.srv #文件位置：std_srvs/Empty.srv #代表一个空的srv类型 --- GetMap.srv #文件位置:nav_msgs/GetMap.srv #获取地图，注意请求部分为空 --- nav_msgs/OccupancyGrid map GetPlan.srv #文件位置:nav_msgs/GetPlan.srv #得到一条从当前位置到目标点的路径 geometry_msgs/PoseStamped start #起始点 geometry_msgs/PoseStamped goal #目标点 float32 tolerance #到达目标点的x，y方向的容错距离 --- nav_msgs/Path plan SetBool.srv #文件位置：std_srvs/SetBools.srv bool data # 启动或者关闭硬件 --- bool success # 标示硬件是否成功运行 string message # 运行信息 SetCameraInfo.srv #文件位置:sensor_msgs/SetCameraInfo.srv #通过给定的CameraInfo相机信息，来对相机进行标定 sensor_msgs/CameraInfo camera_info #相机信息 --- bool success #如果调用成功，则返回true string status_message #给出调用成功的细节 SetMap.srv #文件位置：nav_msgs/SetMap.srv #以初始位置为基准，设定新的地图 nav_msgs/OccupancyGrid map geometry_msgs/PoseWithCovarianceStamped initial_pose --- bool success TalkerListener.srv #文件位置: 自定义srv文件 --- bool success # 标示srv是否成功运行 string message # 信息，如错误信息等 Trigger.srv #文件位置:std_srvs/Trigger.srv --- bool success # 标示srv是否成功运行 string message # 信息，如错误信息等 Parameter server 简介 前文介绍了ROS中常见的两种通信方式——主题和服务，这节介绍另外一种通信方式——参数服务器（parameter server）。与前两种通信方式不同，参数服务器也可以说是特殊的“通信方式”。特殊点在于参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。 参数服务器，作为ROS中另外一种数据传输方式，有别于topic和service，它更加的静态。参数服务器维护着一个数据字典，字典里存储着各种参数和配置。 字典简介 何为字典，其实就是一个个的键值对，我们小时候学习语文的时候，常常都会有一本字典，当遇到不认识的字了我们可以查部首查到这个字，获取这个字的读音、意义等等，而这里的字典可以对比理解记忆。键值kay可以理解为语文里的“部首”这个概念，每一个key都是唯一的，参照下图： 每一个key不重复，且每一个key对应着一个value。也可以说字典就是一种映射关系，在实际的项目应用中，因为字典的这种静态的映射特点，我们往往将一些不常用到的参数和配置放入参数服务器里的字典里，这样对这些数据进行读写都将方便高效。 维护方式，参数服务器的维护方式非常的简单灵活，总的来讲有三种方式： 命令行维护 launch文件内读写 node源码 下面我们来一一介绍这三种维护方式。 命令行维护 使用命令行来维护参数服务器，主要使用rosparam语句来进行操作的各种命令，如下表： rosparam 命令 作用 rosparam set param_key param_value 设置参数 rosparam get param_key 显示参数 rosparam load file_name 从文件加载参数 rosparam dump file_name 保存参数到文件 rosparam delete 删除参数 rosparam list 列出参数名称 load&&dump文件 load和dump文件需要遵守YAML格式，YAML格式具体示例如下： name:'Zhangsan' age:20 gender:'M' score{Chinese:80,Math:90} score_history:[85,82,88,90] 简明解释。就是“名称+：+值”这样一种常用的解释方式。一般格式如下： key : value 遵循格式进行定义参数。其实就可以把YAML文件的内容理解为字典，因为它也是键值对的形式。 launch文件内读写 launch文件中有很多标签，而与参数服务器相关的标签只有两个，一个是，另一个是。这两个标签功能比较相近，但一般只设置一个参数 观察上例比如的param就定义了一个key和一个value，交给了参数服务器维护。而param只给出了key，没有直接给出value，这里的value是由后没的脚本运行结果作为value进行定义的。而rosparam的典型用法，先指定一个YAML文件，然后施加command,其效果等于rosparam load file_name 。 node源码 除了上述最常用的两种读写参数服务器的方法，还有一种就是修改ROS的源码，也就是利用API来对参数服务器进行操作。具体内容我们学习完后面章节再进行介绍。 参数类型 ROS参数服务器为参数值使用XMLRPC数据类型，其中包括:strings, integers, floats, booleans, lists, dictionaries, iso8601 dates, and base64-encoded data。 Action 简介 Actionlib是ROS中一个很重要的库，类似service通信机制，actionlib也是一种请求响应机制的通信方式，actionlib主要弥补了service通信的一个不足，就是当机器人执行一个长时间的任务时，假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，致使通信受阻。当service通信不能很好的完成任务时候，actionlib则可以比较适合实现长时间的通信过程，actionlib通信过程可以随时被查看过程进度，也可以终止请求，这样的一个特性，使得它在一些特别的机制中拥有很高的效率。 通信原理 Action的工作原理是client-server模式，也是一个双向的通信模式。通信双方在ROS Action Protocol下通过消息进行数据的交流通信。client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。 工作模式的结构示意图如下： 通信双方在ROS Action Protocal下进行交流通信是通过接口来实现,如下图: 我们可以看到,客户端会向服务器发送目标指令和取消动作指令,而服务器则可以给客户端发送实时的状态信息,结果信息,反馈信息等等,从而完成了service没法做到的部分. Action 规范 利用动作库进行请求响应，动作的内容格式应包含三个部分，目标、反馈、结果。 目标 机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速度等等。从而使机器人完成动作任务。 反馈 在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。 结果 当运动完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。 Action规范文件格式 Action规范文件的后缀名是.action，它的内容格式如下： # Define the goal uint32 dishwasher_id # Specify which dishwasher we want to use --- # Define the result uint32 total_dishes_cleaned --- # Define a feedback message float32 percent_complete Action实例详解 Actionlib是一个用来实现action的一个功能包集。我们在demo中设置一个场景，执行一个搬运的action，搬运过程中客户端会不断的发回反馈信息，最终完成整个搬运过程． 首先写handling.action文件,类比如上的格式.包括三个部分,目标,结果,反馈.如下: # Define the goal uint32 handling_id --- # Define the result uint32 Handling_completed --- # Define a feedback message float32 percent_complete 写完之后修改文件夹里CmakeLists.txt如下内容: find_package(catkin REQUIRED genmsg actionlib_msgs actionlib) add_action_files(DIRECTORY action FILES DoDishes.action) generate_messages(DEPENDENCIES actionlib_msgs) add_action_files(DIRECTORY action FILES Handling.action) generate_messages( DEPENDENCIES actionlib_msgs) 修改package.xml,添加所需要的依赖如下: actionlib actionlib_msgs actionlib actionlib_msgs 然后回到工作空间 catkin_ws进行编译. 本例中设置的的action,定义了一个搬运的例子,首先写客户端,实现功能发送action请求,包括进行目标活动,或者目标活动.之后写服务器,实验返回客户端活动当前状态信息,结果信息,和反馈信息.从而实现action.本例测试结果截图如下: 常见action类型 本小节介绍常见的action类型以及其定义 AddTwoInts.action #文件位置:自定义action文件 #表示将两个整数求和 int64 a int64 b --- int64 sum --- AutoDocking.action #文件位置:自定义action文件 #goal --- #result string text --- #feedback string state string text GetMap.action #文件位置:nav_msgs/GetMap.action #获取地图信息，响应部分为空 --- nav_msgs/OccupancyGrid map --- #无返回部分 MoveBase.action #文件位置:geometry_msgs/MoveBase.action geometry_msgs/PoseStamped target_pose --- --- geometry_msgs/PoseStamped base_position 小结 至此，ROS通信架构的四种通信方式就介绍结束，我们可以对比学习这四种通信方式，去思考每一种通信的优缺点和适用条件，在正确的地方用正确的通信方式，这样整个ROS的通信会更加高效，机器人也将更加的灵活和智能。机器人学会了通信，也就相当于有了“灵魂”。 "},"ROS/基础/05-常用工具.html":{"url":"ROS/基础/05-常用工具.html","title":"常用工具","keywords":"","body":"datetime:2022/04/25 10:51 author:nzb 常用工具 Gazebo 简介 ROS中的工具就是帮助我们完成一系列的操作，使得我们的工作更加轻松高效。ROS工具的功能大概有以下几个方向：仿真、调试、可视化。本节课我们要学习的Gazebo就是实现了仿真的功能，而调试与可视化由Rviz、rqt来实现，我们下节再依次介绍。 认识 Gazebo 对于Gazebo,大家可能并不陌生，因为我们在前面的学习过程中已经数次用到这个仿真环境，无论是在topic通信还是在service通信中，我们的demo都是在Gazebo中实现。 Gazebo是一个机器人仿真工具，模拟器，也是一个独立的开源机器人仿真平台。当今市面上还有其他的仿真工具例如V—Rep、Webots等等。但是Gazebo不仅开源，也是是兼容ROS最好的仿真工具。 Gazebo的功能很强大，最大的优点是对ROS的支持很好，因为Gazebo和ROS都由OSRF（Open Source Robotics Foundation）开源机器人组织来维护，Gazebo支持很多开源的物理引擎比如最典型的ODE。可以进行机器人的运动学、动力学仿真，能够模拟机器人常用的传感器（如激光雷达、摄像头、IMU等），也可以加载自定义的环境和场景。 仿真的意义 仿真不仅仅只是做出一个很酷的3D场景，更重要的是给机器人一个逼近现实的虚拟物理环境，比如光照条件、物理距离等等。设定好具体的参数，让机器人完成我们设定的目标任务。比如一些有危险因素的测试，就可以让机器人在仿真的环境中去完成，例如无人车在交通环境复杂的交通要道的效果，我们就可以在仿真的环境下测试各种情况无人车的反应与效果，如车辆的性能、驾驶的策略、车流人流的行为模式等，又或者各种不可控因素如雨雪天气，突发事故，车辆故障等，从而收集结果参数指标信息等等，只有更大程度的逼近现实，才能得出车辆的真实效果。直到无人车在仿真条件下做到万无一失，才能放心的投放到真实环境中去使用，这即避免了危险因素对实验者的威胁，也节约了时间和资源，这就是仿真的意义。 通常一些不依赖于具体硬件的算法和场景都可以在Gazebo上仿真，例如图像识别、传感器数据融合处理、路径规划、SLAM等任务完全可以在Gazebo上仿真实现，大大减轻了对硬件的依赖。 演示 和我们前面的实例测试一样，我们打开教材的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch 操作说明 平移：鼠标左键 旋转：鼠标滚轮中键 放缩：鼠标滚轮 -界面左侧是控制面板 导入模型就在控制面板的insert,可以直接拖入模拟空间，也可以按需自制模型拖入。小结 虽然Gazebo目前的功能还称不上强大，同时还存在着一些BUG，但是对于我们的入门学习也已经是足够了，随着版本的更新，Gazebo也在越来越强大。 RViz 简介 本节课介绍的是我们在ROS开发中非常常用的一个工具，基本上的调试和开发都离不开这个工具——RViz(the Robit Visualization tool)机器人可视化工具，可视化的作用是直观的，它极大的方便了监控和调试等操作。 演示 依然打开教材的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch，之后在命令行打开新的终端直接输入$ rviz 打开工具。 和Gazebo一样，也会显示出一个3D环境，不过操作上有所不同，具体操作如下： 平移：鼠标滚轮中键 旋转：鼠标左键 放缩：鼠标滚轮 左侧控制面板，可以添加插件 RViz的插件种类繁多功能强大，非常适合我们开发调试ROS程序。 差异 虽然从界面上来看，RViz和Gazebo非常相似，但实际上两者有着很大的不同，Gazebo实现的是仿真，提供一个虚拟的世界，RViz实现的是可视化，呈现接收到的信息。左侧的插件相当于是一个个的subscriber,RViz接收信息，并且显示。所以RViz和Gazebo有本质的差异。 小结 RViz和Gazebo是我们常用的ROS工具，更好的利用这些工具是我们ROS进阶的基础。具体的操作和使用可以参考我们的官方演示视频，跟着视频去实战演练，熟悉这两个工具。 rqt 简介 rqt是一个基于qt开发的可视化工具，拥有扩展性好、灵活易用、跨平台等特点，主要作用和RViz一致都是可视化，但是和RViz相比，rqt要高级一个层次，。 命令 rqt_graph :显示通信架构 rqt_plot ：绘制曲线 rqt_console ：查看日志 rqt_graph rqt_graph是来显示通信架构，也就是我们上一章所讲的内容节点、主题等等，当前有哪些Node和topic在运行，消息的流向是怎样，都能通过这个语句显示出来。此命令由于能显示系统的全貌，所以非常的常用。 rqt_plot rqt_plot将一些参数，尤其是动态参数以曲线的形式绘制出来。当我们在开发时查看机器人的原始数据，我们就能利用rqt_plot将这些原始数据用曲线绘制出来，非常的直观，利于我们分析数据。 rqt_console rqt_console里存在一些过滤器，我们可以利用它方便的查到我们需要的日志。 实例测试 首先打开我们教材的模拟场景，输入roslaunch robot_sim_demo robot_spawn_launch 输入命令语句rqt_graph,显示出了当前环境下运行的Node和topic，十分直观的看到通信结构以及消息流向。注意在椭圆形的代表节点，矩形代表topic。 输入命令语句rqt_plot,显示出曲线坐标窗口，在上方输入框里添加或者删除topic，比如我们查看速度，可以在框里设置好topic后，移动机器人，就可以看到自动绘制的线速度或者角速度曲线。 输入命令语句rqt_console，显示日志的输出，配合rqt_logger_level查看日志的级别。 小结 rqt_graph这个功能是强大的，它使得我们初学者可以直观的看到ROS的通信架构和信息流，方便我们理解的同时，也使得我们能够最快的纠错等等。rqt_plot绘制数据曲线图，也是极大的帮助我们了解数据的变化态势，理解数据流的作用，用曲线来显示我们的操作，精确直观。rqt_console配合rqt_logger_level，查看日志，对于查找错误和DeBug都有很大帮助。 Rosbag 简介 rosbag是一个这是一套用于记录和回放ROS主题的工具。它旨在提高性能，并避免消息的反序列化和重新排序。rosbag package提供了命令行工具和代码API，可以用C++或者python来编写包。而且rosbag命令行工具和代码API是稳定的，始终保持向后的兼容性。 命令 rosbag对软件包来操作，一个包是ROS用于存储ROS消息数据的文件格式，rosbag命令可以记录、回放和操作包。指令列表如下： 命令 作用 cheak 确定一个包是否可以在当前系统中进行，或者是否可以迁移。 decompress 压缩一个或多个包文件。 filter 解压一个或多个包文件。 fix 在包文件中修复消息，以便在当前系统中播放。 help 获取相关命令指示帮助信息 info 总结一个或多个包文件的内容。 play 以一种时间同步的方式回放一个或多个包文件的内容。 record 用指定主题的内容记录一个包文件。 reindex 重新索引一个或多个包文件。 参考链接 小结 rosbag通过命令行能够对软件包进行很多的操作，更重要的拥有代码API，可以对包进行重新编写。增加一个ROS API，用于通过服务调用与播放和录制节点进行交互。 Rosbridge 简介 Rosbridge是一个用在ROS系统和其他系统之间的一个功能包,就像是它的名字一样,起到一个\"桥梁\"的作用,使得ros系统和其他系统能够进行交互.Rosbridge为非ROS程序提供了一个JSON API,有许多与Rosbridge进行交互的前端，包括一个用于Web浏览器交互的WebSocket服务器。Rosbridge_suite是一个包含Rosbridge的元程序包，用于Rosbridge的各种前端程序包（如WebSocket程序包）和帮助程序包。 协议和实现 Rosbridge主要包含两部分内容:协议(Potocol)和实现(Implementation) 协议 Ｒosbridge Protocol提供了非ROS程序与ROS通信的具体的格式规范，规范基于JSON格式,包括订阅topic，发布message,调用server，设置参数，压缩消息等等．例如订阅topic的格式规范如下： { \"op\": \"subscribe\", \"topic\": \"/cmd_vel\", \"type\": \"geometry_msgs/Twist\" } 此规范与所用的编程语言和传输方式无关，任何可以发送JSON格式的语音和传输方式都可以Rosbridge protocol进行交流，并且与ROS进行交互． 实现 Rosbridge_suite元程序包是实现Ｒosbridge　Protocol并提供WebSocket传输层的包的集合。 这些软件包包括： Rosbridge_library : 核心rosbridge软件包。Rosbridge_library负责获取JSON字符串并将命令发送到ROS，反过来接收处理ROS发过来的信息，将之转换为JSON字符串，并将结果转交给非ROS程序。 rosapi : 通过服务调用来访问某些ROS操作，这些服务通常为ROS客户端库保留的服务．这些操作包括获取和设置参数，获取主题列表等等。 rosbridge_server : 虽然Rosbridge_library提供JSON到ROS转换，但它将传输层留给其他人。Rosbridge_server提供了一个WebSocket连接，所以浏览器可以与ROS“交谈”。Roslibjs是一个浏览器的JavaScript库，可以通过rosbridge_server与ROS进行交流。 安装与使用 安装 Rosbridge是基于ROS的，首先要确保自己正确的安装完成了ROS之后可以启动终端执行命令： sudo apt-get install ros- -rosbridge-server 中间的为自己的ROS版本，依照自己的版本进行安装． 使用 关于更深入的使用，可以参考本课程的视频课程，简单的入门使用可以参考链接如下： 参考链接 moveit! 简介 2012年，一款叫做moveit!的移动操作软件诞生了，moveit！最初在Willow Garage由Sachin Chitta，Ioan Sucan，Gil E. Jones，Acorn Pooley，Suat Gedikli，Dave Hershberger开发，它融合了研究者在运动规划、操纵、3D感知、运动学、控制和导航方面的最新进展，为操作者提供了一个易于使用的平台，使用它可以开发先进的机器人应用，也被广泛应用于工业，商业，研发和其他领域。由于以上特性，moveit！一跃成为在机器人上最广泛使用的开源操作软件，截止2017年，已经被用于超过65台机器人。 moveit!视频链接 使用 moveit!的使用通过为用户提供接口来调用它，包括C++、Python、GUI三种接口。ROS中的move_group节点充当整合器，整合多个独立组件，提供ROS风格的Action和service。move_group通过ROS topic和action与机器人通讯，获取机器人的位置、节点等状态，获取数据再传递给机器人的控制器。 move_group节点获取到节点状态信息或者机器人变换信息时候，会通过控制器的接口去处理这些信息，比如进行坐标转换、规划场景、3D感知。另外，move_group的结构比较容易扩展，不仅具有独立的能力如抓放，运动规划，也可扩展自公共类，但实际作为独立的插件运行。moveit!系统结构图如下： 官网链接 "},"ROS/基础/06-roscpp.html":{"url":"ROS/基础/06-roscpp.html","title":"roscpp","keywords":"","body":"datetime:2022/04/25 10:51 author:nzb Client Library与roscpp Client Library简介 ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。尽管语言不通，但这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。 目前ROS支持的Clinet Library包括： Client Library 介绍 roscpp ROS的C++库，是目前最广泛应用的ROS客户端库，执行效率高 rospy ROS的Python库，开发效率高，通常用在对运行时间没有太大要求的场合，例如配置、初始化等操作 roslisp ROS的LISP库 roscs Mono/.NET.库，可用任何Mono/.NET语言，包括C#，Iron Python， Iron Ruby等 rosgo ROS Go语言库 rosjava ROS Java语言库 rosnodejs Javascript客户端库 ... ... 目前最常用的只有roscpp和rospy，而其余的语言版本基本都还是测试版。 从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。 整个ROS包括的packages如下，你可以看到roscpp、rospy处于什么位置。 roscpp roscpp位于/opt/ros/kinetic之下，用C++实现了ROS通信。在ROS中，C++的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。所以简单地理解，你也可以把roscpp就当作为一个C++的库，我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。 通常我们要调用ROS的C++接口，首先就需要#include 。 roscpp的主要部分包括： ros::init() : 解析传入的ROS参数，创建node第一步需要用到的函数 ros::NodeHandle : 和topic、service、param等交互的公共接口 ros::master : 包含从master查询信息的函数 ros::this_node：包含查询这个进程(node)的函数 ros::service：包含查询服务的函数 ros::param：包含查询参数服务器的函数，而不需要用到NodeHandle ros::names：包含处理ROS图资源名称的函数 具体可见：http://docs.ros.org/api/roscpp/html/index.html 以上功能可以分为以下几类： Initialization and Shutdown 初始与关闭 Topics 话题 Services 服务 Parameter Server 参数服务器 Timers 定时器 NodeHandles 节点句柄 Callbacks and Spinning 回调和自旋（或者翻译叫轮询？） Logging 日志 Names and Node Information 名称管理 Time 时钟 Exception 异常 看到这么多接口，千万别觉得复杂，我们日常开发并不会用到所有的功能，你只需对要有一些印象，掌握几个比较常见和重要的用法就足够了。下面我们来介绍关键的用法。 节点初始、关闭以及NodeHandle 当执行一个ROS程序，就被加载到了内存中，就成为了一个进程，在ROS里叫做节点。每一个ROS的节点尽管功能不同，但都有必不可少的一些步骤，比如初始化、销毁，需要通行的场景通常都还需要节点的句柄。 这一节我们来学习Node最基本的一些操作。 初始化节点 对于一个C++写的ROS程序，之所以它区别于普通C++程序，是因为代码中做了两层工作： 调用了ros::init()函数，从而初始化节点的名称和其他信息，一般我们ROS程序一开始都会以这种方式开始。 创建ros::NodeHandle对象，也就是节点的句柄，它可以用来创建Publisher、Subscriber以及做其他事情。 句柄(Handle) 这个概念可以理解为一个“把手”，你握住了门把手，就可以很容易把整扇门拉开，而不必关心门是什么样子。NodeHandle就是对节点资源的描述，有了它你就可以操作这个节点了，比如为程序提供服务、监听某个topic上的消息、访问和修改param等等。 关闭节点 通常我们要关闭一个节点可以直接在终端上按Ctrl+C，系统会自动触发SIGINT句柄来关闭这个进程。 你也可以通过调用ros::shutdown()来手动关闭节点，但通常我们很少这样做。 以下是一个节点初始化、关闭的例子。 #include int main(int argc, char** argv) { ros::init(argc, argv, \"your_node_name\"); ros::NodeHandle nh; //....节点功能 //.... ros::spin();//用于触发topic、service的响应队列 return 0; } 这段代码是最常见的一个ROS程序的执行步骤，通常要启动节点，获取句柄，而关闭的工作系统自动帮我们完成，如果有特殊需要你也可以自定义。你可能很关心句柄可以用来做些什么，接下来我们来看看NodeHandle常用的成员函数。 NodeHandle常用成员函数 NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是一个定义好的类，通过include，我们可以创建这个类，以及使用它的成员函数。 NodeHandle常用成员函数包括： //创建话题的publisher ros::Publisher advertise(const string &topic, uint32_t queue_size, bool latch=false); //第一个参数为发布话题的名称 //第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么就的消息就会出队。通常设为一个较小的数即可。 //第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如/map这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。 //创建话题的subscriber ros::Subscriber subscribe(const string &topic, uint32_t queue_size, void(*)(M)); //第一个参数是订阅话题的名称 //第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，就消息就会出队 //第三个参数是回调函数指针，指向回调函数来处理接收到的消息 //创建服务的server，提供服务 ros::ServiceServer advertiseService(const string &service, bool(*srv_func)(Mreq &, Mres &)); //第一个参数是service名称 //第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。 //创建服务的client ros::ServiceClient serviceClient(const string &service_name, bool persistent=false); //第一个函数式service名称 //第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机的连接，这样后续的请求会快一些。通常我们设为flase //查询某个参数的值 bool getParam(const string &key, std::string &s); bool getParam (const std::string &key, double &d) const； bool getParam (const std::string &key, int &i) const； //从参数服务器上获取key对应的值，已重载了多个类型 //给参数赋值 void setParam (const std::string &key, const std::string &s) const； void setParam (const std::string &key, const char *s) const; void setParam (const std::string &key, int i) const; //给key对应的val赋值，重载了多个类型的val 可以看出，NodeHandle对象在ROS C++程序里非常重要，各种类型的通信都需要用NodeHandle来创建完成。 下面我们具体来看topic、service和param这三种基本通信方式的写法。 topic in roscpp Topic通信 Topic是ROS里一种异步通信的模型，一般是节点间分工明确，有的只负责发送，有的只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。 为了讲明白topic通信的编程思路，我们首先来看topic_demo中的代码,这个程序是一个消息收发的例子： 自定义一个类型为gps的消息（包括位置x，y和工作状态state信息），一个node以一定频率发布模拟的gps消息，另一个node接收并处理，算出到原点的距离。 源代码见ROS-Academy-for-Beginners/topic_demo 创建gps消息 在代码中，我们会用到自定义类型的gps消息，因此就需要来自定义gps消息，在msg路径下创建gps.msg： 见topic_demo/msg/gps.msg string state #工作状态 float32 x #x坐标 float32 y #y坐标 以上就定义了一个gps类型的消息，你可以把它理解成一个C语言中的结构体，类似于 struct gps { string state; float32 x; float32 y; } 在程序中对一个gps消息进行创建修改的方法和对结构体的操作一样。 当你创建完了msg文件，记得修改CMakeLists.txt和package.xml，从而让系统能够编译自定义消息。 在CMakeLists.txt中需要改动 find_package(catkin REQUIRED COMPONENTS roscpp std_msgs message_generation #需要添加的地方 ) add_message_files(FILES gps.msg) #catkin在cmake之上新增的命令，指定从哪个消息文件生成 generate_messages(DEPENDENCIES std_msgs) #catkin新增的命令，用于生成消息 #DEPENDENCIES后面指定生成msg需要依赖其他什么消息，由于gps.msg用到了flaot32这种ROS标准消息，因此需要再把std_msgs作为依赖 package.xml中需要的改动 message_generation message_runtime 当你完成了以上所有工作，就可以回到工作空间，然后编译了。编译完成之后会在devel路径下生成gps.msg对应的头文件，头文件按照C++的语法规则定义了topic_demo::gps类型的数据。 要在代码中使用自定义消息类型，只要#include ，然后声明，按照对结构体操作的方式修改内容即可。 topic_demo::gps mygpsmsg; mygpsmsg.x = 1.6; mygpsmsg.y = 5.5; mygpsmsg.state = \"working\"; 消息发布节点 定义完了消息，就可以开始写ROS代码了。通常我们会把消息收发的两端分成两个节点来写，一个节点就是一个完整的C++程序。 见topic_demo/src/talker.cpp #include #include //自定义msg产生的头文件 int main(int argc, char **argv) { ros::init(argc, argv, \"talker\"); //用于解析ROS参数，第三个参数为本节点名 ros::NodeHandle nh; //实例化句柄，初始化node topic_demo::gps msg; //自定义gps消息并初始化 ... ros::Publisher pub = nh.advertise(\"gps_info\", 1); //创建publisher，往\"gps_info\"话题上发布消息 ros::Rate loop_rate(1.0); //定义发布的频率，1HZ while (ros::ok()) //循环发布msg { ... //处理msg pub.publish(msg);//以1Hz的频率发布msg loop_rate.sleep();//根据前面的定义的loop_rate,设置1s的暂停 } return 0; } 机器人上几乎所有的传感器，几乎都是按照固定频率发布消息这种通信方式来传输数据，只是发布频率和数据类型的区别。 消息接收节点 见topic_demo/src/listener.cpp #include #include #include void gpsCallback(const topic_demo::gps::ConstPtr &msg) { std_msgs::Float32 distance; //计算离原点(0,0)的距离 distance.data = sqrt(pow(msg->x,2)+pow(msg->y,2)); ROS_INFO(\"Listener: Distance to origin = %f, state: %s\",distance.data,msg->state.c_str()); //输出 } int main(int argc, char **argv) { ros::init(argc, argv, \"listener\"); ros::NodeHandle n; ros::Subscriber sub = n.subscribe(\"gps_info\", 1, gpsCallback); //设置回调函数gpsCallback ros::spin(); //ros::spin()用于调用所有可触发的回调函数，将进入循环，不会返回，类似于在循环里反复调用spinOnce() //而ros::spinOnce()只会去触发一次 return 0; } 在topic接收方，有一个比较重要的概念，就是回调(CallBack)，在本例中，回调就是预先给gps_info 话题传来的消息准备一个回调函数，你事先定义好回调函数的操作，本例中是计算到原点的距离。只有当有消息来时，回调函数才会被触发执行。具体去触发的命令就是ros::spin()，它会反复的查看有没有消息来，如果有就会让回调函数去处理。 因此千万不要认为，只要指定了回调函数，系统就回去自动触发，你必须ros::spin()或者ros::spinOnce()才能真正使回调函数生效。 CMakeLists.txt文件修改 在CMakeLists.txt添加以下内容，生成可执行文件 add_executable(talker src/talker.cpp) #生成可执行文件talker add_dependencies(talker topic_demo_generate_messages_cpp) #表明在编译talker前，必须先生编译完成自定义消息 #必须添加add_dependencies，否则找不到自定义的msg产生的头文件 #表明在编译talker前，必须先生编译完成自定义消息 target_link_libraries(talker ${catkin_LIBRARIES}) #链接 add_executable(listener src/listener.cpp ) #声称可执行文件listener add_dependencies(listener topic_demo_generate_messages_cpp) target_link_libraries(listener ${catkin_LIBRARIES})#链接 以上cmake语句告诉catkin编译系统如何去编译生成我们的程序。这些命令都是标准的cmake命令，如果不理解，请查阅cmake教程。 之后经过catkin_make，一个自定义消息+发布接收的基本模型就完成了。 扩展：回调函数与spin()方法 回调函数在编程中是一种重要的方法，在维基百科上的解释是： In computer programming, a callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time. 回调函数作为参数被传入到了另一个函数中（在本例中传递的是函数指针），在未来某个时刻（当有新的message到达），就会立即执行。Subscriber接收到消息，实际上是先把消息放到一个队列 中去，如图所示。队列的长度在Subscriber构建的时候设置好了。当有spin函数执行，就会去处理消息队列中队首的消息。 spin具体处理的方法又可分为阻塞/非阻塞,单线程/多线程，在ROS函数接口层面我们有4种spin的方式： spin方法 阻塞 线程 ros::spin() 阻塞 单线程 ros::spinOnce() 非阻塞 单线程 ros::MultiThreadedSpin() 阻塞 多线程 ros::AsyncMultiThreadedSpin() 非阻塞 多线程 阻塞与非阻塞的区别我们已经讲了，下面来看看单线程与多线程的区别： 我们常用的spin()、spinOnce()是单个线程逐个处理回调队列里的数据。有些场合需要用到多线程分别处理，则可以用到MultiThreadedSpin()、AsyncMultiThreadedSpin()。 service in roscpp Service通信 Service是一种请求-反馈的通信机制。请求的一方通常被称为客户端，提供服务的一方叫做服务器端。Service机制相比于Topic的不同之处在于： 消息的传输是双向的，有反馈的，而不是单一的流向。 消息往往不会以固定频率传输，不连续，而是在需要时才会向服务器发起请求。 在ROS中如何请求或者提供一个服务，我们来看service_demo的代码：一个节点发出服务请求（姓名，年龄），另一个节点进行服务响应，答复请求。 创建Greeting服务 创建service_demo/Greeting.srv文件，内容包括： string name #短横线上边部分是服务请求的数据 int32 age --- #短横线下面是服务回传的内容。 string feedback srv格式的文件创建后，也需要修改CMakeLissts.txt,在其中加入 add_service_files(FILES Greeting.srv) 其余与添加msg的改动一样。然后进行catkin_make，系统就会生成在代码中可用的Greeting类型。在代码中使用,只需要#include ，然后即可创建该类型的srv。 service_demo::Greeting grt; //grt分为grt.request和grt.response两部分 grt.request.name = \"HAN\"; //不能用grt.name或者grt.age来访问 grt.request.age = \"20\"; ... 新生成的Greeting类型的服务，其结构体的风格更为明显，可以这么理解，一个Greeting服务结构体中嵌套了两个结构体，分别是请求和响应： struct Greeting { struct Request { string name; int age; }request; struct Response { string feedback; }response; } 创建提供服务节点(server) service_demo/srv/server.cpp内容如下： #include #include bool handle_function(service_demo::Greeting::Request &req, service_demo::Greeting::Response &res){ //显示请求信息 ROS_INFO(“Request from %s with age %d”, req.name.c_str(), req.age); //处理请求，结果写入response res.feedback = “Hi ” + req.name + “. I’m server!”; //返回true，正确处理了请求 return true; } int main(int argc, char** argv){ ros::init(argc, argv, “greetings_server”); //解析参数，命名节点 ros::NodeHandle nh; //创建句柄，实例化node ros::ServiceServer service = nh.advertiseService(“greetings”, handle_function); //写明服务的处理函数 ros::spin(); return 0; } 在以上代码中，服务的处理操作都写在handle_function() 中，它的输入参数就是Greeting的Request和Response两部分，而非整个Greeting对象。通常在处理函数中，我们对Requst数据进行需要的操作，将结果写入到Response中。在roscpp中，处理函数返回值是bool型，也就是服务是否成功执行。不要理解成输入Request，返回Response，在rospy中是这样的。 创建服务请求节点(client) service_demo/srv/client.cpp内容如下： # include \"ros/ros.h\" # include \"service_demo/Greeting.h\" int main(int argc, char **argv) { ros::init(argc, argv, \"greetings_client\");// 初始化，节点命名为\"greetings_client\" ros::NodeHandle nh; ros::ServiceClient client = nh.serviceClient(\"greetings\"); // 定义service客户端，service名字为“greetings”，service类型为Service_demo // 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv service_demo::Greeting srv; srv.request.name = \"HAN\"; srv.request.age = 20; if (client.call(srv)) { // 注意我们的response部分中的内容只包含一个变量response，另，注意将其转变成字符串 ROS_INFO(\"Response from server: %s\", srv.response.feedback.c_str()); } else { ROS_ERROR(\"Failed to call service Service_demo\"); return 1; } return 0; } 以上代码比较关键的地方有两处，一个是建立一个ServiceClient，另一个是开始调用服务。建立client需要用nh.serviceClient(\"greetings\") ，指明服务的类型和服务的名称。而调用时可以直接用client.call(srv)，返回结果不是response，而是是否成功调用远程服务。 CMakeLists.txt和pacakge.xml修改方法和topic_demo修改方法类似，不再赘述。 param in roscpp Parameter Server 严格来说，param并不能称作一种通信方式，因为它往往只是用来存储一些静态的设置，而不是动态变化的。所以关于param的操作非常轻巧，非常简单。 关于param的API，roscpp为我们提供了两套，一套是放在ros::paramnamespace下，另一套是在ros::NodeHandle下，这两套API的操作完全一样，用哪一个取决于你的习惯。 param_demo 我们来看看在C++中如何进行param_demo的操作，param_demo/param.cpp文件，内容包括： #include int main(int argc, char **argv){ ros::init(argc, argv, \"param_demo\"); ros::NodeHandle nh; int parameter1, parameter2, parameter3, parameter4, parameter5; //Get Param的三种方法 //① ros::param::get()获取参数“param1”的value，写入到parameter1上 bool ifget1 = ros::param::get(\"param1\", parameter1); //② ros::NodeHandle::getParam()获取参数，与①作用相同 bool ifget2 = nh.getParam(\"param2\",parameter2); //③ ros::NodeHandle::param()类似于①和② //但如果get不到指定的param，它可以给param指定一个默认值(如33333) nh.param(\"param3\", parameter3, 33333); if(ifget1) //param是否取得 ... //Set Param //① ros::param::set()设置参数 parameter4 = 4; ros::param::set(\"param4\", parameter4); //② ros::NodeHandle::setParam()设置参数 parameter5 = 5; nh.setParam(\"param5\",parameter5); //Check Param //① ros::NodeHandle::hasParam() bool ifparam5 = nh.hasParam(\"param5\"); //② ros::param::has() bool ifparam6 = ros::param::has(\"param6\"); //Delete Param //① ros::NodeHandle::deleteParam() bool ifdeleted5 = nh.deleteParam(\"param5\"); //② ros::param::del() bool ifdeleted6 = ros::param::del(\"param6\"); ... } 以上是roscpp中对param进行增删改查所有操作的方法，非常直观。 param_demo中的launch文件 实际项目中我们对参数进行设置，尤其是添加参数，一般都不是在程序中，而是在launch文件中。因为launch文件可以方便的修改参数，而写成代码之后，修改参数必须重新编译。 因此我们会在launch文件中将param都定义好，比如这个demo正确的打开方式应该是roslaunch param_demo param_demo_cpp.launch param_demo/launch/param_demo_cpp.launch内容为： param3: 3 param4: 4 param5: 5 通过和两个标签我们设置好了5个param，从而在之前的代码中进行增删改查的操作。 命名空间对param的影响 在实际的项目中，实例化句柄时，经常会看到两种不同的写法 ros::NodeHandle n; ros::NodeHandle nh(\"~\");` 这两种写法有什么不同呢？以本教学报的name_demo为例。在本节launch文件夹的demo.launch定义两个参数，一个全局serial 他的数值是5,一个是局部的serial，他的数值是10. 在name_demo.cpp中，我们分别尝试了，利用全局命名空间句柄提取全局的param和局部的param，以及在局部命名空间下的句柄提取全局的param和局部的param，详细的代码如下： #include int main(int argc, char* argv[]) { int serial_number = -1;//serial_number初始化 ros::init(argc, argv, \"name_demo\");//node初始化 /*创建命名空间*/ //n 是全局命名空间 ros::NodeHandle n; //nh 是局部命名空间 ros::NodeHandle nh(\"~\"); /*全局命名空间下的Param*/ ROS_INFO(\"global namespace\"); //提取全局命名空间下的参数serial n.getParam(\"serial\", serial_number); ROS_INFO(\"global_Serial was %d\", serial_number); //提取局部命名空间下的参数serial n.getParam(\"name_demo/serial\", serial_number);//在全局命名空间下，要提取局部命名空间下的参数，需要添加node name ROS_INFO(\"global_to_local_Serial was %d\", serial_number); /*局部命名空间下的Param*/ ROS_INFO(\"local namespace\"); //提取局部命名空间下的参数serial nh.getParam(\"serial\", serial_number); ROS_INFO(\"local_Serial was %d\", serial_number); //提取全局命名空间下的参数serial nh.getParam(\"/serial\", serial_number);//在局部命名空间下，要提取全局命名空间下的参数，需要添加“/” ROS_INFO(\"local_to_global_Serial was %d\", serial_number); ros::spin(); return 0; } 最后的结果 [ INFO] [1525095241.802257811]: global namespace [ INFO] [1525095241.803512501]: global_Serial was 5 [ INFO] [1525095241.804515959]: global_to_local_Serial was 10 [ INFO] [1525095241.804550167]: local namespace [ INFO] [1525095241.805126562]: local_Serial was 10 [ INFO] [1525095241.806137701]: local_to_global_Serial was 5 时钟 Time 与 Duration ROS里经常用到的一个功能就是时钟，比如计算机器人移动距离、设定一些程序的等待时间、设定计时器等等。roscpp同样给我们提供了时钟方面的操作。 具体来说，roscpp里有两种时间的表示方法，一种是时刻（ros:: Time），一种是时长（ros::Duration）。无论是Time还是Duration都具有相同的表示方法： int32 sec int32 nsec Time/Duration都由秒和纳秒组成。 要使用Time和Duration，需要#include 和#include ros::Time begin = ros::Time::now(); //获取当前时间 ros::Time at_some_time1(5,20000000); //5.2s ros::Time at_some_time2(5.2) //同上，重载了float类型和两个uint类型的构造函数 ros::Duration one_hour(60*60,0); //1h double secs1 = at_some_time1.toSec();//将Time转为double型时间 double secs2 = one_hour.toSec();//将Duration转为double型时间 Time和Duration表示的概念并不相同，Time指的是某个时刻，而Duration指的是某个时段，尽管他们的数据结构都相同，但是用在不同的场景下。 ROS为我们重载了Time、Duration类型之间的加减运算，比如: ros::Time t1 = ros::Time::now() - ros::Duration(5.5); //t1是5.5s前的时刻，Time加减Duration返回都是Time ros::Time t2 = ros::Time::now() + ros::Duration(3.3);//t2是当前时刻往后推3.3s的时刻 ros::Duration d1 = t2 - t1;//从t1到t2的时长，两个Time相减返回Duration类型 ros::Duration d2 = d1 -ros::Duration(0,300);//两个Duration相减，还是Duration 以上是Time、Duration之间的加减运算，要注意没有Time+Time的做法。 sleep 通常在机器人任务执行中可能有需要等待的场景，这时就要用到sleep功能，roscpp中提供了两种sleep的方法： ros::Duration(0.5).sleep(); //用Duration对象的sleep方法休眠 ros::Rate r(10); //10HZ while(ros::ok()) { r.sleep(); //定义好sleep的频率，Rate对象会自动让整个循环以10hz休眠，即使有任务执行占用了时间 } Timer Rate的功能是指定一个频率，让某些动作按照这个频率来循环执行。与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，创建方法和topic中的subscriber很像。 void callback1(const ros::TimerEvent&) { ROS_INFO(\"Callback 1 triggered\"); } void callback2(const ros::TimerEvent&) { ROS_INFO(\"Callback 2 triggered\"); } int main(int argc, char **argv) { ros::init(argc, argv, \"talker\"); ros::NodeHandle n; ros::Timer timer1 = n.createTimer(ros::Duration(0.1), callback1); //timer1每0.1s触发一次callback1函数 ros::Timer timer2 = n.createTimer(ros::Duration(1.0), callback2); //timer2每1.0s触发一次callback2函数 ros::spin(); //千万别忘了spin，只有spin了才能真正去触发回调函数 return 0; } 日志和异常 Log ROS为开发者和用户提供了一套日志记录和输出系统，这套系统的实现方式是基于topic，也就是每个节点都会把一些日志信息发到一个统一的topic上去，这个topic就是/rosout。 rosout 本身也是一个node，它专门负责进行日志的记录。我们在启动master的时候，系统就会附带启动rosout。 在roscpp中进行日志的输出，需要先include ,这个头文件包括了五个级别的日志输出接口，分别是： DEBUG INFO WARN ERROR FATAL 用法非常简单： ROS_DEBUG(\"The velocity is %f\", vel); ROS_WARN(\"Warn: the use is deprecated.\"); ROS_FATAL(\"Cannot start this node.\"); ... 当然也可以在一些特定场景，特定条件下输出，不过对于普通开发者来说可能用不到这么复杂的功能。具体可参考：http://wiki.ros.org/roscpp/Overview/Logging Exception roscpp中有两种异常类型，当有以下两种错误时，就会抛出异常： ros::InvalidNodeNameException 当无效的基础名称传给ros::init(),通常是名称中有/,就会触发 ros::InvalidNameExcaption 当无效名称传给了roscpp "},"ROS/基础/07-rospy.html":{"url":"ROS/基础/07-rospy.html","title":"rospy","keywords":"","body":"datetime:2022/04/25 10:51 author:nzb rospy与主要接口 rospy vs roscpp rospy是Python版本的ROS客户端库，提供了Python编程需要的接口，你可以认为rospy就是一个Python的模块(Module) 。这个模块位于/opt/ros/kineetic/lib/python2.7/dist-packages/rospy之中。 rospy包含的功能与roscpp相似，都有关于node、topic、service、param、time相关的操作。但同时rospy和roscpp也有一些区别： rospy没有一个NodeHandle，像创建publisher、subscriber等操作都被直接封装成了rospy中的函数或类，调用起来简单直观。 rospy一些接口的命名和roscpp不一致，有些地方需要开发者注意，避免调用错误。 相比于C++的开发，用Python来写ROS程序开发效率大大提高，诸如显示、类型转换等细节不再需要我们注意，节省时间。但Python的执行效率较低，同样一个功能用Python运行的耗时会高于C++。因此我们开发SLAM、路径规划、机器视觉等方面的算法时，往往优先选择C++。 ROS中绝大多数基本指令，例如rostopic,roslaunch都是用python开发的，简单轻巧。 ROS中Python代码的组织方式 要介绍rospy，就不得不提Python代码在ROS中的组织方式。通常来说，Python代码有两种组织方式，一种是单独的一个Python脚本，适用于简单的程序，另一种是Python模块，适合体量较大的程序。 单独的Python脚本 对于一些小体量的ROS程序，一般就是一个Python文件，放在script/路径下，非常简单。 your_package |- script/ |- your_script.py |-... Python模块 当程序的功能比较复杂，放在一个脚本里搞不定时，就需要把一些功能放到Python Module里，以便其他的脚本来调用。ROS建议我们按照以下规范来建立一个Python的模块： your_package |- src/ |-your_package/ |- _init_.py |- modulefiles.py |- scripts/ |- your_script.py |- setup.py 在src下建立一个与你的package同名的路径，其中存放_init_.py以及你的模块文件。这样就建立好了ROS规范的Python模块，你可以在你的脚本中调用。 如果你不了解init.py 的作用，可以参考这篇博客 ROS中的这种Python模块组织规范与标准的Python模块规范并不完全一致，你当然可以按照Python的标准去建立一个模块，然后在你的脚本中调用，但是我们还是建议按照ROS推荐的标准来写，这样方便别人去阅读。 通常我们常用的ROS命令，大多数其实都是一个个Python模块，源代码存放在ros_comm 仓库的tools路径下你可以看到每一个命令行工具（如rosbag、rosmsg）都是用模块的形式组织核心代码，然后在script/下建立一个脚本来调用模块。 常用rospy的API 这里分类整理了rospy常见的一些用法，请你浏览一遍，建立一个初步的影响。 具体API 请查看 Node相关 返回值 方法 作用 rospy.init_node(name, argv=None, anonymous=False) 注册和初始化node MasterProxy rospy.get_master() 获取master的句柄 bool rospy.is_shutdown() 节点是否关闭 rospy.on_shutdown(fn) 在节点关闭时调用fn函数 str get_node_uri() 返回节点的URI str get_name() 返回本节点的全名 str get_namespace() 返回本节点的名字空间 ... ... ... Topic相关 函数： 返回值 方法 作用 [[str, str]] get_published_topics() 返回正在被发布的所有topic名称和类型 Message wait_for_message(topic, topic_type, time_out=None) 等待某个topic的message spin() 触发topic或service的回调/处理函数，会阻塞直到关闭节点 ... ... ... Publisher类： 返回值 方法 作用 __init__(self, name, data_class, queue_size=None) 构造函数 publish(self, msg) 发布消息 str unregister(self) 停止发布 ... ... ... Subscriber类： 返回值 方法 作用 __init__(self, name, data_class, call_back=None, queue_size=None) 构造函数 unregister(self, msg) 停止订阅 ... ... ... Service相关 函数： 返回值 方法 作用 wait_for_service(service, timeout=None) 阻塞直到服务可用 ... ... ... Service类(server)： 返回值 方法 作用 __init__(self, name, service_class, handler) 构造函数，handler为处理函数，service_class为srv类型 shutdown(self) 关闭服务的server ... ... ... ServiceProxy类(client)： 返回值 方法 作用 __init__(self, name, service_class) 构造函数，创建client call(self, args, *kwds) 发起请求 __call__(self, args, *kwds) 同上 close(self) 关闭服务的client ... ... ... Param相关 函数： 返回值 方法 作用 XmlRpcLegalValue get_param(param_name, default=_unspecified) 获取参数的值 [str] get_param_names() 获取参数的名称 set_param(param_name, param_value) 设置参数的值 delete_param(param_name) 删除参数 bool has_param(param_name) 参数是否存在于参数服务器上 str search_param() 搜索参数 ... ... ... 时钟相关 函数： 返回值 方法 作用 Time get_rostime() 获取当前时刻的Time对象 float get_time() 返回当前时间，单位秒 sleep(duration) 执行挂起 ... ... ... Time类： 返回值 方法 作用 __init__(self, secs=0, nsecs=0) 构造函数 Time now() 静态方法 返回当前时刻的Time对象 ... ... ... Duration类： 返回值 方法 作用 __init__(self, secs=0, nsecs=0) 构造函数 ... ... ... topic in rospy 与roscpp类似，我们用python来写一个节点间消息收发的demo，同样还是创建一个自定义的gps类型的消息，一个节点发布模拟的gps信息，另一个接收和计算距离原点的距离。 自定义消息的生成 gps.msg定义如下： string state #工作状态 float32 x #x坐标 float32 y #y坐标 我们需要修改CMakeLists.txt文件，方法见5.3节，这里需要强调一点的就是，对创建的msg进行catkin_make 会在~/catkin_ws/devel/lib/python2.7/dist-packages/topic_demo下生成msg模块（module）。 有了这个模块，我们就可以在python程序中from topic_demo.msg import gps,从而进行gps类型消息的读写。 消息发布节点 与C++的写法类似，我们来看topic用Python如何编写程序，见topic_demo/scripts/pytalker.py： import rospy # 导入自定义的数据类型 from topic_demo.msg import gps def talker(): # Publisher 函数第一个参数是话题名称，第二个参数 数据类型，现在就是我们定义的msg 最后一个是缓冲区的大小 # queue_size: None（不建议） #这将设置为阻塞式同步收发模式！ # queue_size: 0（不建议）#这将设置为无限缓冲区模式，很危险！ # queue_size: 10 or more #一般情况下，设为10 。queue_size太大了会导致数据延迟不同步。 pub = rospy.Publisher('gps_info', gps, queue_size=10) rospy.init_node('pytalker', anonymous=True) # 更新频率是1hz rate = rospy.Rate(1) x = 1.0 y = 2.0 state = 'working' while not rospy.is_shutdown(): # 计算距离 rospy.loginfo('Talker: GPS: x=%f ,y= %f', x, y) pub.publish(gps(state, x, y)) x = 1.03 * x y = 1.01 * y rate.sleep() if __name__ == '__main__': talker() 以上代码与C++的区别体现在这几个方面： rospy创建和初始化一个node，不再需要用NodeHandle。rospy中没有设计NodeHandle这个句柄，我们创建topic、service等等操作都直接用rospy里对应的方法就行。 rospy中节点的初始化并一定得放在程序的开头，在Publisher建立后再初始化也没问题。 消息的创建更加简单，比如gps类型的消息可以直接用类似于构造函数的方式gps(state,x,y)来创建。 日志的输出方式不同，C++中是ROS_INFO()，而Python中是rospy.loginfo() 判断节点是否关闭的函数不同，C++用的是ros::ok()而Python中的接口是rospy.is_shutdown() 通过以上的区别可以看出，roscpp和rospy的接口并不一致，在名称上要尽量避免混用。在实现原理上，两套客户端库也有各自的实现，并没有基于一个统一的核心库来开发。这也是ROS在设计上不足的地方。 ROS2就解决了这个问题，ROS2中的客户端库包括了rclcpp(ROS Clinet Library C++)、rclpy(ROS Client Library Python) ,以及其他语言的版本，他们都是基于一个共同的核心ROS客户端库rcl来开发的，这个核心库由C语言实现。 消息订阅节点 见topic_demo/scripts/pylistener.py： import rospy import math # 导入mgs from topic_demo.msg import gps # 回调函数输入的应该是msg def callback(gps): distance = math.sqrt(math.pow(gps.x, 2) + math.pow(gps.y, 2)) rospy.loginfo('Listener: GPS: distance=%f, state=%s', distance, gps.state) def listener(): rospy.init_node('pylistener', anonymous=True) # Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称 rospy.Subscriber('gps_info', gps, callback) rospy.spin() if __name__ == '__main__': listener() 在订阅节点的代码里，rospy与roscpp有一个不同的地方：rospy里没有spinOnce()，只有spin()。 建立完talker和listener之后，经过catkin_make，就完成了python版的topic通信模型。 Service in rospy 本节用python来写一个节点间，利用Service通信的demo，与5.4类似，创建一个节点，发布模拟的gps信息，另一个接收和计算距离原点的距离。 srv文件 在5.4节，我们已经说过要建立一个名为Greeting.srv的服务文件，内容如下： string name #短横线上边部分是服务请求的数据 int32 age --- #短横线下面是服务回传的内容 string feedback 然后修改CMakeLists.txt 文件。ROS的catkin编译系统会将你自定义的msg、srv（甚至还有action）文件自动编译构建，生成对应的C++、Python、LISP等语言下可用的库或模块。许多初学者错误地以为，只要建立了一个msg或srv文件，就可以直接在程序中使用，这是不对的，必须在CMakeLists.txt 中添加关于消息创建、指定消息/服务文件那几个宏命令。 创建提供服务节点(server) 见service_demo/scripts/server_demo.py： import rospy from service_demo.srv import * def server_srv(): # 初始化节点，命名为 \"greetings_server\" rospy.init_node(\"greetings_server\") # 定义service的server端，service名称为\"greetings\"， service类型为Greeting # 收到的request请求信息将作为参数传递给handle_function进行处理 s = rospy.Service(\"greetings\", Greeting, handle_function) rospy.loginfo(\"Ready to handle the request:\") # 阻塞程序结束 rospy.spin() def handle_function(req): # 注意我们是如何调用request请求内容的，是将其认为是一个对象的属性，在我们定义 # 的Service_demo类型的service中，request部分的内容包含两个变量，一个是字符串类型的name，另外一个是整数类型的age rospy.loginfo('Request from %s with age %d', req.name, req.age) # 返回一个Service_demo.Response实例化对象，其实就是返回一个response的对象，其包含的内容为我们在Service_demo.srv中定义的 # response部分的内容，我们定义了一个string类型的变量feedback，因此，此处实例化时传入字符串即可 return GreetingResponse(\"Hi %s. I' server!\" % req.name) # 如果单独运行此文件，则将上面定义的server_srv作为主函数运行 if __name__ == \"__main__\": server_srv() 以上代码中可以看出Python和C++在ROS服务通信时，server端的处理函数有区别： C++的handle_function() 传入的参数是整个srv对象的request和response两部分，返回值是bool型，显示这次服务是否成功的处理，也就是： bool handle_function(service_demo::Greeting::Request &req, service_demo::Greeting::Response &res){ ... return true; } 而Python的handle_function()传入的只有request，返回值是response，即： def handle_function(req): ... return GreetingResponse(\"Hi %s. I' server!\"%req.name) 这也是ROS在两种语言编程时的差异之一。相比来说Python的这种思维方式更加简单，符合我们的思维习惯。 创建服务请求节点(client) service_demo/srv/client.cpp内容如下： import rospy from service_demo.srv import * def client_srv(): rospy.init_node('greetings_client') # 等待有可用的服务 \"greetings\" rospy.wait_for_service(\"greetings\") try: # 定义service客户端，service名称为“greetings”，service类型为Greeting greetings_client = rospy.ServiceProxy(\"greetings\", Greeting) # 向server端发送请求，发送的request内容为name和age,其值分别为\"HAN\", 20 # 此处发送的request内容与srv文件中定义的request部分的属性是一致的 # resp = greetings_client(\"HAN\",20) resp = greetings_client.call(\"HAN\", 20) rospy.loginfo(\"Message From server:%s\" % resp.feedback) except rospy.ServiceException, e: rospy.logwarn(\"Service call failed: %s\" % e) # 如果单独运行此文件，则将上面函数client_srv()作为主函数运行 if __name__ == \"__main__\": client_srv() 以上代码中greetings_client.call(\"HAN\",20)等同于greetings_client(\"HAN\",20)。 param与time param_demo 相比roscpp中有两套对param操作的API，rospy关于param的函数就显得简单多了，包括了增删查改等用法： rospy.get_param() rospy.set_param() rospy.has_param() rospy.delete_param() rospy.search_param() rospy.get_param_names() 下面我们来看看param_demo里的代码： import rospy def param_demo(): rospy.init_node(\"param_demo\") rate = rospy.Rate(1) while (not rospy.is_shutdown()): # get param parameter1 = rospy.get_param(\"/param1\") parameter2 = rospy.get_param(\"/param2\", default=222) rospy.loginfo('Get param1 = %d', parameter1) rospy.loginfo('Get param2 = %d', parameter2) # delete param rospy.delete_param('/param2') # set param rospy.set_param('/param2', 2) # check param ifparam3 = rospy.has_param('/param3') if (ifparam3): rospy.loginfo('/param3 exists') else: rospy.loginfo('/param3 does not exist') # get all param names params = rospy.get_param_names() rospy.loginfo('param list: %s', params) rate.sleep() if __name__ == \"__main__\": param_demo() time_demo 时钟 rospy中的关于时钟的操作和roscpp是一致的，都有Time、Duration和Rate三个类。 首先，Time和Duration前者标识的是某个时刻（例如今天22:00），而Duration表示的是时长(例如一周) 。但他们具有相同的结构（秒和纳秒）： int32 secs int32 secs 创建Time和Duration rospy中的Time和Duration的构造函数类似，都是_init_(self,secs=0, nsecs=0),指定秒和纳秒(1ns = 10^-9 s) time_now1 = rospy.get_rostime() # 当前时刻的Time对象 返回Time对象 time_now2 = rospy.Time.now() # 同上 time_now3 = rospy.get_time() # 得到当前时间，返回float 4单位秒 time_4 = rospy.Time(5) # 创建5s的时刻 duration = rospy.Duration(3 * 60) # 创建3min时长 关于Time、Duration之间的加减法和类型转换，和roscpp中的完全一致，请参考5.6节，此处不再重复。 sleep duration.sleep() # 挂起 rospy.sleep(duration) # 同上，这两种方式效果完全一致 loop_rate = Rate(5) # 利用Rate来控制循环频率 while (rospy.is_shutdown()): loop_rate.sleep() # 挂起，会考虑上次loop_rate.sleep的时间 关于sleep的方法，Rate类中的sleep主要用来保持一个循环按照固定的频率，循环中一般都是发布消息、执行周期性任务的操作。这里的sleep会考虑上次sleep的时间，从而使整个循环严格按照指定的频率。 定时器Timer rospy里的定时器和roscpp中的也类似，只不过不是用句柄来创建，而是直接rospy.Timer(Duration, callback)，第一个参数是时长，第二个参数是回调函数。 def my_callback(event): print 'Timer called at ' + str(event.current_real) rospy.Timer(rospy.Duration(2), my_callback) # 每2s触发一次callback函数 rospy.spin() 同样不要忘了rospy.spin()，只有spin才能触发回调函数。 回调函数的传入值是TimerEvent类型，该类型包括以下几个属性： rospy.TimerEvent last_expected 理想情况下为上一次回调应该发生的时间 last_real 上次回调实际发生的时间 current_expected 本次回调应该发生的时间 current_real 本次回调实际发生的时间 last_duration 上次回调所用的时间（结束-开始） "},"Utils/docker/Docker.html":{"url":"Utils/docker/Docker.html","title":"Docker","keywords":"","body":"1、Docker基本组成 1.1、Docker Client 客户端 1.2、Docker Daemon 守护进程客户端/守护进程C/S模式我们通过客户端发送命令给守护进程，守护进程执行结果返回给客户端 1.3、Docker Image 镜像容器的基石层叠的只读文件系统 1.4、Docker Container 容器通过镜像启动 1.5、Docker Registry 仓库公有私有 1.6、示意图 2、Docker容器相关技术简介 2.1、Docker依赖的Linux内核特性 2.1.1、Namespaces命名空间 编程语言封装 -> 代码隔离 操作系统 系统资源的隔离 进程、网络、文件系统... 分为5种命名空间： PID(Process ID) 进程隔离 NET(Network) 管理网络接口 IPC(InterProcess Communication) 管理跨进程通信的访问 MNT(Mount) 管理挂载点 UTS(Unix Timesharing System) 隔离内核和版本标识 2.1.2、Control groups(cgroups)控制组 用来分配资源 资源限制 优先级设定 资源计量 资源控制 2.2、Docker容器的能力 文件系统隔离：每个容器都有自己的root文件系统 进程隔离：每个容器都运行在自己的进程环境中 网络隔离：容器间的虚拟网络接口和IP地址都是分开的 资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器 3、Docker客户端与守护进程 1、客户端与守护进程通信 2、Remote API与Docker守护进程进行通信 RESTful 风格API 3、连接方式 unix://var/run/docker.sock(默认) tcp://host:port fd://sockerfd 4、Docker守护进程的配置和操作 1、查看守护进程ps -ef | grep dockersudo docker stats 查看docker的运行状态 2、使用service命令管理sudo service docker start/stop/restart 3、Docker的启动选项 docker -d [OPTIONS] 运行相关： -d： 以守护的形式运行 -D,--debug=false -e,--exec-driver=\"native\" -g,--graph=\"/var/lib/docker\" --icc=true -l,--log-level=\"info\" --label=[] 标签区别，key-value形式：name=nzb -p,--pidfile=\"/var/run/docker.pid 服务器连接相关： -G,--group=\"docker\" -H,--host=[] 启动选项，默认 -H unix://var/run/docker.sock --tls=false --tlscacert=\"/home/sven/.docker/ca.pem\" --tlscert=\"/home/sven/.docker/cert.pem\" --tlskey=\"/home/sven/.docker/key.pem\" --tlsverify=false Remote API相关： --api-enable-cors=false 存储相关： -s,--storage-driver=\"\" --selinux-enabled=false --storage-opt=[] Registry相关： --insecure-registry=[] --registry-mirror=[] 网络设置相关： -b,--bridge=\"\" --bip=\"\" --fixed-cidr=\"\" --fixed-cidr-v6=\"\" --dns=[] --dns-search=[] --ip=0.0.0.0 --ip-forward=true --ip-masq=true --iptables=true --ipv6=false --mtu=0 4、启动配置文件 /etc/default/docker 5、Docker的远程访问 1、环境准备 另一台安装Docker的服务器 --label name=server1/2 修改Docker守护进程启动选项，区别服务器-H tcp://0.0.0.0:2375测试：curl http://host:2375/info 保证Client API与Server API 版本一致 修改客户端配置docker -H tcp:host:2375或使用环境变量DOCKER_HOSTexport DOCKER_HOST=\"tcp://host:2375\"测试：docker info 如想访问本地的docker服务：export DOCKER_HOST=\"\" 置空环境变量 如果docker开启了远程服务，如何访问本地：修改启动选项-H，可以有多个： -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 6、Docker容器 1、基本操作 1.1、启动容器docker run IMAGE [COMMAND] [ARG]例： docker run ubuntu echo 'Hello World' 1.2、启动交互式容器docker run -i -t IMAGE /bin/bash -i --interactive=true | false 默认是false -t --tty=true | false 默认是false 1.3、查看容器docker ps [-a] [-l] -a：列出使用容器 -l：列出最新创建的容器 不指定参数则列出所有正在运行的容器 docker inspect 容器id或容器名字：查看容器详细信息 1.4、自定义容器名 docker run --name=自定义名 -i -t IMAGE /bin/bash 1.5、重新启动停止的容器 docker start [-i] 容器名 -i：以交互的方式重新启动容器 1.6、删除停止的容器 docker rm 容器名 2、守护式容器 2.1、以守护形式运行容器 docker run -i -t IMAGE /bin/bash Ctrl+P Ctrl+Q 组合键退出就会在后台运行 2.2、附加到运行中的容器 docker attach 容器名或容器id 2.3、启动守护式容器 docker run -d 镜像名 [COMMAND] [ARG...] -d：启动时使用后台的方式启用 例： docker run --name dc1 -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 2.4、查看容器日志 docker logs [-f] [-t] [--tail] 容器名 -f --follows=true | false 默认是false 一直跟踪并放回结果 -t --timestamps=true | false 默认是false 加上时间戳 --tail=\"all\" 返回结尾多少条的数据 2.5、查看容器内进程 docker top 容器名 2.6、在运行中的容器内启动新进程 docker exec [-d] [-i] [-t] 容器名 [COMMAND] [ARG...] 进入mysql容器： docker exec -it 容器名 bash 2.7、停止守护式容器 docker stop 容器名 或 docker kill 容器名 7、容器中部署静态网站 7.1、设置容器的端口映射 run [-P] [-p] -P,--publish-all=true | false 默认是false 将为容器暴露的所有端口进行映射 例： docker run -P -i -t ubuntu /bin/bash -p,--pulish=[] 指定映射哪些容器的端口 四种方式： containerPort docker run -p 80 -i -t ubuntu /bin/bash 随机映射 hostPort:containerPort docker run -p 8080:80 -i -t ubuntu /bin/bash ip:containerPort docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash ip:hostPort:containerPort docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash 7.2、部署流程 创建映射80端口的交互式容器 安装Nginx 安装文本编辑器vim 创建静态文件 修改Nginx配置文件 运行Nginx 验证网站访问 8、查看和删除镜像 1、镜像的存储地址 docker info 查看镜像的存储地址 2、列出镜像 docker images [OPTIONS] [REPOSITORY] -a,--all=false 显示所有镜像，包括中间层镜像 -f,-filter --no-trunc=false id截断 -q,--quiet=false 只显示镜像的唯一IDREPOSITORY仓库是包含一系列的镜像，而REGISTRY仓库包含很多REPOSITORY仓库TAG例如：ubuntu:14.04ubuntu:latest 3、查看镜像 docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...] -f,--format=\"\" 4、删除镜像 docker rmi [OPTIONS] IMAGE [IMAGE...] -f,--force=false 强制删除镜像 - --no-prune=false 不会删除未打标签的镜像 例： docker rmi $(docker images -q ubuntu) 删除所有Ubuntu仓库中的所有镜像 9、获取和推送镜像 1、查找镜像 1.1、Docker Hub https://registry.hub.docker.com 1.2、docker search [OPTIONS] TERM --automated=false 是否是自动构建的镜像 --no-trunc=false -s,--stars=0 最多返回25个结果 2、拉取镜像 docker pull [OPTIONS] NAME[:TAG] -a,--all-tags=false 下载带有标签的的仓库的所有镜像 使用--registry-mirror选项加速拉取镜像速度 修改：etc/default/docker 添加：DOCKER_OPTS=\"--registry-mirror=http://MIRROR-ADDR\" 例：https://www.daocloud.io 注册获取加速地址 3、推送镜像 docker push NAME[:TAG] NAME:仓库名 TAG:标签名 10、构建镜像 1、docker commit 通过容器构建docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] CONTAINER 容器名 -a,--author=\"\" -m,--message=\"\" -p,--pause=true 构建镜像时不暂停运行的容器 2、docker build 通过Dockerfile文件构建 例： #First Dockerfile From ubuntu:14.04 MAINTAINER dormancypress \"dormancypress@outlook.com\" RUN apt-get update RUN apt-get install -y nginx EXPOSE 80 docker build [OPTIONS] PATH | URL | - --force-rm=false --no-cache=false 不使用缓存 --pull=false -q,--quite=false 不显示构建过程 --rm=true -t,--tag=\"\" 指定构建的镜像的名字 PATH | URL 构建镜像的路径，可以使用“.”表示当前文件夹 11、Dockerfile指令 1、指令格式 # Comment 注释 INSTRUCTION argument 指令 2、指令 2.1、FROM FROM FROM : 已经存在的镜像 基础镜像 必须是第一条非注释指令 2.2、MAINTAINER MAINTAINER 指定镜像的作者信息，包含镜像的所有者和联系信息相当于前面的commit命令的-a选项 2.3、RUN 指定当前镜像中运行的命令(镜像构建时运行的) -RUN (shell模式) /bin/sh -c command 例： RUN echo hello -RUN [\"executable\",\"param1\",\"param2\"] (exec模式) 例： RUN [\"/bin/bash\",\"-c\",\"echo hello\"] 2.4、EXPOSE EXPOSE [...] 指定运行该镜像的容器使用的端口（只是告诉容器使用的端口） 为了安全起见，run命令中还要指定端口 docker run -p 80 -d dormancypress/df_test1 nginx -g \"daemon off;\" 2.5、CMD容器运行时运行的指令，会被docker run 命令中的指令覆盖 CMD [\"executable\",\"param1\",\"param2\"] (exec模式) CMD command param1 param2 (shell模式) CMD [\"param1\",\"param2\"] (作为ENTERYPOINT指令的默认参数) 例：CMD [\"/usr/sbin/nginx\", \"-g\", \"daemon off;\"] 2.6、ENTERYPOINT 容器运行时运行的指令，不会被docker run 命令中的指令覆盖 ENTERYPOINT [\"executable\",\"param1\",\"param2\"] (exec模式) ENTERYPOINT command param1 param2 (shell模式) 2.7、ADD ADD ... ADD [\"\"...\"\"](适用于文件路径中有空格的情况) 2.8、COPY COPY ... COPY [\"\"...\"\"](适用于文件路径中有空格的情况) ADD vs COPY ADD包含类型tar的解压功能 如果当纯复制文件，Docker推荐使用COPY 2.9、VOLUME添加容器卷VOLUME [\"/data\"] 2.10、WORKDIR WORKDIR /path/to/workdir 一般不使用绝对路径，如果使用相对路径，会一直传递下去 2.11、ENV 设置环境变量与WORKDIR类似 ENV ENV = 2.12、USER 指定镜像会以什么用户来运行 2.13、ONBUILD 镜像触发器 当一个镜像被其他镜像作为基础镜像时执行 会在构建过程中插入指令 12、构建过程 1、构建过程 从基础镜像运行一个容器 执行一条指令，对容器做出修改 执行类似docker commit的操作，提交一个新的镜像层 在基于刚提交的镜像运行一个新容器 执行Dockerfile中的下一条指令，直至所有指令执行完毕 ps:构建中会删除中间层容器，而不会删除中间层镜像，所以可以使用中间层镜像进行调试，查找错误 2、镜像缓存 构建缓存: 构建一次后再构建就会使用构建缓存 不使用缓存 使用--no-cache选项 或 ENV REFRESH_DATE 2019-4-7 3、查看镜像构建的过程 docker history [image] --no-trunc: 不截断输出完整信息 13、容器的网络连接 1、Docker容器的网络基础 Linux虚拟网桥特点： 可设置IP地址 相当于拥有一个隐藏的虚拟网卡 docker0的地址划分： IP：172.17.42.1 子网掩码：255.255.0.0 MAC:02:42:ac:11:00:00到02:42:11:ff:ff 总共提供了65534个地址 需要使用网桥管理工具：sudo apt-get install bridge-utils 查看网桥：sudo brctl show 添加虚拟网桥：sudo brctl add br0 修改地址：sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0 修改docker0地址： sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0 更改docker守护进程的启动配置 /etc/default/docker 中添加DOCKER_OPS值 DOCKER_OPS=\"-b=br0\" 2、Docker容器的互联 2.1、运行所有容器互联（默认） 因为每次关闭重启容器IP地址都会改变所有使用--link选项可以使新启动的容器为其起别名，就不用担心IP改变 --linkdocker run --link=[CONTAINER_NAME]:[ALIAS] [IMAGE] [COMMAND] 2.2、拒绝容器间的互联 --icc=false 2.3、允许特点容器间的连接 --icc=false --iptables=true --link 3、Docker容器与外部网络的连接 3.1、ip-forward --ip-forward=true(默认) 允许数据转发 查看ip_forward的值： sysctl net.ipv4.conf.all.forwarding 3.2、iptables 什么是iptables: Iptables是Linux内核集成的包过滤防火墙系统，几乎所有的Linux发行版本都会包含IPtables的功能。 表(table):下图中的nat、mangle、raw、filter... 链(chain):代表数据处理的不同环节 规则(rule):每个链下的操作 ACCEPT、REJECT、DROP filter表中包含的链： INPUT FORWARD OUTPUT 查看iptables： sudo iptables [-t filter] -L -n -t:指定表名（默认） 3.3、允许特定IP访问容器 sudo iptables -I DOCKER -s 禁止访问ip -d 目的ip -p TCP --dport 80 -j ACCEPT 3.4、限制IP访问容器 sudo iptables -I DOCKER -s 禁止访问ip -d 目的ip -p TCP --dport 80 -j DROP 14、Docker容器的数据卷 什么是数据卷： 数据卷是经过特殊设计的目录，可以绕过联合文件系统（UFS）,为一个或多个容器提供访问。 数据卷设计的目的，在于设计的永久化，他完全独立于容器的生存周期，因此，Docker不会再容器删除时删除其挂载的数据卷， 也不会存在类似的垃圾收集机制，对容器引用的数据卷进行处理。 1、为容器添加数据卷 docker run -v ~/container_data:/data -it ubuntu /bin/bash ~/container_data： 本机目录 /data： 容器目录 2、为数据卷添加访问权限 docker run -v ~/container_data:/data:ro -it ubuntu /bin/bash ro: 只读 3、使用Dockerfile构建包含数据卷的镜像 Dockerfile指令 VOLUME[\"/data\"] 但是，利用这个镜像创建的容器构建的数据卷都是不一样的，则不能实现共享。 15、Docker的数据卷容器 1、挂载数据卷容器的方法 docker run --volumes-from [CONTAINER NAME] 即时删除了数据卷容器，挂载了这个数据卷容器的容器还是能正常使用。因为只要一个数据卷还在被使用就不会被删除。 16、Docker数据卷的备份和还原 1、数据备份方法 docker run --volumes-from [container name] -v $(pwd):/backup:wr ubuntu tar -cvf /backup/backup.tar [container data volume] $(pwd):备份文件存储的目录 /backup：容器中的目录 wr ：读写（默认） [container data volume]：需要压缩的数据卷目录 tar -cvf/backup/backup.tar [container data volume]：备份操作（压缩） 2、数据还原方法 docker run --volumes-from [container name] -v $(pwd):/backup:wr ubuntu tar -xvf /backup/backup.tar [container data volume] 17、Docker容器的跨主机连接 1、使用网桥实现跨主机容器连接 1.1、环境准备 Mac OS X + Parallels 两台Ubuntu14.04虚拟机 安装网桥管理工具： apt-get install bridge-utils ip地址： Host1:10.211.55.3 Host2:10.211.55.5 修改/etc/network/interfaces文件 auto bro iface bro inet static address 10.211.55.3 netmask 255.255.255.0 geteway 10.211.55.1 bridge_ports eth0 Docker设置 修改/etc/default/docker文件 -b指定使用自定义网桥 -b=br0 --fixed-cidr限制ip地址分配范围 IP地址划分： Host1:10.211.55.64/26 地址范围：10.211.55.65~10.211.55.126 Host2:10.211.55.128/26 地址范围：10.211.55.129~10.211.55.190 2、使用Open vSwitch实现跨主机容器连接 3、使用Weave实现跨主机容器连接 Docker 磁盘空间占用和清理 磁盘空间占用 Docker 的内置 CLI 指令docker system df，可用于查询镜像（Images）、容器（Containers）和本地卷（Local Volumes）等空间使用大户的空间占用情况。 [root@dockercon ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE kalilinux/kali-linux-docker latest c927a54ec8a4 8 days ago 1.88GB nginx latest 3f8a4339aadd 9 days ago 108MB busybox latest 6ad733544a63 2 months ago 1.13MB [root@dockercon ~]# docker system df TYPE TOTAL ACTIVE SIZE RECLAIMABLE Images 3 0 1.994GB 1.994GB (100%) Containers 0 0 0B 0B Local Volumes 0 0 0B 0B Build Cache 0B 0B 可以进一步通过-v参数查看空间占用细节 [root@dockercon ~]# docker system df -v #镜像空间使用情况 Images space usage: REPOSITORY TAG IMAGE ID CREATED ago SIZE SHARED SIZE UNIQUE SiZE CONTAINERS kalilinux/kali-linux-docker latest c927a54ec8a4 8 days ago ago 1.884GB 0B 1.884GB 0 nginx latest 3f8a4339aadd 9 days ago ago 108.5MB 0B 108.5MB 0 busybox latest 6ad733544a63 2 months ago ago 1.129MB 0B 1.129MB 0 #容器空间使用情况 Containers space usage: CONTAINER ID IMAGE COMMAND LOCAL VOLUMES SIZE CREATED ago STATUS NAMES #本地卷使用情况 Local Volumes space usage: VOLUME NAME LINKS SIZE Build cache usage: 0B 空间清理 不同状态 已使用镜像（used image） 未引用镜像（unreferenced image） 悬空镜像（dangling image） 镜像含义 指所有已被容器（包括已停止的）关联的镜像 没有被分配或使用在容器中的镜像 未配置任何 Tag （也就无法被引用）的镜像 Docker内置自动清理 通过 Docker 内置的 CLI 指令docker system prune来进行自动空间清理。 [root@dockercon ~]# docker system prune --help Usage: docker system prune [OPTIONS] Remove unused data Options: -a, --all Remove all unused images not just dangling ones --filter filter Provide filter values (e.g. 'label==') -f, --force Do not prompt for confirmation --volumes Prune volumes docker system prune 自动清理说明 该指令默认会清除所有如下资源： 已停止的容器（container） 未被任何容器所使用的卷（volume） 未被任何容器所关联的网络（network） 所有悬空镜像（image）。 该指令默认只会清除悬空镜像，未被使用的镜像不会被删除。添加-a 或 --all参数后，可以一并清除所有未使用的镜像和悬空镜像。 可以添加-f 或 --force参数用以忽略相关告警确认信息。 [root@dockercon ~]# docker system prune --help Usage: docker system prune [OPTIONS] Remove unused data Options: -a, --all Remove all unused images not just dangling ones --filter filter Provide filter values (e.g. 'label==') -f, --force Do not prompt for confirmation --volumes Prune volumes [root@dockercon ~]# docker system prune --all WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all images without at least one container associated to them - all build cache Are you sure you want to continue? [y/N] y Deleted Containers: f095899e7343e160d5b32d0688a6561a1a7f6af91c42ffe966649240b58ca23f Deleted Images: untagged: busybox:latest untagged: busybox@sha256:e3789c406237e25d6139035a17981be5f1ccdae9c392d1623a02d31621a12bcc deleted: sha256:6ad733544a6317992a6fac4eb19fe1df577d4dec7529efec28a5bd0edad0fd30 deleted: sha256:0271b8eebde3fa9a6126b1f2335e170f902731ab4942f9f1914e77016540c7bb untagged: kalilinux/kali-linux-docker:latest untagged: kalilinux/kali-linux-docker@sha256:28ff9e4bf40f7399e0570394a2d3d388a7b60c748be1b0a180c14c87afad1968 deleted: sha256:c927a54ec8a46164d7046b2a6dc09b2fce52b3066317d50cf73d14fa9778ca48 untagged: alpine:latest untagged: alpine@sha256:ccba511b1d6b5f1d83825a94f9d5b05528db456d9cf14a1ea1db892c939cda64 untagged: alpine-io:latest Total reclaimed space: 5.219GB "},"Utils/docker/FastDFS.html":{"url":"Utils/docker/FastDFS.html","title":"FastDFS","keywords":"","body":"datetime:2020/1/3 14:24 author:nzb 使用Docker安装FastDFS分布式文件系统 拉取镜像 docker image pull delron/fastdfs 运行tracker docker run -itd --network=host --name fastdfs-tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs 将fastDFS tracker运行目录映射到本机的 /var/fdfs/tracker目录中。 查看是否允许起来 docker ls 停止运行 docker stop fastdfs-tracker 重新运行 docker start fastdfs-tracker 运行storage docker run -itd --network=host --name fastdfs-storage -e TRACKER_SERVER=192.168.1.218:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage TRACKER_SERVER=本机的ip地址:22122 本机ip地址不要使用127.0.0.1 将fastDFS storage运行目录映射到本机的/var/fdfs/storage目录中 查看是否允许起来 docker ls 停止运行 docker stop fastdfs-storage 重新运行 docker start fastdfs-storage 注意：如果无法重新运行，可以删除/var/fdfs/storage/data目录下的fdfs_storaged.pid 文件，然后重新运行storage。 Django项目之FastDFS文件存储系统 FastDFS的Python客户端 python版本的FastDFS客户端使用说明参考：https://github.com/jefforeilly/fdfs_client-py 安装 安装fdfs_client-py-master.zip到虚拟环境中 pip install fdfs_client-py-master.zip pip install mutagen pip install requests 配置 在项目/utils目录下新建fastdfs目录，新建client.conf配置文件 # connect timeout in seconds # default value is 30s connect_timeout=30 # network timeout in seconds # default value is 30s network_timeout=60 # the base path to store log files base_path=FastDFS客户端存放日志文件的目录 # tracker_server can ocur more than once, and tracker_server format is # \"host:port\", host can be hostname or ip address tracker_server=172.17.0.1:22122 #standard log level as syslog, case insensitive, value list: ### emerg for emergency ### alert ### crit for critical ### error ### warn for warning ### notice ### info ### debug log_level=info # if use connection pool # default value is false # since V4.05 use_connection_pool = false # connections whose the idle time exceeds this time will be closed # unit: second # default value is 3600 # since V4.05 connection_pool_max_idle_time = 3600 # if load FastDFS parameters from tracker server # since V4.05 # default value is false load_fdfs_parameters_from_tracker=false # if use storage ID instead of IP address # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # default value is false # since V4.05 use_storage_id = false # specify storage ids filename, can use relative or absolute path # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # since V4.05 storage_ids_filename = storage_ids.conf #HTTP settings http.tracker_server_port=80 #use \"#include\" directive to include HTTP other settiongs ##include http.conf 注意：需要修改一下client.conf配置文件 # FastDFS客户端存放日志文件的目录 base_path= # 运行tracker服务的机器ip tracker_server=172.17.0.1:22122 自定义Django文件存储系统 Django自带文件存储系统，但是默认文件存储在本地，将文件保存到FastDFS服务器上，所以需要自定义文件存储系统。 在项目/utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下 from django.conf import settings from django.core.files.storage import Storage from django.utils.deconstruct import deconstructible from fdfs_client.client import Fdfs_client @deconstructible class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): \"\"\" 初始化 :param base_url: 用于构造图片完整路径使用，图片服务器的域名 :param client_conf: FastDFS客户端配置文件的路径 \"\"\" if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf def _open(self, name, mode='rb'): \"\"\" 用不到打开文件，所以省略 \"\"\" pass def _save(self, name, content): \"\"\" 在FastDFS中保存文件 :param name: 传入的文件名 :param content: 文件内容 :return: 保存到数据库中的FastDFS的文件名 \"\"\" client = Fdfs_client(self.client_conf) ret = client.upload_by_buffer(content.read()) if ret.get(\"Status\") != \"Upload successed.\": raise Exception(\"upload file failed\") file_name = ret.get(\"Remote file_id\") return file_name def url(self, name): \"\"\" 返回文件的完整URL路径 :param name: 数据库中保存的文件名 :return: 完整的URL \"\"\" return self.base_url + name def exists(self, name): \"\"\" 判断文件是否存在，FastDFS可以自行解决文件的重名问题 所以此处返回False，告诉Django上传的都是新文件 :param name: 文件名 :return: False \"\"\" return False 说明: 自定义文件存储系统的方法如下： 1）需要继承自django.core.files.storage.Storage，如 from django.core.files.storage import Storage class FastDFSStorage(Storage): ... 2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取 from django.conf import settings from django.core.files.storage import Storage class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf 3）存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。 _open(name, mode='rb') 被Storage.open()调用，在打开文件时被使用。 _save(name, content) 被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。 Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。 exists(name) 如果名为name的文件在文件系统中存在，则返回True，否则返回False。 url(name) 返回文件的完整访问URL delete(name) 删除name的文件 listdir(path) 列出指定路径的内容 size(name) 返回name文件的总大小 注意，并不是这些方法全部都要实现，可以省略用不到的方法。 4）需要为存储类添加django.utils.deconstruct.deconstructible装饰器 在Django配置中设置自定义文件存储类 在settings.py文件中添加设置 # django文件存储 DEFAULT_FILE_STORAGE = '项目名.utils.fastdfs.fdfs_storage.FastDFSStorage' # FastDFS FDFS_URL = 'http://域名:端口' FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf') 添加image域名 在/etc/hosts中添加访问FastDFS storage服务器的域名 127.0.0.1 xx域名 "},"Utils/Git基本命令.html":{"url":"Utils/Git基本命令.html","title":"Git","keywords":"","body":"Git常用命令 帮助信息 git help 显示常用的git 和使用简短说明 git help -a 显示所有的命令 git help -g 查看使用手册 git help 命令 / git 命令 help 查看某命令的使用说明, F键下一页，B键上一页，Q退出 git 配置（全局配置） 所有的配置都会保存到当前用户目录下的: .gitconfig 文件中 git config --global user.name '名称' 配置用户名 git config --global user.email '邮箱名' 配置邮箱 git config --list 查看配置信息 git config --unset --global user.name '名称' 重置信息 git config --global corlor.ui true 初始化项目 git init 初始化项目 查看状态 git status 状态： untracked:未跟踪的文件 modified: 修改后未添加提交的文件 添加文件 git add .或具体文件 添加当前文件夹的文件或具体文件 提交文件 git commit -m '提交信息' 提交 git commit -am '提交信息' 添加提交 查看提交日志 git log --oneline --decorate --all -10 --graph --author='作者' --index='文件名' --before='2019-3-1/1 week' --oneline:一行显示提交日志 --decorate:显示详细 --all:显示在所有分支上的提交 -10:显示数量 --graph:显示分支信息 --author:指定作者 --grep:搜索某文件 --before:某时间之前 查看文件修改前和修改后的区别 git diff 文件名 查看文件修改的区别，不指明文件则所以修改文件的区别 Git跟踪rename文件/移动文件 git mv 原文件名 新文件名 重命名/移动文件夹或文件名 git add . git commit -m '信息' 删除文件 git rm 文件名1 文件名2 。。。 git rm -r 文件夹名 递归删除 恢复文件 git checkout HEAD^ -- 需要恢复的文件名 HEAD:最近的一次提交 HEAD^:最近的一次提交的上一次提交 HEAD^^:最近的一次提交的上两次提交 HEAD^^...:最近的一次提交的上n次提交 --:当前分支 恢复提交 git revert 提交号 重置提交指针 git reset 选项 提交号 --soft:软重置，不会影响工作区和暂存区的东西 --hard:工作区和暂存区直接重置到指定的状态 --mixed: 默认，会把暂存区重置到指定的状态，并把指针指到当前位置 git status 先看一下add 中的文件 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 - HEAD^ 表示上一个版本，即上一次的commit，也可以写成HEAD~1 - 如果进行两次的commit，想要都撤回，可以使用HEAD~2 git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了 查看/创建/切换分支 git branch -a 查看分支 git branch -r 查看远程分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 查看两个分支之间的区别 git diff master..branch1 文件名 查看两个分支（文件）之间的区别，a表示两点左边的分支，b表示右边的分支 合并分支 git checkout master git merge 分支名 解决合并冲突 手动解决冲突 Git用>>>>>>标记出不同分支的内容 重命名/删除分支 git branch -m 原分支名 新分支名 git branch -d 分支名 保存修改进度 git stash save '描述信息' git stash list 查看工作进度信息 git stash show -p 工作进度代号 查看工作进度和现在的区别 git apply 工作进度代号 恢复工作进度 git shash drop 工作进度代号 删除工作进度 git apply pop 工作进度代号 恢复工作进度同时删除 添加别名 git config --global alias.co(别名) checkout(命令) 或 编辑当前用户文件夹下的.bash_profile文件 alias gco='git checkout' 保存退出 source ~/.bash_profile或重启终端 全局忽略跟踪文件 git config --global core.excludesfile ~/.gitignore_global 告诉git全局范围中忽略的文件包含在.gitignore_global文件中 编辑.gitignore_global需要忽略的文件 项目级忽略文件 在项目根目录下创建.gitignore文件 在.gitignore文件下添加忽略文件 如果你不想推什么文件到git 可以运行这个命令： git update-index --assume-unchanged xxx/xxx.py 忽略已被跟踪的文件 忽略规则只针对还没有被git跟踪的文件及文件夹有效。若需要忽略规则对已被跟踪的文件及文件夹有效，则需要取消对文件或文件夹的跟踪 git rm -r --cached ：取消对文件夹及文件夹下的所有子文件夹、文件的跟踪，文件夹及文件夹下的所有子文件夹、文件的状态将从跟踪状态变为未跟踪状态 git rm --cached ：取消对文件的跟踪，文件的跟踪状态将变为未跟踪状态 取消对文件或文件夹的跟踪之后，.gitignore文件中的忽略规则将会对取消了跟踪状态的文件或文件夹生效 创建远程版本库 git remote add origin 远程版本库url地址 git remote -v 查看远程库信息 git remote rm 移除远程库 推送版本库 git push [-u] origin 分支名 -u:跟踪远程分支的变化 修改远程仓库地址 1.修改命令 git remote origin set-url [url] 2.先删后加 git remote rm origin git remote add origin [url] 3.直接修改config文件 克隆版本库到本地 git clone 远程版本库url地址 目录名 克隆到指定目录下 更新本地版本库 git fetch 拉取版本库 git merge origin/master 合并 或 git pull = git fetch + git merge 第一种比较安全 基于版本库开发自己的版本库，fork到自己账户然后克隆到本地 git fork 远程版本库url地址 添加pull request git pull request 添加贡献者 GitHub中的setting中的collaborator添加贡献者 详情图 "},"Utils/Nginx/Nginx基础.html":{"url":"Utils/Nginx/Nginx基础.html","title":"Nginx基础","keywords":"","body":"datetime:2019/9/5 16:14 author:nzb Nginx的配置 安装Nginx。 yum -y install nginx 修改全局配置文件（/etc/nginx/nginx.conf）。 # 配置用户 user root; # 工作进程数(建议跟CPU的核数量一致) worker_processes auto; # 错误日志 error_log /var/log/nginx/error.log; # 进程文件 pid /run/nginx.pid; # 包含其他的配置 include /usr/share/nginx/modules/*.conf; # 工作模式(多路IO复用方式)和连接上限 events { use epoll; worker_connections 1024;(单进程的并发量, 总并发=进程数*单个进程的并发量) } # HTTP服务器相关配置 http { # 日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 访问日志 access_log /var/log/nginx/access.log main; # 开启高效文件传输模式 sendfile on; # 用sendfile传输文件时有利于改善性能 tcp_nopush on; # 禁用Nagle来解决交互性问题 tcp_nodelay on; # 客户端保持连接时间 keepalive_timeout 30; types_hash_max_size 2048; # 包含MIME类型的配置 include /etc/nginx/mime.types; # 默认使用二进制流格式 default_type application/octet-stream; # 包含其他配置文件 include /etc/nginx/conf.d/*.conf; # 包含项目的Nginx配置文件 include /root/project/conf/*.conf; } 编辑局部配置文件（/root/project/conf/nginx.conf）。 server { # 默认端口 listen 80; # 域名解析 server_name _; # 网站根目录 root /root/project/www; # 缓存图片文件 location ~ \\.(jpeg|jpg|png)${ # 缓存文件类型 # 缓存时间为1day expires 1d; # h:小时, d:天 } access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; # 默认访问页 location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; index index.html index.htm; } location /static/ { alias /root/project/stat/; expires 30d; } } server { listen 443; server_name _; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; } location /static/ { alias /root/project/static/; expires 30d; } } 到此为止，我们可以启动Nginx来访问我们的应用程序，HTTP和HTTPS都是没有问题的，如果Nginx已经运行，在修改配置文件后，我们可以用下面的命令重新启动Nginx。 重启Nginx服务器。 nginx -s reload 或 systemctl restart nginx 说明：可以对Django项目使用python manage.py collectstatic命令将静态资源收集到指定目录下，要做到这点只需要在项目的配置文件settings.py中添加STATIC_ROOT配置即可。 负载均衡配置 下面的配置中我们使用Nginx实现负载均衡，为另外的三个Nginx服务器（通过Docker创建）提供反向代理服务。 docker run -d -p 801:80 --name nginx1 nginx:latest docker run -d -p 802:80 --name nginx2 nginx:latest docker run -d -p 803:80 --name nginx3 nginx:latest user root; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } # 为HTTP服务配置负载均衡 http { upstream fangtx { # 分发：IP：端口 weight权重 max_fails失败次数 fail_timeout分发失败超时时间 server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; # 配置同一用户访问同一个web服务器(解决session丢失问题导致无法登陆和验证码验证(生成和验证不在同一台服务器)) ip_hash; } server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl; listen [::]:443 ssl; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_buffering off; proxy_pass http://fangtx; # 跟上面的upstream后的值一样 } } } 说明：Nginx在配置负载均衡时，默认使用WRR（加权轮询算法），除此之外还支持ip_hash、fair（需要安装upstream_fair模块）和url_hash算法。此外，在配置upstream模块时可以指定服务器的状态值，包括：backup（备份机器，其他服务器不可用时才将请求分配到该机器）、down、fail_timeout（请求失败达到max_fails后的暂停服务时间）、max_fails（允许请求失败的次数）和weight（轮询的权重）。 Keepalived 当使用Nginx进行负载均衡配置时，要考虑负载均衡服务器宕机的情况。为此可以使用Keepalived来实现负载均衡主机和备机的热切换，从而保证系统的高可用性。Keepalived的配置还是比较复杂，通常由专门做运维的人进行配置，一个基本的配置可以参照《Keepalived的配置和使用》。 "},"Utils/Nginx/Nginx进阶.html":{"url":"Utils/Nginx/Nginx进阶.html","title":"Nginx进阶","keywords":"","body":"datetime:2022-01-08 14:34:00 author:nzb Nginx 该文档由 html2text 生成，二次编辑的 简介 高性能 web服务器 反向代理服务器 占用内存少 高并发处理強 正向代理和反向代理 正向代理 以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端 反向代理 正向代理类似一个跳板机，代理访问外部资源，比如：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器，他能访问那个我不能访问的网站 ，于是我先连上代理服务器，告诉它我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。例子：VPN 配置文件详解 # ： 表示配置文件中默认关闭 # user nobody; 配置worker进程用户，主进程master是root，nobody也是一个Linux用户，一般用于启动程序，没有密码 worker_processes auto; 工作进程数，根据硬件调整，通常等于CPU数量或者2倍于CPU数量(建议跟CPU的核数量一致) error_log /var/log/nginx/error.log; 配置全局错误日志级类型，【debug | info | notice | warn | error | crit 】，默认是error # error_log /var/log/nginx/error.log notice; # error_log /var/log/nginx/error.log info; pid /run/nginx.pid; 配置进程pid文件 events events { use epoll; # 配置工作模式(多路IO复用方式)和连接上限 worker_connections 1024; # 单进程的并发量，最大：65535 ​总并发=进程数*单个进程的并发量 单个进程的并发量：655535 } http HTTP服务器相关配置，利用它的反向代理功能提供负载均衡支持 http { include /etc/nginx/mime.types; # 配置Nginx支持哪些多媒体类型，可以在conf/mime.types查看支持哪些多媒体文件 default_type application/octet-stream; # 默认使用二进制流格式，流类型，可以理解为支持任意类型 # 配置日志格式，main是一个变量名 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; # 配置access.log日志及存放路径，并使用上面定义的main日志格式 sendfile on; # 开启高效文件传输模式 tcp_nopush on; # 用sendfile传输文件时有利于改善性能 tcp_nodelay on; # 禁用Nagle来解决交互性问题 keepalive_timeout 30; # 客户端保持连接时间，单位秒 gzip on; # 开启gzip压缩输出 include /etc/nginx/conf.d/*.conf; # 包含其他配置文件，里面文件包含server虚拟主机 include /root/project/conf/*.conf; # 包含项目的Nginx配置文件 server{ # 配置虚拟主机，一个http里面可以有多个(server_name和listen不能完全一样)，可以写在conf.d目录下，包含进来 listen 80; # 配置监听端口，默认端口80 server_name localhost; # 配置服务名，域名解析 root /root/project/www; # 网站根目录 charset koi8-r; # 配置字符集 access_log /root/project/logs/access.log main; # 配置本虚拟主机的访问日志 error_log /root/project/logs/error.log main; location / { # 默认访问页，默认的匹配斜杠“/”（根路径）的请求，当访问路径中有斜杠/，会被location匹配到并进行处理 include uwsgi_params; uwsgi_pass 172.18.61.250:8000; index index.html index.htm; } location / test { # test会拼接到root路径之后 root /opt/www; # root后面的值就是：/test中的“/”（根路径） index index.html index.htm; } error_page 404; # 配置404页面 # error_page 500 502 503 504 /50x.html; # 配置50x错误页面 location /50x.html { # 精准匹配 root html; } } } 主要应用 静态网站部署 包括HTML，js，css，图片等 负载均衡 硬件负载均衡 比如：F5、深信服、Array等 优点是有厂商专业的技术服务团队提供支持，性能稳定 缺点是费用昂贵，对于规模较小的网络应用成本太高 软件负载均衡 比如：Nginx、LVS、HAProxy等 优点是免费开源，成本低廉 主配置 http { # 为HTTP服务配置负载均衡 upstream www.example.com { # 分发：IP：端口 weight 权重 max_fails失败次数 fail_timeout分发失败超时时间 server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; ip_hash; } # 配置同一用户访问同一个web服务器(解决session丢失问题导致无法登陆和验证码验证(生成和验证不在同一台服务器)) server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl; listen [::]:443 ssl; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_buffering off; proxy_pass http://www.example.com; # 跟上面的upstream后的值一样 } } } 其他配置 配置1：备份服务器 # 可以用于更新代码 upstream www.example.com { server 172.18.61.250:801; server 172.18.61.250:803 backup; # 其他所有的非backup服务器down掉的时候，才请求backup服务器 } 配置2 upstream www.example.com { server 172.18.61.250:801; server 172.18.61.250:803 down; # down表示当前的服务器是down状态，不参与负载均衡，基本没什么用 } 负载均衡策略 轮询（默认） # 注意：这里的轮询并不是每个请求轮流分配到不同的后端服务器，与ip_hash类似，但是按照访问url的hash结果来分配请求， # 使得每个url定向到同一个后端服务器，主要应用与后端服务器为缓存时的场景下，如果后端服务器down掉，将自动删除。 # 每台服务器交替访问，需要保证服务器的性能一样，否则会出现请求堆积导致宕机。 upstream www.example.com { server 172.18.61.250:801; server 172.18.61.250:802; server 172.18.61.250:803; } 权重 # 每个请求按一定比例分发到不同的后端服务器，weight值越大访问的比例越大，用于后端服务器性能不均的情况。权重按服务器性能给。 upstream www.example.com { # 分发：IP：端口 weight 权重 max_fails失败次数 fail_timeout分发失败超时时间 server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; ip_hash; } # 配置同一用户访问同一个web服务器(解决session丢失问题导致无法登陆和验证码验证(生成和验证不在同一台服务器)) # 注意：不是说4个请求一次性给第一个，而是给一个后第二个请求给第二个，第三个给第三个，等等 最少连接数 # web请求会被转移到连接数最少的服务器上，当不知道服务器性能时，不过可能导致请求堆积，因为最少连接的应该性能差。 upstream www.example.com { least_conn; server 172.18.61.250:801; server 172.18.61.250:802; server 172.18.61.250:803; } ip_hash # ip_hash也叫ip绑定，每个请求按访问ip的hash值分配，这样每个访问客户端会固定访问一个后端服务器，可以解决会话session丢失的问题。但是模完的数相同（hash碰撞），也会导致请求堆积。 # 算法：hash（\"124.207.55.82\"）% 3 # 客户端ip # 3：3台服务器 upstream www.example.com { server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; ip_hash; } # 配置同一用户访问同一个web服务器(解决session丢失问题导致无法登陆和验证码验证(生成和验证不在同一台服务器)) 静态代理 图片、css、html、js等交给Nginx处理 实现 方式一：在nginx.conf的location中配置静态资源的后缀，进行拦截 例如：当访问静态资源，则从Linux服务器/opt/static目录下获取（举例）location ~.*\\\\.(gif|jpg|png|js|css)$ { root /opt/static; } ~：正则匹配开始 .：任意字符 *：​任意次数一个或多个 \\：转义字符 $：匹配结尾​ 方式二：在nginx.conf的location中配置静态资源所在目录，进行拦截 例如：当访问静态资源，则从Linux服务器/opt/static目录下获取（举例）常用 location ~.*/(css|js|img|images) { # 不匹配以什么结尾，匹配目录 root /opt/static; } 动静分离 动态资源：如Django项目 静态资源：如图片、css、js等由Nginx服务器完成，选择Nginx是因为Nginx效率高 虚拟主机 例如：58同城 虚拟主机，就是把一台物理服务器划分成多个“虚拟”的服务器，这样我们的一台物理服务器就可以做多个服务器来使用，从而可以配置多个网站。 实现 方法一：基于端口的虚拟主机（一般不用，了解） 基于端口的虚拟主机配置，使用端口来区分 浏览器使用同一个域名 + 端口 或 同一个 ip地址 + 端口访问 server { listen 8080; server_name www.example1.com; location / { proxy_pass http://www.myweb.com; } } server { listen 9090; server_name www.example1.com; location / { proxy_pass http://www.myweb1.com; } } 方法二：基于域名的虚拟主机（掌握） 基于域名的虚拟主机是最常见的一种虚拟主机 server { listen 80; server_name www.example1.com; location / { proxy_pass http://www.myweb.com; } } server { listen 80; server_name www.example2.com; location / { proxy_pass http://www.myweb2.com; } } "},"InterviewPreparation/":{"url":"InterviewPreparation/","title":"目录","keywords":"","body":"datetime:2020/10/27 15:46 author:nzb 该目录主要是各个时间段的面试资料以及个人认为的经典题（错题集） 基础 工欲善其事，必先利其器，基础是最重要的。强推：技术面试必备基础知识源地址 技术面试必备基础知识 操作系统 网络 数据库 系统设计 数据结构与算法 算法 线性表 栈 队列 特殊矩阵压缩存储 串 树与二叉树 Python 常用数据结构和算法 错题集 Python 的内存管理机制及调优手段？ 内存管理机制: 引用计数、垃圾回收（引用计数（降到 0）、标记清除、分代回收）、内存池 调优手段：手动垃圾回收、调高垃圾回收阈值、避免循环引用 回调函数，如何通信的? 闭包延迟 单例模式 迭代器和生成器 Python的魔法方法 文件操作 遍历目录与子目录 字符串相关 数字字符串转整形 | 数字字符串排序 | 正则表达式 进程线程协程 进程和线程 | 多进程多线程以及协程的理解 | Python异步使用场景有那些 | 多线程竞争 | Python的线程同步 | 锁及其分类 | 同步、异步、阻塞、非阻塞 | 僵尸进程和孤儿进程及怎么避免僵尸进程？ 网络编程 TCP、UDP | 浏览器通过 WSGI 请求动态资源的过程 | 浏览器访问www.baidu.com的过程 | Post和Get请求的区别 | cookie和session的区别 | 三次握手和四次挥手 HTTPS和HTTP的区别 | 使用Socket套接字需要传入哪些参数 | HTTP常见请求头 | OSI七层模型和TCP/IP四层模型以及五层模型 | url的形式 | 什么是WSGI和uwsgi以及uWSGI 爬虫相关 数据库 历史记录 2020/10/27 "},"InterviewPreparation/TechnicalInterviews/TechnicalInterviews.html":{"url":"InterviewPreparation/TechnicalInterviews/TechnicalInterviews.html","title":"技术面试必备基础知识","keywords":"","body":"datetime:2022-03-08 17:19 author:nzb 技术面试必备基础知识 传送门 操作系统 计算机操作系统 概述 基本特征 1. 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享 共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。 3. 虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。 主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。 * 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 4. 异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 基本功能 1. 进程管理 2. 内存管理 3. 文件管理 4. 设备管理 系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 宏内核和微内核 1. 宏内核 2. 微内核 中断分类 1. 外中断 由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断（Ctril + c）等。 2. 异常 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入 在用户程序中使用系统调用。 进程管理 进程与线程 1. 进程 进程是资源分配的基本单位。 2. 线程 线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。 3. 区别 Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 进程状态的切换 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 进程调度算法 1. 批处理系统 没有太多的用户操作 1.1 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 shortest job first（SJF） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 shortest remaining time next（SRTN） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 2. 交互式系统 有大量的用户交互操作 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 3. 实时系统 实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步 1. 临界区 对临界资源进行访问的那段代码称为临界区。 2. 同步与互斥 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量 4. 管程 经典同步问题 1. 哲学家进餐问题 2. 读者-写者问题 进程通信 进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 1. 管道 管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。 2. FIFO 命名管道，去除了管道只能在父子进程中使用的限制。常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 3. 消息队列 相比于 FIFO，消息队列具有以下优点： 可独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 4. 信号量 一个计数器，用于为多个进程提供对共享数据对象的访问。 5. 共享存储 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 6. 套接字 用于不同机器间的进程通信 死锁 必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 处理方法 鸵鸟策略 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁检测与死锁恢复 不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 1. 每种类型一个资源的死锁检测 2. 每种类型多个资源的死锁检测 3. 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 死锁预防 在程序运行之前预防发生死锁。 1. 破坏互斥条件 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 2. 破坏占有和等待条件 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 3. 破坏不可抢占条件 4. 破坏环路等待 给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免 1. 安全状态 2. 单个资源的银行家算法 3. 多个资源的银行家算法 内存管理 虚拟内存 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 分页系统地址映射 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。 页面置换算法 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。 1. 最佳 OPT, Optimal replacement algorithm 所选择被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 2. 最近最久未使用 LRU, Least Recently Used 在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 3. 最近未使用 NRU, Not Recently Used 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 4. 先进先出 FIFO, First In First Out 选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面换出，导致缺页率升高。 5. 第二次机会算法 FIFO 改进版 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 6. 时钟 第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段 段页式 分页与分段的比较 设备管理 磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法 读写一个磁盘块的时数据影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 1. 先来先服务 FCFS, First Come First Served 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先 SSTF, Shortest Seek Time First * 优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 3. 电梯算法 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 链接 Linux 网络 计算机网络 概述 网络的网络 ISP 互联网服务提供商 ISP 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方 对等（P2P）：不区分客户和服务器 电路交换与分组交换 1. 电路交换 用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 分组交换 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 1. 排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 2. 处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 3. 传输时延 主机或路由器传输数据帧所需要的时间。 4. 传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 计算机网络体系结构 1. 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报 。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI 其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP/IP 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 4. 数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 物理层 通信方式 根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 链路层 包含协议 CSMA/CD 协议 PPP 协议 基本问题 1. 封装成帧 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输 透明表示一个实际存在的事物看起来好像不存在一样。 透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 信道分类 1. 广播信道 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 信道复用技术 1. 频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。 会一直占用一部分信道资源，利用率都不高。 2. 时分复用 时分复用的所有主机在不同的时间占用相同的频率带宽资源。 会一直占用一部分信道资源，利用率都不高。 3. 统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据集集中起来组成统计时分复用帧然后发送。 4. 波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5. 码分复用 CSMA/CD 协议 多点接入、载波监听、碰撞检测 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 2. 点对点信道 一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 PPP 协议 PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式 F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 MAC 地址 MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 以太网 以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 交换机 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 虚拟局域网 虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 网络层 包含协议 IP 协议 ARP 地址解析协议 ICMP 网际控制报文协议 IGMP 网际组管理协议 RIP、OSPF 内部网关协议 BGP 外部网关协议 概述 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式 1. 分类 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {, } 2. 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {, , } 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类 地址解析协议 ARP ARP 实现由 IP 地址得到 MAC 地址。 网际控制报文协议 ICMP ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1. Ping 主要用来测试两台主机之间的连通性。 Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 2. Traceroute 用来跟踪一个分组从源点到终点的路径 虚拟专用网 VPN 一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 网络地址转换 NAT 路由器的结构 路由器从功能上可以划分为 路由选择 分组转发。 分组转发结构由三个部分组成 交换结构 一组输入端口 一组输出端口。 路由器分组转发流程 路由选择协议 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1. 内部网关协议 RIP RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 3. 外部网关协议 BGP 边界网关协议 传输层 包含协议 TCP 传输控制协议 UDP 用户数据报协议` UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 TCP 可靠传输 TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 TCP 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。 TCP 流量控制 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 1. 慢开始与拥塞避免 2. 快重传与快恢复 应用层 包含协议 FTP 文本传输协议 HTTP 超文本传输协议 DHCP 动态主机配置协议 TELNET 远程登录协议 SMTP 邮件发送协议 POP3、IMAP 邮件读取协议` 域名系统 DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。 这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 文件传送协议 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 远程登录协议 TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. SMTP 2. POP3 3. IMAP 常用端口 Web 页面请求过程 1. DHCP 配置主机信息 2. ARP 解析 MAC 地址 3. DNS 解析域名 4. HTTP 请求页面 HTTP 一 、基础概念 请求和响应报文 URL 统一资源定位符 二、HTTP 方法 GET 获取资源 HEAD 获取报文首部 POST 传输实体主体 PUT 上传文件 PATCH 对资源进行部分修改 DELETE 删除文件 OPTIONS 查询支持的方法 CONNECT 要求在与代理服务器通信时建立隧道 TRACE 追踪路径 三、HTTP 状态码 1XX 信息 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误 四、HTTP 首部 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 通用首部字段 e.g：Date 创建报文的日期时间 请求首部字段 e.g： Accept 用户代理可处理的媒体类型 Authorization Web 认证信息 User-Agent HTTP 客户端程序的信息 响应首部字段 e.g：Location 令客户端重定向至指定 URI 实体首部字段 e.g： Content-Type 实体主体的媒体类型 Allow 资源可支持的 HTTP 方法 五、具体应用 连接管理 1. 短连接与长连接 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. 流水线 在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 Cookie 缓存 内容协商 内容编码 范围请求 分块传输编码 多部分对象集合 虚拟主机 通信数据转发 1. 代理 使用代理的主要目的是： 缓存 负载均衡 网络访问控制 访问日志记录 2. 网关 3. 隧道 六、HTTPS HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 加密 1. 对称密钥加密 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2.非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3. HTTPS 采用的加密方式 HTTPS 采用混合的加密机制，正是利用了上面提到的方案： 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性; 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） 认证 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 完整性保护 HTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 七、HTTP/2.0 HTTP/1.x 缺陷 二进制分帧层 服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩 八、HTTP/1.1 新特性 九、GET 和 POST 比较 作用 GET 用于获取资源，而 POST 用于传输实体主体。 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 可缓存 XMLHttpRequest XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 Socket 一、I/O 模型 一个输入操作通常包括两个阶段： 1、等待数据准备好 2、从内核向进程复制数据 阻塞式 I/O 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 CPU 利用率会比较高 非阻塞式 I/O 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling） CPU 利用率比较低 I/O 复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O 信号驱动 I/O 应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中 相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高 异步 I/O 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号 异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O 五大 I/O 模型比较 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。 异步 I/O：第二阶段应用进程不会阻塞。 同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。 非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。 二、I/O 复用 select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。 select select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。 poll poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。 比较 1. 功能 select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。 select 会修改描述符，而 poll 不会； select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制； poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。 2. 速度 select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。 3. 可移植性 几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。 epoll epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。 工作模式 epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。 1. LT 模式 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 2. ET 模式 和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。 很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 应用场景 很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。 1. select 应用场景 select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。 2. poll 应用场景 poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。 3. epoll 应用场景 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。 需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。 通俗举例 数据库 数据库系统原理 一、事务 概念 满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 ACID 1. 原子性（Atomicity） 2. 一致性（Consistency） 3. 隔离性（Isolation） 4. 持久性（Durability） AUTOCOMMIT MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。 二、并发一致性问题 丢失修改 读脏数据 不可重复读 幻影读 三、封锁 封锁粒度 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型 1. 读写锁 互斥锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 2. 意向锁 封锁协议 1. 三级封锁协议 一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 解决丢失修改问题。 因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 解决读脏数据问题。 因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 解决不可重复读的问题。 因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 2. 两段锁协议 MySQL 隐式与显示锁定 MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： SELECT ... LOCK In SHARE MODE; 加 S 锁 SELECT ... FOR UPDATE; 加 X 锁 四、隔离级别 未提交读（READ UNCOMMITTED） 事务中的修改，即使没有提交，对其它事务也是可见的。 提交读（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化（SERIALIZABLE） 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 五、多版本并发控制 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 基本思想 版本号 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号 TRX_ID ：事务开始时的系统版本号。 Undo 日志 ReadView 快照读与当前读 1. 快照读 MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。 2. 当前读 MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。 在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。 SELECT * FROM table WHERE ? lock in share mode; SELECT * FROM table WHERE ? for update; 六、Next-Key Locks 使用 MVCC + Next-Key Locks 可以解决幻读问题 Record Locks 锁定一个记录上的索引，而不是记录本身。 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 Gap Locks 锁定索引之间的间隙，但是不包含索引本身。 Next-Key Locks 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间： (-∞, 10] (10, 11] (11, 13] (13, 20] (20, +∞) 七、关系数据库设计理论 函数依赖 异常 范式 八、ER 图 实体的三种联系 三个组成部分：实体、属性、联系 包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。 表示出现多次的关系 联系的多向性 表示子类 用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 SQL 语法 SQL 练习 MySQL 一、索引 B+ Tree 原理 MySQL 索引 1. B+Tree 索引 是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 2. 哈希索引 哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3. 全文索引 MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4. 空间数据索引 MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 索引优化 1. 独立的列 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 联合索引（多列索引） 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 3. 索引列的顺序 让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity, COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity, COUNT(*) FROM payment; staff_id_selectivity: 0.0001 customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 5. 覆盖索引 索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 索引失效 没有遵循最左匹配原则。 键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 一些关键字会导致索引失效，例如 or， ！= ， not in，is null ,is not unll like查询是以%开头 隐式转换会导致索引失效。 索引列是表达式的一部分，或者是函数的参数 二、查询性能优化 使用 Explain 进行分析 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 优化数据访问 1. 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2. 减少服务器端扫描的行数 最有效的方式是使用索引来覆盖查询。 重构查询方式 1. 切分大查询 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 DELETE FROM messages WHERE create 0 2. 分解大连接查询 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 SELECT * FROM tag JOIN tag_post ON tag_post.tag_id=[tag.id](http://tag.id/) JOIN post ON tag_post.post_id=[post.id](http://post.id/) WHERE tag.tag='mysql'; SELECT * FROM tag WHERE tag='mysql'; SELECT * FROM tag_post WHERE tag_id=1234; SELECT * FROM post WHERE [post.id](http://post.id/) IN (123,456,567,9098,8904); 三、存储引擎 InnoDB MyISAM 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 四、数据类型 整型 浮点数 字符串 时间和日期 五、切分 水平切分 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而减缓单个数据库的压力。 垂直切分 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 Sharding 策略 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题 1. 事务问题 使用分布式事务来解决，比如 XA 接口。 2. 连接 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 3. ID 唯一性 使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 六、复制 主从复制 主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。 读写分离 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 参考资料 Redis 一、概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 二、数据类型 STRING set get del LIST rpush lrange list-key 0 -1 lindex list-key 1 lpop SET sadd smembers sismember srem HASH hset hash-key sub-key1 value1 hgetall hdel hash-key sub-key2 hget hash-key sub-key1 ZSET zadd zset-key 728 member1 zrange zset-key 0 -1 withscores zrangebyscore zset- key 0 800 withscores zrem 三、数据结构 字典 dictht 是一个散列表结构，使用拉链法解决哈希冲突。 跳跃表 是有序集合的底层实现之一。 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。 四、使用场景 计数器 可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 查找表 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 例如 DNS 记录就很适合使用 Redis 进行存储。 消息队列 List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息 不过最好使用 Kafka、RabbitMQ 等消息中间件。 会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。 ZSet 可以实现有序性操作，从而实现排行榜等功能。 五、Redis 与 Memcached 数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式 Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 六、键的过期时间 Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 七、数据淘汰策略 可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 八、持久化 Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB 持久化 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 九、事务 一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。 事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 十、事件 Redis 服务器是一个事件驱动程序。 文件事件 时间事件 事件的调度与执行 十一、复制 连接过程 主从链 十二、Sentinel Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。 十三、分片 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。 十四、一个简单的论坛系统分析 文章信息 点赞功能 对文章进行排序 系统设计 系统设计基础 一、性能 性能指标 1. 响应时间 指某个请求从发出到接收到响应消耗的时间。 2. 吞吐量 系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。 3. 并发用户数 指系统能同时处理的并发用户请求数量。 性能优化 1. 集群 将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。 2. 缓存 缓存能够提高性能的原因如下： 缓存数据通常位于内存等介质中，这种介质对于读操作特别快； 缓存数据可以位于靠近用户的地理位置上； 可以将计算结果进行缓存，从而避免重复计算。 3. 异步 某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。 二、伸缩性 指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。 伸缩性与性能 如果系统存在性能问题，那么单个用户的请求总是很慢的； 如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。 实现伸缩性 应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。 关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。 对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。 三、扩展性 指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。 实现可扩展主要有两种方式： 使用消息队列进行解耦，应用之间通过消息传递进行通信； 使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。 四、可用性 冗余 保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。 应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。 存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。 监控 对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。 服务降级 服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。 五、安全性 要求系统在应对各种攻击手段时能够有可靠的应对措施。 分布式 一、分布式锁 在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。 阻塞锁通常使用互斥量来实现： 互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态； 互斥量为 1 表示未锁定状态。 1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。 数据库的唯一索引 获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。 存在以下几个问题： 锁没有失效时间，解锁失败的话其它进程无法再获得该锁； 只能是非阻塞锁，插入失败直接就报错了，无法重试； 不可重入，已经获得锁的进程也必须重新获取锁。 Redis 的 SETNX 指令 使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。 SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。 EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。 Redis 的 RedLock 算法 使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。 尝试从 N 个互相独立 Redis 实例获取锁； 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功； 如果获取锁失败，就到每个实例上释放锁。 Zookeeper 的有序节点 1. Zookeeper 抽象模型 Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。 2. 节点类型 永久节点：不会因为会话结束或者超时而消失； 临时节点：如果会话结束或者超时就会消失； 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。 3. 监听器 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。 4. 分布式锁实现 创建一个锁目录 /lock； 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点； 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁； 执行业务代码，完成后，删除对应的子节点。 5. 会话超时 如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。 6. 羊群效应 一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。 二、分布式事务 指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。 分布式锁和分布式事务区别： 锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。 而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。 2PC 两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。 1. 运行过程 1.1 准备阶段 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。 1.2 提交阶段 如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。 需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。 2. 存在的问题 2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。 2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。 2.3 数据不一致 在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。 2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。 本地消息表 本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。 三、CAP 分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。 一致性 一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。 对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。 可用性 可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。 在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。 分区容忍性 网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。 在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。 权衡 在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。 可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时， 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性； 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。 四、BASE BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 基本可用 指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。 软状态 指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。 最终一致性 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。 ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。 在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。 五、Paxos 用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。 主要有三类节点： 提议者（Proposer）：提议一个值； 接受者（Acceptor）：对每个提议进行投票； 告知者（Learner）：被告知投票的结果，不参与投票过程。 执行过程 规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。 1. Prepare 阶段 2. Accept 阶段 3. Learn 阶段 约束条件 1. 正确性 指只有一个提议值会生效。 因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。 2. 可终止性 指最后总会有一个提议生效。 Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。 六、Raft Raft 也是分布式一致性协议，主要是用来竞选主节点。 单个 Candidate 的竞选 多个 Candidate 竞选 数据同步 集群 一、负载均衡 集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。 负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。 负载均衡器可以用来实现高可用以及伸缩性： 高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用 伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点 负载均衡器运行过程包含两个部分： 根据负载均衡算法得到转发的节点 进行转发 负载均衡算法 1. 轮询（Round Robin） 轮询算法把每个请求轮流发送到每个服务器上。该算法比较适合每个服务器的性能差不多的场景。 2. 加权轮询（Weighted Round Robbin） 加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。 3. 最少连接（least Connections） 由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。 最少连接算法就是将请求发送给当前最少连接数的服务器上。 4. 加权最少连接（Weighted Least Connection） 在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。 5. 随机算法（Random） 把请求随机发送到服务器上。 和轮询算法类似，该算法比较适合服务器性能差不多的场景。 6. 源地址哈希法 (IP Hash) 源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。 可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session） 转发实现 1. HTTP 重定向 HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。 缺点： 需要两次请求，因此访问延迟比较高； HTTP 负载均衡器处理能力有限，会限制集群的规模。 该负载均衡转发的缺点比较明显，实际场景中很少使用它。 2. DNS 域名解析 在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。 优点： DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。 缺点： 由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。 大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。 3. 反向代理服务器 反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。 在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。 优点： 与其它功能集成在一起，部署简单。 缺点： 所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。 4. 网络层 在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。 源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。 优点： 在内核进程中进行处理，性能比较高。 缺点： 和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。 5. 链路层 在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。 通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。 这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。 这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。 二、集群下的 Session 管理 一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。 Sticky Session 需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。 缺点： 当服务器宕机时，将丢失该服务器上的所有 Session。 Session Replication 在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。 缺点： 占用过多内存； 同步过程占用网络带宽以及服务器处理器时间。 Session Server 使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。 优点： 为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。 缺点： 需要去实现存取 Session 的代码。 攻击技术 一、跨站脚本攻击 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。 危害 窃取用户的 Cookie 伪造虚假的输入表单骗取个人信息 显示伪造的文章或者图片 防范手段 1. 设置 Cookie 为 HttpOnly 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。 2. 过滤特殊字符 例如将 转义为 &gt;，从而避免 HTML 和 Jascript 代码的运行。 二、跨站请求伪造 跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。 XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。 防范手段 1. 检查 Referer 首部字段 Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。 2. 添加校验 Token 在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。 3. 输入验证码 因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。 三、SQL 注入攻击 服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。 防范手段 1. 对传入的参数进行编码转义 2. 单引号转换 将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。 四、拒绝服务攻击 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。 缓存 一、缓存特征 命中率 当某个请求能够通过访问缓存而得到响应时，称为缓存命中。 缓存命中率越高，缓存的利用率也就越高。 最大空间 缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。 当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。 淘汰策略 FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。 LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。 LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。 二、缓存位置 浏览器 当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。 ISP 网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。 反向代理 反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。 本地缓存 使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。 分布式缓存 使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。 相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。 数据库缓存 MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。 CPU 多级缓存 CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。 三、CDN 内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。 CDN 主要有以下优点： 更快地将数据分发给用户； 通过部署多台服务器，从而提高系统整体的带宽性能； 多台服务器可以看成是一种冗余机制，从而具有高可用性。 四、缓存问题 缓存穿透 指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。 解决方案： 对这些不存在的数据缓存一个空数据； 对这类请求进行过滤。 缓存雪崩 指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。 在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。 解决方案： 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现； 分散设置缓存时间 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 使用分布式缓存 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。 缓存预热 缓存一致性 缓存一致性要求数据更新的同时缓存数据也能够实时更新。 解决方案： 在数据更新的同时立即去更新缓存； 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。 要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。 缓存 “无底洞” 现象 指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。 产生原因 缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。 解决方案： 优化批量数据操作命令； 减少网络通信次数； 降低接入成本，使用长连接 / 连接池，NIO 等。 五、数据分布 哈希分布 哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。 传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。 顺序分布 将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。 顺序分布相比于哈希分布的主要优点如下： 能保持数据原有的顺序； 并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。 六、一致性哈希 Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。 七、LRU 消息队列 一、消息模型 点对点 消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。 发布/订阅 消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。 发布与订阅模式和观察者模式有以下不同： 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。 二、使用场景 异步处理 发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。 例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。 只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。 流量削锋 在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。 可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。 应用解耦 如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。 通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。 三、可靠性 发送端的可靠性 发送端完成操作后一定能将消息成功发送到消息队列中。 实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。 接收端的可靠性 接收端能够从消息队列成功消费一次消息。 两种实现方法： 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。 "},"InterviewPreparation/TechnicalInterviews/01-操作系统.html":{"url":"InterviewPreparation/TechnicalInterviews/01-操作系统.html","title":"操作系统","keywords":"","body":"datetime:2022-03-08 17:19 author:nzb 技术面试必备基础知识 传送门 操作系统 计算机操作系统 概述 基本特征 1. 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享 共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。 3. 虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。 主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。 * 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 4. 异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 基本功能 1. 进程管理 2. 内存管理 3. 文件管理 4. 设备管理 系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 宏内核和微内核 1. 宏内核 2. 微内核 中断分类 1. 外中断 由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断（Ctril + c）等。 2. 异常 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入 在用户程序中使用系统调用。 进程管理 进程与线程 1. 进程 进程是资源分配的基本单位。 2. 线程 线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。 3. 区别 Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 进程状态的切换 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 进程调度算法 1. 批处理系统 没有太多的用户操作 1.1 先来先服务 first-come first-serverd（FCFS） 非抢占式的调度算法，按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 shortest job first（SJF） 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 shortest remaining time next（SRTN） 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 2. 交互式系统 有大量的用户交互操作 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 3. 实时系统 实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步 1. 临界区 对临界资源进行访问的那段代码称为临界区。 2. 同步与互斥 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量 4. 管程 经典同步问题 1. 哲学家进餐问题 2. 读者-写者问题 进程通信 进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 1. 管道 管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。 2. FIFO 命名管道，去除了管道只能在父子进程中使用的限制。常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 3. 消息队列 相比于 FIFO，消息队列具有以下优点： 可独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 4. 信号量 一个计数器，用于为多个进程提供对共享数据对象的访问。 5. 共享存储 允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 6. 套接字 用于不同机器间的进程通信 死锁 必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 处理方法 鸵鸟策略 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 死锁检测与死锁恢复 不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 1. 每种类型一个资源的死锁检测 2. 每种类型多个资源的死锁检测 3. 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 死锁预防 在程序运行之前预防发生死锁。 1. 破坏互斥条件 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 2. 破坏占有和等待条件 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 3. 破坏不可抢占条件 4. 破坏环路等待 给资源统一编号，进程只能按编号顺序来请求资源。 死锁避免 1. 安全状态 2. 单个资源的银行家算法 3. 多个资源的银行家算法 内存管理 虚拟内存 虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 分页系统地址映射 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。 页面置换算法 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。 1. 最佳 OPT, Optimal replacement algorithm 所选择被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 2. 最近最久未使用 LRU, Least Recently Used 在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 3. 最近未使用 NRU, Not Recently Used 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 4. 先进先出 FIFO, First In First Out 选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面换出，导致缺页率升高。 5. 第二次机会算法 FIFO 改进版 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 6. 时钟 第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段 段页式 分页与分段的比较 设备管理 磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法 读写一个磁盘块的时数据影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 1. 先来先服务 FCFS, First Come First Served 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先 SSTF, Shortest Seek Time First * 优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。 3. 电梯算法 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 链接 Linux "},"InterviewPreparation/TechnicalInterviews/02-网络.html":{"url":"InterviewPreparation/TechnicalInterviews/02-网络.html","title":"网络","keywords":"","body":"datetime:2022-03-08 17:19 author:nzb 技术面试必备基础知识 传送门 网络 计算机网络 概述 网络的网络 ISP 互联网服务提供商 ISP 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方 对等（P2P）：不区分客户和服务器 电路交换与分组交换 1. 电路交换 用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 分组交换 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 1. 排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 2. 处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 3. 传输时延 主机或路由器传输数据帧所需要的时间。 4. 传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 计算机网络体系结构 1. 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报 。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI 其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP/IP 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 4. 数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 物理层 通信方式 根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 链路层 包含协议 CSMA/CD 协议 PPP 协议 基本问题 1. 封装成帧 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输 透明表示一个实际存在的事物看起来好像不存在一样。 透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 信道分类 1. 广播信道 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 信道复用技术 1. 频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。 会一直占用一部分信道资源，利用率都不高。 2. 时分复用 时分复用的所有主机在不同的时间占用相同的频率带宽资源。 会一直占用一部分信道资源，利用率都不高。 3. 统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据集集中起来组成统计时分复用帧然后发送。 4. 波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5. 码分复用 CSMA/CD 协议 多点接入、载波监听、碰撞检测 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 2. 点对点信道 一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 PPP 协议 PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式 F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 MAC 地址 MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 以太网 以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 交换机 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 虚拟局域网 虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 网络层 包含协议 IP 协议 ARP 地址解析协议 ICMP 网际控制报文协议 IGMP 网际组管理协议 RIP、OSPF 内部网关协议 BGP 外部网关协议 概述 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式 1. 分类 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {, } 2. 子网划分 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {, , } 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类 地址解析协议 ARP ARP 实现由 IP 地址得到 MAC 地址。 网际控制报文协议 ICMP ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1. Ping 主要用来测试两台主机之间的连通性。 Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 2. Traceroute 用来跟踪一个分组从源点到终点的路径 虚拟专用网 VPN 一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 网络地址转换 NAT 路由器的结构 路由器从功能上可以划分为 路由选择 分组转发。 分组转发结构由三个部分组成 交换结构 一组输入端口 一组输出端口。 路由器分组转发流程 路由选择协议 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1. 内部网关协议 RIP RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 3. 外部网关协议 BGP 边界网关协议 传输层 包含协议 TCP 传输控制协议 UDP 用户数据报协议` UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 TCP 可靠传输 TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 TCP 滑动窗口 窗口是缓存的一部分，用来暂时存放字节流。 TCP 流量控制 流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 1. 慢开始与拥塞避免 2. 快重传与快恢复 应用层 包含协议 FTP 文本传输协议 HTTP 超文本传输协议 DHCP 动态主机配置协议 TELNET 远程登录协议 SMTP 邮件发送协议 POP3、IMAP 邮件读取协议` 域名系统 DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。 这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 文件传送协议 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 动态主机配置协议 DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 远程登录协议 TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. SMTP 2. POP3 3. IMAP 常用端口 Web 页面请求过程 1. DHCP 配置主机信息 2. ARP 解析 MAC 地址 3. DNS 解析域名 4. HTTP 请求页面 HTTP 一 、基础概念 请求和响应报文 URL 统一资源定位符 二、HTTP 方法 GET 获取资源 HEAD 获取报文首部 POST 传输实体主体 PUT 上传文件 PATCH 对资源进行部分修改 DELETE 删除文件 OPTIONS 查询支持的方法 CONNECT 要求在与代理服务器通信时建立隧道 TRACE 追踪路径 三、HTTP 状态码 1XX 信息 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误 四、HTTP 首部 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 通用首部字段 e.g：Date 创建报文的日期时间 请求首部字段 e.g： Accept 用户代理可处理的媒体类型 Authorization Web 认证信息 User-Agent HTTP 客户端程序的信息 响应首部字段 e.g：Location 令客户端重定向至指定 URI 实体首部字段 e.g： Content-Type 实体主体的媒体类型 Allow 资源可支持的 HTTP 方法 五、具体应用 连接管理 1. 短连接与长连接 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. 流水线 在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 Cookie 缓存 内容协商 内容编码 范围请求 分块传输编码 多部分对象集合 虚拟主机 通信数据转发 1. 代理 使用代理的主要目的是： 缓存 负载均衡 网络访问控制 访问日志记录 2. 网关 3. 隧道 六、HTTPS HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 加密 1. 对称密钥加密 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2.非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3. HTTPS 采用的加密方式 HTTPS 采用混合的加密机制，正是利用了上面提到的方案： 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性; 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） 认证 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 完整性保护 HTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 七、HTTP/2.0 HTTP/1.x 缺陷 二进制分帧层 服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩 八、HTTP/1.1 新特性 九、GET 和 POST 比较 作用 GET 用于获取资源，而 POST 用于传输实体主体。 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 可缓存 XMLHttpRequest XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 Socket 一、I/O 模型 一个输入操作通常包括两个阶段： 1、等待数据准备好 2、从内核向进程复制数据 阻塞式 I/O 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回 CPU 利用率会比较高 非阻塞式 I/O 应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling） CPU 利用率比较低 I/O 复用 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O 信号驱动 I/O 应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中 相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高 异步 I/O 应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号 异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O 五大 I/O 模型比较 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。 异步 I/O：第二阶段应用进程不会阻塞。 同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。 非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。 二、I/O 复用 select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。 select select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。 poll poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。 比较 1. 功能 select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。 select 会修改描述符，而 poll 不会； select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制； poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。 2. 速度 select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。 3. 可移植性 几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。 epoll epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。 工作模式 epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。 1. LT 模式 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 2. ET 模式 和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。 很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 应用场景 很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。 1. select 应用场景 select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。 2. poll 应用场景 poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。 3. epoll 应用场景 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。 需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。 需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。 通俗举例 "},"InterviewPreparation/TechnicalInterviews/03-数据库.html":{"url":"InterviewPreparation/TechnicalInterviews/03-数据库.html","title":"数据库","keywords":"","body":"datetime:2022-03-08 17:19 author:nzb 技术面试必备基础知识 传送门 数据库 数据库系统原理 一、事务 概念 满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 ACID 1. 原子性（Atomicity） 2. 一致性（Consistency） 3. 隔离性（Isolation） 4. 持久性（Durability） AUTOCOMMIT MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。 二、并发一致性问题 丢失修改 读脏数据 不可重复读 幻影读 三、封锁 封锁粒度 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型 1. 读写锁 互斥锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 2. 意向锁 封锁协议 1. 三级封锁协议 一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 解决丢失修改问题。 因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 解决读脏数据问题。 因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 解决不可重复读的问题。 因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 2. 两段锁协议 MySQL 隐式与显示锁定 MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： SELECT ... LOCK In SHARE MODE; 加 S 锁 SELECT ... FOR UPDATE; 加 X 锁 四、隔离级别 未提交读（READ UNCOMMITTED） 事务中的修改，即使没有提交，对其它事务也是可见的。 提交读（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化（SERIALIZABLE） 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 五、多版本并发控制 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 基本思想 版本号 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号 TRX_ID ：事务开始时的系统版本号。 Undo 日志 ReadView 快照读与当前读 1. 快照读 MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。 2. 当前读 MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。 在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。 SELECT * FROM table WHERE ? lock in share mode; SELECT * FROM table WHERE ? for update; 六、Next-Key Locks 使用 MVCC + Next-Key Locks 可以解决幻读问题 Record Locks 锁定一个记录上的索引，而不是记录本身。 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 Gap Locks 锁定索引之间的间隙，但是不包含索引本身。 Next-Key Locks 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间： (-∞, 10] (10, 11] (11, 13] (13, 20] (20, +∞) 七、关系数据库设计理论 函数依赖 异常 范式 八、ER 图 实体的三种联系 三个组成部分：实体、属性、联系 包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。 表示出现多次的关系 联系的多向性 表示子类 用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 SQL 语法 SQL 练习 MySQL 一、索引 B+ Tree 原理 MySQL 索引 1. B+Tree 索引 是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 2. 哈希索引 哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3. 全文索引 MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4. 空间数据索引 MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 索引优化 1. 独立的列 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 联合索引（多列索引） 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 3. 索引列的顺序 让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity, COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity, COUNT(*) FROM payment; staff_id_selectivity: 0.0001 customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 5. 覆盖索引 索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 索引失效 没有遵循最左匹配原则。 键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 一些关键字会导致索引失效，例如 or， ！= ， not in，is null ,is not unll like查询是以%开头 隐式转换会导致索引失效。 索引列是表达式的一部分，或者是函数的参数 二、查询性能优化 使用 Explain 进行分析 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 优化数据访问 1. 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2. 减少服务器端扫描的行数 最有效的方式是使用索引来覆盖查询。 重构查询方式 1. 切分大查询 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 DELETE FROM messages WHERE create 0 2. 分解大连接查询 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 SELECT * FROM tag JOIN tag_post ON tag_post.tag_id=[tag.id](http://tag.id/) JOIN post ON tag_post.post_id=[post.id](http://post.id/) WHERE tag.tag='mysql'; SELECT * FROM tag WHERE tag='mysql'; SELECT * FROM tag_post WHERE tag_id=1234; SELECT * FROM post WHERE [post.id](http://post.id/) IN (123,456,567,9098,8904); 三、存储引擎 InnoDB MyISAM 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 四、数据类型 整型 浮点数 字符串 时间和日期 五、切分 水平切分 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而减缓单个数据库的压力。 垂直切分 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 Sharding 策略 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题 1. 事务问题 使用分布式事务来解决，比如 XA 接口。 2. 连接 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 3. ID 唯一性 使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 六、复制 主从复制 主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。 读写分离 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 参考资料 Redis 一、概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 二、数据类型 STRING set get del LIST rpush lrange list-key 0 -1 lindex list-key 1 lpop SET sadd smembers sismember srem HASH hset hash-key sub-key1 value1 hgetall hdel hash-key sub-key2 hget hash-key sub-key1 ZSET zadd zset-key 728 member1 zrange zset-key 0 -1 withscores zrangebyscore zset- key 0 800 withscores zrem 三、数据结构 字典 dictht 是一个散列表结构，使用拉链法解决哈希冲突。 跳跃表 是有序集合的底层实现之一。 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。 四、使用场景 计数器 可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 查找表 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 例如 DNS 记录就很适合使用 Redis 进行存储。 消息队列 List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息 不过最好使用 Kafka、RabbitMQ 等消息中间件。 会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。 ZSet 可以实现有序性操作，从而实现排行榜等功能。 五、Redis 与 Memcached 数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式 Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 六、键的过期时间 Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 七、数据淘汰策略 可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 八、持久化 Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB 持久化 将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 九、事务 一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。 事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 十、事件 Redis 服务器是一个事件驱动程序。 文件事件 时间事件 事件的调度与执行 十一、复制 连接过程 主从链 十二、Sentinel Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。 十三、分片 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。 十四、一个简单的论坛系统分析 文章信息 点赞功能 对文章进行排序 "},"InterviewPreparation/TechnicalInterviews/04-系统设计.html":{"url":"InterviewPreparation/TechnicalInterviews/04-系统设计.html","title":"系统设计","keywords":"","body":"datetime:2022-03-08 17:19 author:nzb 技术面试必备基础知识 传送门 系统设计 系统设计基础 一、性能 性能指标 1. 响应时间 指某个请求从发出到接收到响应消耗的时间。 2. 吞吐量 系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。 3. 并发用户数 指系统能同时处理的并发用户请求数量。 性能优化 1. 集群 将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。 2. 缓存 缓存能够提高性能的原因如下： 缓存数据通常位于内存等介质中，这种介质对于读操作特别快； 缓存数据可以位于靠近用户的地理位置上； 可以将计算结果进行缓存，从而避免重复计算。 3. 异步 某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。 二、伸缩性 指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。 伸缩性与性能 如果系统存在性能问题，那么单个用户的请求总是很慢的； 如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。 实现伸缩性 应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。 关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。 对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。 三、扩展性 指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。 实现可扩展主要有两种方式： 使用消息队列进行解耦，应用之间通过消息传递进行通信； 使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。 四、可用性 冗余 保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。 应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。 存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。 监控 对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。 服务降级 服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。 五、安全性 要求系统在应对各种攻击手段时能够有可靠的应对措施。 分布式 一、分布式锁 在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。 阻塞锁通常使用互斥量来实现： 互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态； 互斥量为 1 表示未锁定状态。 1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。 数据库的唯一索引 获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。 存在以下几个问题： 锁没有失效时间，解锁失败的话其它进程无法再获得该锁； 只能是非阻塞锁，插入失败直接就报错了，无法重试； 不可重入，已经获得锁的进程也必须重新获取锁。 Redis 的 SETNX 指令 使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。 SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。 EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。 Redis 的 RedLock 算法 使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。 尝试从 N 个互相独立 Redis 实例获取锁； 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功； 如果获取锁失败，就到每个实例上释放锁。 Zookeeper 的有序节点 1. Zookeeper 抽象模型 Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。 2. 节点类型 永久节点：不会因为会话结束或者超时而消失； 临时节点：如果会话结束或者超时就会消失； 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。 3. 监听器 为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。 4. 分布式锁实现 创建一个锁目录 /lock； 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点； 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁； 执行业务代码，完成后，删除对应的子节点。 5. 会话超时 如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。 6. 羊群效应 一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。 二、分布式事务 指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。 分布式锁和分布式事务区别： 锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。 而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。 2PC 两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。 1. 运行过程 1.1 准备阶段 协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。 1.2 提交阶段 如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。 需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。 2. 存在的问题 2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。 2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。 2.3 数据不一致 在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。 2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。 本地消息表 本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。 三、CAP 分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。 一致性 一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。 对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。 可用性 可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。 在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。 分区容忍性 网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。 在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。 权衡 在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。 可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时， 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性； 为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。 四、BASE BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 基本可用 指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。 软状态 指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。 最终一致性 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。 ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。 在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。 五、Paxos 用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。 主要有三类节点： 提议者（Proposer）：提议一个值； 接受者（Acceptor）：对每个提议进行投票； 告知者（Learner）：被告知投票的结果，不参与投票过程。 执行过程 规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。 1. Prepare 阶段 2. Accept 阶段 3. Learn 阶段 约束条件 1. 正确性 指只有一个提议值会生效。 因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。 2. 可终止性 指最后总会有一个提议生效。 Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。 六、Raft Raft 也是分布式一致性协议，主要是用来竞选主节点。 单个 Candidate 的竞选 多个 Candidate 竞选 数据同步 集群 一、负载均衡 集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。 负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。 负载均衡器可以用来实现高可用以及伸缩性： 高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用 伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点 负载均衡器运行过程包含两个部分： 根据负载均衡算法得到转发的节点 进行转发 负载均衡算法 1. 轮询（Round Robin） 轮询算法把每个请求轮流发送到每个服务器上。该算法比较适合每个服务器的性能差不多的场景。 2. 加权轮询（Weighted Round Robbin） 加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。 3. 最少连接（least Connections） 由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。 最少连接算法就是将请求发送给当前最少连接数的服务器上。 4. 加权最少连接（Weighted Least Connection） 在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。 5. 随机算法（Random） 把请求随机发送到服务器上。 和轮询算法类似，该算法比较适合服务器性能差不多的场景。 6. 源地址哈希法 (IP Hash) 源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。 可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session） 转发实现 1. HTTP 重定向 HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。 缺点： 需要两次请求，因此访问延迟比较高； HTTP 负载均衡器处理能力有限，会限制集群的规模。 该负载均衡转发的缺点比较明显，实际场景中很少使用它。 2. DNS 域名解析 在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。 优点： DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。 缺点： 由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。 大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。 3. 反向代理服务器 反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。 在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。 优点： 与其它功能集成在一起，部署简单。 缺点： 所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。 4. 网络层 在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。 源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。 优点： 在内核进程中进行处理，性能比较高。 缺点： 和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。 5. 链路层 在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。 通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。 这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。 这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。 二、集群下的 Session 管理 一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。 Sticky Session 需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。 缺点： 当服务器宕机时，将丢失该服务器上的所有 Session。 Session Replication 在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。 缺点： 占用过多内存； 同步过程占用网络带宽以及服务器处理器时间。 Session Server 使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。 优点： 为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。 缺点： 需要去实现存取 Session 的代码。 攻击技术 一、跨站脚本攻击 跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。 危害 窃取用户的 Cookie 伪造虚假的输入表单骗取个人信息 显示伪造的文章或者图片 防范手段 1. 设置 Cookie 为 HttpOnly 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。 2. 过滤特殊字符 例如将 转义为 &gt;，从而避免 HTML 和 Jascript 代码的运行。 二、跨站请求伪造 跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。 XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。 防范手段 1. 检查 Referer 首部字段 Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。 2. 添加校验 Token 在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。 3. 输入验证码 因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。 三、SQL 注入攻击 服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。 防范手段 1. 对传入的参数进行编码转义 2. 单引号转换 将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。 四、拒绝服务攻击 拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。 分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。 缓存 一、缓存特征 命中率 当某个请求能够通过访问缓存而得到响应时，称为缓存命中。 缓存命中率越高，缓存的利用率也就越高。 最大空间 缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。 当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。 淘汰策略 FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。 LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。 LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。 二、缓存位置 浏览器 当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。 ISP 网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。 反向代理 反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。 本地缓存 使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。 分布式缓存 使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。 相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。 数据库缓存 MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。 CPU 多级缓存 CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。 三、CDN 内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。 CDN 主要有以下优点： 更快地将数据分发给用户； 通过部署多台服务器，从而提高系统整体的带宽性能； 多台服务器可以看成是一种冗余机制，从而具有高可用性。 四、缓存问题 缓存穿透 指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。 解决方案： 对这些不存在的数据缓存一个空数据； 对这类请求进行过滤。 缓存雪崩 指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。 在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。 解决方案： 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现； 分散设置缓存时间 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 使用分布式缓存 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。 缓存预热 缓存一致性 缓存一致性要求数据更新的同时缓存数据也能够实时更新。 解决方案： 在数据更新的同时立即去更新缓存； 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。 要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。 缓存 “无底洞” 现象 指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。 产生原因 缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。 解决方案： 优化批量数据操作命令； 减少网络通信次数； 降低接入成本，使用长连接 / 连接池，NIO 等。 五、数据分布 哈希分布 哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。 传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。 顺序分布 将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。 顺序分布相比于哈希分布的主要优点如下： 能保持数据原有的顺序； 并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。 六、一致性哈希 Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。 七、LRU 消息队列 一、消息模型 点对点 消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。 发布/订阅 消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。 发布与订阅模式和观察者模式有以下不同： 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。 二、使用场景 异步处理 发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。 例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。 只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。 流量削锋 在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。 可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。 应用解耦 如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。 通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。 三、可靠性 发送端的可靠性 发送端完成操作后一定能将消息成功发送到消息队列中。 实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。 接收端的可靠性 接收端能够从消息队列成功消费一次消息。 两种实现方法： 保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。 保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。 "},"InterviewPreparation/DataStructuresAlgorithms/DataStructuresAlgorithms.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/DataStructuresAlgorithms.html","title":"数据结构与算法","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 算法 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性 有穷时间内能执行完 算法是有穷的 程序可以是无穷的 确定性 相同的输入只会产生相同的输出 可行性 可以用已有的基本操作实现算法 输入 丢给算法处理的数据 输出 算法处理的结果 “好”算法的特质 正确性 能正确解决问题 可读性 对算法的描述能让其他人也看得懂 健壮性 算法能处理一些异常状况 高效率与低储存量需求 即算法执行省时、省内存 时间复杂度、空间复杂度 时间复杂度和空间复杂度 时间和空间增长的趋势 时间复杂度 时间开销与问题规模 n 之间的关系 如何计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法时间复杂度 T(n) 大 O 表示法（Big O）：，T (n) = O ( f(n) ) T(n)：算法的渐进时间复杂度 f(n)：代码执行次数 O：正比例关系 常用技巧 加法法则：O (f(n)) + O(g(n)) = O (max(f(n),g(n))) 乘法法则：O(f(n)) x O(g(n)) = O(f(n) x g(n)) 记忆技巧：常对幂指阶 常见的时间复杂度量级 x 轴：输入问题的量级；y 轴：时间的复杂度 O (1) O (logN) 设想需要 K 次循环 i 就会大于等于 n；则2^k = n；k = log2n O (n) 解释 int i =1：执行一次 i 所以复杂度：O (1 + 3N) = O (N)；因为 Big O 计算的是 N 接近于无限大的情况下，所以常量 1 和 倍数 3 都没意义了 O (nlogN) O (n^2) 因为 n 趋近于无限大，所以 n 相对于 n ^2 就是一个常量 O (nm) 三种复杂度 最坏时间复杂度 考虑输入数据“最好”的情况 平均时间复杂度 考虑所有输入数据都等概率出现的情况 最好时间复杂度 考虑输入数据“最好”的情况 空间复杂度 空间开销（内存开销）与问题规模 n 之间的关系 如何计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法空间复杂度 S(n) 注：有的算法各层函数所需的存储空间不同，分析方法略有区别 常用技巧 加法法则：O (f(n)) + O(g(n)) = O (max(f(n),g(n))) 乘法法则：O(f(n)) x O(g(n)) = O(f(n) x g(n)) 记忆技巧：常对幂指阶 O (1) 需要的空间是一个常数量 O (n) 经过 for 循环，数组里面就会有值，如果往数组里面添加越多的数据，则需要更多的空间内存等 O (n^2) 矩阵（二维数组） 其他复杂度指标 线性表 定义 逻辑结构 值的注意的特性 数据元素同类型、有限、有序 重要术语 表长、空表 表头、表尾 前驱、后继 数据元素的位序（从 1 开始） 类似索引 基本操作 运算 创销、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出（还可以根据实际需求增加其他基本操作） 其他值的注意的点 理解什么时候要传入参数的引用“&” 值传递还是引用传递 函数命名要有可读性 存储/物理结构 顺序表（顺序存储） 存储结构 逻辑上相邻的数据元素物理上也相邻 实现方式 静态分配 使用“静态数组”实现 大小一旦确定就无法改变 动态分配 使用“动态数组”实现 顺序表存满时，可再用 malloc 动态扩展顺序表的最大容量 需要将数据元素复制到新的存储区域，并用 free 函数释放原区域 特点 随机访问 能在 O(1) 时间内找到第 i 个元素 存储密度高 扩展容量不方便 插入、删除元素不方便 基本操作 插入 插入位置之后的元素都要后移 时间复杂度 最好 O(1) 插入末尾，数据不动 最坏 O (n) 插入表头，数据后移 平均 O(n) 删除 删除位置之后的元素都要前移 时间复杂度 最好 O(1) 删除末尾，数据不动 最坏 O (n) 删除表头，数据前移 平均 O(n) 查找 按位查找 获取表 L 中第 i 个位置的元素的值 用数组下标即可得到第 i 个元素 L.data[i - 1] 时间复杂度 最好、最坏、平均时间复杂度都是 O(1) 按值查找 在顺序表 L 中查找第一个元素值等于 e 的元素，并返回其位序 从第一个元素开始依次往后检索 时间复杂度 最好 O(1) 第一个位置 最坏 O(n) 最坏一个位置 平均 O(n) 每个位置的概率相同 代码要点 注意位序 i 和数组下标的区别 位序是第几个元素，从 1 开始，下标是从 0 开始 判断位序 i 的合法性 链表（链式存储） 单链表 定义 用“链式存储”（存储结构）实现了“线性结构”（逻辑结构） 一个结点存储一个数据元素 各结点间先后关系用一个指针表示 两种实现 不带头结点 空表判断：L == NULL，写代码不方便 带头结点 空表判断：L -> next == NULL，写代码方便 头指针 L 加上下一个结点不带数据只带下一个结点的指针域 基本操作 插入 按位序插入 循环遍历找到第 i -1 的节点，然后插入 带头结点 当前指针指向，从 0 开始，表示第几个节点 不带头结点 当前指针指向，从 1 开始，表示第几个节点 指定结点的后插操作 在 p 结点后插入元素 e s 为插入的结点 s -> data = e s-> next = p->next p->next = s 指定结点的前插操作 知道头指针 依次遍历找到 p 结点，然后插入即可，时间复杂度 O(n) 不知道头指针 在 p 结点后插入元素 e s 为插入的结点 s -> next = p -> next s -> data = p -> data p -> data = e p -> next = s 删除 按位序删除 和插入操作类似 指定结点的删除 删除指定结点 p 需要改变前驱结点的 next 指针 方法1：传入头指针，循环找 p 的前驱结点 方法2：类似结点前插入 p -> data = p -> next -> data p -> next = p -> next -> next 指定结点是最后一个结点时，需要特殊处理，因为q -> next = NULL，没有 data 查找 注意带头和不带头以及最后一个结点（就是 p 指针为 NULL） 按位查找 注意与“顺序表”对比 单链表不具备“随机访问”的特性，只能依次扫描 按值查找 求单链表长度 Key 三种基本操作的时间复杂度都是 O(n) 注意边界条件的处理 建立 尾插法 头插法 链表的逆置 双链表 初始化 头结点的 prior、next 都指向 NULL 插入（后插） 注意新插入结点、前驱结点、后继结点的指针修改 边界情况：新插入结点在最后一个位置，需特殊处理 删除（后删） 注意删除结点的前驱结点、后继结点的指针修改 边界情况：如果被删除结点是最后一个数据结点，需特殊处理 遍历 从一个给定结点开始，向后遍历、向前遍历的实现（循环的终止条件） 链表不具备随机存取特性，查找操作只能通过顺序遍历实现 循环链表 循环单链表 判断循环单链表是否为空：L -> next == L 判断结点 p 是否为循环单链表的表尾结点：p -> next == L，p指针下一个是否指向头指针 循环双链表 判断循环双链表是否为空：L -> next == L 判断结点 p 是否为循环双链表的表尾结点：p -> next == L，p指针下一个是否指向头指针 静态链表 用数组的方式实现的链表 优点：增、删操作不需要大量移动元素 缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景 不支持指针的低级语言 数据元素数量固定不变的场景（如操作系统的文件分配表 FAT） 使用 随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关，例如数组。 非随机存取就是顺序存取了，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表。 栈（Stack） 定义 一种操作受限的线性表，只能在栈顶插入、删除 特性：后进先出（FIFO） 术语：栈顶、栈底、空栈 基本操作 创、销 增、删（元素进栈、出栈，只能在栈顶操作） 增 删 查（获得栈顶元素，但不删除） 判空 S.top = -1 栈顶指针为-1 顺序栈 顺序存储 用静态数组实现 ，并需要记录栈顶指针 基本操作 创、增、删、查 销：清空、回收 只需要 top = -1 都是 O(1) 时间复杂度 两种实现 初始化 top = -1 指向栈顶元素 入栈 S.data[++S.top] = x 是先栈顶指针加一后赋值，不能先赋值在加一，这样会覆盖元素 出栈 x = S.data[S.top--] 是先赋值后栈顶指针减一 获得栈顶元素 x = S.data[S.top] 栈空/满栈条件？ 到达栈顶：s.top = MaxSize -1 初始化 top = 0 指向栈顶元素的后一位，接下来可以插入元素的位置 入栈 S.data[S.top++] = x 先赋值在加一 出栈 x = S.data[--S.top]] 是先栈顶指针减一后赋值 获得栈顶元素 x = S.data[S.top-1] 栈空/满栈条件？ 到达栈顶：s.top = MaxSize 共享栈 两个栈共享同一片内存空间，两个栈从两边往中间增长 初始化 0 号栈栈顶指针初始时 top0 = -1；1 号栈栈顶指针初始时 top1 = MaxSize 栈满条件 top0 + 1 = top1 链栈 跟单链表类似，只是只能在头部操作 用链式方式实现的栈 两种实现方式 带头结点 不带头结点（推荐） 基本操作 创（初始化） 增（进栈） 删（出栈） 查（获取栈顶元素） 如何判空、判满？ 栈的应用 括号匹配 依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配 匹配失败情况 左括号单身 栈非空 右括号单身 栈已空 左右括号不匹配 表达式求值 概念 运算符、操作数、界限符 三种表达式 中缀表达式（人算） 运算符在操作数中间 后缀表达式（机算，常用） 运算符在操作数后面 一个中缀表达式可以对应多个后缀、前缀表达式 前缀表达式（机算，不常用） 运算符在操作数前面 后缀表达式 中缀转后缀 按“左优先”原则确定运算符的运算次序 一个中缀表达式只对应一个后缀表达式（确保算法的“确定性”） 根据上面确定的次序，依次将各个运算符和与之相邻的两个操作数按 的规则合体 后缀转中缀 从左往右扫描，每遇到一个运算符，就 将 变为 (左操作数 运算符 右操作数)的形式 计算 从左往右扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是“右操作数”） 前缀表达式 中缀转前缀 按“右优先”原则确定运算符的运算次序 根据上面确定的次序，依次将各个运算符和与之相邻的两个操作数按 的规则合体 计算 从右往左扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是“左操作数”） 递归 栈中的每一个元素对应内存中的一块区域里面的数据不跟其他元素冲突 队列 定义 一种操作受限的线性表，只能在队尾插入、在队头删除 特性：先进先出（FIFO） 术语：队头、队尾、空队列、队头元素、队尾元素 基本操作 创、销 增、删（入队、出队、只能在规定的一段进行） 查（获得队头元素，但不删除） 判空 队列的顺序实现 实现思路 用静态数组存放数据 元素，设置队头/队尾（front、rear）指针 循环队列：用模运算（取余）将存储空间在逻辑上变为“环状” Q.rear = (Q.rear + 1) % MaxSize 重要考点 如何初始化、入队、出队 如何判空、判满 如何计算队列的长度 分析思路 确定 front、rear 指针的指向 rear 指向队尾元素后一个位置 rear 指向队尾元素 确定判空判满的方法 牺牲一个存储单元 增加 size 变量记录队列长度 增加 tag = 0/1 用于标记最近的一次操作是出队/入队 队列的链式实现 区别 带头结点 不带头结点 基本操作 创（初始化） 增（入队） 注意第一个元素入队 删（出队） 注意 最后一个元出队 查（获取队头元素） 判空 判满？不存在的，可以无限加（内存足够） 队列变种 双端队列 允许从两端插入、两端删除的队列 输入受限的双端队列 允许从两端删除、从一端插入的队列 输出受限的双端队列 允许从两端插入、从一端删除的队列 队列应用 树的层次遍历 图的广度优先遍历 操作系统的应用 CPU资源的分配：多个进程运行（浏览器、QQ、微信） 打印数据缓冲区 特殊矩阵压缩存储 对称矩阵 特点 对方阵中的任意一个元素，有 a(i,j) = a(j,i) 压缩 只存储主对角线 + 下三角区（或主对角线 + 上三角区） 三角矩阵 特点 上三角区全为常数（下三角矩阵）；或下三角区全为常数（上三角矩阵） 压缩 按行优先/列优先规则依次存储非 常量区域，并在最后一个位置存放常量 c 三对角矩阵（带状矩阵） 特点 当 |i - j| > 1时，有 a (i,j) = 0（1 压缩 按行优先/列优先规则依次存储带状区域 稀疏矩阵 特点 非零元素个数远小于零元素个数 压缩 只存储非零元素 顺序存储 顺序存储三元组（行，列，值） 链式存储 十字链表法 串 字符串 定义 串，即字符串（string）是由零个或多个字符组成的有限序列 术语：串长、空串、空格串、子串、主串、字符在主串中的位置、子串在主串中的位置 串 V.S 线性表 串的数据对象限定为字符集 串的基本操作大多以“子串”为操作对象 基本操作 定位操作 比较操作 字符集编码 每个字符在计算机中对应一个二进制数，比较字符的大小其实就是比较二进制数的大小 存储结构 顺序存储和链式存储跟线性表一样 顺序存储 静态数组 动态数组 链式存储 可让每个结点存多个字符，没有字符的位置使用“#” 或 “\\0”补足 静态数组 基本操作 求子串 串的比较 求串在主串中的位置 子串匹配算法 朴素模式匹配算法 串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在的位置 朴素模式匹配算法（简单模式匹配算法）思想 将主串中与模式串长度相同的子串搞出来，挨个与模式串对比 当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串 若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要（n - m + 1）* m次比较 最坏时间复杂度：O(nm) 最坏情况：每个子串的前 m- 1个字符都和模式串匹配，只有第 m 个字符不匹配 比较好的情况：每个子串的第 1 个字符就与模式串不匹配 KMP 算法 粗劣分析算法性能 KMP 算法优化 二者比较 朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加。最坏时间复杂度 O(nm) KMP 算法：当子串和模式串不匹配时，主串指针 i 不回溯，模式串指针 j = next[j] 如果不会经常出现子串与模式串部分匹配的时候，KMP 算法性能也不会比朴素算法好多少 算法平均时间复杂度：O(n + m) next 数组手算方法：当第 j 个字符匹配失败，由前 1~j - 1 个字符组成的串记为 S，则：next[j] = S 的最长相等前后缀长度 + 1 特别的：next[1] = 0, next[2] = 1 链表和数组的区别 数组静态分配内存，链表动态分配内存； 数组在内存中连续，链表不连续是分散的； 数组元素在栈区，链表元素在堆区； 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 链表也没有下标的概念，只能通过头节点指针，从每一个节点，依次往下找，因为下个节点的位置信息只能通过上个节点知晓。 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。 链表只需要知道操作位置的指针 树与二叉树 定义 树（Tree）是 n（n>=0)个结点的有限集。n=0 时称为空树。在任意一颗非空树中： 1）有且仅有一个特定的称为根（Root）的结点； 2）当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。 此外，树的定义还需要强调以下两点： 1）n>0 时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。 2）m>0 时，子树的个数没有限制，但它们一定是互不相交的。 示例树： 结点的度 一个结点拥有的子树数目称为结点的度。叶子节点的度为 0 。 叶子节点：没有子节点的节点 所有节点中的最大的度称为树的 度，树中的节点树即为树中所有节点的度之和加一：即：树中的节点树 = 树中所有节点的度之和 + 1 结点关系 结点子树的根结点为该结点的孩子结点。相应该结点称为孩子结点的双亲结点。 上图中，A 为 B 的双亲结点，B 为 A 的孩子结点。 同一个双亲结点的孩子结点之间互称兄弟结点。 上图中，结点 B 与结点 C 互为兄弟结点。 结点层次和树的深度 从根开始定义起，根为第一层，根的孩子为第二层，以此类推。 树中结点的最大层次数称为树的深度或高度。上图所示树的深度为4。 二叉树 定义 二叉树是 n(n>=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。 二叉树特点 1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 2）左子树和右子树是有顺序的，次序不能任意颠倒。 3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 4）非空二叉树只有一个根节点。 二叉树性质 1）在二叉树的第 i 层上最多有 2^(i-1) 个节点 。（i>=1） 2）二叉树中如果深度为 k ,那么最多有 2^k-1个节点。(k>=1） 3）n0 = n2 + 1： 度为0的节点（叶子节点）总是比度为 2 的节点多一个。 n0 表示度数为 0 的节点数，n2 表示度数为2的节点数。 4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。 具有 n 个节点的二叉树的深度至少为 [log2n]+1，其中 [log2n] 是向下取整。 5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性： (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; (2) 若 2i>n，则该结点无左子树， 否则，编号为 2i 的结点为其左子树结点； (3) 若 2i+1>n，则该结点无右子树， 否则，编号为 2i+1 的结点为其右子树结点。 斜树 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树 满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 满二叉树的特点有： 1）第 k 层上有 2 ^ (k - 1) 个节点。 2）深度为 m 的满二叉树有 2 ^m - 1个节点 3）非叶子结点的度一定是2。 完全二叉树 完全二叉树：对一颗具有 n 个结点的二叉树按层编号，如果编号为 i(1 除最后一层外，每一层的节点数都达到了最大值，在最后一层上只缺少右边的若干个节点。 满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树的存储结构 顺序存储 二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 二叉树为完全二叉树 一棵完全二叉树采用顺序存储方式，当二叉树为完全二叉树时，结点数刚好填满数组。 二叉树不为完全二叉树 其中浅色结点表示结点不存在，其中，∧表示数组中此位置没有存储结点。此时可以发现，顺序存储结构中已经出现了空间浪费的情况。 右斜树 对于这种右斜树极端情况，采用顺序存储的方式是十分浪费空间的。 因此，顺序存储一般适用于完全二叉树。 二叉链表 链式存储：由二叉树定义可知，二叉树的每个结点最多有两个子节点。因此，可以将结点数据结构定义为一个数据和两个指针域。 采用一种链表结构存储二叉树，这种链表称为二叉链表。 二叉树遍历 二叉树的遍历一个重点考查的知识点。 定义 二叉树的遍历：是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。 二叉树的访问次序可以分为四种 前序遍历 中序遍历 后序遍历 层序遍历 前序遍历 根 - 左 - 右 前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：ABDHIEJCFG 中序遍历 左 - 根 - 右 中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：HDIBJEAFCG 后序遍历 左 - 右 - 根 后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：HIDJEBFGCA 层次遍历 层次遍历就是按照树的层次自上而下的遍历二叉树。针对上图所示二叉树的层次遍历结果为：ABCDEFGHIJ 遍历常考考点 1）已知前序遍历序列和中序遍历序列，确定一棵二叉树。 例题：若一棵二叉树的前序遍历为ABCDEF，中序遍历为CBAEDF，请画出这棵二叉树。 分析：前序遍历第一个输出结点为根结点，故A为根结点。早中序遍历中根结点处于左右子树结点中间，故结点A的左子树中结点有CB，右子树中结点有EDF。 按照同样的分析方法，对A的左右子树进行划分，最后得出二叉树的形态如下图所示 2）已知后序遍历序列和中序遍历序列，确定一棵二叉树。 后序遍历中最后访问的为根结点，因此可以按照上述同样的方法，找到根结点后分成两棵子树，进而继续找到子树的根结点，一步步确定二叉树的形态。 注：已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。 "},"InterviewPreparation/DataStructuresAlgorithms/01-算法.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/01-算法.html","title":"算法","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 算法 程序 = 数据结构 + 算法 数据结构是要处理的信息 算法是处理信息的步骤 算法的五个特性 有穷性 有穷时间内能执行完 算法是有穷的 程序可以是无穷的 确定性 相同的输入只会产生相同的输出 可行性 可以用已有的基本操作实现算法 输入 丢给算法处理的数据 输出 算法处理的结果 “好”算法的特质 正确性 能正确解决问题 可读性 对算法的描述能让其他人也看得懂 健壮性 算法能处理一些异常状况 高效率与低储存量需求 即算法执行省时、省内存 时间复杂度、空间复杂度 时间复杂度和空间复杂度 时间和空间增长的趋势 时间复杂度 时间开销与问题规模 n 之间的关系 如何计算 找到一个基本操作（最深层循环） 分析该基本操作的执行次数 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法时间复杂度 T(n) 大 O 表示法（Big O）：，T (n) = O ( f(n) ) T(n)：算法的渐进时间复杂度 f(n)：代码执行次数 O：正比例关系 常用技巧 加法法则：O (f(n)) + O(g(n)) = O (max(f(n),g(n))) 乘法法则：O(f(n)) x O(g(n)) = O(f(n) x g(n)) 记忆技巧：常对幂指阶 常见的时间复杂度量级 x 轴：输入问题的量级；y 轴：时间的复杂度 O (1) O (logN) 设想需要 K 次循环 i 就会大于等于 n；则2^k = n；k = log2n O (n) 解释 int i =1：执行一次 i 所以复杂度：O (1 + 3N) = O (N)；因为 Big O 计算的是 N 接近于无限大的情况下，所以常量 1 和 倍数 3 都没意义了 O (nlogN) O (n^2) 因为 n 趋近于无限大，所以 n 相对于 n ^2 就是一个常量 O (nm) 三种复杂度 最坏时间复杂度 考虑输入数据“最好”的情况 平均时间复杂度 考虑所有输入数据都等概率出现的情况 最好时间复杂度 考虑输入数据“最好”的情况 空间复杂度 空间开销（内存开销）与问题规模 n 之间的关系 如何计算 普通程序 找到所占空间大小与问题规模相关的变量 分析所占空间 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法空间复杂度 S(n) 递归程序 找到递归调用的深度 x 与问题规模 n 的关系 x = f(n) x 的数量级 O (x) 就是算法空间复杂度 S(n) 注：有的算法各层函数所需的存储空间不同，分析方法略有区别 常用技巧 加法法则：O (f(n)) + O(g(n)) = O (max(f(n),g(n))) 乘法法则：O(f(n)) x O(g(n)) = O(f(n) x g(n)) 记忆技巧：常对幂指阶 O (1) 需要的空间是一个常数量 O (n) 经过 for 循环，数组里面就会有值，如果往数组里面添加越多的数据，则需要更多的空间内存等 O (n^2) 矩阵（二维数组） 其他复杂度指标 "},"InterviewPreparation/DataStructuresAlgorithms/Algorithm/01-埃氏筛选法.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/Algorithm/01-埃氏筛选法.html","title":"埃氏筛选法","keywords":"","body":"datetime:2022/07/22 10:20 author:nzb 埃氏筛选法 __date__ = \"2022/7/21 9:02\" __doc__ = \"\"\"统计素数个数-埃氏筛选法\"\"\" import timeit from memory_profiler import profile from functools import partial # BF算法,即暴力(Brute Force)算法 def is_prime(num: int) -> bool: \"\"\"是否素数\"\"\" for i in range(2, num): if num % i == 0: return False return True # @profile(precision=4) def brute_force(num: int) -> int: \"\"\"统计素数个数\"\"\" cnt = 0 for i in range(2, num): cnt += 1 if is_prime(i) else 0 return cnt # 埃氏筛法 # @profile(precision=4) def eratosthenes(num: int) -> int: \"\"\" 埃氏筛法 首先，将2到n范围内的所有整数写下来。其中最小的数字2是素数。将表中所有2的倍数都划去。表中剩余的最小数字是3，它不能被更小的数整除，所以是素数。再将表中所有3的倍数全都划去。依次类推，如果表中剩余的最小数字是m时，m就是素数。然后将表中所有m的倍数全部划去。像这样反复操作，就能依次枚举n以内的素数。 :param num: :return: \"\"\" flag = [False] * num # False 代表素数 cnt = 0 for i in range(2, num): if not flag[i]: cnt += 1 for j in range(i * i, num, i): flag[j] = True return cnt if __name__ == '__main__': print(\"brute_force cost time:\\t\", timeit.timeit(partial(brute_force, 1000), number=100)) print(\"eratosthenes cost time:\\t\", timeit.timeit(partial(eratosthenes, 1000), number=100)) 内存花费（1次） brute_force cost memory: 39.1797 MiB eratosthenes cost memory: 39.2148 MiB 时间花费（100次） brute_force cost time: 0.31746810000000003 eratosthenes cost time: 0.009979599999999977 "},"InterviewPreparation/DataStructuresAlgorithms/Algorithm/02-双指针法.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/Algorithm/02-双指针法.html","title":"双指针法","keywords":"","body":"datetime:2022/07/22 10:29 author:nzb 双指针法 __date__ = \"2022/7/22 9:50\" __doc__ = \"\"\"删除排序数组中的重复项-双指针法\"\"\" from memory_profiler import profile from functools import partial import timeit # @profile(precision=4) def remove_duplicates(data: list) -> int: if len(data) == 0: return 0 i = 0 for j in range(len(data)): if data[i] != data[j]: i += 1 data[i] = data[j] return i + 1 # @profile(precision=4) def remove_duplicates2(data: list) -> int: return len(set(data)) if __name__ == '__main__': print(timeit.timeit(partial(remove_duplicates, [0, 1, 2, 2, 3, 3, 4]), number=100)) print(timeit.timeit(partial(remove_duplicates2, [0, 1, 2, 2, 3, 3, 4]), number=100)) 内存花费（1次） 38.9531 MiB 39.0117 MiB 时间花费（100次） 8.159999999995948e-05 2.6299999999979118e-05 "},"InterviewPreparation/DataStructuresAlgorithms/02-线性表.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/02-线性表.html","title":"线性表","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 线性表 定义 逻辑结构 值的注意的特性 数据元素同类型、有限、有序 重要术语 表长、空表 表头、表尾 前驱、后继 数据元素的位序（从 1 开始） 类似索引 基本操作 运算 创销、增删改查（所有数据结构适用的记忆思路） 判空、判长、打印输出（还可以根据实际需求增加其他基本操作） 其他值的注意的点 理解什么时候要传入参数的引用“&” 值传递还是引用传递 函数命名要有可读性 存储/物理结构 顺序表（顺序存储） 存储结构 逻辑上相邻的数据元素物理上也相邻 实现方式 静态分配 使用“静态数组”实现 大小一旦确定就无法改变 动态分配 使用“动态数组”实现 顺序表存满时，可再用 malloc 动态扩展顺序表的最大容量 需要将数据元素复制到新的存储区域，并用 free 函数释放原区域 特点 随机访问 能在 O(1) 时间内找到第 i 个元素 存储密度高 扩展容量不方便 插入、删除元素不方便 基本操作 插入 插入位置之后的元素都要后移 时间复杂度 最好 O(1) 插入末尾，数据不动 最坏 O (n) 插入表头，数据后移 平均 O(n) 删除 删除位置之后的元素都要前移 时间复杂度 最好 O(1) 删除末尾，数据不动 最坏 O (n) 删除表头，数据前移 平均 O(n) 查找 按位查找 获取表 L 中第 i 个位置的元素的值 用数组下标即可得到第 i 个元素 L.data[i - 1] 时间复杂度 最好、最坏、平均时间复杂度都是 O(1) 按值查找 在顺序表 L 中查找第一个元素值等于 e 的元素，并返回其位序 从第一个元素开始依次往后检索 时间复杂度 最好 O(1) 第一个位置 最坏 O(n) 最坏一个位置 平均 O(n) 每个位置的概率相同 代码要点 注意位序 i 和数组下标的区别 位序是第几个元素，从 1 开始，下标是从 0 开始 判断位序 i 的合法性 链表（链式存储） 单链表 定义 用“链式存储”（存储结构）实现了“线性结构”（逻辑结构） 一个结点存储一个数据元素 各结点间先后关系用一个指针表示 两种实现 不带头结点 空表判断：L == NULL，写代码不方便 带头结点 空表判断：L -> next == NULL，写代码方便 头指针 L 加上下一个结点不带数据只带下一个结点的指针域 基本操作 插入 按位序插入 循环遍历找到第 i -1 的节点，然后插入 带头结点 当前指针指向，从 0 开始，表示第几个节点 不带头结点 当前指针指向，从 1 开始，表示第几个节点 指定结点的后插操作 在 p 结点后插入元素 e s 为插入的结点 s -> data = e s-> next = p->next p->next = s 指定结点的前插操作 知道头指针 依次遍历找到 p 结点，然后插入即可，时间复杂度 O(n) 不知道头指针 在 p 结点后插入元素 e s 为插入的结点 s -> next = p -> next s -> data = p -> data p -> data = e p -> next = s 删除 按位序删除 和插入操作类似 指定结点的删除 删除指定结点 p 需要改变前驱结点的 next 指针 方法1：传入头指针，循环找 p 的前驱结点 方法2：类似结点前插入 p -> data = p -> next -> data p -> next = p -> next -> next 指定结点是最后一个结点时，需要特殊处理，因为q -> next = NULL，没有 data 查找 注意带头和不带头以及最后一个结点（就是 p 指针为 NULL） 按位查找 注意与“顺序表”对比 单链表不具备“随机访问”的特性，只能依次扫描 按值查找 求单链表长度 Key 三种基本操作的时间复杂度都是 O(n) 注意边界条件的处理 建立 尾插法 头插法 链表的逆置 双链表 初始化 头结点的 prior、next 都指向 NULL 插入（后插） 注意新插入结点、前驱结点、后继结点的指针修改 边界情况：新插入结点在最后一个位置，需特殊处理 删除（后删） 注意删除结点的前驱结点、后继结点的指针修改 边界情况：如果被删除结点是最后一个数据结点，需特殊处理 遍历 从一个给定结点开始，向后遍历、向前遍历的实现（循环的终止条件） 链表不具备随机存取特性，查找操作只能通过顺序遍历实现 循环链表 循环单链表 判断循环单链表是否为空：L -> next == L 判断结点 p 是否为循环单链表的表尾结点：p -> next == L，p指针下一个是否指向头指针 循环双链表 判断循环双链表是否为空：L -> next == L 判断结点 p 是否为循环双链表的表尾结点：p -> next == L，p指针下一个是否指向头指针 静态链表 用数组的方式实现的链表 优点：增、删操作不需要大量移动元素 缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景 不支持指针的低级语言 数据元素数量固定不变的场景（如操作系统的文件分配表 FAT） 使用 随机存取就是直接存取，可以通过下标直接访问的那种数据结构，与存储位置无关，例如数组。 非随机存取就是顺序存取了，不能通过下标访问了，只能按照存储顺序存取，与存储位置有关，例如链表。 "},"InterviewPreparation/DataStructuresAlgorithms/03-栈.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/03-栈.html","title":"栈","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 栈（Stack） 定义 一种操作受限的线性表，只能在栈顶插入、删除 特性：后进先出（FIFO） 术语：栈顶、栈底、空栈 基本操作 创、销 增、删（元素进栈、出栈，只能在栈顶操作） 增 删 查（获得栈顶元素，但不删除） 判空 S.top = -1 栈顶指针为-1 顺序栈 顺序存储 用静态数组实现 ，并需要记录栈顶指针 基本操作 创、增、删、查 销：清空、回收 只需要 top = -1 都是 O(1) 时间复杂度 两种实现 初始化 top = -1 指向栈顶元素 入栈 S.data[++S.top] = x 是先栈顶指针加一后赋值，不能先赋值在加一，这样会覆盖元素 出栈 x = S.data[S.top--] 是先赋值后栈顶指针减一 获得栈顶元素 x = S.data[S.top] 栈空/满栈条件？ 到达栈顶：s.top = MaxSize -1 初始化 top = 0 指向栈顶元素的后一位，接下来可以插入元素的位置 入栈 S.data[S.top++] = x 先赋值在加一 出栈 x = S.data[--S.top]] 是先栈顶指针减一后赋值 获得栈顶元素 x = S.data[S.top-1] 栈空/满栈条件？ 到达栈顶：s.top = MaxSize 共享栈 两个栈共享同一片内存空间，两个栈从两边往中间增长 初始化 0 号栈栈顶指针初始时 top0 = -1；1 号栈栈顶指针初始时 top1 = MaxSize 栈满条件 top0 + 1 = top1 链栈 跟单链表类似，只是只能在头部操作 用链式方式实现的栈 两种实现方式 带头结点 不带头结点（推荐） 基本操作 创（初始化） 增（进栈） 删（出栈） 查（获取栈顶元素） 如何判空、判满？ 栈的应用 括号匹配 依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配 匹配失败情况 左括号单身 栈非空 右括号单身 栈已空 左右括号不匹配 表达式求值 概念 运算符、操作数、界限符 三种表达式 中缀表达式（人算） 运算符在操作数中间 后缀表达式（机算，常用） 运算符在操作数后面 一个中缀表达式可以对应多个后缀、前缀表达式 前缀表达式（机算，不常用） 运算符在操作数前面 后缀表达式 中缀转后缀 按“左优先”原则确定运算符的运算次序 一个中缀表达式只对应一个后缀表达式（确保算法的“确定性”） 根据上面确定的次序，依次将各个运算符和与之相邻的两个操作数按 的规则合体 后缀转中缀 从左往右扫描，每遇到一个运算符，就 将 变为 (左操作数 运算符 右操作数)的形式 计算 从左往右扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是“右操作数”） 前缀表达式 中缀转前缀 按“右优先”原则确定运算符的运算次序 根据上面确定的次序，依次将各个运算符和与之相邻的两个操作数按 的规则合体 计算 从右往左扫描，遇到操作数入栈，遇到运算符则弹出两个栈顶元素运算后入栈（注意：先弹出的元素是“左操作数”） 递归 栈中的每一个元素对应内存中的一块区域里面的数据不跟其他元素冲突 "},"InterviewPreparation/DataStructuresAlgorithms/04-队列.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/04-队列.html","title":"队列","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 队列 定义 一种操作受限的线性表，只能在队尾插入、在队头删除 特性：先进先出（FIFO） 术语：队头、队尾、空队列、队头元素、队尾元素 基本操作 创、销 增、删（入队、出队、只能在规定的一段进行） 查（获得队头元素，但不删除） 判空 队列的顺序实现 实现思路 用静态数组存放数据 元素，设置队头/队尾（front、rear）指针 循环队列：用模运算（取余）将存储空间在逻辑上变为“环状” Q.rear = (Q.rear + 1) % MaxSize 重要考点 如何初始化、入队、出队 如何判空、判满 如何计算队列的长度 分析思路 确定 front、rear 指针的指向 rear 指向队尾元素后一个位置 rear 指向队尾元素 确定判空判满的方法 牺牲一个存储单元 增加 size 变量记录队列长度 增加 tag = 0/1 用于标记最近的一次操作是出队/入队 队列的链式实现 区别 带头结点 不带头结点 基本操作 创（初始化） 增（入队） 注意第一个元素入队 删（出队） 注意 最后一个元出队 查（获取队头元素） 判空 判满？不存在的，可以无限加（内存足够） 队列变种 双端队列 允许从两端插入、两端删除的队列 输入受限的双端队列 允许从两端删除、从一端插入的队列 输出受限的双端队列 允许从两端插入、从一端删除的队列 队列应用 树的层次遍历 图的广度优先遍历 操作系统的应用 CPU资源的分配：多个进程运行（浏览器、QQ、微信） 打印数据缓冲区 "},"InterviewPreparation/DataStructuresAlgorithms/05-特殊矩阵压缩存储.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/05-特殊矩阵压缩存储.html","title":"特殊矩阵压缩存储","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 特殊矩阵压缩存储 对称矩阵 特点 对方阵中的任意一个元素，有 a(i,j) = a(j,i) 压缩 只存储主对角线 + 下三角区（或主对角线 + 上三角区） 三角矩阵 特点 上三角区全为常数（下三角矩阵）；或下三角区全为常数（上三角矩阵） 压缩 按行优先/列优先规则依次存储非 常量区域，并在最后一个位置存放常量 c 三对角矩阵（带状矩阵） 特点 当 |i - j| > 1时，有 a (i,j) = 0（1 压缩 按行优先/列优先规则依次存储带状区域 稀疏矩阵 特点 非零元素个数远小于零元素个数 压缩 只存储非零元素 顺序存储 顺序存储三元组（行，列，值） 链式存储 十字链表法 "},"InterviewPreparation/DataStructuresAlgorithms/06-串.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/06-串.html","title":"串","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 串 字符串 定义 串，即字符串（string）是由零个或多个字符组成的有限序列 术语：串长、空串、空格串、子串、主串、字符在主串中的位置、子串在主串中的位置 串 V.S 线性表 串的数据对象限定为字符集 串的基本操作大多以“子串”为操作对象 基本操作 定位操作 比较操作 字符集编码 每个字符在计算机中对应一个二进制数，比较字符的大小其实就是比较二进制数的大小 存储结构 顺序存储和链式存储跟线性表一样 顺序存储 静态数组 动态数组 链式存储 可让每个结点存多个字符，没有字符的位置使用“#” 或 “\\0”补足 静态数组 基本操作 求子串 串的比较 求串在主串中的位置 子串匹配算法 朴素模式匹配算法 串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在的位置 朴素模式匹配算法（简单模式匹配算法）思想 将主串中与模式串长度相同的子串搞出来，挨个与模式串对比 当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串 若模式串长度为 m，主串长度为 n，则直到匹配成功/匹配失败最多需要（n - m + 1）* m次比较 最坏时间复杂度：O(nm) 最坏情况：每个子串的前 m- 1个字符都和模式串匹配，只有第 m 个字符不匹配 比较好的情况：每个子串的第 1 个字符就与模式串不匹配 KMP 算法 粗劣分析算法性能 KMP 算法优化 二者比较 朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针 i 经常回溯，导致时间开销增加。最坏时间复杂度 O(nm) KMP 算法：当子串和模式串不匹配时，主串指针 i 不回溯，模式串指针 j = next[j] 如果不会经常出现子串与模式串部分匹配的时候，KMP 算法性能也不会比朴素算法好多少 算法平均时间复杂度：O(n + m) next 数组手算方法：当第 j 个字符匹配失败，由前 1~j - 1 个字符组成的串记为 S，则：next[j] = S 的最长相等前后缀长度 + 1 特别的：next[1] = 0, next[2] = 1 "},"InterviewPreparation/DataStructuresAlgorithms/07-树与二叉树.html":{"url":"InterviewPreparation/DataStructuresAlgorithms/07-树与二叉树.html","title":"树与二叉树","keywords":"","body":"datetime:2022-04-09 17:46 author:nzb 数据结构与算法 绪论 基本概念 数据 数据元素、数据项 数据对象、数据结构 数据类型、抽象数据类型（ADT） 数据结构三要素 逻辑结构 集合 线性结构 树形结构 图状结构（网状结构） 物理结构（存储结构） 顺序存储 物理内存中是连续的 非顺序存储 物理内存中是分散的 链式存储 索引存储 散列存储 数据的运算 学习建议 概念多，比较无聊。抓大放小，重要的是形成框架，不必纠结细节概念。 链表和数组的区别 数组静态分配内存，链表动态分配内存； 数组在内存中连续，链表不连续是分散的； 数组元素在栈区，链表元素在堆区； 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)； 链表也没有下标的概念，只能通过头节点指针，从每一个节点，依次往下找，因为下个节点的位置信息只能通过上个节点知晓。 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。 链表只需要知道操作位置的指针 树与二叉树 定义 树（Tree）是 n（n>=0)个结点的有限集。n=0 时称为空树。在任意一颗非空树中： 1）有且仅有一个特定的称为根（Root）的结点； 2）当 n>1 时，其余结点可分为 m(m>0) 个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。 此外，树的定义还需要强调以下两点： 1）n>0 时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。 2）m>0 时，子树的个数没有限制，但它们一定是互不相交的。 示例树： 结点的度 一个结点拥有的子树数目称为结点的度。叶子节点的度为 0 。 叶子节点：没有子节点的节点 所有节点中的最大的度称为树的 度，树中的节点树即为树中所有节点的度之和加一：即：树中的节点树 = 树中所有节点的度之和 + 1 结点关系 结点子树的根结点为该结点的孩子结点。相应该结点称为孩子结点的双亲结点。 上图中，A 为 B 的双亲结点，B 为 A 的孩子结点。 同一个双亲结点的孩子结点之间互称兄弟结点。 上图中，结点 B 与结点 C 互为兄弟结点。 结点层次和树的深度 从根开始定义起，根为第一层，根的孩子为第二层，以此类推。 树中结点的最大层次数称为树的深度或高度。上图所示树的深度为4。 二叉树 定义 二叉树是 n(n>=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。 二叉树特点 1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 2）左子树和右子树是有顺序的，次序不能任意颠倒。 3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 4）非空二叉树只有一个根节点。 二叉树性质 1）在二叉树的第 i 层上最多有 2^(i-1) 个节点 。（i>=1） 2）二叉树中如果深度为 k ,那么最多有 2^k-1个节点。(k>=1） 3）n0 = n2 + 1： 度为0的节点（叶子节点）总是比度为 2 的节点多一个。 n0 表示度数为 0 的节点数，n2 表示度数为2的节点数。 4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。 具有 n 个节点的二叉树的深度至少为 [log2n]+1，其中 [log2n] 是向下取整。 5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性： (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; (2) 若 2i>n，则该结点无左子树， 否则，编号为 2i 的结点为其左子树结点； (3) 若 2i+1>n，则该结点无右子树， 否则，编号为 2i+1 的结点为其右子树结点。 斜树 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树 满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 满二叉树的特点有： 1）第 k 层上有 2 ^ (k - 1) 个节点。 2）深度为 m 的满二叉树有 2 ^m - 1个节点 3）非叶子结点的度一定是2。 完全二叉树 完全二叉树：对一颗具有 n 个结点的二叉树按层编号，如果编号为 i(1 除最后一层外，每一层的节点数都达到了最大值，在最后一层上只缺少右边的若干个节点。 满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树的存储结构 顺序存储 二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 二叉树为完全二叉树 一棵完全二叉树采用顺序存储方式，当二叉树为完全二叉树时，结点数刚好填满数组。 二叉树不为完全二叉树 其中浅色结点表示结点不存在，其中，∧表示数组中此位置没有存储结点。此时可以发现，顺序存储结构中已经出现了空间浪费的情况。 右斜树 对于这种右斜树极端情况，采用顺序存储的方式是十分浪费空间的。 因此，顺序存储一般适用于完全二叉树。 二叉链表 链式存储：由二叉树定义可知，二叉树的每个结点最多有两个子节点。因此，可以将结点数据结构定义为一个数据和两个指针域。 采用一种链表结构存储二叉树，这种链表称为二叉链表。 二叉树遍历 二叉树的遍历一个重点考查的知识点。 定义 二叉树的遍历：是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。 二叉树的访问次序可以分为四种 前序遍历 中序遍历 后序遍历 层序遍历 前序遍历 根 - 左 - 右 前序遍历通俗的说就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：ABDHIEJCFG 中序遍历 左 - 根 - 右 中序遍历就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：HDIBJEAFCG 后序遍历 左 - 右 - 根 后序遍历就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。 上图所示二叉树的前序遍历输出为：HIDJEBFGCA 层次遍历 层次遍历就是按照树的层次自上而下的遍历二叉树。针对上图所示二叉树的层次遍历结果为：ABCDEFGHIJ 遍历常考考点 1）已知前序遍历序列和中序遍历序列，确定一棵二叉树。 例题：若一棵二叉树的前序遍历为ABCDEF，中序遍历为CBAEDF，请画出这棵二叉树。 分析：前序遍历第一个输出结点为根结点，故A为根结点。早中序遍历中根结点处于左右子树结点中间，故结点A的左子树中结点有CB，右子树中结点有EDF。 按照同样的分析方法，对A的左右子树进行划分，最后得出二叉树的形态如下图所示 2）已知后序遍历序列和中序遍历序列，确定一棵二叉树。 后序遍历中最后访问的为根结点，因此可以按照上述同样的方法，找到根结点后分成两棵子树，进而继续找到子树的根结点，一步步确定二叉树的形态。 注：已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。 "},"InterviewPreparation/ClassicQuestion/20201027/":{"url":"InterviewPreparation/ClassicQuestion/20201027/","title":"2020","keywords":"","body":"datetime:2020/10/27 16:58 author:nzb 文件操作 现在要处理一个大小为 10 G 的文件，但是内存只有 4 G，如果在只修改 get_lines 函数而其他代码保持不变的情况下，应该如何实现？需要考虑的问题都有那些？ def get_lines(): with open('file.txt','rb') as f: for i in f: yield i 遍历目录与子目录 抓取.pyc文件 第一种 ```python import os def get_files(dir,suffix): res = [] for root,dirs,files in os.walk(dir): for filename in files: name,suf = os.path.splitext(filename) if suf == suffix: res.append(os.path.join(root,filename)) print(res) get_files(\"./\",'.pyc') - 第二种 ```python import os def pick(obj): if obj.endswith(\".pyc\"): print(obj) def scan_path(ph): file_list = os.listdir(ph) for obj in file_list: if os.path.isfile(obj): pick(obj) elif os.path.isdir(obj): scan_path(obj) if __name__=='__main__': path = input('输入目录') scan_path(path) 第三种 ```python from glob import iglob def func(fp, postfix): for i in iglob(f\"{fp}/*/{postfix}\", recursive=True): print(i) if name == \"main\": postfix = \".pyc\" func(\"K:\\Python_script\", postfix) # 数字字符串转整形 字符串 \"123\" 转换成 123 ，不使用内置api，例如 int() - 第一种 ```python def atoi(s): num = 0 for v in s: for j in range(10): if v == str(j): num = num * 10 + j return num 第二种def atoi(s): num = 0 for v in s: num = num * 10 + ord(v) - ord('0') return num 第三种def atoi(s): num = 0 for v in s: t = \"%s * 1\" % v n = eval(t) num = num * 10 + n return num 第四种from functools import reduce def atoi(s): return reduce(lambda num, v: num * 10 + ord(v) - ord('0'), s, 0) 数字字符串排序 让所有奇数都在偶数前面，而且奇数升序排列，偶数降序排序，如字符串'1982376455',变成'1355798642' print(\"\".join(sorted('1982376455', key=lambda x: int(x) % 2 == 0 and 20 - int(x) or int(x)))) # 分解 int(x) % 2 == 0 and 20 - int(x)：这是排序偶数，降序排序 int(x)：剩下的奇数升序排序 python函数重载机制？ 函数重载主要是为了解决两个问题。 1。可变参数类型。 2。可变参数个数。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同 的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字 不同的函数。 好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处 理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中 很可能是相同的代码，没有必要做成两个不同函数。 那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参 数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数 终归是需要用的。 好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 回调函数，如何通信的? 回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。 闭包延迟 详情 下面这段代码的输出结果将是什么？请解释。 def multipliers(): return [lambda x: i *x for i in range(4)] print([m(2) for m in multipliers()]) 上面代码的输出结果是 [6,6,6,6]，不是我们想的 [0,2,4,6] 上述问题产生的原因是python闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。 因此，当任何由multipliers()返回的函数被调用时,i的值将在附近的范围进行查找。 那时，不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值3. def multipliers(): for i in range(4): yield lambda x: i *x 你如何修改上面的 multipliers 的定义产生想要的结果？ def multipliers(): return [lambda x,i = i: i*x for i in range(4)] 单例模式 装饰器 from functools import wraps def singleton(cls): _instance = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return wrapper 使用基类 class SingletonMeta(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, \"__instance\"): setattr(cls, \"__instance\", super().__new__(cls, *args, **kwargs)) return getattr(cls, \"__instance\") class Foo(SingletonMeta): pass 使用元类 class SingletonMeta(type): \"\"\"自定义元类\"\"\" def __call__(cls, *args, **kwargs): if not hasattr(cls, \"__instance\"): setattr(cls, \"__instance\", super().__call__(*args, **kwargs)) return getattr(cls, \"__instance\") class Foo(metaclass=SingletonMeta): pass 请用一行代码实现将 1-N 的整数列表以 3 为单位分组 N =100 print ([[x for x in range(1,100)] [i:i+3] for i in range(0,100,3)]) Python的魔法方法 魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被Python所调用， 你可以定义自己想要的行为，而这一切都是自动发生的，它们经常是两个下划线包围来命名的（比如 __init__ , __len__ ), Python的魔法方法是非常强的所以了解其使大用方法也变得尤为重要! __init__： 构造器，当一个实例被创建的时候初始化的方法，但是它并不是实例化调用的第一个方法。 __new__：才是实例化对象调用的第一个方法，它只取下 cls 参数，并把其他参数传给 __init___。 ___new__： 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元祖或者字符串这样不经常改变的类型的时候。 __call__： 让一个类的实例像函数一样被调用 __getitem__： 定义获取容器中指定元素的行为，相当于 self[key] __getattr__： 定义当用户试图访问一个不存在属性的时候的行为。 __setattr__： 定义当一个属性被设置的时候的行为 __getattribute___： 定义当一个属性被访问的时候的行为 多进程多线程以及协程的理解 这个问题被问的概念相当之大， 进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单 位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。 线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线 程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。 协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和 栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 协程 python asyncio的原理？ asyncio 这个库就是使用 python 的 yield 这个可以打断保存当前函数的上下文的机制， 封装好了 selector 摆脱掉了复杂的回调关系 单线程+异步 I/O Python异步使用场景有那些 1、 不涉及共享资源，获对共享资源只读，即非互斥操作 2、 没有时序上的严格关系 3、 不需要原子操作，或可以通过其他方式控制原子性 4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能 5、 不影响主线程逻辑 多线程竞争 线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全 那么怎么解决多线程竞争问题？---锁 锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。 锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了 锁的致命问题: 死锁 Python的线程同步 setDaemon(False) 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在 Python 中， 默认情况下就是 setDaemon(False) ,主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。 import threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.start() print('---主线程--结束') if __name__ =='__main__': main() #执行结果 ---主线程--结束 ---子线程结束--- setDaemon（True) 当我们使用 setDaemon(True) 时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止 ```python import threading import time def thread(): time.sleep(2) print(’---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True)#设置子线程守护主线程 t1.start() print('---主线程结束---') if name =='main': main() 执行结果 ---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束 - join（线程同步) join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。 当设置守护线程时，含义是主线程对于子线程等待 timeout 的时间将会杀死该子线程，最后退出程序，所以说，如果有 10 个子线程， 全部的等待时间就是每个 timeout 的累加和，简单的来说，就是给每个子线程一个 timeout 的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。 没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。 ```python import threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True) t1.start() t1.join(timeout=1) #1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行 #2 如果不设置timeout参数就等子线程结束主线程再结束 #3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束 print('---主线程结束---') if __name__=='__main___': main() 锁及其分类 定义：锁(Lock)是 python 提供的对线程控制的对象。 分类：互斥锁，可重入锁，死锁 死锁 若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。 GIL锁 全局解释器锁（互斥锁） 作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！ 所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。 进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换 三者的关系：进程里有线程，线程里有协程。 多线程交互访问数据，怎么避免重读？ 创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。 什么是线程安全，什么是互斥锁？ 每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。 同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作， 导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。 同步、异步、阻塞、非阻塞 同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。 异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！ 阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。 非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。 同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。 僵尸进程和孤儿进程及怎么避免僵尸进程？ 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（进程号为 1 ）所收养，并由 init 进程对他们完成状态收集工作。 僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 避免僵尸进程的方法： 1.fork 两次用孙子进程去完成子进程的任务 2.用 wait() 函数使父进程阻塞 3.使用信号量，在 signal handler 中调用 waitpid , 这样父进程不用阻塞 IO密集型和CPU密集型区别？ IO密集型：系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写。 CPU密集型：大部分时间用来做计算，逻辑判断等 CPU 动作的程序称之 CPU 密集型。 python中进程与线程的使用场景？ 多进程适合在 CPU 密集操作（ cpu 操作指令比较多，如位多的的浮点运算）。 多线程适合在 IO 密性型操作（读写数据操作比多的的，比如爬虫） 线程是并发还是并行，进程是并发还是并行？ 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 线程是并发，进程是并行; 进程之间互相独立，是系统分配资源的最小单位，同一个进程中的所有线程共享资源。 TCP和UDP 详情 TCP 套接字：是使用 TCP 协议提供的传输服务来实现网络通信的编程接口。 UDP 套接字：一种非常轻便的传输协议，也称做用户数据报协议，简称 UDP。 TCP 和 UDP 都是提供端到端传输服务的协议。 二者的差别：就如同打电话和发短信的区别， 后者不对传输的可靠性和可达性做出任何承诺从而避免了 TCP 中握手和重传的开销， 所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP 可能是更好的选择。 可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏， 这无非就是部分数据传丢或传错造成的。 浏览器通过WSGI请求动态资源的过程? 浏览器发送的请求被 Nginx 监听到，Nginx 根据请求的 URL 的 PATH 或者后缀把请求静态资源的分发到静态资源的目录， 别的请求根据配置好的转发到相应端口。 实现了 WSGI 的程序会监听某个端口，监听到 Nginx 转发过来的请求接收后 (一般用 socket 的 recv 来接收 HTTP 的报文)以后把请求的报文封装成 environ 的字典对象， 然后再提供一个 startresponse 的方法。把这两个对象当成参数传入某个方法比如 wsgiapp(environ, start_response) 或者实现了 __call(self, environ, start_response) 方法的某个实例。这个实例再调用 start_response 返回给实现了 WSGI 的中间件，再由中间件返回给 Nginx。 Django 项目中有个 wsgi.py 的文件，里面设置了 DJANGO_SETTINGS_MODULE 为项目的配置文件，如何获取 wsgi 的APP。 浏览器访问www.baidu.com的过程 (1) 浏览器获取输入的域名 www.baidu.com (2) 浏览器向 DNS 请求解析 www.baidu.com 的 IP 地址 (3) 域名系统 DNS 解析出百度服务器的 IP 地址-通过网关出去 (4) 浏览器与该服务器建立 TCP 连接(默认端口号 80 ) (5) 浏览器发出 HTTP 请求，请求百度首页 (6) 服务器通过 HTTP 响应把首页文件发送给浏览器 (7) TCP 连接释放 (8) 浏览器将首页文件进行解析，并将 Web 页显示给用户。 Post和Get请求的区别 GET： 1.请求参数在请求行中，在url后。 2.请求的url长度有限制的 3.不太安全 4.发送一次TCP数据包 POST： 1.请求参数在请求体中 2.请求的url长度没有限制的 3.相对安全 4.发送两次TCP数据包 cookie和session的区别 cookie： 客户端技术，数据保存在客户端，数据不够安全，只能存储 4kb 数据 单个 cookie 保存的数据不超过4K，浏览器限制一个站点最多保存 20 个 cookie session：服务器端技术，数据保存在服务器，数据相对安全，用户看不到数据只能看到 sessionid， 数据存储根据服务器的容量而定 session 会在一定时间内保存在服务器上，当访问增多，会较占用服务器的性能，考虑到减轻服务器性能，应使用 cookie 可以考虑将登陆信息等重要信息存放在 session，其他信息如果需要保留，可以放在 cookie 中 三次握手和四次挥手 三次握手主要有两个目的：信息对等和防止超时。 信息对等 两台机器通信时都需要确认四个信息： 自己发报文的能力 自己收报文的能力 对方发报文的能力 对方收报文的通知 握手 第一次握手：第一次握手 A 机器向 B 机器发送 SYN 数据包，此时只有 B 机器能确认自己收报文的能力和对方发报文的能力。 第二次握手：每二次握手后 B 响应 A 机器的 SYN 数据包，此时 A 机器就能确认：自己发报文的能力、自己收报文的能力、对方发报文的能力、对方收报文的能力 第三次握手：每三次握手后 A 应答 B 机器的 SYN + ACK 数据包，此时 B 机器就能确认：自己发报文的能力、对方收报文的能力 防止超时 三次握手除了保证信息对等也是了防止请求超时导致脏连接。TTL网络报文的生存往往会超过TCP请求超时时间，如果两次握手就能创建连接，传输数据并释放连接后，第一个超时的连接请求才到达B机器，B机器 会以为是 A 创建新连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT，所以会直接丢弃了B的确认数据，导致 B 机器单方面的创建连接完毕。 四次挥手 一次 客户端发送关闭数据包 服务端收到关闭连接请求后，通知应用程序处理完剩下的数据 二次 服务端响应客户端的关闭连接请求，说需要处理完剩下的数据，然后再发消息给你 客户端收到应答后继续等待 三次 服务端处理完剩下的数据后，主动向客户端发送数据包 客户端收到应答后，发送数据包 四次 服务端收到数据包后关闭连接 客户端 TIME_WAIT 状态等待 2MSL 后，关闭连接 什么是2MSL：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”， 2MSL即两倍的MSL 为什么要有TIME_WAIT 确认被动关闭（机器B）能够顺利进入CLOSED状态 假如A机器发送最后一个ACK后，但由于网络原因ACK包未能到达 B 机器，此时 B机器通常会认为 A机器 没有收到 FIN+ACK报文，会重发一次FIN+ACK报文。如果 A机器 发送最后一个ACK后，自私的关闭连接进入 CLOSED状态，就可能导致 B 无法收到ACK报文，无法正常关闭。 HTTPS和HTTP的区别 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 使用Socket套接字需要传入哪些参数 Address Family 和 Type，分别表示套接字应用场景和类型。 family 的值可以是 AF_UNIX(Unix 域，用于同一台机器上的进程间通讯)，也可以是 AF_INET（对于 IPV4 协议的 TCP 和 UDP） type 参数， 流套接字(SOCK_STREAM) 数据报文套接字(SOCK_DGRAM) 原始套接字(SOCK_RAW) HTTP常见请求头 请求头 说明 Accept 浏览器可接受的MIME类型 Accept-Charset 浏览器可接受的字符集 Accept-Encoding 浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间 Accept-Language 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到 Authorization 授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中 Connection 表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小 Content-Length 表示请求消息正文的长度 Cookie 这是最重要的请求头信息之一 From 请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它 Host 初始URL中的主机和端口 If-Modified-Since 只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答 Pragma 指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝 Referer 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面 User-Agent 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用 UA-Pixels，UA-Color，UA-OS，UA-CPU 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型 OSI七层模型和TCP/IP四层模型以及五层模型 OSI 7、应用层（Application）：为用户的应用程序提供网络服务 6、表示层（Presentation）：将信息表示为一定形式和格式的数据流 5、会话层（Session）：负责通信主机之间会话的建立、管理和拆除，协调通信双方的会话 4、传输层（Transport）：负责通信主机间端到端的连接 3、网络层（Network）：负责将分组从源机送到目的机，包括寻址和最优路径选择等 2、数据链路层（Data Link）：提供可靠的帧传递，实现差错控制、流控等等 1、物理层（Physical）：提供透明的比特流（01流）传递 TCP/IP 4、应用层（Application）：为用户提供所需要的各种服务 3、传输层（Transport）：为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性 2、网际层（Internet）：主要解决主机到主机的通信问题 1、网络接口层（Network Access）：负责监视数据在主机和网络之间的交换 url的形式 URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。 也可认为由4部分组成：协议、主机、端口、路径 什么是WSGI和uwsgi以及uWSGI? WSGI：web 服务网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给 web 框架。 实现 wsgi 协议的模块： wsgiref：本质上就是编写一 socket 服务端，用于接收用户请求（django) werkzeug：本质上就是编写一个 socket 服务端，用于接收用户请求(flask) uwsgi：是实现了 wsgi 协议的一个模块，模块本质：一个 socket 服务器 uWSGI：是一个 web 服务器，它实现了WSGI协议、uwsgi、http等协议。 三种区别 WSGI 是一种通信协议。 uwsgi 是一种线路协议而不是通信协议，在此常用于在 uWSGI 服务器与其他网络服务器的数据通信。 uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。 Nginx nginx 是一个开源的高性能的HTTP服务器和反向代理： 1.作为web服务器，它处理静态文件和索引文件效果非常高 2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间 3.稳定性高，配置简洁。 4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用 同源策略 协议相同 域名相同 端口相同 只要有一项不同就会出现跨域 Django请求生命周期 1.wsgi ,请求封装后交给web框架（Flask，Django) 2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session 3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数 4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates 5.中间件，对响应的数据进行处理 6.wsgi，将响应的内容发送给浏览器 scrapy和scrapy-redis有什么区别？为什么选择redis数据库？ 1) scrapy 是一个 Python 爬虫框架，爬取效率极高，具有高度定制性，但是不支持分布式。 而 scrapy-redis 一套基于 redis 数据库、运行在 scrapy 框架之上的组件，可以让 scrapy 支持分布式策略， Slave 端共享 Master 端 redis 数据库里的 item 队列、请求队列和请求指纹集合。 2)为什么选择 redis 数据库，因为 redis 支持主从同步，而且数据都是缓存在内存中的，所以基于 redis 的分布式爬虫，对请求和数据的高频读取效率非常高。 分布式爬虫主要解决什么问题？ 1、ip 2、带宽 3、cpu 4、io scrapy的去重与过滤器的使用 InnoDB和MyISAM以及MEMORY的区别 InnoDB：支持事务（提交、回滚）、支持外键、支持奔溃修复和并发控制，适合频繁更新和删除 清空整个表时：一行一行删除，效率慢 MyISAM：插入数据快，空间内存使用比较低，适合只插入和读取的相关业务 清空整个表时：重建表 MEMORY：所有数据都存在内存中，数据的处理速度快，但安全性不高，只适合相对较小的数据库表 drop,delete与truncate的区别 drop 直接删掉表；truncate 删除表中数据，再插入时自增长 id 又从 1 开始；delete 删除表中数据，可以加where字句 1.delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。 truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。 并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。 2.表和索引所占空间。当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。 drop语句将表所占用的空间全释放掉。 3.一般而言，drop>truncate>delete 4.应用范围。truncate只能对table，delete可以是table和view 5.truncate和delete只删除数据，而drop则删除整个表（结构和数据) 6.truncate与不带where的delete：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束(constrain), 触发器（trigger)索引(index);依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid. 索引的工作原理及其种类 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树以其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动） 悲观锁和乐观锁 悲观锁：就是很悲观，每次去拿数据的时候认为别人会修改，所以每次拿数据的时候都会上锁，这样只要别人想要这个数据就会block直到它拿到锁， 传统的关系型数据库就有很多这样机制的锁：行锁、表锁、读锁、写锁等，都是在操作之前上锁 乐观锁：就是很乐观，每次去拿数据的时候认为别人不会修改，所以每次拿数据的时候都不会上锁，但是在更新的时候会去判断一下在此期间有没有别人更新这个数据， 可以使用版本号等机制，乐观锁适用于多读的应用类型，可以提高吞吐量 存储函数与存储过程的区别 语法 存储函数不能有输出参数，因为存储函数本身就是输出参数，而存储过程可以有输出参数 可以直接对存储函数进行调用，不需要使用 call 存储函数必须包含一条 return 语句，而这条语句不允许包含于存储过程中 Redis宕机怎么解决? 宕机:服务器停止服务 如果只有一台 redis，肯定会造成数据丢失，无法挽救 多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看： slave从redis宕机，配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志1，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据; 如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库，此时重新启动主数据 库，执行SLAVEOF，把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。 以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法:redis的哨兵(sentinel)的功能 值传递和引用传递 def fn(k, v, d={}): d[k] = v print(d) fn('1', 1) fn('2', 2) fn('3', 3, {}) # 结果 {'1': 1} # 直接将键值对传递给字典 {'1': 1, '2': 2} # 因为字典在内存中是可变对象类型，指向了同一个地址，传递了新的键值对后相当于给字典添加的新键值对 {'3': 3} # 给了一个新的字典，所以不是原来默认参数的字典 copy和deepcopy 复制不可变类型 数值、字符串、元组 不管是 copy 还是 deepcopy，都是同一个地址，和 “=” 赋值一样，id() 后的值都相同 复制可变类型 列表、字典 第一种：复制的对象中无复杂对象，原来的值改变不会影响浅复制的值，同时浅复制的值改变不会影响原来的值，两者 id 值不同 第二种：复制的对象中有复杂对象（例如：一个列表中的一个元素是列表） copy：改变原来的值中的复杂对象的值，会影响浅复制的值 deepcopy：完全独立复制，包括内层列表或字典 排序 正数从小到大，负数从大到小a = [-8, 5, 7, -5, -1, 6, -2, 3, 4, -3, 9] sorted(a, key=lambda x: (x 数字相同，按字符串排序a = [['op', 55], ['ef', 30],['ab', 10], ['gh', 55], ['cd', 20], ['xy', 55]] sorted(a, key=lambda x: x[1] and x[0]) # 或 sorted(a, key=lambda x: (x[1], x[0])) int(\"1.4\") 和 int(1.4) 结果 int(\"1.4\")：报错 int(1.4)：1 "},"Works/01-贞仕.html":{"url":"Works/01-贞仕.html","title":"福建路阳有限公司","keywords":"","body":"datetime:2022/04/17 16:34 author:nzb 福建贞仕信息有限公司 任职时间:2019-03 ~ 2020-12 任职岗位：后端工程师 所学技能或知识 Django开发经验 Django-restframework重写异常处理手柄 Django-restframework登录相关 Django-restframework过滤类相关 Django-Fastdfs重写存储类 Django-restframework序列化相关 api接口自动化测试 为接口加速加缓存 "},"Works/02-快仓.html":{"url":"Works/02-快仓.html","title":"上海快仓自动化有限公司","keywords":"","body":"datetime:2022/04/17 16:34 author:nzb 上海快仓自动化科技有限公司 任职时间:2021-03 ~ 任职岗位：Python工程师 所学技能或知识 目录 Flask configparser模块 对象取值魔术方法：__getattribute、__getattr、__getitem__ Flask 构造函数及蓝图 #!/usr/bin/env python # -*- coding:utf8 -*- __date__ = \"2021/9/28 10:26\" from functools import wraps from flask import Flask, jsonify, request, Blueprint from geventwebsocket.server import WSGIServer from flask_cors import CORS # 跨域 from geventwebsocket.handler import WebSocketHandler flask_app = Flask(__name__, static_folder='dist', template_folder='dist', static_url_path='') flask_app.debug = True CORS(flask_app, supports_credenials=True) @flask_app.before_request def before_request(): \"\"\" 每一次请求之前被调用到 \"\"\" user_ip = request.environ.get('HTTP_X_REAL_IP', request.remote_addr) print('{:-^100}\\nmehtod:{}\\npath:{}\\nargs:{}\\npost data:{}\\nip:{}\\n{:-^100}'.format('请求开始', request.method, request.full_path, dict(request.args), request.get_json(), user_ip, '视图函数中的打印')) @flask_app.after_request def after_request(resp): \"\"\" 每一次请求之后被调用 :param resp: 这个参数是response对象 :return: 需要返回一个response对象，可以是新的，也可以是传入进入的 \"\"\" print('{:-^100}\\nresponse data:{}'.format('请求结果', resp.get_json())) return resp def test_permision(func): @wraps(func) def wrapper(*args, **kwargs): query_param = dict(request.args) if query_param.get(\"test\") == \"1\": res = {\"success\": False, \"data\": \"\", \"errorMsg\": \"无权限\"} return jsonify(res) return func(*args, **kwargs) return wrapper class BaseBulePrint(Blueprint): \"\"\"自定义蓝图类，继承蓝图基类\"\"\" def __init__(self, name, import_name): super(BaseBulePrint, self).__init__(name, import_name) def add_http(self, url, func): # strict_slashes对url最后的反斜杠是否严格要求 self.add_url_rule(url, methods=['POST', 'GET'], view_func=test_permision(func), strict_slashes=False) def add_socket(self, url, func): self.add_url_rule(url, view_func=func) def generateResponse(self, success=True, data=\"\", message=\"\"): \"\"\" 与qs对接商定返回请求的结构体 :param success: :param data: :param message: :return: \"\"\" ret = {} ret[\"success\"] = success ret[\"data\"] = data ret[\"errorMsg\"] = message return jsonify(ret) class BluePrintTest1(BaseBulePrint): def __init__(self): super(BluePrintTest1, self).__init__(\"blue_test1\", __name__) self.add_http(\"/blue_print\", self.blue_print) def blue_print(self): print(self.__class__.__name__) return self.generateResponse(True) class BluePrintTest2(BaseBulePrint): def __init__(self): super(BluePrintTest2, self).__init__(\"blue_test2\", __name__) self.add_http('/test', self.test) def test(self): print(\"Hello World!!!\") return self.generateResponse(True) blue_test1 = BluePrintTest1() blue_test2 = BluePrintTest2() flask_app.register_blueprint(blue_test1) flask_app.register_blueprint(blue_test2) # web基础层 class _WebServer(object): def __init__(self): self.flask_app = flask_app def run_forever(self, ip='0.0.0.0', port=8088): # 开启web服务 server = WSGIServer((ip, port), self.flask_app, handler_class=WebSocketHandler) server.serve_forever() class WebTestApi(_WebServer): \"\"\"仅供测试\"\"\" def __init__(self): super(WebTestApi, self).__init__() if __name__ == \"__main__\": WebTestApi().run_forever('0.0.0.0', 8088) configparser模块 配置文件 [host] host_ip = 127.0.0.1 [db] engine = mysql host = 127.0.0.1 port = 3306 user = root password = 123456 database = devops [log] log_path = /var/opt/adminset/logs log_level = info [demo.com] port = 110 上述配置文件代码如何生成？ import configparser as cp config = cp.ConfigParser() # config后面跟的是一个section的名字，section的段的内容的创建类似于创建字典。类似与字典当然还有别的操作方式啦！ # 类似与最经典的字典操作方式 config[\"host\"] = { \"host_ip\": \"127.0.0.1\" } config[\"db\"] = { \"engine\": \"mysql\", \"host\": \"127.0.0.1\", \"port\": \"3306\", \"user\": \"root\", \"password\": \"123456\", \"database\": \"devops\" } config[\"log\"] = { \"log_path\": \"/var/opt/adminset/logs\", \"log_level\": \"info\" } config[\"demo.com\"] = {\"port\": \"110\"} with open(\"./config.ini\", 'w') as f: config.write(f) 读取文件内容 import configparser as cp config = cp.ConfigParser() # ---------------------------查找文件内容,基于字典的形式 print(config.sections()) # [] config.read('config.ini') print(config.sections()) # ['host', 'db', 'log', 'demo.com'] print('bytebong.com' in config) # False print('demo.com' in config) # True print(config['demo.com'][\"port\"]) # 110 print(config['host']['host_ip']) # 127.0.0.1 print(config['log']) # for key in config['db']: # 注意,有default会默认default的键 print(key) print(config.options('db')) # 同for循环,找到'bitbucket.org'下所有键,['engine', 'host', 'port', 'user', 'password', 'database'] print(config.items('demo.com')) # 找到'bitbucket.org'下所有键值对,[('port', '110')] print(config.get('db', 'user')) # root get方法Section下的key对应的value 修改文件内容 import configparser as cp config = cp.ConfigParser() config.read('config.ini') # 读文件 config.add_section('test') # 添加section config.remove_section('db') # 删除section config.remove_option('log', \"log_level\") # 删除一个配置项 config.set('host', 'host_port', '11111') # 设置或修改 config.set('log', 'log_path', '/logs') config.set('test', 'k2', '22222') with open('new_config.ini', 'w') as f: config.write(f) 新配置文件 [host] host_ip = 127.0.0.1 host_port = 11111 [log] log_path = /logs [demo.com] port = 110 [test] k2 = 22222 对象取值魔术方法 __getattribute__ __getattr__ __getitem__ class Foo(object): data = {'a': 1, 'b': 2} def __init__(self, x): self.x = x def get(self, key): return self.data.get(key) def __getitem__(self, item): \"\"\" 通过 Foo()[\"x\"] 获取属性值 :param item: :return: \"\"\" print(f\"__getitem__:{item}\") return self.get(item) def __getattr__(self, item): \"\"\" 通过 Foo().x 获取属性值 :param item: :return: \"\"\" print(f\"__getattr__:{item}\") if item not in self.data: return \"没有该值\" return self.data.get(item) def __getattribute__(self, item): \"\"\" :param item: :return: \"\"\" print(f\"__getattribute__:{item}\") # 父类该方法注释：\"\"\" Return getattr(self, name). \"\"\" # getattr 获取对象的属性或方法 data = super(Foo, self).__getattribute__(item) return data if __name__ == '__main__': ins = Foo(\"属性x\") print(\"{:-^100}\".format(\"ins.data 分割线\")) print(ins.data) # 解析（实例获取类属性） # ins.data 触发 __getattribute__:data # 该实例存在该属性，父类 getattr(self, name)，获取到其值 print(\"{:-^100}\".format(\"ins.a 分割线\")) print(ins.a) # 解析 （实例获取类属性） # ins.a 触发 __getattribute__:a # 该实例不存在该属性，父类 getattr(self, name) 也获取不到值，因此接着触发 __getattr__:a # if判断条件中 self.data 又是获取类属性，触发 __getattribute__:data # if条件不成立，return self.data 又是获取类属性，触发 __getattribute__:data，返回字典 # 字典 get 取值 print(\"{:-^100}\".format(\"ins.x 分割线\")) print(ins.x) # 解析（实例获取实例属性） # ins.x 触发 __getattribute__:x，实例属性存在返回值 print(\"{:-^100}\".format(\"ins['c'] 分割线\")) print(ins['c']) # 解析（实例获取不存在的属性） # 触发 __getitem__:c # self.get(item) 触发 __getattribute__:get 去获取 get 属性或方法 # self.data.get(key) 触发 __getattribute__:data，返回类属性字典 # 字典取值返回 print(\"{:-^100}\".format(\"ins.c 分割线\")) print(ins.c) # 解析（实例获取不存在的属性） # 触发 __getattribute__:c，父类也没有 # 触发 __getattr__:c # if判断条件中 self.data 又是获取类属性，触发 __getattribute__:data # 满足添加返回值 print(\"{:-^100}\".format(\"Foo.data 分割线\")) print(Foo.data) # 解析（类获取类属性） # 直接返回值 print(\"{:-^100}\".format(\"getattr(ins, 'c') 分割线\")) print(getattr(ins, \"c\")) # 解析（类获取类属性） # 该取值跟 \".\" 取一样，可以当做点取的另一种写法，但是该方法可以设置默认值 --------------------------------------------ins.data 分割线-------------------------------------------- __getattribute__:data {'a': 1, 'b': 2} ---------------------------------------------ins.a 分割线---------------------------------------------- __getattribute__:a __getattr__:a __getattribute__:data __getattribute__:data 1 ---------------------------------------------ins.x 分割线---------------------------------------------- __getattribute__:x 属性x --------------------------------------------ins['c'] 分割线-------------------------------------------- __getitem__:c __getattribute__:get __getattribute__:data None ---------------------------------------------ins.c 分割线---------------------------------------------- __getattribute__:c __getattr__:c __getattribute__:data 没有该值 --------------------------------------------Foo.data 分割线-------------------------------------------- {'a': 1, 'b': 2} ---------------------------------------getattr(ins, 'c') 分割线---------------------------------------- __getattribute__:c __getattr__:c __getattribute__:data 没有该值 Process finished with exit code 0 __getattribute__ 属性拦截器，所有对象尝试去访问属性的时候，就会调用该方法 class A: x = '类属性x' def __init__(self, y): self.y = y def __getattribute__(self, attr_name): print(\"进入到__getattribute__方法\") return super().__getattribute__(attr_name) a = A('实例属性y') print(a.y) # 输出： 进入到__getattribute__方法 # 实例属性y print(a.x) # 输出： 进入到__getattribute__方法 # 类属性x print(A.x) # 输出： 类属性x 当对象去访问实例属性、类属性时，都会进入到该实例所在的类【这就是为什么A.x没有输出进入到__getattribute__方法的原因 type(A)是type】的 __getattribute__（self,attr_name）方法中 __getattr__ 当尝试获取一个不存在的属性时发生的行为 class Test: name = \"测试\" def __getattr__(self, attr_name): if attr_name == \"height\": return \"不晓得好高\" else: raise AttributeError test = Test() print(test.name) # 输出： 测试 print(test.height) # 输出： 不晓得好高 print(test.gendler) # 报错，AttributeError print(Test.height) # 报错， 类Test 所属的类type中没有设置对应height的__getattr__方法， # AttributeError: type object 'Test' has no attribute 'height' 当对象去访问一个该对象实例属性、所属类属性、所属类父类属性都不存在的属性时候，就会进入到该对象所属类的__getattr__(self,attr_name) 方法中【这也就是为什么Test.height会报错的原因，因为类Test所属类是type，没有设置这个__getattr__】 访问顺序 优先级如下： 实例属性 类属性 父类属性（mro顺序） getattr 对象去访问属性的时候，可能存在实例属性、类属性、父类属性、getattr方法设置的属性获取 同名的情况，优先级如下： class C: x = 'C_X' class D(C): x = 'D_X' def __getattr__(self, attr_name): if attr_name == \"x\": return 999 else: raise AttributeError d = D() # 优先级1：实例属性 d.__dict__['x'] = 6 # 设置实例属性 print(d.x) # 输出的是6 # 优先级2：类属性 del d.x # 删除实例属性 print(d.x) # 输出的是类属性 D_X # 优先级3：父类属性 del D.x # 删除类属性 print(d.x) # 输出的是父类属性 C_X # 优先级4：__getattr__ del C.x # 删除父类属性 print(d.x) # 输出的是999 每一次去获取属性，都会先进到getattribute 方法，然后根据上述顺序，如果类属性是描述符：数据描述符优先级>同名实例属性, 实例属性>同名非数据描述符 拓展 __getattribute__只有在访问了才会去调用 给对象的属性赋值的时候，并不会调用，如果需要获取到属性的值，就会调用 class A: def __init__(self, x): self.x = x def __getattribute__(self, attr_name): print(\"进入到__getattribute__方法\") return super().__getattribute__(attr_name) a = A({\"name\": \"kobe\"}) a.x = {\"height\": \"198\"} # 直接赋值，不会调用__getattribute__ a.x['height'] = '200' # 这里相当于要先获取到a.x,然后再去修改a.x的'height'的值，所以触发了访问属性，会调用__getattribute__ 访问属性时，并不是直接去调用__getattribute__方法 其实在点操作符去访问属性的时候，是通过了一个hook函数来执行查找 def getattr_hook(obj, name): \"Emulate slot_tp_getattr_hook() in Objects/typeobject.c\" try: # 尝试 执行__getattribute__方法 return obj.__getattribute__(name) except AttributeError: # 如果 该对象所属的类中没有 __getattr__方法，直接报错没有找到该属性 if not hasattr(type(obj), '__getattr__'): raise # 如果该对象所属类有__getattr__方法，就去调用该方法 return type(obj).__getattr__(obj, name) # __getattr__ 根据上述原理，如果用户直接调用 obj.__getattribute__()，__getattr__() 的补充查找机制就会被绕过。 测试如下： class Test: def __getattr__(self, attr_name): return \"这是__getattr__方法\" test = Test() print(test.x) # 访问一个不存在的属性 会正常走到__getattr__方法去 print(test.__getattribute__('x')) # 报错没有该属性, AttributeError: 'Test' object has no attribute 'x' 上述源码也解释了，实例在访问不存在的属性的时候，调用getattr方法，就会进入到该对象所属类的__getattr__(self,attr_name)方法中 这就表示，直接实例test所属的类Test去访问不存在的属性的时候是走不到这个方法里的，同理，如果给实例test添加一个getattr方法，但是test所属的Test类是没有getattr方法的，这时候test去访问不存在的属性 也会报错 class Test: pass test = Test() test.__getattr__ = lambda attr_name: \"固定返回内容\" print(test.xx) # 报错没有该属性, AttributeError: 'Test' object has no attribute 'xx' "},"FinancialManagement/基金/基金基础-货基债基股基/01-纯债基金.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/01-纯债基金.html","title":"纯债基金","keywords":"","body":"datetime:2020/1/13 14:00 author:nzb 天天基金网 纯债基金实战 选长期纯债基金 基金排行 开放基金排行 债券型 分类：长期纯债 近3年、排名前30位作为候选基金池 逐个点击基金名称，点击债券持仓：1、剔除投资可转债的基金；2、剔除小公司的基金；3、剔除规模较大（基金规模超过20亿）的基金；4、剔除同一家大型基金公司旗下排在第二名以及以下兄弟基金 找出综合费率最低的、成立时间相对较长、基金经理年级较大、管理时间较长 推荐后端一次性收取的，持有一年以上 选长期纯债基金 基金排行 开放基金排行 债券型 分类：定期开放债券 别选杠杆比例超过160%的债基、选择封闭期为一年的债基、看准下次开放时间 总结：购买还是力哥推荐的股票指数基金，后续讲解 "},"FinancialManagement/基金/基金基础-货基债基股基/02-股票型基金.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/02-股票型基金.html","title":"股票型基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 股票型基金是基金中风险最高的基金，货基和债基是低风险的。 股票型基金持仓不低于80%。 主动型股票型基金挑选技巧（股票型基金不推荐主动性，推荐指数基金） 拼爹-基金公司 拼人-基金经理 基金经理的基本背景：年龄(至少35以上)、学历(经济学、金融学、理学、管理学等)、履历(管理时间越长越好) 基金经理的操盘风格：短线、长线；晨星投资风格箱 换手率在50%-200%属于正常，担心超过200%，500%、1000%的。 晨星风格箱 拼业绩：基金过往业绩，基金业绩考量因素： 成立时间足够久：选择成立时间三年以上，最好五年以上的 基金业绩够稳定：过去5年中，每年的业绩回报都能始终稳定在同类基金的前20%排名内的基金 晨星网数星星选基金 拼规模 投资中小盘基金：适合挑选10-20亿规模 投资大盘股基金：适合挑选30-100亿规模 超过100亿或不到2亿甚至只有三五千万：不碰 拼成本 考虑管理费小于或等于1.5%的股票型基金 申购费：一般1.5%，天天基金网，蚂蚁财富等0.15% 赎回费：最高0.5%，有些基金具有持有政策 总结：挑选赎回费阶梯征收的基金 "},"FinancialManagement/基金/基金基础-货基债基股基/03-大数据指数基金.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/03-大数据指数基金.html","title":"大数据指数基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 不适合投资 "},"FinancialManagement/基金/基金基础-货基债基股基/04-ETF基金.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/04-ETF基金.html","title":"ETF基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb ETF基金 指数基金中的战斗机 ETF基金一级市场净值 = 基金批发价 ETF基金二级市场价格 = 基金零售价 折价：零售价 溢价：零售价 > 批发价 溢价率：基金这一刻二级市场价格除以该基金这一刻估值它所算出来的基金净值它所得到的百分比。 ETF基金套利 查看折溢价：集思录 -> ETF基金 -> 溢价率 交易建议 溢价率 > 3% 谨慎交易 溢价率 > 5% 暂停买入 溢价率 > 10% 建议卖出，溢价回归后买入 相反 折价率 > 3% 考虑优先买入 折价率 > 10% 加速买入 一般情况下正常折溢价都在1%~2%之间 ETF交易时段： 工作日 周一到周五 上午：9.30 - 11:30 下午：1:00 - 3:00 集合竞价规则 9:15 - 9:20 可挂单、可测单 9:20 - 9:25 可挂单、不可测单 9:25 以后就可以看到集合竞价的具体的成交价格和数量了 ETF基金买卖流程(二级市场) 注：和股票买卖是一模一样的，以下以华泰证券交易软件为例 打开软件，进入到股票交易界面(千万不要进入基金交易界面) 然后点击买入，输入证券代码，有买入5挡和卖出5挡 如果想要一挂上去就立刻成交：买入ETF时就选择挂卖一价，卖出ETF时就选择挂买一价。 也可以挂自己想要的价格，待价格达到时就能成交 基金规模低于2亿不要买，超过10亿以上的适合去投资。 ETF联接基金优势 持有成本比普通指数基金低 可自动设置定投计划 ETF基金 VS ETF联接基金 成本上： ETF基金 胜 操作上： ETF联接基金 胜(起步价低、可定投) "},"FinancialManagement/基金/基金基础-货基债基股基/05-LOF基金.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/05-LOF基金.html","title":"LOF基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb LOF基金(没经验，不建议投资) 同时具备ETF基金和ETF联接基金的优势 "},"FinancialManagement/基金/基金基础-货基债基股基/06-四大行业指数.html":{"url":"FinancialManagement/基金/基金基础-货基债基股基/06-四大行业指数.html","title":"四大行业指数","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 四大行业指数 未来最有钱途的指数，适合长期投资 泛理财 中证金融指数：银行、证券、保险三大行业的指数 中证互联网金融指数 泛娱乐 中证教育产业指数 中证娱乐产业指数 中证传媒产业指数 中证影视产业指数 中证文体休闲产业指数 中证TMT指数 泛教育 中证教育产业指数 中证娱乐产业指数 中证传媒产业指数 中证影视产业指数 中证文体休闲产业指数 中证TMT指数 泛健康 各种 医药和医疗指数 互联网医疗指数 中证健康产业指数 "},"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/01-分级基金.html":{"url":"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/01-分级基金.html","title":"分级基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 分级基金(杠杆基金) 基础信息 一倍正向杠杆：基准净值上涨1元，收益2元。 两倍正向杠杆：基准基准上涨1元，收益4元。 一倍反向杠杆：基金基准下跌1元，收益1元。 分级约定收益 = 一年期定期存款基准利率 + 1.5%~5% 分级A:分级B = 5:5 初始杠杆率：2 计算方法：母基金份额/分级B：10/5=2(2倍) 不建议碰债券型分级基金。 场内基金规模低于2亿份一律不要碰。 为什么需要学习分级基金： 分级基金存有赚钱机会 分级基金会王者归来 为未来杠杆投资打下基础 母基金净值 = 分级A净值分级A占比 + 分级B净值分级B占比 分级基金给分级A的利息不是现金而是母基金的份额 分级A定期折算基准日 分级基金正式成立的日期 每年12月到1月之间选择一天，一般是12月1日或12月15日或一月元旦节之后的第一个交易日。 分级A实战攻略 永续分级A ≈ 永续债券 或者叫无期债券 建议投资永续分级A 隐含收益率 = 约定收益率/分级A的加个 - (分级A的净值 - 1) 可在集思录网找到现成数据 ：首页 -> 分级基金 -> A类 -> 修正收益率 修正收益率才是选择分级A的王道，这是针对一般的永续型分级A。不适用有期限的分级A。 加息周期(央行处于加息周期时)：约定收益率较低(如：3%、3.2%)的分级A -> 折价回归 -> 修正收益率提高 ----->优先考虑投资 加息周期(央行处于加息周期时)：约定收益率较高(如：4%、4.5%)的分级A -> 溢价回归 -> 修正收益率降低 降息反之 定期折算对分级A的影响： T日：定折基准日：母基金暂停申赎 配对转换暂停 T+1日：分级A暂停交易：母基金暂停申赎 T+2日：分级A 上午10:30恢复交易 分级B实战攻略 杠杆是把双刃剑，不建议投资，分级B适合激进型投资者。 初始杠杆：分级A:分级B = 5:5 初始杠杆率：2 计算方法：母基金份额/分级B：10/5=2(2倍) 净值杠杆：分级B净值/母基金净值的涨幅=母基金总净值/B份额总净值 =(母基金份数×母基金净值)/(B份额份数×B份额净值) =(母基金净值/B份额净值)×份额杠杆(初始杠杆) 价格杠杆(集思录可查看)：母基金总净值/B份额总市值 =(母基金份数×母基金净值)/(B份额份数×B份额价格) =(母基金净值/B份额价格)×份额杠杆 分级B因为有分级A的融资成本，股市不涨不跌，依然会不断亏钱。 除权除息处理：把基金的净值相对降下来 除权就是送股票 除息就是送现金 定期折算不会影响分级B，而不定期折算会影响分级A、分级B和母基金。 不定期折算：只有在满足规定条件时才会触发的折算。可在集思录上查看上下折阈值 向上折算：简称上折：分级A、分级B份额不变，母基金、分级A 、分级B净值回归1元，净值超出1元的部分转换成母基金 向下折算：简称下折：对分级A持有人利益的保护，对分级B持有人利益的巨大潜在伤害。 触发上下折标准： 触发上折要看母基金净值 触发下折要看分级B净值 下折母基金需跌在15%以内一律不要碰。 不定期折算对分级A、B的影响： T日：定折基准日：母基金暂停申赎 配对转换暂停 T+1日：分级A、B暂停交易：母基金暂停申赎 T+2日：分级A、B 上午10:30恢复交易 深成指分级A的投资： 深成指A价格 > 1元 -----> 千万别买 0.8 合理水平 深成指A价格 具备投资价值 深成指A价格 风险不高 可定投的奇葩分级B：深成指B和H股B 深成指B价格 考虑定投 深成指B价格 放心定投 深成指B价格 加码定投 分级套利 分级A定折套利(难) 市场预期导致利差空间缩小 定折完成后分级A下降速度快 分级B上折套利(机会渺茫) 分级A和分级B的下折套利(折价率不够高不要轻易尝试套利) 拆分合并套利(常见) "},"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/02-避险基金.html":{"url":"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/02-避险基金.html","title":"避险基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 避险基金(保本基金) 基础知识 适合老年人 选择保本基金(注意事项)： 分为保证型和护本型 必须完整持有一个保本周期(2年、3年或5年) 多数设计有惩罚性的赎回费率 保本基金并非都100%全额保本 设置了触发收益率条款(最常见的设置是15%) "},"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/03-量化基金.html":{"url":"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/03-量化基金.html","title":"量化基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 量化基金 量化策略四种常见策略 量化选股策略：利用数量化的方法挑选具备潜在阿尔法收益的股票组合。 量化择时策略：通过量化模型预测未来市场的走势，判断股价未来会上涨就买入，判断股价未来会下跌则卖出。 趋势跟踪策略 事件驱动型交易策略 SVM交易策略 统计套利策略：通过对历史数据的统计分析找出变量与收益之间的关系来指导套利交易。 算法交易策略： "},"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/04-QDII基金.html":{"url":"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/04-QDII基金.html","title":"QDII基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb QDII基金 基础知识 QDII型基金优势 投资门槛较低 流动性较高 管理费低 QDII基金的特殊风险 汇率风险 市场本身风险 资本流动管制风险 成本高于普通基金 基金净值的显示存在滞后性 建议购买ETF或LOF型的QDII基金 如何查看折溢价套利：集思录 ：首页 --> T+0 QDII --> 参考溢价率 --> 具体的套利方法跟LOF一样 "},"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/05-FOF基金.html":{"url":"FinancialManagement/基金/基金进价-特种基金：分级基金QDII基金量化基金等/05-FOF基金.html","title":"FOF基金","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb FOF基金 基础知识 FOF基金特点 80%以上基金资产投资其他基金 投资单只基金最高比例占比20% 不能投资其他FOF基金 基金管理人、托管人不得对基金中基金的管理费、托管费以及销售费双重收费。 不得投资分级基金 不得持有运作小于1年，最近定期报告披露规模小于2亿元的基金 不得收取投资自家产品部分的管理费托管费和销售费 FOF基金优点 获得相对更高的投资性价比 不受传统基金的投资限制(比如：股票型基金必须买80%的股票等) 分类 根据基金管理人 内部管理型 外部管理型 根据基金配置 内部配置型 全市场配置型 组合后分类 内部管理 + 内部配置 优点：收费 最低 缺点：对产品丰富程度要求高 内部管理 + 全市场配置 优点：可以避免道德风险 缺点：考验团队尽调能力，双重收费，投资成本高 外部管理 + 内部管理 优点：收费低，避免道德风险 缺点：需支付第三方费用，无法完全避免道德风险 外部配置 + 全市场配置 优点：投资决策独立性最高，可投资范围最大，基本杜绝了道德风险 缺点：整体收费变得更高 总结：不建议投资FOF基金 "},"FinancialManagement/基金/基金定投/01-基金定投.html":{"url":"FinancialManagement/基金/基金定投/01-基金定投.html","title":"基金定投","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 基金定投 原理 通过定期定额投资不停的分批次小额买入基金，使基金的收益曲线更接近宏观经济的走势，变得比较平滑 - 只要基金从0.2元反弹到0.375元，你就解套，到1元你就赚了 - 只要基金从0.2元反弹到0.28元，你就解套，到1元你就赚了357% 下跌时坚持定投，亏损比例越来越小 上涨时坚持定投，盈利比例越来越小 波动剧烈的基金更适合定投，买指数基金就是买大盘，还有股票，黄金，石油等其他波动剧烈的产品 选择合适的进场时机，基金定投才能发挥最大作用 建议投资者每周或每月做一次变额定投 智能定投 智能定投运用策略 均线策略 运用移动平均线MA作为参考指标来指导基金定投的策略 蚂蚁财富的慧定投就是均线策略 指数近十日振幅超过5%，定投金额减少 指数近十日振幅小于5%，定投金额增加 均线策略智能定投缺点 未充分考虑定投时的估值因素，不够长的均线缺乏足够的参考价值 未解决止盈问题 风险偏好策略 根据投资者的风险承受能力以及投资时长智能匹配基金类别和配置比例进行定投 风险偏好型策略智能定投缺点 门槛较高 定投成本高 动态再平衡策略 选择关联度不大或负相关的基金品种构建基金定投组合 蛋定投(变额定投) 二八轮动策略：用量化模型去追涨杀跌，如果发现追错了毫不犹豫马上掉头通过多次轮换来不断积累收益 二八轮动策略不适合震荡行情 力哥七步定投 解决上面定投缺点 概述篇 核心：2、4、5、7 2：回报率 能获取15%~25%的回报，平均20%的年化收益 4：四大原则 长期坚持定期不定额 长期坚持止盈不止损(克服恐惧 战胜贪婪) 只问贵贱 不看趋势(放下预测 安心定投) 越跌越买 越涨越卖 5：5种具体投资策略 全天候配置策略 低估值折时轮动策略(哪个便宜，哪个多点，哪个贵了，少配点，太贵了不要去定投了) 价值平均策略 网格交易策略 动态再平衡策略 7；具体的7个操作步骤 完成风险偏好测试：保守型、稳健型、平衡型、进取型、激进型 全面统计家庭财务信息 做好家庭资产配置方案 提取生活警急备用金(货基，把3~6个月的家庭支出金额拿出来作为备用金) 购置合适的保险(不建议买储蓄型保险，只要买比较便宜的消费型保险有个基本保障就行了) 消费型保险 储蓄型保险 将钱分成长期和短期(未来3年可能要用) 现金口袋：现金流规划 保险口袋：家庭保障规划 消费口袋：消费和短期投资规划 储蓄口袋：长期投资规划(只有前面3个口袋搞定才能实施定投策略) 布局：设计存量资金定投计划(已经拥有的资金) 计划定投阶段 不同资金阶段，低阶级增值，高阶级保值 布局定投阶段 维持定投阶段 调整定投阶段 未来一年完成存量定投布局 收割：对提前完成定投的基金进行网格收割(维持定投阶段) 总结：设置增量资金定投计划(调整定投阶段) 布局篇 设计存量资金定投计划(已经拥有的资金) 计划定投阶段 布局定投阶段 维持定投阶段 调整定投阶段 选基篇 不同经济周期配置不同的大类资产，能获得截然不同的收益表现 大类资产：股票类，债券类，现金类，黄金在类的大宗商品 4种不同的经济时期(难以预测未来经济走势) 经济复苏：经济上行，通胀下行，GDP在不懂上升，CPI却始终维持在低位----->增持股票，减持大宗商品 经济过热阶段：经济上行，通胀上行----->增持股票，大宗商品，减持债券，减持现金 经济滞胀阶段：经济下行，通胀上行----->减持各类资产，现金为王，本金保住 经济衰退阶段：经济下行，通胀下行----->增持债券，减持大宗商品 不管处于何种经济周期总有投资品种表现突出 适合定投的标主要是：股票、石油、黄金、大宗商品 估值篇 市盈率(PE)是判断估值高低最重要的指标，其次起到辅助参考价值的市净率(PB) 不建议投资个股或对股票进行定投 估值 绝对估值：指数评价市盈率超过了50倍的，一律不碰 相对估值 纵向比较：以史为鉴(历史数据) 横向比较 倾向于纵向比较判断估值高不高 分为点数组越小，估值越低，越有投资价值 力式五分位法： 低估：0% ~ 19.99% 合理偏低：20% ~ 39.99% 合理：40% ~ 59.99% 合理偏高：60% ~ 79.99% 高估：80% ~ 100% 分位点低于40%开始定投(市净率也一样，如果市盈率很低 ，但是市净率超过了60%也不要定投) 分位点高于41%不适合开始定投 力哥看黄金价格(大宗商品影响因素很多) 金价低估： 金价合理：1000美元/盎司 ~ 1500美元/盎司 金价高估：> 1500美元/盎司 力哥看石油价格(大宗商品影响因素很多) 石油低估： 石油合理：35美元/桶 ~ 75美元/桶 石油高估：> 75美元/桶 定投标的最少不少于3个，不高于12个 港股：恒生指数和H股指数 美股：标普指数和纳斯达克指数 A股：沪深300、中证500、估值相对较低行业指数 操作篇 定投布局周期至少一年 资金量较小的每月定投一次，存量资金分成12份，较多双周定投一次，存量资金分成25份，更多每周定投一次，存量资金分成50份 如果后续没有足够的增量资金(资金来源)可以跟上，这时存量资金定投布局需要适当延长，以规避中短期的价格波动，但是最长不超过2年 判断依据：存量资金/月收入 > 100 -----> 适当延长定投布局周期 定投方式更推荐场内基金(ETF、LOF和分级B) 场内基金不能设置自动定投，需要主动打卡股票交易软件进行，容易情绪化 未来一年完成存量定投布局(价值平均策略) 目标市值恒定策略：一直保持市值为定投目标即 此次定投金额 = 目标定投市值 - 当前定投市值 定投份额 = 此次定投金额 / 基金成交价 (最小100份额，需要四舍五入) 分位点 分位点： 分位点：20% ~ 39.9% 按既定定投，正常的市值恒定定投 分位点： PE分位点 PE分位点 PE分位点 PE分位点 分位点： > 45% 视情况而定 PE分位点 > 45% 把每次基准定投的金额降低到0.75倍 PE分位点 > 50% 把每次基准定投的金额降低到0.5倍 PE分位点 > 55% 把每次基准定投的金额降低高到0.25倍 PE分位点 > 60% 停止定投，维持恒定的市值就可以了 PE分位点 > 65% 抛售已投的基金份额25% PE分位点 > 70% 再抛售已投的基金份额25% PE分位点 > 75% 再抛售已投的基金份额25% PE分位点 > 80% 清仓 如果市盈率((PE)没有高于80%，而市净率(PB)高于80%，同样清仓 收割篇 对提前完成定投的基金进行网格收割(维持定投阶段) 网格交易：就是通过设定一个锚点以此为基准，通过涨跌来调控仓位大小的交易策略 上涨网格空隙大 下跌网格空隙小 网格交易法利弊 在熊市没有估值依托 牛市容易卖光筹码 对震荡市是十分有利 涨跌幅度达到多少时可以网格交易一次呢？ 没有完全一定的说法 单边行情中(牛市、熊市) 网格应放大一点(跌的时候跌得有点大了，一次性多补点，涨的时候涨得有点大了，收割一波大的) 震荡行情中 网格应收小一点 建议最大网格为20%，最小网格为3% 同一时期上涨时收割网格大于下跌时补仓网格，比如：涨5%(20%)时收割一次，那么跌3%(15%)就要补仓一次 七步定投策略对后背资金的要求比较高 总结篇 设置增量资金定投计划(调整定投阶段) 动态再平衡策略 总结：具体的7个操作步骤 完成风险偏好测试：保守型、稳健型、平衡型、进取型、激进型 全面统计家庭财务信息 做好家庭资产配置方案 布局：设计存量资金定投计划(已经拥有的资金) 全天候配置策略(二维三核，左右护法) 低估值折时轮动策略 未来一年完成存量定投布局 价值平均策略 收割：对提前完成定投的基金进行网格收割(维持定投阶段) 网格交易策略 总结：设置增量资金定投计划(调整定投阶段) 动态再平衡策略 低估值折时轮动策略 普通定投成本比较高，怎么破？ 用超低佣金的场内基金代替 普通定投无法用量化指标做到低位多头高位少投，怎么破？ 运用价值平均策略 普通定投没考虑估值因素怎么破？ 运用低估值折时轮动策略 普通定投不会自动止盈怎么破？ 运用动态再平衡策略 普通定投震荡市不赚钱怎么破？ 运用网格交易策略市盈率( "},"FinancialManagement/基金/00-投资术语.html":{"url":"FinancialManagement/基金/00-投资术语.html","title":"基金投资术语","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 投资理财原则：不懂不要碰、明确自己的风险承受能力。 单位净值 累计净值 现代投资组合理论 ：货币基金、债券基金和股票基金组合 晨星投资风格箱 白马股：价值型股票、业绩稳定、分红能力強 黑马股：成长型股票、业绩一般、分红很少、成长空间大 β系数 :基金和业绩评价基准之间的相关性，大多数股票或基金的β系数介于0.5到1.5间。 基金业绩评价基准 ：基金KPI，根据基金自身特性定制的考核标准 α系数 ：代表一个基金的绝对回报或超额收益。 R平方 ：表明α系数和β系数的精准度。R平方越高可信度越高。 夏普比率 ：夏普比率 = (基金回报率-市场无风险回报率)/标准差。是评价基金优劣的最重要的标准化指标，夏普比率越高基金性价比越高。 特雷诺指数 ：特雷诺指数 = (基金回报率-市场无风险回报率)/β系数。 股票价格指数：描述股票市场总体价格水平变化的指标 上证指数 ：其样本股是在上海证券交易所全部上市股票，包括A股和B股，反映了上海证券交易所上市股票价格的变动情况 上证50指数 上证180指数 深证指数 深证成指 ：深证成分指数是深圳证券交易所的主要股指，代码为399001，简称：深成指 深证100指数 ：由深圳证券交易市场流通市值最大成交最活跃的100只成份股所编制的股票指数，代码为：399330 沪深300指数 ：大盘股中的精华 中证500指数 ：中小盘股中的精华 上证50、中证500、沪深300是中国市场最具代表性的指数。 指数失真 成分指数 ：根据科学客观的选样方法挑选出的样本股所构成的指数，只计算流通股，剔除非流通股。 支付对价 ETF基金 ETF联接基金 集合竞价模式 LOF基金 分级基金 ：把一个基金的资产和收益拆分成不同风险级别的两个子基金。 CPPI策略 TIPP策略 OBPI策略 打新基金 ：资金用于打新股的基金。 IPO 市盈率 ：（股份收益比率或本益比）股票市价与其每股收益的比例，最常用来评估股价水平是否合理的指标之一。 生命周期基金 定增基金 量化基金 量化对冲基金 等额本金还款法 等额本息还款法 QDII基金 房地产信托投资基金 FOF基金 ：一种专门投资于其他证券投资基金的证券投资基金。 场外基金 ：不能在交易所上市交易的基金 "},"FinancialManagement/基金/00-投资误区.html":{"url":"FinancialManagement/基金/00-投资误区.html","title":"投资误区","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 投资误区 误区一：基金一定要长期投资吗？ 把握时机，不能为了长期投资而长期投资，就好比春种秋收 误区二：基金净值是越便宜越好吗？ 并非如此 净值低： 新基金：不推荐 业绩差：不推荐 老基金，业绩也不错：通过分红或拆分减下来，不推荐 净值高：业绩优秀 误区三：是不是分红越多的基金越好？ 分红和基金的好坏没有必然关系，有恶性分红来实现二次营销就像上面说的。 "},"FinancialManagement/基金/基金全球配置大法/01-全球配置.html":{"url":"FinancialManagement/基金/基金全球配置大法/01-全球配置.html","title":"全球配置","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 基金全球配置大法 八个字：二维三核、左右护法 核心-卫星资产配置理论 股市： 成熟市场 北美市场 西欧市场 日本市场 新兴市场 亚太市场 东亚市场 东盟市场 澳新市场 南亚市场 中东市场 东欧市场 拉美市场 二维三核市场标的(一一对应) 核心：中国、中国香港、美国 卫星：印度、东盟、德国 香港相比日本的优势： 香港是全球三大金融中心之一 中国大陆发展继续惠及香港 左右护法：黄金和石油 具体投资建议：投资指数基金，尤其是成本最低可以场内交易的ETF基金 基金配置原则 估值越低投越多，估值越高投越少，高到一定程度后果断清仓 核心资产最低不低于50%，卫星资产最高不能高于50%，一般三七开或二八开 "},"FinancialManagement/基金/基金全球配置大法/02-场外基金开户和买卖实操.html":{"url":"FinancialManagement/基金/基金全球配置大法/02-场外基金开户和买卖实操.html","title":"场外基金开户和买卖实操","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 场外基金开户和买卖实操 场外基金 ：不能在交易所上市交易的基金 直销(例如：购买华夏基金公司的某一款基金) 直接百度华夏基金 点击官网 点击右上角的开户 填写绑定银行卡 输入姓名、身份证号 填写手机、邮编、地址并设置密码 缺点：基金组合不方便，建议在一站式代销平台上购买场外基金 代销(天天基金网，蚂蚁财富，雪球蛋卷) 开户跟上面直销差不多一样 稍微复杂点的是券商交易软件(以华泰证券为例) PC端 点击软件左下角的基金这一栏(如果你从来没有在你想买的基金的公司开过户，就要点击左侧的基金开户，勾选对应的基金公司，然后开户) 如果是新发行的基金，正处于认购期，点击认购，输入基金代码，基金份额，确认下单 如果是已经在运作期间就点击申购 如果要赎回，就点击赎回 华泰证券手机端的涨乐财富通 登录账号 点击下单栏的理财 点击基金 输入基金代码、名称 天天基金网赎回方式 赎回到绑定银行卡(速度慢) 赎回到活期宝(天天基金网自己建立的货基) 转入其他基金 点击基金交易栏下的基金转换，可看到目前持仓的基金 点击右边的普通转换，也就是同一基金公司的内部转换，能享受较低的转换手续费，超级转换是不同基金公司的转换 基金分红方式 现金分红 红利再投资(货基固定的红利再投资) 以天天基金网为例 点击基金交易菜单栏下的基金分红设置，就能看到持仓基金 点击相应基金后面的修改按钮，然后选择你想要的分红方式 "},"FinancialManagement/基金/基金全球配置大法/03-场内基金开户和买卖实操.html":{"url":"FinancialManagement/基金/基金全球配置大法/03-场内基金开户和买卖实操.html","title":"场内基金开户和买卖实操","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 场内基金开户和买卖实操 场内基金优点 手续费更低 操作更灵活 便于高级套利 场内基金缺点 选择面小 无法设置自动定投 不利于执行既定策略 场内基金必须通过券商的交易软件进行买卖 券商账户开户 证券账户(收费40元，各收20，网上开户全免了) 沪A 深A 资金账户 以华泰证券为例 华泰证券官网或App涨乐财富通 pc：身份证、银行卡、摄像头、麦克风的电脑 手机端：手机、身份证、银行卡 个人基本信息、银行卡信息、设置密码、上传身份证、视频认证、完成风险测评、资料审核、短信通知、确保存管功能激活(有些银行直接激活，有些需要手动激活) 买卖实操(华泰证券pc端) 左侧股票一栏点击银证转账 银行->券商: 券商->银行: 银证转账时间：交易日：8:30am - 4:00pm 买卖场内基金注意点： 是通过左下角股票这一栏的买入和卖出这2个入口，跟买卖股票一样的 不是基金这一栏 买入数量不能超过最大可买数量 买入数量必须是100的整数倍 价格优先原则 > 时间优先原则 没成交的可在撤单一栏撤单 常用的还有查询这一功能 资金股票： 资金余额：账户里的全部资金 可取资金：可以提现的资金 冻结资金：正挂单买入的资金 可用资金；可买入证券的资金 只能现金分红 对于有时间、有自控能力的推荐用场内基金做定投：成本更低、效率更高、更灵活 "},"FinancialManagement/基金/基金全球配置大法/04-看懂股票行情.html":{"url":"FinancialManagement/基金/基金全球配置大法/04-看懂股票行情.html","title":"看懂股票行情","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 看懂股票行情 以华泰证券软件为例 k线 K线(阴阳线) 开盘价、收盘价、单日最低价、单日最高价 柱子的顶和底对应开盘价和收盘价，谁高谁在上面 阴线：开盘价高于收盘价，下跌，用实心柱子表示(绿色或蓝色) 阳线：收盘价高于开盘价，上涨，用空心柱子表示(红色) 上影线：最高点表示单日最高价，无上影线：光头 下影线：最低点表示单日最低价，无下影线：光脚 十字星：开盘价和收盘价比较接近， 上下影线都很长：大十字星， 上下影线都很短：小十字星 只有下影线，没有上影线：T型光头十字星 只有上影线，没有下影线：倒T型光头十字星 一字线 向下跳空缺口：除权的影响，通过k线的复权功能防止k线图失真 涨跌幅波动 小幅波动：涨跌幅0~1.5% 中幅波动：涨跌幅1.5%~5% 大幅波动：涨跌幅5%~10% 以上证指数的年k线为例： 2007年：柱子很长很高大，说明这一年全年都涨得不错 2005年：柱子很短，而上影线特别长，说明这一年年中的时候股市疯涨了一阵子，但是后来跌下来，对应2015的股灾。 2008年：全年从头跌到尾，超级大熊市 复权 向前复权：保持现有价格不变，将以前的价格折算相应缩减 向后复权：保持先前的价格不变，将除权后的价格增加修复回去，这个用的比较多 移动平均线(均线，MA) MA + 数字：表示多少日均线 MA20=20日均线：包含了当天收盘价在内的20个交易日的平均值 日均线指标：MA5、MA10 季均线指标：MA30、MA60 年均线指标：MA120、MA250、MA500 也可以自定义均线 短期均线超越中长期均线叫金叉，向上的趋势 中长期均线超越短期均线叫死叉，向下的趋势 成交量柱形图 在k线和均线下部分 MAVOL开头的线是成交量均线，后面跟的数字表示几日的平均线 如何查看某个股票或基金的K线图 直接打卡软件在键盘上敲出股票代码或名字首字母，弹出搜索框，选中双击 上下键对K线图放大缩小 左右键可以显示十字坐标线，鼠标空白处点一下也可以 长期查看可右击空白处，添加自选股 F10可快速查看股票公司或基金概况 F3、F4可快速查看上证指数和深证成指这两个大盘指数的情况 "},"FinancialManagement/基金/基金全球配置大法/05-基金套牢怎么办.html":{"url":"FinancialManagement/基金/基金全球配置大法/05-基金套牢怎么办.html","title":"基金套牢怎么办","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 基金被套牢怎么办 四大策略 加仓策略：通过不断在 更低的成本价买入更多份额的该基金来摊薄该基金的整体持有成本 一投成本价1元，二投时减低至0.5元，买入20000快40000份额，最后持有成本摊薄到0.6元，只要涨会0.6元就可以解套 执行加仓策略的前提 被套牢的是个好基金 足够多可长期投资的资金 加仓策略的基本原则 套牢越深，投入资金越多 亏损渐小，投入速度放缓 加仓策略难执行，不要盲目加仓 装死策略：任由套牢基金跌下去，既不割肉止损也不加仓投入，等待下一轮牛市回归 执行装死策略的难点 时间成本难控制，时间是有价值的 未来走势不确定 装死策略执行前提 套牢基金 长期无他用 套牢基金 本身质地好 指数基金比主动型基金更适合装死策略 换仓策略： 忘记成本，换个赛道 止损策略： 最不推荐，原则是：止盈不止损 总结 基金质地好 + 资金允许 = 加仓策略 基金质地好 + 资金不够 = 装死策略 基金质地差 = 换仓策略 "},"FinancialManagement/股票/01-股票市场常用名称解释.html":{"url":"FinancialManagement/股票/01-股票市场常用名称解释.html","title":"股票市场常用名称解释","keywords":"","body":"股票市场常用名词解释 一、基础知识部分 1、资本市场：资本市场是指证券融资和经营一年以上中长期资金借贷的金融市场。货币市场是经营一年以内短期资金融通的金融市场，资金需求者通过资本市场筹集长期资金，通过货币市场筹集短期资金。 2、股票：股票是股份有限公司在筹集资本时向出资人发行的股份凭证，代表着其持有者对股份公司的所有权。具有以下基本特征：不可偿还性，参与性，收益性（股票通常被高通货膨胀期间可优先选择的投资对象），流通性，价格波动性和风险性。 3、债券：债券是政府、金融机构、工商企业等机构直接向社会借债筹措资金时，向投资者发行，并且承诺按一定利率支付利息并按约定条件偿还本金的债权债务凭证。具有如下特征：偿还性，流通性，安全性，收益性。 4、可转换证券：是一种其持有人有权将其转换成为另一种不同性质的证券，主要包括可转换公司债券和可转换优先股。 5、权证：是指标的证券发行人或其以外的第三人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买或出售标的证券，或以现金结算方式收取结算差价的有价证券。 6、认购权证：发行人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买标的证券的有价证券。 7、认沽权证：发行人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人出售标的证券的有价证券。 8、证券投资基金：基金是指一种利益共享、风险共担的集合证券投资方式，即通过发行基金单位，集中投资者的资金，由基金托管人托管，由基金管理人管理和运用资金，从事股票、债券等金融工具投资。 9、开放式基金：是指基金发行总额不固定，基金单位总数随时增减，投资者可以按基金的报价在国家规定的营业场所申购或者赎回基金单位的一种基金。 10、封闭式基金：是指事先确定发行总额，在封闭期内基金单位总数不变，基金上市后投资者可以通过证券市场转让、买卖基金单位的一种基金。 11、一级市场：指股票的初级市场也即发行市场，在这个市场上投资者可以认购公司发行的股票。 12、IPO：全称Initial public offering( 首次公开募股）指某公司（股份有限公司或有限责任公司）首次向社会公众公开招股的发行方式。 13、发行价：当股票上市发行时，上市公司从公司自身利益及确保股票上市成功等角度出发，对上市的股票不按面值发行，而制订一个较为合理的价格来发行，这个价格就称为股票的发行价。 14、溢价发行：指新上市公司以高于面值的价格办理公开发行或已上市公司以高于面值的价格办理现金增资。 15、折价发行：指以低于面前的价格发行。 16、二级市场：指流通市场，是已发行股票进行买卖交易的场所。 17、A股：A股的正式名称是人民币普通股票。 18、B股：B股的正式名称是人民币特种股票。 19、H股：H股即注册地在内地、上市地在香港的外资股。 20、S股：沪深证券交易所2006年10月9日起一次性调整有关A股股票的证券简称。其中，1014家G公司取消“G”标记，恢复股改方案实施前的股票简称；其余276家未进行股改或已进行股改但尚未实施的公司，其简称前被冠以“S”标记，以提示投资者。 21、ST股票：ST板块股就是指在沪深股市上挂牌的股票，因经营亏损或其他异常情况中国证监会为了提醒股民注意特别处理的股票。 22、ST股票：ST板块股就是指在沪深股市上挂牌的股票，对有终止上市风险的个股中国证监会为了提醒股民注意特殊处理的股票。 23、蓝筹股：蓝筹股是指资本雄厚,股本和市值较大的信誉优良的上市公司发行的股票。 24、红筹股：红筹股是香港和国际投资者把在境外注册、在香港上市的那些带有中国大陆概念的股票。 25、绩优股：是指过去几年业绩和盈余较佳,展望未来几年仍可看好，只是不会再有高度成长的可能的股票。该行业远景尚佳，投资报酬率也能维持一定的高水平。 26、垃圾股：垃圾股指的是业绩较差的公司的股票。这类上中公司或者由于行业前景不好，或者由于经营不善等，有的甚至进入亏损行列。其股票在市场上的表现萎靡不振，股价走低，交投不活跃，年终分红也差。 27、成长股：指新添的有前途的产业中，利润增长率较高的企业股票。成长股的股价呈不断上涨趋势。 28、冷门股：是指交易量小，流通性差，价格变动小的股票。 29、龙头股：龙头股指的是某一时期在股票市场的炒作中对同行业板块的其他股票具有影响和号召力的股票，它的涨跌往往对其他同行业板块股票的涨跌起引导和示范作用。龙头股并不是一成不变的，它的地位往往只能维持一段时间。 30、国家股：国家股是指有权代表国家投资的部门或机构（国资委）以国有资产向公司投资形成的股份，包括公司现有国有资产折算成的股份。它是国有股权的一个组成部分。 31、法人股：法人股是指企业法人或具有法人资格的事业单位和社会团体，以其依法可支配的资产投入公司形成的非上市流通的股份。 32、公众股：公众股是指社会公众依法以其拥有的财产投入公司时形成的可上市流通的股份。 33、基本面： 基本面包括宏观经济运行态势和上市公司基本情况。宏观经济运行态势反映出上市公司整体经营业绩，也为上市公司进一步的发展确定了背景，因此宏观经济与上市公司及相应的股票价格有密切的关系。上市公司的基本面包括财务状况、盈利状况、市场占有率、经营管理体制、人才构成等各个方面。 34、技术面：技术面指反映介变化的技术指标、走势形态以及K线组合等。技术分析有三个前提假设，即市场行为包容一切信息；价格变化有一定的趋势或规律；历史会重演。由于认为市场行为包括了所有信息，那么对于宏观面、政策面等因素都可以忽略，而认为价格变化具有规律和历史会重演，就使得以历史交易数据判断未来趋势变得简单了。 35、牛市：牛市也称多头市场，指市场行情普通看涨，延续时间较长的大升市。 36、熊市：熊市也称空头市场，指行情普通看淡，延续时间相对较长的大跌市。 37、牛皮市：指在所考察交易日里，证券价格上升、下降的幅度很小，价格变化不大，市价像被钉住了似的，如牛皮之坚韧。 38、集合竞价：所谓集合竞价就是在当天还没有成交价的时候，根据前一天的收盘价和对当日股市的预测来输入股票价格，而在这段时间里输入计算机主机的所有价格都是平等的，不需要按照时间优先和价格优先的原则交易，而是按最大成交量的原则来定出股票的价位，这个价位就被称为集合竞价的价位，而这个过程被称为集合竞价。 39、连续竞价：所谓连续竞价，即是指对申报的每一笔买卖委托。 40、零股交易：不到一个成交单位(1手=100股)的股票，如1股、10股，称为零股．在卖出股票时，可以用零股进行委托；但买进股票时不能以零股进行委托，最小单位是1手，即100股。 41、涨跌幅限制：涨跌幅限制是指在一个交易日内，除上市首日证券外，证券的交易价格相对上一交易日收市价格的涨跌幅度不得超过10%；超过涨跌限价的委托为无效委托。 42、涨停板：证券市场中交易当天股价的最高限度称为涨停板，涨停板时的股价叫涨停板价。 43、跌停板：证券交易当天股价的最低限度称为跌停板，跌停板时的股价称跌停板价。 44、托管：托管是在托管券商制度下，投资者在一个或几个券商处以认购、买入、转换等方式委托这些券商管理自己的股份，并且只可以在这些券商处卖出自己的证券；券商为投资者提供证券买、分红派息自动到帐、证券与资金的查询、转托管等各项业务服务。 45、转托管：转托管是在托管券商制度下，投资者要将其托管股份从一个券商处转移到另一个券商处托管，就必须办理一定的手续，实现股份委托管理的转移，即所谓的转托管。 46、指定交易：指定交易指投资者可以指定某一证券营业部为自己买卖证券的唯一的交易营业部。 47、派息：股票前一日收盘价减去上市公司发放的股息称为派息。 48、含权：凡是有股票有权未送配的均称含权。 49、除权：除权是由于公司股本增加，每股股票所代表的企业实际价值（每股净资产）有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。 50、填权：指除权后该股票价格出现上涨，将除权前后的价格落差部分完全补回的情形。 51、贴权：贴权是指在除权除息后的一段时间里，如果多数人不看好该股，交易市价低于除权（除息）基准价，即股价比除权除息前有所下降，则为贴权。 52、XR：证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利。当股票名称前出现XR 的字样时，表明当日是这只股票的除权日。 53、除息：除息由于公司股东分配红利，每股股票所代表的企业实际价值（每股净资产）有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。 54、DR：证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利。 55、XD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 56、配股：配股是上市公司根据公司发展的需要，依据有关规定和相应程序，旨在向原股东进一步发行新股、筹集资金的行为。 57、分红配股：分红即是上市公司对股东的投资回报；配股是上市公司按照公司发展的需要，根据有关规定和相应程序，向原股东增发新股，进一步筹集资金的行为。 58、送红股：送红股是上市公司将本年的利润留在公司里，发放股票作为红利，从而将利润转化为股本。 59、转增股本：转增股本是指公司将资本公积转化为股本，转增股本并没有改变股东的权股益，但却增加了股本规模，因而客观结果与送红股相似。 60、股权登记日：上市公司在送股、配股和派息的时候，需要定出某一天，界定哪些股东可以参加分红或参与配股，定出的这一天就是股权登记日。 61、买壳上市：买壳上市是指一些非上市公司通过收购一些业绩较差、筹资能力弱化的上市公司，剥离被购公司资产，注入自己的资产，从而实现间接上市的目的。 62、大小非减持：非是指非流通股，由于股改使非流通股可以流通持股低于5%的非流通股叫小非,大于5%的叫大非。非流通股可以流通后,他们就会抛出来套现，就叫减持。 63、估值：股票估值是使用一定的方法发现股票内在价值，并买入价值被低估的股票或卖出价值被高估的股票来获得投资收益的股票投资方法和理念。 64、价值回归：当股指或股票价格和其内在价值严重背离后，股指或股票价格降低至其内在价值的过程。 65、QFII：合格境外机构投资者。 66、DQII：合格境内机构投资者。 二、技术分析部分 67、K线：又称为日本线，起源于日本。K线是一条柱状的线条，由影线和实体组成。影线在实体上方的部分叫上影线，下方的部分叫下影线。实体分阳线和阴线两种，又称红（阳）线和黑（阴）线。一条K线的记录就是某一种股票一天的价格变动情况。 68、实体：当日收盘价与开盘价之差。收盘价大于开盘价叫做阳实体，收盘价小于开盘价叫做阴实体。一般情况下，出现阳实体说明买盘比较旺盛，推动股价向上攀升，出现阴实体说明卖盘踊跃，迫使股价节节走低。 69、阳线(红线)：在K线图中中间的矩形长条叫实体，如果收盘价高于开盘价，则实体为阳线或红线。 大阳线---（收盘价-开盘价）/开盘价>7% 中阳线---7%>（收盘价-开盘价）/开盘价>3% 小阳线---3%>（收盘价-开盘价）/开盘价>1% 小阳星---1%>（收盘价-开盘价）/开盘价 70、阴线(绿线)：在K线图中中间的矩形长条叫实体，如果开盘价高于收盘价，则实体为阴线线或绿线。 大阴线---（开盘价-收盘价）/开盘价>7% 中阴线---7%>（开盘价-收盘价）/开盘价>3% 小阴线---3%>（开盘价-收盘价）/开盘价>1% 71、上影线：在K线图中，从实体向上延伸的细线叫上影线。在阳线中，它是当日最高价与收盘价之差；在阴线中，它是当日最高价与开盘价之差。 72、下影线：在K线图中，从实体向下延伸的细线叫下影线。在阳线中，它是当日开盘价与最低价之差；在阴线中，它是当日收盘价与最低价之差。 73、趋势：就是股票价格市场运动的方向；趋势的方向有三个：上升方向；下降方向和水平方向。趋势的类型有主要趋势、次要趋势和短暂趋势三种。 74、趋势线：趋势线是用来衡量价格波动的方向的直线，由趋势线的方向可以明确地看出股价的趋势。在上升趋势中，将两个低点连成一条直线，就得到上升趋势线。在下降趋势中，将两个高点连成一条直线，就得到下降趋势线。上升趋势线起支撑作用，下降趋势线起压力作用，也就是说，上升趋势线是支撑线的一种，下降趋势线是压力线的一种。 75、支撑线：又称为抵抗线。当股价跌到某个价位附近时，股价停止下跌甚至有可能回升，这是因为多方在此买入造成的。支撑线起阻止股价继续下跌的作用。这个起着阻止股价继续下跌的价位就是支撑线所在的位置。 76、压力线：又称为阻力线。当股价上涨到某个价位附近时，股价会停止上涨，甚至回落，这是因为空方在此抛出造成的。压力线起阻止股价继续上市的作用。这个起着阻止股价继续上升的价位就是压力线所在的位置。 77、轨道线：又称通道线或管道线，是基于趋势线的一种方法。在已经得到了趋势线后，通过第一个峰和谷可以做出这条趋势线的平行线，这条平行线就是轨道线。轨道的作用是限制股价的变动范围，让它不能变得太离谱。一个轨道一旦得到确认，那么价格将在这个通道里变动。对上面的或下面的直线的突破将意味着有一个大的变化。 78、骗线：主力或大户利用市场心理，在趋势线上做手脚，使散户做出错误的决定。 三、交易术语部分 79、筹码：投资人手中持有一定数量的股票。 80、多头：预期未来价格上涨，以目前价格买入一定数量的股票等价格上涨后，高价卖出，从而赚取差价利润的交易行为，特点为先买后卖的交易行为。 81、空头：预期未来行情下跌，将手中股票按目前价格卖出，待行情跌后买进，获利差价利润。其特点为先卖后买的交易行为。 82、利多：对于多头有利，能刺激股价上涨的各种因素和消息，如：银根放松，GDP增长加速等。 83、利空：对空头有利，能促使股价下跌的因素和信息，如：利率上升，经济衰退，公司经营亏损等。 84、多头陷阱（诱多）：即为多头设置的陷阱，通常发生在指数或股价屡创新高，并迅速突破原来的指数区且达到新高点，随后迅速滑跌破以前的支撑位，结果使在高位买进的投资者严重被套。 85、空头陷阱（诱空）：通常出现在指数或股价从高位区以高成交量跌至一个新的低点区，并造成向下突破的假象，使恐慌性抛盘涌出后迅速回升至原先的密集成交区，并向上突破原压力线，使在低点卖出者踏空。 86、跳空缺口与回补：是指相邻的两根 K线间没有发生任何交易,由于突发消息的影响,或者投资者比较看好或看空时,股价在走势图上出现空白区域,这就是跳空缺口；在股价之后的走势中，将跳空的缺口补回，称之为补空。 87、反弹：在股市上，股价呈不断下跌趋势，终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。 88、反转：股价朝原来趋势的相反方向移动分为向上反转和向下反转。 89、回档：在股市上，股价呈不断上涨趋势，终因股价上涨速度过快而反转回跌到某一价位，这一调整现象称为回档。 90、回探：股指或股票价格在缓慢上升后，趋势发生改变，缓慢下跌到前期低点区域时，即为回探。 91、盘整：股价经过一段快捷上升或下降后，遭遇阻力或支撑而呈小幅涨跌变动，做换手整理。股价在有限幅度内波动，一般是指上下5%的幅度内的波动。 92、超买：股价持续上升到一定高度，买方力量基本用尽，股价即将下跌。 93、超卖：股价持续下跌到一定低点，卖方力量基本用尽，股价即将回升。 94、吃货：指庄家在低价时暗中买进股票，叫做吃货。 95、出货：指庄家在高价时，不动声色地卖出股票，称为出货。 96、多翻空：原本看好行情的买方，看法改变，变为卖方。 97、空翻多：原本打算卖出股票的一方，看法改变，变为买方。 98、多杀多：普遍认为当天股价将上涨，于是抢多头帽子的人持多，然而股价却没有大幅上涨，无法高价卖出，等到交易快要结束时，竟相卖出，因而造成收盘时股价大幅下挫的情形。 99、满仓：手上全是股票，钱都买了股票。 100、半仓：一半股票，一半资金。 101、空仓：手上没有股票，全都卖空了。 102、斩仓：一般来说是忍痛把赔了钱的股票卖掉。 103、建仓：投资者开始买入看涨的股票。 104、补仓：把以前卖掉的股票再买回来，或许是在某只股票上再追买一些。 105、增仓：你的第一笔买入某股票称建仓；在以后的过程中继续买入称增仓。 106、突破：指股价经过一段盘档时间后，产生的一种价格波动。 107、探底：股价持续跌挫至某价位时便止跌回升，如此一次或数次。 108、割肉：指高价买进股票后，大势下跌，为避免继续损失，低价赔本卖出股票。 109、追高：当股价处于绝对高位时，不断的买入股票。 110、逼空：是指多头连续大幅上涨，逼迫空头止损投降。 111、抛售：立刻卖出手中所有的股票。 112、离场：当下跌趋势形成时，预计未来一段时间不参与操作股票，简称离场。 113、死多：是看好股市前景，买进股票后，如果股价下跌，宁愿放上几年，不赚钱绝不脱手。 114、护盘：庄家为了保持股价稳定，而投入资金购买市场上抛售的股票，以保持股价相对稳定。 115、崩盘：崩盘即证券市场上由于某种利空原因，出现了证券大量抛出，导致证券市场价格无限度下跌，不知到什么程度才可以停止。这种接连不断地大量抛出证券的现象也称为卖盘大量涌现。 116、跳水：跳水即指短时间内快速下跌；大盘或某股票不顾一切大幅度迅猛地下跌，即走势像高台挑水一样在短时间内直线向下。 117、抬拉：抬拉是用非常方法，将股价大幅度抬起。通常大户在抬拉之后便大抛出以牟取暴利。 118、打压：打是用非常方法，将股价大幅度压低。通常大户在打压之后便大量买进以取暴利。 118、洗盘：指庄家大户为降低拉升成本和阻力，先把股价大幅度杀低，回收散户恐慌抛售的股票，然后抬高股价乘机获取价差利益的行为。 119、整理：股市上的股价经过大幅度迅速上涨或下跌后，遇到阻力线或支撑线，原先上涨或下跌趋势明显放慢，开始出现幅度为15％左右的上下跳动，并持续一段时间，这种现象称为整理。 120、获利盘和套牢盘：获利盘一般是指股票交易中，能够卖出赚钱的那部分股票。每一只股票都有获利盘和套牢盘，套牢盘就是买入的股票亏本。他们相互作用。 121、放量缩量：它们是指股票的交易量，与前一天或者前一段时间相比，放大了或是缩小了，称为放量，缩量。 122、止损：是指当某一投资出现的亏损达到预定数额时，及时斩仓出局，以避免形成 更大的亏损。其目的就在于投资失误时把损失限定在较小的范围内。 123、利空出尽：在证券市场上，证券价格因各种不利消息的影响而下跌，这种趋势持续一段时间，跌到一定的程度，空方的力量开始减弱，投资者须不再被这些利空的因素所影响，证券价格开始反弹上升，这种现象就被称作利空出尽。 124、强势调整：就是主力在洗盘，通过洗盘，将意志不坚定的获利盘和解套盘清洗出去，同时又抬高了行情的市场成本，从而为主力扫清障碍和减轻上行压力。 125、惯性：处于涨势或者跌势的时候，其趋势一般将延续。 126、冲高回落：指股指或股价在一段时间内涨到一定位置后，趋势发生改变，形成下跌。 127、大幅振荡：指在较短时间内股指或股票价格在最高点与最低点不断变化，幅度大于5%。 128、震荡调整：买方与卖方的力量相当，在某一价格上上下波动，把价格尽力调整到它的价值，围绕着价值而上下波动、震荡。 129、背离 ：背离是指当股票或指数在下跌或上涨过程中，不断创新低（高），而一些技术指标不跟随创新低（高），称为背离。 130、钝化：当股票走势形成单边上涨（或下跌）时，技术指标产生死叉（或金叉）后，股价并不向相反方向运行，只是在高位（或低位）横盘，指标线有时会拧在一起，像绳子一样。这种情况被称为“钝化”。 131、震仓：震仓就是指主力明明想把股价做上去，但是由于有短线买家利用图表分析跟风持货，或收到该股票的小道消息入货，而主力又不想让这些人白坐轿子白赚钱，于是明明想往上拉抬的，偏偏有意把股价打下去。多数短线炒家都是买涨不买跌，或追涨杀跌的，当股价出乎意料地向下跌，就会令很多数短线跟风者斩仓离场，被主力震出来。也有人称此为洗盘。 132、套牢：预期股价上涨而买入股票，结果股价却下跌，又不甘心将股票卖出，被动等等获利时机的出现。 133、阴跌：指股价进一步退两步，缓慢下滑的情况，如阴雨连绵，长期不止。 134、做多动能：支持股价上涨的所有条件。 135、空仓观望：判断未来不易操作股票，即空仓观望。 四、行情术语部分 136、日开盘价：日开盘价是指每个交易日的第一笔成交价格，这是传统的开盘价定义。目前中国市场采用集合竞价的方式产生开盘价。 137、日收盘价：日收盘价是指每个交易日的最后一笔成交价格。因为收盘价是当日行情的标准，又是下一个交易日开盘价的依据，可据以预测未来证券市场行情，所以投资者对行情分析时一般采用收盘价作为计算依据。 138、日最低价：指当天该股票成交价格中的最低价格。 139、日最高价：指当天该股票成交价格中的最高价格。 140、日成交额：指当天已成交股票的金额总数。 141、日成交量：指当天成交的股票数量。 142、总手：总手是到目前为止该股的总成交量（手数）。 143、现手：现手是刚成交的一笔交易的手数。 144、盘口：股票交易中,具体到个股买进\\卖出5个挡位的交易信息。“盘口”是在股市交易过程中，看盘观察交易动向的俗称。 145、内盘：委托以买方成交的纳入“内盘”，成交价是买入价时成交的手数总和称为内盘。 当外盘累计数量比内盘累计数量大很多，而股价也在上涨时，表明很多人在抢盘买入股票。 146、外盘：委托以卖方成交的纳入“外盘”，成交价是卖出价时成交的手数总和称为外盘。 147、量比：当日总成交手数与近期平均成交手数的比值。如果量比数值大于1，表示这个时刻的成交总手量已经放大；若量比数值小于1，表示这个时刻成交总手萎缩。 148、委比：通过对委买手数和委卖手数之差与委买手数和委卖手。 149、换手率：换手率是指在一定时间内市场中股票转手买卖的频率，是反映股票流通性的指标之一。计算公式为:换手率=(某一段时间内的成交量/流通股数)×100%。 五、财务名词部分 150、市盈率（PE）：市盈率又称股份收益比率或本益比，是股票市价与其每股收益的比值，计算公式是：市盈率=当前每股市场价格/每股税后利润。 151、市净率（PB）：是股票市价与每股净资产的比值，市净率=股票市价/每股净资产。 152、每股税后利润：每股税后利润又称每股盈利，可用公司税后利润除以公司总股数来计算。 153、市值：即为股票的市场价值，亦可以说是股票的市场价格，它包括股票的发行价格和交易买卖价格。股票的市场价格是由市场决定的。股票的面值和市值往往事不一致的。 六、宏观经济名词部分 154、货币政策：指中央银行为实现既定的经济目标（稳定物价，促进经济增长，实现充分就业和平衡国际收支）运用各种工具调节货币供给和利率，进而影响宏观经济的方针和措施的总合。 155、财政政策：是指国家根据一定时期政治、经济、社会发展的任务而规定的财政工作的指导原则，通过财政支出与税收政策来调节总需求。增加政府支出，可以刺激总需求，从而增加国民收入，反之则压抑总需求，减少国民收入。税收对国民收入是一种收缩性力量，因此，增加政府税收，可以抑制总需求从而减少国民收入，反之，则刺激总需求增加国民收入。 156、通货紧缩：当市场上流通的货币减少，人民的货币所得减少，购买力下降，影响物价之下跌，造成通货紧缩。长期的货币紧缩会抑制投资与生产，导致失业率升高及经济衰退。 157、通货膨胀：通货膨胀是指流通中货币量超过实际需要量所引起的货币贬值、物价上涨的经济现象。 158、消费者物价指数(CPI)：是反映与居民生活有关的商品及劳务价格统计出来的物价变动指标，通常作为观察通货膨胀水平的重要指标。 159、生产者物价指数（PPI）：生产者物价指数主要的目的在衡量各种商品在不同的生产阶段的价格变化情形。PPI是衡量工业企业产品出厂价格变动趋势和变动程度的指数，是反映某一时期生产领域价格变动情况的重要经济指标，也是制定有关经济政策和国民经济核算的重要依据。 160、再贴现率：商业银行在票据未到期以前将票据卖给中央银行，得到中央银行的贷款，称为再贴现。中央银行在对商业银行办理贴现贷款中所收取的利息率，称为再贴现率。 161、公开市场业务：是指中央银行通过买进或卖出有价证券，吞吐基础货币，调节货币供应量的活动。 162、法定存款准备金率：是法律规定的商业银行准备金与商业银行吸收存款的比率。商业银行吸收的存款不能全部放贷出去，必须按照法定比率留存一部分作为随时应付存款人提款的准备金。 七、基金名词部分 163、指数基金：是一种以拟和目标指数、跟踪目标指数变化为原则，实现与市场同步成长的基金品种。 164、保本基金：是指在其招募说明书中明确规定相关的担保条款，即在满足一定持有期限后，为投资人提供本金或收益保障的一类基金。 165、货币市场基金：指投资于货币市场（一年以内，平均期限120天）的投资基金。 166、交易所交易基金（ETFs）：指可以在交易所上市交易的基金，其代表的是一揽子股票的投资组合。 167、上市型开放式基金（LOF）：即可以在一级市场申购赎回又可以在二级市场买卖的开放式基金。 168、基金成立日：指基金达到成立条件后，基金管理人宣布基金成立的日期。 169、基金募集期：指自招募说明书公告之日起到基金成立日的时间段。 170、存续期：指基金合同生效至终止之间的不定期期限。 171、认购：指在基金募集期内，投资者按照基金合同的规定申请购买基金份额的行为。 172、申购：指在基金合同生效后的存续期间，投资者申请购买基金份额的行为。 173、赎回：指在基金合同生效后的存续期间，基金份额持有人按基金合同规定的条件要求基金管理人购回基金份额的行为。 174、基金转换：指基金份额持有人按基金管理人规定的条件，申请将其持有的基金管理人管理的某一基金的基金份额转换为基金管理人管理的，且由同一登记结算机构办理登记结算的其他基金的基金份额的行为。 175、开放日：指为投资者办理基金申购、赎回等业务的工作日。 176、基金单位净值：基金所拥有的资产每个营业日根据市场收盘价所计算出之总资产价值，扣除基金当日之各类成本及费用后，所得到的就是该基金当日之净资产价值。除以基金当日所发行在外的单位总数，就是每单位净值。 177、基金累计净值：是指基金最新净值与成立以来的分红业绩之和，体现了基金从成立以来所取得的累计收益(减去一元面值即是实际收益)，可以比较直观和全面地反映基金在运作期间的历史表现，结合基金的运作时间，则可以更准确地体现基金的真实业绩水平。 178、资本利得：二级市场上买卖证券的价差。 179、红利再投资：将投资者分得的收益再投资于基金，并折算成相应数量的基金单位，这实际上是将应分配的收益折为等额的新的基金单位送给投资者。 "},"FinancialManagement/股票/02-看盘-早盘.html":{"url":"FinancialManagement/股票/02-看盘-早盘.html","title":"早盘","keywords":"","body":"datetime:2022/1/23 12:49 author:nzb 看盘系列-早盘 集合竞价决定了一个股票当天的定位。在这个里面有很多学问。但是我看很多朋友对集合竞价的了解并不多，甚至能基本的规则都没有弄清楚。所以今天特意写一篇文章来解释下这个事情。 一、竞价规则 首先我们要了解几个时间节点： 9点15之前，你下的单子是在券商的服务器排队。 9点15-9点20 之间，9点15的时候券商的所有单子集中开闸，去上交所或深交所排队。然后在这个阶段会进行价格撮合。这个阶段你可以撤单。 9点20-9点25 之间，这个时间段只能下单不能撤单，所以这个时候下的单子都是真实的下单。最终会在9：25撮合成最终的开盘价。竞价仍然是按照价格优先，时间优先的原则进行。 9点25-9点30之间，这时间可以下单，但是不会做处理，这些单子都会在9:30的时候一次性处理。 9点30-15点之间，这阶段为连续竞价阶段。当然深交所的规则是在14点57—15点，也就是收盘前最后3分钟进行结合竞价。 通过上面几个基本的规则，我们就能明白几件事情。 1、你连夜挂单想抢先成交，你要买的话就必须挂涨停价，要卖的话就必须挂跌停价。你不要什么头天晚上下单，但是挂个5%的价格。你这个价格还赶不上第二天9:19别人下的涨停价的单子快。 2、那么要想抢先成交，需要在头天什么时候挂单呢?这个每个券商都不同，有的是前一天下午4点就可以挂了。有的要晚上12点才能挂。具体时间你需要咨询你的券商。 3、这个时候有人就问了。我12点挂的单子，那肯定比不上4点下单的人。这个问题是不尽然的。他4点挂的单，和你12点挂的单，其实都是在你们券商服务器里面排队。并不是在交易所的服务器里排队。要等到9:15的时候所有券商开闸把单子放到交易所排队。所以券商服务器到交易所服务器的速度决定了谁才是真正的排在前面的。既然是同一时间开闸，为什么有的快，有的慢。那是因为有的券商服务器离交易所服务器的物理距离近。有的券商就把服务器放在交易所附近的写字楼里。比如所马路对面，隔壁什么的。这也就能争取到那0.0001秒的时间。目前看，华鑫证券的通道是比较快的。所以大家也能经常在未开板新股或一字板的龙虎榜中看到华鑫证券的名字。 4、所以有些主力为了吸引眼球会在9:20之前用大单顶个高的价格出来，然后在9:20之前10多秒撤单。如果你看到高开就去追，但是他撤了你没来得及，就会成交了。还有些主力为了测试上方的抛压，会试探用以个单子挂涨停价，看会不会有抛盘出来。然后在9:20之前撤单。这个都是套路。总之记住9:20之前的下单都不是最终的。 二、竞价图形的含义 以上是规则。那么集合竞价的图形和结果我们怎么去判断呢。 软件默认是看不到集合竞价图形的，你需要按 键盘上的 “ / ” 键，多按几次，就可以切换出来了。 图形的下半区是成交量，分为AB 两种，A为下单但未匹配的量，B为下单匹配的量。也就是可以成交的成交量，如果买的一方占优势，就显示为红色，如果是卖的一方占优势就显示为绿色。 三、竞价结果的判断 竞价后产生的开盘价有3种形式，红盘开，平盘开，绿盘开。 比如说前一天涨停，第二天高开，则表示前一天打板的没有被闷杀，说明该股赚钱效应不错。如果是绿开，则说明头天打板是亏钱的。今天开盘就要谨慎。 然后要看竞价分时图的曲线，有些个股是低开，但是分时图最后几分钟的趋势是往上的。比如说创意信息3月8日是假阳线(收盘价比开盘价高，但是还是绿盘)，3月9日集合竞价开始平开，然后跌停，然后崽来起，最后阶段缓慢爬升。最终开盘价10.54，但是最终开盘就是往上走的，所以不要一味只看是绿盘还是红盘。更重要的是看趋势。其实那种缓慢爬升的比一笔拉升的趋势更可靠。 另外就是要看集合成交量，如果高开放大量，是要小心的。大幅低开但是没量，也不用太担心。 总结 9.20 之前，大量卖盘，瞬间把股价打压很低，随后9.20前几秒，这些大量卖单被取消 主力试探承接 出货：为未来出货确认有多少承接盘 承接多，今天就可以立即出货 承接少，那就缓慢打压股价出货 诱空：促使散户赶快出货 9.00 一开始，大幅拉升，大量买单，9.20 买单纷纷撤单 主力试探抛盘 拉升：为未来拉升确认有多少抛盘 抛盘多：采取缓慢拉升的策略 抛盘少：今天（最近）选择立即拉升 诱多：利用假拉升引诱追涨买入，然后撤掉自己的单子 开盘 高开（涨停直接开盘，说明市场对股价的上升认可度高） 股价上升初期高开：说明主力完成了建仓，想把股价拉出建仓的区域 震荡阶段高开：可能是利好消息的刺激 股价上涨末期高开：可能是吸引散户进场，诱多行为，需注意 平开 低开（跌停开盘）：可能主力决心跑路了，没有人愿意将股票以极低的价格卖出，看相关信息减仓观察 "},"FinancialManagement/股票/03-看盘-盘后.html":{"url":"FinancialManagement/股票/03-看盘-盘后.html","title":"盘后","keywords":"","body":"datetime:2022/1/27 17:04 author:nzb 看盘系列-盘后 尾盘拉升 上涨前奏 位置：相对较低，不包括一直阴跌的 到达前期高点多次止跌，均线回踩，有较大支撑 横盘：成交量一度萎缩，随后成交量放量上涨突破，量价齐升（拉升)和量价齐跌（洗盘） 出货信号 尾盘打压 洗盘 出货 "},"FinancialManagement/股票/04-看盘-大盘分时图分析技巧.html":{"url":"FinancialManagement/股票/04-看盘-大盘分时图分析技巧.html","title":"大盘分时图分析技巧","keywords":"","body":"datetime:2022/1/27 17:40 author:nzb 看盘系列-大盘分时图分析技巧 上证-综合指数（大多国有企业） 白线：大盘股 黄线：小盘股 白线上涨在上，黄线在下：说明大盘股领涨，相反，小盘股领涨 白线和黄线运行相反：说明当前市场资金关注点存在分歧，白线在上，说明市场青睐大盘股，相反，青睐小盘股 深证成分指数（中小创） 大盘分时 集合竞价、成交量 指数高开高走，成交量同步放大，说明市场做多意愿比较明显 指数低开低走，成交量同步放大，先观望或减仓 指数高开高走或低开低走，但是成交量逐渐萎缩，可能方向或风格要发生改变了 特殊情况 如果市场处于上升通道，上涨乏力，可能只是阶段性的调整，大局势是没有改变的 下跌缩量可能还要下跌 开盘半小时 开盘半小时，价格一浪比一浪高，而且成交量逐步放大，说明今天市场的买方实力非常强劲，大盘震荡走高的可能性就大，但是需要注意，如果指数走高，成交量到达极高，也就是阶段性的天量，需要考虑主力是不是在出货 开盘半小时，价格一浪比一浪低，而且成交量逐步放大，可能后面还有低点 支撑位、压力位 点位 开盘 前一天收盘 前一天高点 前一天低点 指数关口 均线 下跌到上面某一点位不在下跌，就是支撑位 如果多次确认支撑，发现这个支撑有效，就大胆去干 如果跌破，考虑不参与或减仓 上涨每次到上面某一点位就会回落，就是压力位 如果连续冲击几次都冲不过去，这里的压力就比较大，就要考虑风险 如果冲破了压力，就是突破，如何确认是否成功，就看之前的压力位能否成为支撑位 "},"FinancialManagement/股票/05-看盘-K线图.html":{"url":"FinancialManagement/股票/05-看盘-K线图.html","title":"K线图","keywords":"","body":"datetime:2022/1/28 11:11 author:nzb 看盘系列-K线图 K线基础 K线又称蜡烛图、日本线、阴阳线、棒线等，源于日本德川幕府时代(1603~1867年)，被当时日本米市的商人用来记录米市的行情与价格波动，后因其细腻独到的标画方式而被广泛影用。 在股市中K线被用作记录当天的价格变化，一条K线代表当天的价格走势，多个K线在一起就形成了K线图，代表多日的价格变化。 K线分为两种：阳线、阴线。 K线计算周期：1分钟K线、5分钟K线、15分钟K线、30分钟K线、60分钟K线、日K线、周K线、月K线、年K线。也可以自定义制定周期K线。 K线有4个价位组成：开盘价、收盘价、最高价、最低价。中间的矩形为实体，实体以上的细线为上影线，实体以下的细线叫做下影线。 如下图： 阳线在分时图上显示样式： 阴线和阳线一样，只不过阴线开盘价和收盘价反转过来，开盘价在上、收盘价在下，以阴线收盘。 K线每日的开盘价和收盘价以及波动范围不同，形成了不同的阳线和阴线。而每个K线都有它的基本意义，下面我们就来认识一下这些K线。 小阳线和小阴线：大盘波动范围一般在0.6--1.5%；个股波动范围一般在0.6—3%； 中阳线和中阴线：大盘波动范围一般在1.6-3.5%；个股波动范围一般在3—7%； 大阳线和大阴线：大盘波动范围一般在3.6%；个股波动范围一般在7%以上； 在上面所述的范围内，有无上下影线都属于相应阳线和阴线。如果实体部分占据波动范围的70%以上，说明方向越明确。单根k线只能看出当日的多空情况，后市的涨跌还需要根据量能、K线的位置、市场的情绪进行综合分析。 下面会以出现概率多的走势进行讲解，不排除还有其他的走势： ①此形态又称全秃阳（阴）线，也称光头光脚阳（阴）线，该线无上下影线。它属于行情一面倒的形态，此线的出现有很大的确定性，后市向着攻陷的方向继续前进。如果小阳和小阴出现此K线，由于量能的不足，后市可能会遇到反手打压、震荡调整的行情比较多。 ②此形态为又称穿头破脚阳（阴）线，下有撑上有压，一日判多空形态。小阳和小阴会极易出现吞噬或方向不明的走势。中阴或中阳出现此形态，后市极易向着攻陷的方向继续前进，大阴或大阳出现此形态，极易出现反手洗盘或相反方向的走势。 ③此形态又称电阻线，为下有撑上有压当日多空激烈交战形态，如果上下影线小于实体或影线过小，一般后市会向着攻陷的方向继续前进，如果上下影线是实体的1倍或2倍以上，说明当日多空交战十分激烈，消耗量能巨大，后市极易出现方向不明或调整的走势。 ④此形态又称锤子线，无上影线实体较小，下影长度至少达到实体的2倍以上，下影线越长越好，越长代表信号越明朗强烈。在后市看涨时称为锤子线，在后市看跌时叫做上吊线，也叫吊颈线。该图线若处在高价位，是行情见顶的信号，若处在低价位，则是行情见底的信号，可考虑买入股票。所有的阴线和阳线出现这种形态都是低位看多，高位看空。有上影线的说明上方有压力，明日出现下杀洗盘，区间震荡整理的走势比较多。小阴小阳出现此形态多以上下震荡方向不明走势为多。 ⑤此形态又称倒锤子线，反追线。在后市看跌或高位出现时叫做流星线。上影线越长越好，长度至少达到实体高度的2倍。明日开盘定多空，此形态意味着当日市场失去了继续上升的动力，股价出现新高之后立即遭到空方的严厉打压，可视为弱势。因而投资者应对倒锤子线的出现保持高度警惕。这个和锤子线一样，所有的阴线和阳线出现这种形态都是低位看多，高位看空。横盘整理出现此形态也应出局观望。所有阴线出现此形态应观望为主，阳线低位出现此形态，可根据明日开盘价和抛压量能考虑是否进场。小阴小阳出现此形态多以上下震荡方向不明走势为多。 ⑥此形态为光头阳（阴）线，和锤子线的区别为，光头阳线实体大于下影线，而锤子线实体小于下影线。此形态实体越多越好，中阳线出现此形态有的是当日尾盘主力拉升诱多，有的是量能不足上有压力，有的是稳步上升，不管哪一种下个交易日多为下杀洗盘、获利筹码出局为主，如能突破光头阳（阴）线最高价继续看涨。 大阳出现此形态多以涨停为主，后市继续看涨。 中阴大阴出现此形态多为止跌信号，下影线越长止跌信号越强。需要注意的是阴线低位看多，高位看空。 ⑦此形态为光脚阳（阴）线，和倒锤子线的区别为，光脚线实体大于下影线，而倒锤子线实体小于下影线。此形态实体越多越好， 中阳和大阳出现此形态是多方攻陷某个压力位遇到了阻力，但是不会阻碍多方继续上涨的趋势。有的个股会震荡调整后继续上攻，如果是真正强势股，这种形态，阳线继续上涨居多。需要注意的是阳线低位看多，高位看空。中阴和大阴出现此形态，一律看空。 注：上面所说的低位是近期一段时间的最低点或次低点，高位是指有一定涨幅，哪怕在横盘震荡也属于高位。 单根K线只能一日判多空，而无法辨别趋势，在看盘的过程中还应了解K线组合以及趋势、量能、大盘等种种因素，方能增加胜算。学习了K线的含义，还有K线十字星的含义也要懂得才可以。 八大经典卖出形态： 1.上吊线 上吊线实际上就是上涨走势中的锤子线。它在上涨走势中一旦出现，就表明本来多方占据优势的局面有较大可能被扭转，之后股价有可能出现下跌走势。 如图： 2.黄昏星 黄昏星形态与启明星正好相反，它出现在上涨走势中，又三根K线组成。第一根是阳线，第二根是十字线，第三根是阴线。第三根K线实体深入到第一根K线实体之内。 如图： 黄昏星形态是较为强烈的看跌信号，它表明下跌动能在经过十字线的搏斗之后已经战胜了上涨动能，后市看跌。 3.看跌吞没 该形态出现在上涨趋势中，由两根K线组成。第一根K线是实体较小的阳线，第二根K线是实体较长的阴线，且这根阴线的实体将前阳阴的实体从上到下全部吞没。 如图： 看跌吞没是强烈的看跌信号。该形态中阴线实体完全吞没了阳线实体，说明下跌动能已经完全占据优势，股价接下来有较大可能出现一波跌势。 4.乌云盖顶 乌云盖顶形态出现在涨势中，由一阴一阳两根K线组成。其中前根K线为中阳线或大阳线，后根K线为中阴线或大阴线，且阴线的开盘价要高于阳线的收盘价，阴线实体已深入到阳线实体的二分之一下处。 如图： 乌云盖顶表明市场上涨动能急剧释放的同时，下跌动能突然而至并占据上风，之后股价有较大可能出现一波下跌走势。但其可靠性不如看跌吞没形态。 需要注意的是，在实际操作中，阴线实体深入阳线实体部分越多，转势信号就越强烈。当阴线完全跌破阳线实体时，就转化为看跌吞没形态。由此就可以知道为什么看跌吞没的看跌意义强于乌云盖顶了。 5.倾盆大雨 倾盆大雨形态出现在股价上涨途中，由一阳一阴两K线组成。与乌云盖顶形态类似，先是一根大阳线或中阳线，接着出现一根高开的大阴线或中阴线，阴线的收盘价要低于前一根阳线的开盘价。 如图： 倾盆大雨形态是见顶信号，且看跌意义更强于乌云盖顶，甚至强于看跌吞没。阴线实体高出阳线实体越多，转势信号就越强。 6.高位孕线 高位孕线出现在上涨走势中，由两个K线组成。第一根K线实体较长，第二根K线实体较小，且被包括在第一根K线的实体之内。两根K线的颜色没有限制。 如图： 与低位孕线形态类似，有时候高位孕线会出现多根K线组合在一起的“孕育”形态，这是因为后面几根K线的实体都较小，都被包括在第一根K线的实体之内，因此可以将后面几根K线叠加在一起。 高位孕线表明市场在高位，多空双方正在进行激烈的交锋，多方占据优势的局面正在改变，之后股价有较大可能出现一波下跌走势。 而且高位孕线的第二根K线还有可能是锤子线、十字星等，它预示着更强的下跌动能。 7.三只乌鸦 三只乌鸦又称暴跌三杰，顾名思义是指在上涨走势中，连续出现三根阴线所组成的K线形态。这三根K线多为大阴线或中阴线，且每次均以调高开盘，最后以下跌收盘。 如图： 传统观念认为乌鸦是不祥之物，三只乌鸦出现，预示着后市看跌意味深重。 需要注意的一点是，三只乌鸦大多出现在下跌趋势启动之初。 8.下降三法 下降三法又称下跌三部曲，出现在股价下跌过程中，由大小不等的5根K线组成。这5根K线中，第一根K线为大阴线或中阴线，接下来三根为小阳线，且阳线的最高价低于第一根阴线的开盘价，之后出现一根大阴线或中阴线，且其收盘价要低于第一根阳线的开盘价。 如图： 下降三法表明上涨动能只是昙花一现，空方再次夺回控制权，股价接下来仍会延续下跌走势。 看涨的20种形态图 1、低位锤形线 形态介绍：上涨形态。一般在下跌趋势中，出现下影线较长上影线较短的K线形态，形状如一把锤子，称为低位锤型线。 买入参考位：锤形线出现次日，若能确定收盘价能够越过锤形线实体，则构成买点。 止损参考位：锤形线最低点。 2、低位倒锤线 形态介绍：上涨形态。一般在下跌趋势中，出现下影线较短而上影线较长的K线形态，形状如一把倒着的锤子，称为低位倒锤型线。 买入参考位：倒锤形线出现次日，若能确定收盘价能够越过锤形线实体，则构成买点。 止损参考位：倒锤形线最低点。 3、低位十字星 形态介绍：上涨形态。一般在下跌趋势中，出现上影线和下影线均较长的K线，形状如一颗十字星，称为低位十字星。 买入参考位：低位十字星出现次日，若股价上涨越过十字星实体，则构成买点。 止损参考位：十字星最低点。 4、看涨捉腰带 形态介绍：上涨形态。一般在下跌趋势或盘整趋势中中，出现开盘价基本处于当日最低价，没有影线或影线极短，且实体较长的K线形态，称为看涨捉腰带线，又称为开盘光脚阳线。 买入参考位：看涨捉腰带线出现次日，若股价未创新低，则构成买点。 止损参考位：捉腰带线最低位。 5、低位螺旋桨 形态介绍：上涨形态。在下跌趋势中，出现一根带有较长的上下影线小阴线或小阳线，形状如螺旋桨，称为低位螺旋桨。 买入参考位：低位螺旋桨线出现次日，若股价上涨越过螺旋桨实体，则构成买点。 止损参考位：螺旋桨线最低位。 6、启明之星 形态介绍：上涨形态。在一根实体较长的阴线之后，出现一根实体向下低开的星线，之后是一根阳线，此阳线的实体上端进入第一根阴线的实体之内。这三根K线构成的形态，称为启明之星，或早晨之星。 买入参考位：星线出现次日，若股价继续上涨越过前根阳线实体，则构成买点。 止损参考位：星线最低位。 7、看涨吞没 形态介绍：上涨形态。在下跌趋势中，出现前阴后阳的两根K线，第二根K线实体吞没了第一根K线的实体，完全将第一根实体包住，这两根k线形成的组合称为看涨吞没。 买入参考位：看涨吞没形态出现次日，若能确认股价不跌破形态最低点，则买点出现。 止损参考位：形态最低点。 8、曙光初现 形态介绍：上涨形态。在连续下跌的行情中，在一段下跌过后收出一根大阴线，之后由一根大阳线收在阴线的二分之一处上方，意为多头发力，但并未完全占据优势，此种形态被称为曙光初现。 买入参考位：曙光初现形态出现次日，若能确认股价不跌破形态最低点，则买点出现。 止损参考位：形态最低点。 9、平头底部 形态介绍：上涨形态。在一轮下降趋势中，两根K线有相同的最低价，意味行情探低见底，股价将反转上升。此种形态称为平头底部，是较好的短线小幅加仓补仓的机会。 买入参考位：平头底部形态出现次日，若股价继续上涨并越过前根K线的实体，则买点出现。 止损参考位：形态最低点。 10、旭日东升 形态介绍：上涨形态。在下跌趋势中，出现一根中阴线或大阴线，紧接着出现一根高开的中阳线或大阳线，阳线的收盘价高于阴线开盘价，意味着多头力量较强，此种形态称为旭日东升。 买入参考位：旭日东升形态出现次日，若股价继续上涨并越过前根K线实体，则买点出现。 止损参考位：阴线最低点。 11、好友反攻 形态介绍：上涨形态。在下跌趋势中，出现一根中阴线或大阴线，紧接着出现一根跳空低开但随即上涨的中阳线或大阳线，其收盘价与前根阴线的收盘价基本相同，这种形态称为好友反攻。 买入参考位：好友反攻形态出现后，次日的股价上涨并越过前根K线实体，则买点出现。 止损参考位：形态最低点。 12、阴孕十字 形态介绍：上涨形态。在下跌趋势中，出现一根中阴线或大阴线，紧接着出现一根包含在前一根阴线的实体之内的十字星线，此种形态称为阴线孕十字线，又称为十字怀胎。 买入参考位：阴线孕十字线出现后，次日若股价继续上涨并越过十字线实体，则买点出现。 止损参考位：形态最低点。 13、多方炮 形态介绍：上涨形态。在上涨或下跌趋势中，出现一根中阳线或大阳线，紧接着出现一根实体孕育于阳线实体内的阴线，在阴线之后，又出现一根将阴线完全包住且成交量放大的阳线，这三根K线形成的组合称为多方炮，即两阳夹一阴。 买入参考位：多方炮形态出现后，次日股价继续上涨并越过第三根阳线实体，则买点出现。 止损参考位：第三根K线最低点。 14、上升三法 形态介绍：上涨形态。上涨趋势中，放量出现一根中阳线或大阳线后，出现三根小实体K线，其实体位于第一根阳线实体之内，之后又出现一根高开阳线，其收盘价高于第一根阳线的收盘价。此种形态组合称为上升三法。 买入参考位：上升三法形态出现后，次日股价一旦能够确认不会跌破前根K线最低价，则买点出现。 止损参考位：该形态的最低点。 15、红三兵 形态介绍：上涨形态。在上涨或下跌趋势中，连续出现的三根小阳线，实体和影线均较短，且没有出现跳空高开的情况，预示着后势行情看涨，这三根K线的组合被形象地称为红三兵。 买入参考位：红三兵形态出现次日，若股价继续上涨并越过第三根小阳线的实体，则买点出现。 止损参考位：第一根阳线的最低点。 16、上涨分手 形态介绍：上涨形态。在上涨趋势中，出现一根中阴线或大阴线；紧接着出现一根高开高走的阳线，该阳线的开盘价与前根阴线的开盘价大致相等，如果成交量放大，则预示着后面还有行情。这两根K线开盘价相同而运动方向相反，因此被称为上涨分手。 买入参考位：上涨分手形态形成次日，若能确定股价不跌破前日K线开盘价，则买点出现。 止损参考位：阴线的最低价。 17、三空阴线 形态介绍：上涨形态。在下跌趋势中，连续出现三根跳空低开下跌的阴线，过度下跌是对做空能量的极大消耗，当空头能量消耗尽时，股价极易出现见底行情，此种形态被称为三空阴线。 买入参考位：买入参考位：三空阴线形态出现次日，若股价上涨并越过前根K根开盘价，则买点出现。 止损参考位：第三根阴线最低点。 18、下跌尽头线 形态介绍：上涨形态。在下跌趋势中，出现一根带长下影线的阴线，紧接着出现一根小K线，第二根K线的实体及阴线，完全处于前跟K线的长下影线之内，此时意味着下跌行情可能发生反转，被称为下跌尽头线。 买入参考位：下跌尽头线形态出现次日，若股价继续上涨并越过前根K线实体，则买点出现。 止损参考位：长下影阴线的最低点。 19、三阳开泰 形态介绍：上涨形态。通常在上涨行情初期，连续出现三根中阳线或大阳线，每一天的最高价都高于前一天的最高价，每一天的最低价都高于前一天最低价，且成交量放大，一般为加速进场的信号，此种K线形态称为三阳开泰。 买入参考位：三阳开泰形态出现次日，若股价继续上涨并越过前根K线实体，则买点出现。 止损参考位：第一根阳线的最低点。 20、看涨舍子线 形态介绍：上涨形态。下跌趋势中，一根阴线之后出现一根十字线，接着又出现一根阳线，如果十字线和其前后的阴线、阳线都存在跳空缺口，且阳线的向上跳空缺口弥补了十字线的向下跳空缺口。则此种形态称为看涨舍子线。 买入参考位：看涨舍子线形态出现次日，若能确认股价不跌回前根十字线的缺口，即未弥补之前的缺口，则买点出现。 止损参考位：十字线的最低点。 "}}