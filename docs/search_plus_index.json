{"./":{"url":"./","title":"Introduction","keywords":"","body":"datetime:2019/6/14 9:04 author:nzb 笔记格式：{ { } } 写成 { { } } ， { % % } 写成 { % % }，空格隔开 gitbook 生成文档 注意：SUMMARY.md 目录中有的 markdown 才会转成静态 html, 并且才能全局搜索得到 电子书 学习笔记 算法 算法图解 Linux 入门基础 Python Python语言基础 Python PEP8编码规范 | 初识Python | 语言元素 分支结构 | 循环结构 | 构造程序逻辑 | 函数和模块的使用 字符串和常用数据结构 | 面向对象编程基础 | 面向对象编程进阶 图形用户界面和游戏开发 | 文件和异常 | 字符串和正则表达式 进程和线程 | 网络编程入门 | 网络应用开发 | 图像和文档处理 | logging日志模块 Python语言进阶 常用数据结构 函数的高级用法 - “一等公民” / 高阶函数 / Lambda函数 / 作用域和闭包 / 装饰器 面向对象高级知识 - “三大支柱” / 类与类之间的关系 / 垃圾回收 / 魔术属性和方法 / 混入 / 元类 / 面向对象设计原则 / GoF设计模式 迭代器和生成器 - 相关魔术方法 / 创建生成器的两种方式 / 并发和异步编程 - 多线程 / 多进程 / 异步IO / async和await asynico异步编程 Python 第三方库 Django 快速上手 | 深入模型 | 静态资源和Ajax请求 | Django模板系统 Django的View(视图) | Django的路由系统 | Django ORM相关操作 Cookie、Session和分页 | Form、ModelForm组件 | 中间件 Django-REST-framework Django生命周期) | Django中间件 Django-Rest-framework组件: 认证 | 权限 | 频率控制(节流) | 版本(全局配置就行) | 解析器(全局配置就行) 序列化 | 分页 | 视图 | 路由 | 渲染器 | django组件：content-type Django项目开发经验 登录相关 | 异常处理手柄 | 过滤相关 | 存储类重写 | 序列化相关 | 自动化测试 | 接口加速缓存 PyQt5 导航 窗口 / 按钮 / 垂直布局和水平布局 / 栅格布局 / 布局添加标签和背景图 单选框 / 复选框 / 键盘提示 / 行编辑器 / 按钮组 / 布局组 / 无边框窗口 框架 / 分离器 / 滑动条 / 滚动条 / 刻度盘 / 上下拨号 / 生成随机数 进度条 / 工具框 / 菜单栏工具栏 / 文档编辑框 / 字体文本框 / 颜色文本框 打印 / 打印预览 / 打印PDF / 消息提示框 / 右键菜单 / 选项卡 / 堆叠小部件 可停靠的窗口小部件 / 日历 / 单选下拉框 / 首字母模糊填充 / 打开更多窗口 时间编辑 / 列表部件 / PySide Qt简介 界面设计师QtDesigner 发布程序 常用控件1 常用控件2 常用控件3 常用控件4 GoLang GoLang基础 GoLang发展史 打印输出 变量和常量 数据类型 运算符 流程控制 数组 切片 map 函数 time包日期函数 指针 结构体 GoMod及包 数据库基础和进阶 关系型数据库MySQL 关系型数据库概述 MySQL的安装和使用 SQL的使用 DDL - 数据定义语言 - create / drop / alter DML - 数据操作语言 - insert / delete / update / select DCL - 数据控制语言 - grant / revoke 相关知识 范式理论 - 设计二维表的指导思想 数据完整性 数据一致性 在Python中操作MySQL 计算机二级 | 数据库三大范式 | MySQL主从复制 NoSQL入门 NoSQL概述 | Redis概述 | Mongo概述 Redeis Redis安装与配置文件 Redis基础 Redis键 | Redis字符串 | Redis哈希 | Redis列表 | Redis集合 | Redis有序集合 | Redis发布订阅 Redis多数据库 | Redis事务 | Redis数据淘汰策略 | Redis持久化 | Redis缓存与数据库Mysql一致性方案 数据分析 数学基础 高等数学 | 概率论 | 微积分 | SVD | 似然函数 | 后验概率估计 | 拉格朗日乘子法 | 核函数 梯度 | 概率分布与概率密度 | 泰勒公式 | 激活函数 | 熵 | 特征值与特征向量 | 矩阵 数据分析库 numpy基础 | pandas基础 | pandas连接合并追加 | matplotlib基础 Web前端 Web前端入门 | HTML5 | CSS | JavaScript jQuery | jQuery-UI | Vue.js | RESTful规范 工具 Docker 基本组成 / 容器相关技术简介 / 客户端与守护进程 / 守护进程的配置和操作 远程访问 / 容器 / 容器中部署静态网站 / 查看和删除镜像 / 获取和推送镜像 构建镜像 / DockerFile指令 / 构建过程 / 容器的网络连接 / 容器的数据卷 数据卷容器 / 数据卷的备份和还原 Docker入门PDF Docker部署Django Uwsgi+Nginx+MySQL+Redis Docker简单部署Django的FastDFS Git 帮助信息 / git配置(全局配置) / 初始化项目 / 查看状态 / 添加文件 / 提交文件 / 查看提交日志 查看文件修改前后的区别 / git跟踪rename文件和移动文件 / 删除文件 / 恢复文件 / 恢复提交 重置提交指针 / 查看、创建、切换分支 / 查看两个分支的区别 / 合并分支 / 解决合并冲突 / 重命名和删除分支 保存修改进度 / 添加别名 / 全局忽略跟踪文件 / 项目级忽略文件 / 创建远程版本库 / 推送版本库 修改远程仓库地址 / 克隆版本库到本地 / 更新本地版本库 / 基于版本库开发自己的版本库 / 添加pull request / 添加贡献者 Nginx 面试 面试题 "},"Python/PEP8.html":{"url":"Python/PEP8.html","title":"Python PEP8编码规范 ","keywords":"","body":"Python编码规范指南 详情参考：https://www.python.org/dev/peps/pep-0008/ 缩进 每级缩进使用4个空格。 连续行应该对齐折叠元素，无论是垂直的Python的隐式行连接圆括号内的，中括号内的，大括号内的，还是使用悬挂缩进[5]。 使用悬挂缩进应注意以下几点； 1、第一行没有参数并且使用更多的缩进来区别它本身和连续行。 风格良好： # 与分界符对齐。 foo = long_function_name(var_one, var_two, var_three, var_four) # 包括更多的缩进以区别于其他的。 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 悬挂缩进应增加一个级别 foo = long_function_name( var_one, var_two, var_three, var_four) 风格不良： # 第一行参数禁止不使用垂直对齐 foo = long_function_name(var_one, var_two, var_three, var_four) # 当无法区分缩进时，需要进一步缩进 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) 2、对于连续行，4个空格规则是可选的。 可选的： # 悬挂缩进可能缩进不是4个空格 foo = long_function_name( var_one, var_two, var_three, var_four) 3、if语句条件块足够长时需要编写多行，值得注意的是两个字符组成的关键字（例如if），加上一个空格，加上开括号为多行条件的后续行创建一个4个空格的缩进。 这可以给嵌入if内的缩进语句产生视觉冲突，这也自然被缩进4个空格。这个PEP没有明确如何（是否）进一步区分条件行和if语句内的嵌入行。 这种情况下，可以接受的选项包括，但不仅限于： # 没有额外的缩进 if (this_is_one_thing and that_is_another_thing): do_something() # 添加一行注释，这将为编辑器支持语法高亮提供一些区分。 # supporting syntax highlighting. if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something() # 在条件连接行，增加额外的缩进 if (this_is_one_thing and that_is_another_thing): do_something() 4、多行结构中的结束花括号/中括号/圆括号是最后一行的第一个非空白字符， 如： my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 或者是最后一行的第一个字符， 如： my_list = [ 1, 2, 3, 4, 5, 6, ] result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) 制表符还是空格？ 空格是缩进方法的首选。 制表符仅用于与已经用制表符做缩进的代码保持一致。 Python3不允许混用制表符和空格来缩进。 Python2代码混用制表符和空格缩进，将被转化为只使用空格。 调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！ 行的最大长度 限制所有行最多79个字符。 下垂的长块结构限制为更少的文本（文档字符串或注释），行的长度应该限制在72个字符。 限制编辑器窗口宽度使得并排打开多个文件成为可能，并且使用代码审查工具显示相邻列的两个版本工作正常。 绝大多数工具的默认折叠会破坏代码的可视化结构，使其更难以理解。编辑器中的窗口宽度设置为80个字符。即使该工具将在最后一列中标记 字形。一些基于网络的工具可能不会提供动态的自动换行。 有些团队强烈喜欢较长的行长度。对于代码维护完全或主要由一个团队的，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到 100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。 Python标准库采取保守做法，要求行限制到79个字符（文档字符串/注释到72个字符）。 折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面使用小括号来变成多行。连续行使用反斜杠更好。 反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠： with open('/path/to/some/file/you/want/to/read') as file_1, \\ open('/path/to/some/file/being/written', 'w') as file_2: file_2.write(file_1.read()) （为进一步思考With语句的多行缩进，见前面多行if语句的讨论。） 另一个这样的例子是assert语句。 确保适当的连续行缩进。 换行应该在二元操作符的前面还是后面？ 风格良好： # 好的做法：很容易看出二元操作符和被操作对象的关系 income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 风格不良： # 不好的做法：操作符和被操作符的对象是分离的 income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 空行 顶级函数和类的定义之间有两行空行。 类内部的函数定义之间有一行空行。 额外的空行用来（谨慎地）分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。 在函数中谨慎地使用空行来表示逻辑部分。 Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。 注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。 源文件编码 在源文件中一直使用utf-8编码，在python2中使用ascll编码。 文件，在python2 中使用ascll编码，在python3中使用utf-8编码 导入 导入通常是单独一行，例如： 风格良好： import os import sys from subprocess import Popen, PIPE 风格不良： import sys, os 导入常常位于文件顶部，在模块注释和字符串文档之后，在模块的全局变量和常量之前。 导入应该按照以下顺序分组： 1. 标准库导入 2. 相关的第三方导入 3. 特定的本地应用/库导入 在每个导入组之间放一行空行。 把任何相关__all__规范放在导入之后。 推荐绝对导入，因为它们更易读，并且如果导入系统配置的不正确（例如当包中的一个目录结束于sys.path） 它们有更好的表现（至少给出更好的错误信息）： import mypkg.sibling from mypkg import sibling from mypkg.sibling import example 明确的相对导入可以用来接受替代绝对导入，特别是处理复杂包布局时，绝对导入过于冗长。 from . import sibling from .sibling import example 标准库代码应该避免复杂包布局并使用绝对导入。 隐式的相对导入应该永远不被使用，并且在Python3中已经移除。 从一个包含类的模块中导入类时，通常下面这样是好的写法： from myclass import MyClass from foo.bar.yourclass import YourClass 如果这种写法导致本地名字冲突，那么就这样写： import myclass import foo.bar.yourclass 并使用“myclass.MyClass”和“foo.bar.yourclass.YourClass”来访问。 避免使用通配符导入（from import *），因为它们使哪些名字出现在命名空间变得不清楚，这混淆了读者和许多自动化工具。 通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口， 该接口定义从一个可选的加速器模块并且哪些定义将被重写提前并不知道）。 用这种方式重新命名，下面的有关公共和内部接口的指南仍适用。 模块级别的内置属性 模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后， 任意import语句之前，from __future__导入除外。Python强制要求from __future__导入必须在任何代码之前，只能在模块级文档字符串之后。 \"\"\"This is the example module. This module does stuff. \"\"\" from __future__ import barry_as_FLUFL __all__ = ['a', 'b', 'c'] __version__ = '0.1' __author__ = 'Cardinal Biggles' import os import sys 字符串引号 Python中，单引号字符串和双引号字符串是一样的。本PEP不建议如此。建议选择一条规则并坚持下去。当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠。这提高可读性。 三引号字符串，与PEP 257 文档字符串规范一致总是使用双引号字符。 表达式和语句中的空格 以下情况避免使用多余的空格： 紧挨着小括号，中括号或大括号。 Yes: spam(ham[1], {eggs: 2}) No: spam( ham[ 1 ], { eggs: 2 } ) 紧挨在逗号，分号或冒号前： Yes: if x == 4: print x, y; x, y = y, x No: if x == 4 : print x , y ; x , y = y , x 在切片中冒号像一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。 例外：当一个切片参数被省略时，该空格被省略。 风格良好： ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] 风格不良： ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] 紧挨着左括号之前，函数调用的参数列表的开始处： Yes: spam(1) No: spam (1) 紧挨着索引或切片开始的左括号之前： Yes: dct['key'] = lst[index] No: dct ['key'] = lst [index] 为了与另外的赋值（或其它）操作符对齐，不止一个空格。 Yes: x = 1 y = 2 long_variable = 3 No: x = 1 y = 2 long_variable = 3 其它建议 始终避免行尾空白。因为它们通常不可见，容易导致困惑：如果\\后面跟了一个空格，它就不是一个有效的续行符了。 很多编辑器不保存行尾空白，CPython项目中也设置了commit前检查以拒绝行尾空白的存在。 始终在这些二元操作符的两边放置一个空格：赋值（= ），增强赋值（+= ，-= 等）， 比较（== ， ， != ， <> ， = ，in ， not in ，is ，is not ），布尔（and ，or ，not ）。 如果使用了不同优先级的操作符，在低优先级操作符周围增加空格（一个或多个）。不要使用多于一个空格，二元运算符两侧空格数量相等。 Yes: i = i + 1 submitted += 1 x = x*2 - 1 hypot2 = x*x + y*y c = (a+b) * (a-b) No: i=i+1 submitted +=1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) 当=符号用于指示关键字参数或默认参数值时，它周围不要使用空格。 Yes: def complex(real, imag=0.0): return magic(r=real, i=imag) No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 带注解的函数使用正常的冒号规则，并且在->两侧增加一个空格： Yes: def munge(input: AnyStr): ... def munge() -> AnyStr: ... No: def munge(input:AnyStr): ... def munge()->PosInt: ... 如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）。 Yes: def munge(sep: AnyStr = None): ... def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... No: def munge(input: AnyStr=None): ... def munge(input: AnyStr, limit = 1000): ... 不鼓励使用复合语句（同一行有多条语句）。 风格良好: if foo == 'blah': do_blah_thing() do_one() do_two() do_three() 最好不要: if foo == 'blah': do_blah_thing() do_one(); do_two(); do_three() 尽管有时if/for/while的同一行跟一小段代码，在一个多条子句的语句中不要如此。避免折叠长行！ 最好不要: if foo == 'blah': do_blah_thing() for x in lst: total += x while t 什么时候使用尾部逗号？ 尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。 为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）： Yes: FILES = ('setup.cfg',) OK, but confusing: FILES = 'setup.cfg', 当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。 通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。 Yes: FILES = [ 'setup.cfg', 'tox.ini', ] initialize(FILES, error=True, ) No: FILES = ['setup.cfg', 'tox.ini',] initialize(FILES, error=True,) 注释 同代码相矛盾的注释比没有注释更差。当代码修改时，始终优先更新注释！ 注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符（不更改标识符的情况下！）。 如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。 在句尾的句号后边使用两个空格。 写英语注释时，遵循断词和空格。 非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。 非英语国家的Python程序员：请写下你的意见，在英语中，除非你是120%肯定，代码将不会被不讲你的语言的人阅读。 注释块 注释块通常适用于一些（或全部）紧跟其后的代码，并且那些代码应使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非注释里面的文本有缩进）。 注释块内的段落之间由仅包含#的行隔开。 行内注释 谨慎地使用行内注释。 行内注释就是注释和代码在同一行，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。 如果行内注释指出的是显而易见，那么它就是不必要的。不要使用无效注释，主要是说明其目的 不要这样做： x = x + 1 # Increment x But sometimes, this is useful: x = x + 1 # Compensate for border 文档字符串 编写好的文档字符串（即“代码”）约定在PEP 257中是永存的。 为所有公共模块，函数，类和方法书写文档字符串。对非公开的方法书写文档字符串是没有必要的，但应该写注释描述这个方法是做什么的。 这些注释应该写在def行后面。 PEP 257描述了好的文档字符串约定。最重要的是，多行文档字符串以一行\"\"\"结束，例如： yes: \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于只有一行的文档字符串，\"\"\"同一行上。 命名规范 使用单独的小写字母（b） 使用单独的大写字母（B） 使用小写字母（lowercase） 使用小写字母和下划线（lower_case_with_underscores） 使用大写字母（UPPERCASE） 使用大写字母和下划线（UPPER_CASE_WITH_UPPERCASE） 驼峰式写法（CamelCase）：在使用缩写的时候，大写优于小写例如HTTPServer优于HttpServer 首字母大写，然后使用下划线是一种丑陋的写法 1、避免使用的名称 在写变量的时候，尽量避免小写的l和大写字母O和大写字母I，主要原因是容易和数字中1,0相混淆。当想使用‘l’时，用‘L’代替。 2、包名和模块名 模块尽量使用简短的全部小写的名称，如果可以增加可读性那么可以使用下划线，python的包不推荐使用下划线， 但是在引用其他语言写的扩展包中可以使用下划线来表示区分 3、类名称 类名称主要遵循为CapWords约定，表示为首字母大写 4、类型变量名称 类型变量名称应该首字母大写，并且尽量短，比如：T, AnyStr, Num。对于协变量和有协变行为的变量，建议添加后缀__co或者__contra。 5、异常名 因为异常应该是类，所以类的命名规则在这里也同样适用。然而，异常名（如果这个异常确实是一个错误）应该使用后缀“Error”。 6、全局变量名 （希望这些变量是在一个模块内使用。）这些规则和那些有关函数的规则是相同的。 模块设计为通过from M import *来使用，应使用__all__机制防止导出全局变量，或使用加前缀的旧规则，为全局变量加下划线（可能你像表明这些全局变量是“非公开模块”）。 7、函数名 函数名应该是小写字母，必要时单词用下划线分开以提高可读性。 混合大小写仅用于这种风格已经占主导地位的上下文（例如threading.py），以保持向后兼容性。 8、函数和方法参数 使用self做实例化方法的第一个参数。 使用cls做类方法的第一个参数。 如果函数的参数名与保留关键字冲突，最好是为参数名添加一个后置下划线而不是使用缩写或拼写错误。 因此class_ 比clss好。（也许使用同义词来避免更好。）。 9、常量 常量通常定义于模块级别并且所有的字母都是大写，单词用下划线分开。例如MAX_OVERFLOW和TOTAL。 "},"Python/Python语言基础/00-初识Python.html":{"url":"Python/Python语言基础/00-初识Python.html","title":"初识Python","keywords":"","body":"datetime:2019/6/29 9:04 author:nzb 初识Python Python简介 Python的历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面又出现了Java和C#实现的版本Jython和IronPython，以及PyPy、Brython、Pyston等其他实现），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，同时提供了“列表”和“字典”等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了实现完整的垃圾回收)，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（如修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以查看一篇名为《Python简史》的博文。 Python的优缺点 Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python的缺点主要集中在以下几点。 执行效率稍低，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被淡化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 Python的应用领域 目前Python在Web应用开发、云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。 搭建编程环境 Windows环境 可以在Python官方网站下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装Python 3.x，需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.6 to PATH”（将Python 3.6添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议使用自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示。如果稍后运行Python程序时，出现因为缺失一些动态链接库文件而导致Python解释器无法工作的问题，可以按照后面说的方法加以解决。如果系统显示api-ms-win-crt*.dll文件缺失，可以参照《api-ms-win-crt*.dll缺失原因分析和解决方法》一文讲解的方法进行处理或者直接在微软官网下载Visual C++ Redistributable for Visual Studio 2015文件进行修复；如果是因为更新Windows的DirectX之后导致某些动态链接库文件缺失问题，可以下载一个DirectX修复工具进行修复。 Linux环境 Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。 安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。 yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python源代码并解压缩到指定目录。 wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz xz -d Python-3.7.3.tar.xz tar -xvf Python-3.7.3.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。 cd Python-3.7.3 ./configure --prefix=/usr/local/python37 --enable-optimizations make && make install 修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。 cd ~ vim .bash_profile # ... 此处省略上面的代码 ... export PATH=$PATH:/usr/local/python37/bin # ... 此处省略下面的代码 ... source .bash_profile macOS环境 macOS也自带了Python 2.x版本，可以通过Python的官方网站提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，可以通过执行python3命令来启动3.x版本的Python解释器。 从终端运行Python程序 确认Python的版本 可以Windows的命令行提示符中键入下面的命令。 python --version 或者是在Linux或macOS系统的终端中键入下面的命令。 python3 --version 当然也可以先输入python或python3进入交互式环境，再执行以下的代码检查Python的版本。 import sys print(sys.version_info) print(sys.version) 编写Python源代码 可以用文本编辑工具（推荐使用Sublime、TextMate、Visual Studio Code等高级文本编辑工具）编写Python源代码并用py作为后缀名保存该文件，代码内容如下所示。 print('hello, world!') 运行程序 切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了\"hello, world!\"。 python hello.py 或 python3 hello.py 代码中的注释 注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾 \"\"\" 第一个Python程序 - hello, world! 向伟大的Dennis M. Ritchie先生致敬 Version: 0.1 Author: 骆昊 \"\"\" print('hello, world!') # print(\"你好,世界！\") print('你好', '世界') print('hello', 'world', sep=', ', end='!') print('goodbye, world', end='!\\n') 其他工具介绍 IDLE - 自带的集成开发工具 IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。 IPython - 更好的交互式编程工具 IPython是一种基于Python的交互式解释器。相较于原生的Python交互式环境，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。 pip install ipython 或 pip3 install ipython 安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。 当然，我们也可以通过安装Jupyter工具并运行名为notebook的程序在浏览器窗口中进行交互式代码编写操作。 pip install jupyter 或 pip3 intall jupyter 然后执行下面的命令： jupyter notebook Sublime - 文本编辑神器 首先可以通过官方网站下载安装程序安装Sublime 3或Sublime 2。 安装包管理工具。 通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。 Sublime 3 import urllib.request,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib.request.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) Sublime 2 import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read());print('Please restart Sublime Text to finish installation') 手动安装浏览器输入 https://sublime.wbond.net/Package%20Control.sublime-package 下载这个文件 下载好以后，打开sublime text，选择菜单Preferences->Browse Packages... 打开安装目录 此时会进入到一个叫做Packages的目录下，点击进入上一层目录Sublime Text3，在此目录下有一个文件夹叫做Installed Packages，把刚才下载的文件放到这里就可以了。然后重启sublime text3，观察Preferences菜单最下边是否有Package Settings 和Package Control两个选项，如果有，则代表安装成功了。 安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件： SublimeCodeIntel - 代码自动补全工具插件。 Emmet - 前端开发代码模板插件。 Git - 版本控制工具插件。 Python PEP8 Autoformat - PEP8规范自动格式化插件。 ConvertToUTF8 - 将本地编码转换为UTF-8。 说明：事实上Visual Studio Code可能是更好的选择，它不用花钱并提供了更为完整和强大的功能。 PyCharm - Python开发神器 PyCharm的安装、配置和使用在《玩转PyCharm》进行了介绍，有兴趣的读者可以选择阅读。 练习 在Python交互环境中查看下面的代码结果，并试着将这些内容翻译成中文。 import this 说明：当前键入上面的命令后会在交互式环境中看到如下所示的输出，这段内容被称为“Python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 学习使用turtle在屏幕上绘制图形。 说明：turtle是Python内置的一个非常有趣的模块，特别适用于让小朋友体会什么是编程，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言. import turtle turtle.pensize(4) turtle.pencolor('red') turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.mainloop() "},"Python/Python语言基础/01-语言元素.html":{"url":"Python/Python语言基础/01-语言元素.html","title":"语言元素","keywords":"","body":"datetime:2019/5/14 9:38 author:nzb 语言元素 指令和程序 计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们使用的计算机虽然器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于“冯·诺依曼结构”的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用维基百科或者百度百科科普一下。 变量和类型 在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如'hello'和\"hello\",字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。 变量命名 需要符合PEP8要求 在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符 Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> 右移，左移 & 按位与 ^ ` ` 按位异或，按位或 > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= ` =`^= >>= （复合）赋值运算符 说明：在实际开发中，如果搞不清楚优先级可以使用括号来确保运算的执行顺序。 练习 练习1：华氏温度转摄氏温度。 \"\"\" 将华氏温度转换为摄氏温度 F = 1.8C + 32 \"\"\" f = float(input('请输入华氏温度: ')) c = (f - 32) / 1.8 print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 练习2：输入圆的半径计算计算周长和面积。 \"\"\" 输入半径计算圆的周长和面积 \"\"\" import math radius = float(input('请输入圆的半径: ')) perimeter = 2 * math.pi * radius area = math.pi * radius * radius print('周长: %.2f' % perimeter) print('面积: %.2f' % area) 练习3：输入年份判断是不是闰年。 \"\"\" 输入年份 如果是闰年输出True 否则输出False \"\"\" year = int(input('请输入年份: ')) # 如果代码太长写成一行不便于阅读 可以使用\\或()折行 is_leap = (year % 4 == 0 and year % 100 != 0 or year % 400 == 0) print(is_leap) "},"Python/Python语言基础/02-分支结构.html":{"url":"Python/Python语言基础/02-分支结构.html","title":"分支结构","keywords":"","body":"datetime:2019/5/14 9:38 author:nzb 分支结构 分支结构的应用场景 迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。类似的场景还有很多，给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。 if语句的使用 在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。 \"\"\" 用户身份验证 \"\"\" username = input('请输入用户名: ') password = input('请输入口令: ') # 如果希望输入口令时 终端中没有回显 可以使用getpass模块的getpass函数 # import getpass # password = getpass.getpass('请输入口令: ') if username == 'admin' and password == '123456': print('身份验证成功!') else: print('身份验证失败!') 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值。 \"\"\" 分段函数求值 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 elif x >= -1: y = x + 2 else: y = 5 * x + 3 print('f(%.2f) = %.2f' % (x, y)) 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。 \"\"\" 分段函数求值 3x - 5 (x > 1) f(x) = x + 2 (-1 1: y = 3 * x - 5 else: if x >= -1: y = x + 2 else: y = 5 * x + 3 print('f(%.2f) = %.2f' % (x, y)) 说明：大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提出这个观点是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，如果可以使用扁平化的结构就不要去用嵌套，因此之前的写法是更好的做法。 练习 练习1：英制单位与公制单位互换 \"\"\" 英制单位英寸和公制单位厘米互换 \"\"\" value = float(input('请输入长度: ')) unit = input('请输入单位: ') if unit == 'in' or unit == '英寸': print('%f英寸 = %f厘米' % (value, value * 2.54)) elif unit == 'cm' or unit == '厘米': print('%f厘米 = %f英寸' % (value, value / 2.54)) else: print('请输入有效的单位') 练习2：掷骰子决定做什么 \"\"\" 掷骰子决定做什么事情 \"\"\" from random import randint face = randint(1, 6) if face == 1: result = '唱首歌' elif face == 2: result = '跳个舞' elif face == 3: result = '学狗叫' elif face == 4: result = '做俯卧撑' elif face == 5: result = '念绕口令' else: result = '讲冷笑话' print(result) 说明：上面的代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。 练习3：百分制成绩转等级制 \"\"\" 百分制成绩转等级制成绩 90分以上 --> A 80分~89分 --> B 70分~79分 --> C 60分~69分 --> D 60分以下 --> E \"\"\" score = float(input('请输入成绩: ')) if score >= 90: grade = 'A' elif score >= 80: grade = 'B' elif score >= 70: grade = 'C' elif score >= 60: grade = 'D' else: grade = 'E' print('对应的等级是:', grade) 练习4：输入三条边长如果能构成三角形就计算周长和面积 \"\"\" 判断输入的边长能否构成三角形 如果能则计算出三角形的周长和面积 \"\"\" import math a = float(input('a = ')) b = float(input('b = ')) c = float(input('c = ')) if a + b > c and a + c > b and b + c > a: print('周长: %f' % (a + b + c)) p = (a + b + c) / 2 area = math.sqrt(p * (p - a) * (p - b) * (p - c)) print('面积: %f' % (area)) else: print('不能构成三角形') 说明：上面的代码中使用了math模块的sqrt函数来计算平方根。用边长计算三角形面积的公式叫做海伦公式。 练习5：个人所得税计算器。 \"\"\" 输入月收入和五险一金计算个人所得税 \"\"\" salary = float(input('本月收入: ')) insurance = float(input('五险一金: ')) diff = salary - insurance - 3500 if diff 说明：上面的代码中使用了Python内置的abs()函数取绝对值来处理-0的问题。 "},"Python/Python语言基础/03-循环结构.html":{"url":"Python/Python语言基础/03-循环结构.html","title":"循环结构","keywords":"","body":"datetime:2019/5/14 9:49 author:nzb 循环结构 循环结构的应用场景 如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个\"hello, world\"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for-in循环 如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环，例如下面代码中计算$\\sum_{n=1}^{100}n$。 \"\"\" 用for循环实现1~100求和 \"\"\" sum = 0 for x in range(101): sum += x print(sum) 需要说明的是上面代码中的range类型，range可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。 知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。 \"\"\" 用for循环实现1~100之间的偶数求和 \"\"\" sum = 0 for x in range(2, 101, 2): sum += x print(sum) 也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。 \"\"\" 用for循环实现1~100之间的偶数求和 \"\"\" sum = 0 for x in range(1, 101): if x % 2 == 0: sum += x print(sum) while循环 如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环，while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 \"\"\" 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 \"\"\" import random answer = random.randint(1, 100) counter = 0 while True: counter += 1 number = int(input('请输入: ')) if number answer: print('小一点') else: print('恭喜你猜对了!') break print('你总共猜了%d次' % counter) if counter > 7: print('你的智商余额明显不足') 说明：上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 \"\"\" 输出乘法口诀表(九九表) \"\"\" for i in range(1, 10): for j in range(1, i + 1): print('%d*%d=%d' % (i, j, i * j), end='\\t') print() 练习 练习1：输入一个数判断是不是素数。 \"\"\" 输入一个正整数判断它是不是素数 \"\"\" from math import sqrt num = int(input('请输入一个正整数: ')) end = int(sqrt(num)) is_prime = True for x in range(2, end + 1): if num % x == 0: is_prime = False break if is_prime and num != 1: print('%d是素数' % num) else: print('%d不是素数' % num) 练习2：输入两个正整数，计算最大公约数和最小公倍数。 \"\"\" 输入两个正整数计算最大公约数和最小公倍数 \"\"\" x = int(input('x = ')) y = int(input('y = ')) if x > y: x, y = y, x for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: print('%d和%d的最大公约数是%d' % (x, y, factor)) print('%d和%d的最小公倍数是%d' % (x, y, x * y // factor)) break 练习3：打印三角形图案。 \"\"\" 打印各种三角形图案 * ** *** **** ***** * ** *** **** ***** * *** ***** ******* ********* \"\"\" row = int(input('请输入行数: ')) for i in range(row): for _ in range(i + 1): print('*', end='') print() for i in range(row): for j in range(row): if j "},"Python/Python语言基础/04-练习.html":{"url":"Python/Python语言基础/04-练习.html","title":"构造程序逻辑","keywords":"","body":"datetime:2019/5/14 9:51 author:nzb 练习 练习清单 寻找“水仙花数”。 寻找“完美数”。 “百钱百鸡”问题。 生成“斐波拉切数列”。 Craps赌博游戏。 "},"Python/Python语言基础/05-函数和模块的使用.html":{"url":"Python/Python语言基础/05-函数和模块的使用.html","title":"函数和模块的使用","keywords":"","body":"datetime:2019/5/14 9:54 author:nzb 函数和模块的使用 在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。 $$x_1 + x_2 + x_3 + x_4 = 8$$ 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。 $$C_M^N =\\frac{M!}{N!(M-N)!}, \\text{(M=7, N=3)} $$ 可以用Python的程序来计算出这个值，代码如下所示。 \"\"\" 输入M和N计算C(M,N) \"\"\" m = int(input('m = ')) n = int(input('n = ')) fm = 1 for num in range(1, m + 1): fm *= num fn = 1 for num in range(1, n + 1): fn *= num fmn = 1 for num in range(1, m - n + 1): fmn *= num print(fm // fn // fmn) 函数的作用 不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数 在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。 def factorial(num): \"\"\" 求阶乘 :param num: 非负整数 :return: num的阶乘 \"\"\" result = 1 for n in range(1, num + 1): result *= n return result m = int(input('m = ')) n = int(input('n = ')) # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数 print(factorial(m) // factorial(n) // factorial(m - n)) 说明：Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。 函数的参数 函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 from random import randint def roll_dice(n=2): \"\"\" 摇色子 :param n: 色子的个数 :return: n颗色子点数之和 \"\"\" total = 0 for _ in range(n): total += randint(1, 6) return total def add(a=0, b=0, c=0): return a + b + c # 如果没有指定参数那么使用默认值摇两颗色子 print(roll_dice()) # 摇三颗色子 print(roll_dice(3)) print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) # 传递参数时可以不按照设定的顺序进行传递 print(add(c=50, a=100, b=200)) 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 # 在参数名前面的*表示args是一个可变参数 # 即在调用add函数时可以传入0个或多个参数 def add(*args): total = 0 for val in args: total += val return total print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) print(add(1, 3, 5, 7, 9)) 用模块管理函数 对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 def foo(): print('hello, world!') def foo(): print('goodbye, world!') # 下面的代码会输出什么呢？ foo() 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。 module1.py def foo(): print('hello, world!') module2.py def foo(): print('goodbye, world!') test.py from module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py import module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py from module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py from module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。 module3.py def foo(): pass def bar(): pass # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py import module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习 练习1：实现计算求最大公约数和最小公倍数的函数。 def gcd(x, y): (x, y) = (y, x) if x > y else (x, y) for factor in range(x, 0, -1): if x % factor == 0 and y % factor == 0: return factor def lcm(x, y): return x * y // gcd(x, y) 练习2：实现判断一个数是不是回文数的函数。 def is_palindrome(num): temp = num total = 0 while temp > 0: total = total * 10 + temp % 10 temp //= 10 return total == num 练习3：实现判断一个数是不是素数的函数。 def is_prime(num): for factor in range(2, num): if num % factor == 0: return False return True if num != 1 else False 练习4：写一个程序判断输入的正整数是不是回文素数。 if __name__ == '__main__': num = int(input('请输入正整数: ')) if is_palindrome(num) and is_prime(num): print('%d是回文素数' % num) 通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题。 def foo(): b = 'hello' def bar(): # Python中可以在函数内部再定义函数 c = True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not defined if __name__ == '__main__': a = 100 # print(b) # NameError: name 'b' is not defined foo() 上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符min、len等都属于内置作用域）。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 def foo(): a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 def foo(): global a a = 200 print(a) # 200 if __name__ == '__main__': a = 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收)。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用闭包)，这个我们在后续的内容中进行讲解。 说明：很多人经常会将“闭包”一词和“匿名函数”混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看维基百科或者知乎上对这个概念的讨论。 说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。 def main(): # Todo: Add your code here pass if __name__ == '__main__': main() "},"Python/Python语言基础/06-字符串和常用数据结构.html":{"url":"Python/Python语言基础/06-字符串和常用数据结构.html","title":"字符串和常用数据结构","keywords":"","body":"datetime:2019/5/14 9:57 author:nzb 字符串和常用数据结构 使用字符串 第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓字符串，就是由零个或多个字符组成的有限序列，一般记为$${\\displaystyle s=a{1}a{2}\\dots a_{n}(0\\leq n \\leq \\infty)}$$。 我们可以通过下面的代码来了解字符串的使用。 def main(): str1 = 'hello, world!' # 通过len函数计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find('or')) # 8 print(str1.find('shit')) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index('or')) # print(str1.index('shit')) # 检查字符串是否以指定的字符串开头 print(str1.startswith('He')) # False print(str1.startswith('hel')) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith('!')) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, ' ')) str2 = 'abc123456' # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 = ' jackfrued@126.com ' print(str3) # 获得字符串修剪左右两侧空格的拷贝 print(str3.strip()) if __name__ == '__main__': main() 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。 使用列表 下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。 def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。 def main(): fruits = ['grape', 'apple', 'strawberry', 'waxberry'] fruits += ['pitaya', 'pear', 'mango'] # 循环遍历列表元素 for fruit in fruits: print(fruit.title(), end=' ') print() # 列表切片 fruits2 = fruits[1:4] print(fruits2) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits[:] print(fruits3) fruits4 = fruits[-3:-1] print(fruits4) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits[::-1] print(fruits5) if __name__ == '__main__': main() 下面的代码实现了对列表的排序操作。 def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == '__main__': main() 我们还可以使用列表的生成式语法来创建列表，代码如下所示。 import sys def main(): f = [x for x in range(1, 10)] print(f) f = [x + y for x in 'ABCDE' for y in '1234567'] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) if __name__ == '__main__': main() 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： $${\\displaystyle F_{0}=0}$$ $${\\displaystyle F_{1}=1}$$ $${\\displaystyle F{n}=F{n-1}+F_{n-2} }({n}\\geq{2})$$ def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == '__main__': main() 使用元组 Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 def main(): # 定义元组 t = ('骆昊', 38, True, '四川成都') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。 使用集合 Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 def main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 & set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 = set2) # print(set1.issuperset(set2)) print(set1 >= set3) # print(set1.issuperset(set3)) if __name__ == '__main__': main() 说明：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典 字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 def main(): scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82} # 通过键可以获取字典中对应的值 print(scores['骆昊']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\\t--->\\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('骆昊', 100)) # 清空字典 scores.clear() print(scores) if __name__ == '__main__': main() 练习 练习1：在屏幕上显示跑马灯文字 import os import time def main(): content = '北京欢迎你为你开天辟地…………' while True: # 清理屏幕上的输出 os.system('cls') # os.system('clear') print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0] if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。 import random def generate_code(code_len=4): \"\"\" 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 \"\"\" all_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' last_pos = len(all_chars) - 1 code = '' for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。 def get_suffix(filename, has_dot=False): \"\"\" 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 \"\"\" pos = filename.rfind('.') if 0 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。 def max2(x): m1, m2 = (x[0], x[1]) if x[0] > x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] > m1: m2 = m1 m1 = x[index] elif x[index] > m2: m2 = x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天 def is_leap_year(year): \"\"\" 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False \"\"\" return year % 4 == 0 and year % 100 != 0 or year % 400 == 0 def which_day(year, month, date): \"\"\" 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 \"\"\" days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + date def main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1)) if __name__ == '__main__': main() 练习6：打印杨辉三角。 def main(): num = int(input('Number of rows: ')) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end='\\t') print() if __name__ == '__main__': main() 综合案例 案例1：双色球选号 from random import randrange, randint, sample def display(balls): \"\"\" 输出列表中的双色球号码 \"\"\" for index, ball in enumerate(balls): if index == len(balls) - 1: print('|', end=' ') print('%02d' % ball, end=' ') print() def random_select(): \"\"\" 随机选择一组号码 \"\"\" red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_balls def main(): n = int(input('机选几注: ')) for _ in range(n): display(random_select()) if __name__ == '__main__': main() 说明：上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。 综合案例2：约瑟夫环问题 \"\"\" 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 \"\"\" def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter 综合案例3：井字棋游戏 import os def print_board(board): print(board['TL'] + '|' + board['TM'] + '|' + board['TR']) print('-+-+-') print(board['ML'] + '|' + board['MM'] + '|' + board['MR']) print('-+-+-') print(board['BL'] + '|' + board['BM'] + '|' + board['BR']) def main(): init_board = { 'TL': ' ', 'TM': ' ', 'TR': ' ', 'ML': ' ', 'MM': ' ', 'MR': ' ', 'BL': ' ', 'BM': ' ', 'BR': ' ' } begin = True while begin: curr_board = init_board.copy() begin = False turn = 'x' counter = 0 os.system('clear') print_board(curr_board) while counter 说明：最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。 "},"Python/Python语言基础/07-面向对象编程基础.html":{"url":"Python/Python语言基础/07-面向对象编程基础.html","title":"面向对象编程基础","keywords":"","body":"datetime:2019/5/14 10:11 author:nzb 面向对象编程基础 活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是“面向对象编程”，我们先来看看比较正式的说法。 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。 这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于知乎。 说明：以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。 之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，“软件危机”、“软件工程”等一系列的概念开始在行业中出现。 当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“银弹”，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。 说明：当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。 类和对象 简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。 定义类 在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_av(self): if self.age 说明：写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象 当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。 def main(): # 创建学生对象并指定姓名和年龄 stu1 = Student('骆昊', 38) # 给对象发study消息 stu1.study('Python程序设计') # 给对象发watch_av消息 stu1.watch_av() stu2 = Student('王大锤', 15) stu2.study('思想品德') stu2.watch_av() if __name__ == '__main__': main() 访问可见性问题 对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Test('hello') # AttributeError: 'Test' object has no attribute '__bar' test.__bar() # AttributeError: 'Test' object has no attribute '__foo' print(test.__foo) if __name__ == \"__main__\": main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print('__bar') def main(): test = Test('hello') test._Test__bar() print(test._Test__foo) if __name__ == \"__main__\": main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解。 面向对象的支柱 面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习 练习1：定义一个类描述数字时钟 class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): \"\"\"初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 \"\"\" self._hour = hour self._minute = minute self._second = second def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。 from math import sqrt class Point(object): def __init__(self, x=0, y=0): \"\"\"初始化方法 :param x: 横坐标 :param y: 纵坐标 \"\"\" self.x = x self.y = y def move_to(self, x, y): \"\"\"移动到指定位置 :param x: 新的横坐标 \"param y: 新的纵坐标 \"\"\" self.x = x self.y = y def move_by(self, dx, dy): \"\"\"移动指定的增量 :param dx: 横坐标的增量 \"param dy: 纵坐标的增量 \"\"\" self.x += dx self.y += dy def distance_to(self, other): \"\"\"计算与另一个点的距离 :param other: 另一个点 \"\"\" dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y)) def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) if __name__ == '__main__': main() 说明：本章中的插图来自于Grady Booch等著作的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。 "},"Python/Python语言基础/08-面向对象编程进阶.html":{"url":"Python/Python语言基础/08-面向对象编程进阶.html","title":"面向对象编程进阶","keywords":"","body":"datetime:2019/5/14 10:30 author:nzb 面向对象进阶 在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器 之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 class Person(object): def __init__(self, name, age): self._name = name self._age = age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age = age def play(self): if self._age __slots__魔法 我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = ('_name', '_age', '_gender') def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): if self._age 静态方法和类方法 之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 from math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b > c and b + c > a and a + c > b def perimeter(self): return self._a + self._b + self._c def area(self): half = self.perimeter() / 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c = 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t = Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print('无法构成三角形.') if __name__ == '__main__': main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 from time import time, localtime, sleep class Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock = Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ == '__main__': main() 类之间的关系 简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态 刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 class Person(object): \"\"\"人\"\"\" def __init__(self, name, age): self._name = name self._age = age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age = age def play(self): print('%s正在愉快的玩耍.' % self._name) def watch_av(self): if self._age >= 18: print('%s正在观看爱情动作片.' % self._name) else: print('%s只能观看《熊出没》.' % self._name) class Student(Person): \"\"\"学生\"\"\" def __init__(self, name, age, grade): super().__init__(name, age) self._grade = grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade = grade def study(self, course): print('%s的%s正在学习%s.' % (self._grade, self._name, course)) class Teacher(Person): \"\"\"老师\"\"\" def __init__(self, name, age, title): super().__init__(name, age) self._title = title @property def title(self): return self._title @title.setter def title(self, title): self._title = title def teach(self, course): print('%s%s正在讲%s.' % (self._name, self._title, course)) def main(): stu = Student('王大锤', 15, '初三') stu.study('数学') stu.watch_av() t = Teacher('骆昊', 38, '老叫兽') t.teach('Python程序设计') t.watch_av() if __name__ == '__main__': main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 from abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \"\"\"宠物\"\"\" def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \"\"\"发出声音\"\"\" pass class Dog(Pet): \"\"\"狗\"\"\" def make_voice(self): print('%s: 汪汪汪...' % self._nickname) class Cat(Pet): \"\"\"猫\"\"\" def make_voice(self): print('%s: 喵...喵...' % self._nickname) def main(): pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')] for pet in pets: pet.make_voice() if __name__ == '__main__': main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 综合案例 案例1：奥特曼打小怪兽 from abc import ABCMeta, abstractmethod from random import randint, randrange class Fighter(object, metaclass=ABCMeta): \"\"\"战斗者\"\"\" # 通过__slots__魔法限定对象可以绑定的成员变量 __slots__ = ('_name', '_hp') def __init__(self, name, hp): \"\"\"初始化方法 :param name: 名字 :param hp: 生命值 \"\"\" self._name = name self._hp = hp @property def name(self): return self._name @property def hp(self): return self._hp @hp.setter def hp(self, hp): self._hp = hp if hp >= 0 else 0 @property def alive(self): return self._hp > 0 @abstractmethod def attack(self, other): \"\"\"攻击 :param other: 被攻击的对象 \"\"\" pass class Ultraman(Fighter): \"\"\"奥特曼\"\"\" __slots__ = ('_name', '_hp', '_mp') def __init__(self, name, hp, mp): \"\"\"初始化方法 :param name: 名字 :param hp: 生命值 :param mp: 魔法值 \"\"\" super().__init__(name, hp) self._mp = mp def attack(self, other): other.hp -= randint(15, 25) def huge_attack(self, other): \"\"\"究极必杀技(打掉对方至少50点或四分之三的血) :param other: 被攻击的对象 :return: 使用成功返回True否则返回False \"\"\" if self._mp >= 50: self._mp -= 50 injury = other.hp * 3 // 4 injury = injury if injury >= 50 else 50 other.hp -= injury return True else: self.attack(other) return False def magic_attack(self, others): \"\"\"魔法攻击 :param others: 被攻击的群体 :return: 使用魔法成功返回True否则返回False \"\"\" if self._mp >= 20: self._mp -= 20 for temp in others: if temp.alive: temp.hp -= randint(10, 15) return True else: return False def resume(self): \"\"\"恢复魔法值\"\"\" incr_point = randint(1, 10) self._mp += incr_point return incr_point def __str__(self): return '~~~%s奥特曼~~~\\n' % self._name + \\ '生命值: %d\\n' % self._hp + \\ '魔法值: %d\\n' % self._mp class Monster(Fighter): \"\"\"小怪兽\"\"\" __slots__ = ('_name', '_hp') def attack(self, other): other.hp -= randint(10, 20) def __str__(self): return '~~~%s小怪兽~~~\\n' % self._name + \\ '生命值: %d\\n' % self._hp def is_any_alive(monsters): \"\"\"判断有没有小怪兽是活着的\"\"\" for monster in monsters: if monster.alive > 0: return True return False def select_alive_one(monsters): \"\"\"选中一只活着的小怪兽\"\"\" monsters_len = len(monsters) while True: index = randrange(monsters_len) monster = monsters[index] if monster.alive > 0: return monster def display_info(ultraman, monsters): \"\"\"显示奥特曼和小怪兽的信息\"\"\" print(ultraman) for monster in monsters: print(monster, end='') def main(): u = Ultraman('骆昊', 1000, 120) m1 = Monster('狄仁杰', 250) m2 = Monster('白元芳', 500) m3 = Monster('王大锤', 750) ms = [m1, m2, m3] fight_round = 1 while u.alive and is_any_alive(ms): print('========第%02d回合========' % fight_round) m = select_alive_one(ms) # 选中一只小怪兽 skill = randint(1, 10) # 通过随机数选择使用哪种技能 if skill 0: # 如果选中的小怪兽没有死就回击奥特曼 print('%s回击了%s.' % (m.name, u.name)) m.attack(u) display_info(u, ms) # 每个回合结束后显示奥特曼和小怪兽的信息 fight_round += 1 print('\\n========战斗结束!========\\n') if u.alive > 0: print('%s奥特曼胜利!' % u.name) else: print('小怪兽胜利!') if __name__ == '__main__': main() 案例2：扑克游戏 import random class Card(object): \"\"\"一张牌\"\"\" def __init__(self, suite, face): self._suite = suite self._face = face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face == 1: face_str = 'A' elif self._face == 11: face_str = 'J' elif self._face == 12: face_str = 'Q' elif self._face == 13: face_str = 'K' else: face_str = str(self._face) return '%s%s' % (self._suite, face_str) def __repr__(self): return self.__str__() class Poker(object): \"\"\"一副牌\"\"\" def __init__(self): self._cards = [Card(suite, face) for suite in '♠♥♣♦' for face in range(1, 14)] self._current = 0 @property def cards(self): return self._cards def shuffle(self): \"\"\"洗牌(随机乱序)\"\"\" self._current = 0 random.shuffle(self._cards) @property def next(self): \"\"\"发牌\"\"\" card = self._cards[self._current] self._current += 1 return card @property def has_next(self): \"\"\"还有没有牌\"\"\" return self._current 说明：大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。 案例3：工资结算系统 \"\"\" 某公司有三种类型的员工 分别是部门经理、程序员和销售员 需要设计一个工资结算系统 根据提供的员工信息来计算月薪 部门经理的月薪是每月固定15000元 程序员的月薪按本月工作时间计算 每小时150元 销售员的月薪是1200元的底薪加上销售额5%的提成 \"\"\" from abc import ABCMeta, abstractmethod class Employee(object, metaclass=ABCMeta): \"\"\"员工\"\"\" def __init__(self, name): \"\"\" 初始化方法 :param name: 姓名 \"\"\" self._name = name @property def name(self): return self._name @abstractmethod def get_salary(self): \"\"\" 获得月薪 :return: 月薪 \"\"\" pass class Manager(Employee): \"\"\"部门经理\"\"\" def get_salary(self): return 15000.0 class Programmer(Employee): \"\"\"程序员\"\"\" def __init__(self, name, working_hour=0): super().__init__(name) self._working_hour = working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour = working_hour if working_hour > 0 else 0 def get_salary(self): return 150.0 * self._working_hour class Salesman(Employee): \"\"\"销售员\"\"\" def __init__(self, name, sales=0): super().__init__(name) self._sales = sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales = sales if sales > 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05 def main(): emps = [ Manager('刘备'), Programmer('诸葛亮'), Manager('曹操'), Salesman('荀彧'), Salesman('吕布'), Programmer('张辽'), Programmer('赵云') ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour = int(input('请输入%s本月工作时间: ' % emp.name)) elif isinstance(emp, Salesman): emp.sales = float(input('请输入%s本月销售额: ' % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print('%s本月工资为: ￥%s元' % (emp.name, emp.get_salary())) if __name__ == '__main__': main() "},"Python/Python语言基础/09-图形用户界面和游戏开发.html":{"url":"Python/Python语言基础/09-图形用户界面和游戏开发.html","title":"图形用户界面和游戏开发","keywords":"","body":"datetime:2019/5/14 11:44 author:nzb 图形用户界面和游戏开发 基于tkinter模块的GUI GUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。 下面的代码演示了如何使用tkinter做一个简单的GUI应用。 import tkinter import tkinter.messagebox def main(): flag = True # 修改标签上的文字 def change_label_text(): nonlocal flag flag = not flag color, msg = ('red', 'Hello, world!')\\ if flag else ('blue', 'Goodbye, world!') label.config(text=msg, fg=color) # 确认退出 def confirm_to_quit(): if tkinter.messagebox.askokcancel('温馨提示', '确定要退出吗?'): top.quit() # 创建顶层窗口 top = tkinter.Tk() # 设置窗口大小 top.geometry('240x160') # 设置窗口标题 top.title('小游戏') # 创建标签对象并添加到顶层窗口 label = tkinter.Label(top, text='Hello, world!', font='Arial -32', fg='red') label.pack(expand=1) # 创建一个装按钮的容器 panel = tkinter.Frame(top) # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数 button1 = tkinter.Button(panel, text='修改', command=change_label_text) button1.pack(side='left') button2 = tkinter.Button(panel, text='退出', command=confirm_to_quit) button2.pack(side='right') panel.pack(side='bottom') # 开启主事件循环 tkinter.mainloop() if __name__ == '__main__': main() 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。 使用Pygame进行游戏开发 Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。 下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。 制作游戏窗口 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 在窗口中绘图 可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((242, 242, 242)) # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆) pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 加载图像 如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((255, 255, 255)) # 通过指定的文件名加载图像 ball_image = pygame.image.load('./res/ball.png') # 在窗口上渲染图像 screen.blit(ball_image, (50, 50)) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False if __name__ == '__main__': main() 实现动画效果 说到动画这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') # 定义变量来表示小球在屏幕上的位置 x, y = 50, 50 running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False screen.fill((255, 255, 255)) pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0) pygame.display.flip() # 每隔50毫秒就改变小球的位置再刷新窗口 pygame.time.delay(50) x, y = x + 5, y + 5 if __name__ == '__main__': main() 碰撞检测 通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。 from enum import Enum, unique from math import sqrt from random import randint import pygame @unique class Color(Enum): \"\"\"颜色\"\"\" RED = (255, 0, 0) GREEN = (0, 255, 0) BLUE = (0, 0, 255) BLACK = (0, 0, 0) WHITE = (255, 255, 255) GRAY = (242, 242, 242) @staticmethod def random_color(): \"\"\"获得随机颜色\"\"\" r = randint(0, 255) g = randint(0, 255) b = randint(0, 255) return (r, g, b) class Ball(object): \"\"\"球\"\"\" def __init__(self, x, y, radius, sx, sy, color=Color.RED): \"\"\"初始化方法\"\"\" self.x = x self.y = y self.radius = radius self.sx = sx self.sy = sy self.color = color self.alive = True def move(self, screen): \"\"\"移动\"\"\" self.x += self.sx self.y += self.sy if self.x - self.radius = screen.get_width(): self.sx = -self.sx if self.y - self.radius = screen.get_height(): self.sy = -self.sy def eat(self, other): \"\"\"吃其他球\"\"\" if self.alive and other.alive and self != other: dx, dy = self.x - other.x, self.y - other.y distance = sqrt(dx ** 2 + dy ** 2) if distance other.radius: other.alive = False self.radius = self.radius + int(other.radius * 0.146) def draw(self, screen): \"\"\"在窗口上绘制球\"\"\" pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius, 0) 事件处理 可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。 def main(): # 定义用来装所有球的容器 balls = [] # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen = pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption('大球吃小球') running = True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type == pygame.QUIT: running = False # 处理鼠标事件的代码 if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: # 获得点击鼠标的位置 x, y = event.pos radius = randint(10, 100) sx, sy = randint(-10, 10), randint(-10, 10) color = Color.random_color() # 在点击鼠标的位置创建一个球(大小、速度和颜色随机) ball = Ball(x, y, radius, sx, sy, color) # 将球添加到列表容器中 balls.append(ball) screen.fill((255, 255, 255)) # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除 for ball in balls: if ball.alive: ball.draw(screen) else: balls.remove(ball) pygame.display.flip() # 每隔50毫秒就改变球的位置再刷新窗口 pygame.time.delay(50) for ball in balls: ball.move(screen) # 检查球有没有吃到其他的球 for other in balls: ball.eat(other) if __name__ == '__main__': main() 上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是pygame的官方网站，如果英语没毛病就可以赶紧去看看啦。 如果想开发3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看Panda3D。 "},"Python/Python语言基础/10-文件和异常.html":{"url":"Python/Python语言基础/10-文件和异常.html","title":"文件和异常","keywords":"","body":"datetime:2019/5/14 13:49 author:nzb 文件和异常 在实际开发中，常常需要对程序中的数据进行持久化操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 'r' 读取 （默认） 'w' 写入（会先截断之前的内容） 'x' 写入，如果文件已经存在会产生异常 'a' 追加，将内容写入到已有文件的末尾 'b' 二进制模式 't' 文本模式（默认） '+' 更新（既可以读又可以写） 下面这张图来自于菜鸟教程网站，它展示了如果根据应用程序的需要来设置操作模式。 读写文本文件 读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为'r'（如果不指定，默认值也是'r'），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 def main(): f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) f.close() if __name__ == '__main__': main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 def main(): f = None try: f = open('致橡树.txt', 'r', encoding='utf-8') print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') finally: if f: f.close() if __name__ == '__main__': main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。 def main(): try: with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) except FileNotFoundError: print('无法打开指定的文件!') except LookupError: print('指定了未知的编码!') except UnicodeDecodeError: print('读取文件时解码错误!') if __name__ == '__main__': main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示。 import time def main(): # 一次性读取整个文件内容 with open('致橡树.txt', 'r', encoding='utf-8') as f: print(f.read()) # 通过for-in循环逐行读取 with open('致橡树.txt', mode='r') as f: for line in f: print(line, end='') time.sleep(0.5) print() # 读取文件按行读取到列表中 with open('致橡树.txt') as f: lines = f.readlines() print(lines) if __name__ == '__main__': main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为'w'即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为'a'。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999直接的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。 from math import sqrt def is_prime(n): \"\"\"判断素数的函数\"\"\" assert n > 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor == 0: return False return True if n != 1 else False def main(): filenames = ('a.txt', 'b.txt', 'c.txt') fs_list = [] try: for filename in filenames: fs_list.append(open(filename, 'w', encoding='utf-8')) for number in range(1, 10000): if is_prime(number): if number 读写二进制文件 知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 def main(): try: with open('guido.jpg', 'rb') as fs1: data = fs1.read() print(type(data)) # with open('吉多.jpg', 'wb') as fs2: fs2.write(data) except FileNotFoundError as e: print('指定的文件无法打开.') except IOError as e: print('读写文件时出现错误.') print('程序执行结束.') if __name__ == '__main__': main() 读写JSON文件 通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 { 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ {'brand': 'BYD', 'max_speed': 180}, {'brand': 'Audi', 'max_speed': 280}, {'brand': 'Benz', 'max_speed': 320} ] } 可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。 JSON Python object dict array list string str number (int / real) int / float true / false True / False null None Python JSON dict object list, tuple array str string int, float, int- & float-derived Enums number True / False true / false None null 我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。 import json def main(): mydict = { 'name': '骆昊', 'age': 38, 'qq': 957658, 'friends': ['王大锤', '白元芳'], 'cars': [ {'brand': 'BYD', 'max_speed': 180}, {'brand': 'Audi', 'max_speed': 280}, {'brand': 'Benz', 'max_speed': 320} ] } try: with open('data.json', 'w', encoding='utf-8') as fs: json.dump(mydict, fs) except IOError as e: print(e) print('保存数据完成!') if __name__ == '__main__': main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了天行数据提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。 import requests import json def main(): resp = requests.get('http://api.tianapi.com/guonei/?key=APIKey&num=10') data_model = json.loads(resp.text) for news in data_model['newslist']: print(news['title']) if __name__ == '__main__': main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。 "},"Python/Python语言基础/11-字符串和正则表达式.html":{"url":"Python/Python语言基础/11-字符串和正则表达式.html","title":"字符串和正则表达式","keywords":"","body":"datetime:2019/5/14 14:14 author:nzb 使用正则表达式 正则表达式相关知识 在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 匹配不在字符集中的任意单一字符 aeiou 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I'm dancing中的danc (? 匹配exp后面的位置 (? 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明：如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明：上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。 \"\"\" 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 \"\"\" import re def main(): username = input('请输入用户名: ') qq = input('请输入QQ号: ') # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 = re.match(r'^[0-9a-zA-Z_]{6,20}$', username) if not m1: print('请输入有效的用户名.') m2 = re.match(r'^[1-9]\\d{4,11}$', qq) if not m2: print('请输入有效的QQ号.') if m1 and m2: print('你输入的信息是有效的!') if __name__ == '__main__': main() 提示：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。 下面这张图是截止到2017年底，国内三家运营商推出的手机号段。 import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(? 说明：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容 import re def main(): sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.' purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔', '*', sentence, flags=re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ == '__main__': main() 说明：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串 import re def main(): poem = '窗前明月光，疑是地上霜。举头望明月，低头思故乡。' sentence_list = re.split(r'[，。, .]', poem) while '' in sentence_list: sentence_list.remove('') print(sentence_list) # ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡'] if __name__ == '__main__': main() 后话 如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。 "},"Python/Python语言基础/12-进程和线程.html":{"url":"Python/Python语言基础/12-进程和线程.html","title":"进程和线程","keywords":"","body":"datetime:2019/5/14 16:42 author:nzb 进程和线程 今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程 进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。 Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 from random import randint from time import time, sleep def download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() download_task('Python从入门到住院.pdf') download_task('Peking Hot.avi') end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 下面是运行程序得到的一次运行结果。 开始下载Python从入门到住院.pdf... Python从入门到住院.pdf下载完成! 耗费了6秒 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 from multiprocessing import Process from os import getpid from random import randint from time import time, sleep def download_task(filename): print('启动下载进程，进程号[%d].' % getpid()) print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() p1 = Process(target=download_task, args=('Python从入门到住院.pdf', )) p1.start() p2 = Process(target=download_task, args=('Peking Hot.avi', )) p2.start() p1.join() p2.join() end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 启动下载进程，进程号[1530]. 开始下载Python从入门到住院.pdf... 启动下载进程，进程号[1531]. 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 Python从入门到住院.pdf下载完成! 耗费了10秒 总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 from multiprocessing import Process from time import sleep counter = 0 def sub_task(string): global counter while counter 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 父进程和子进程 注意：进程间不共享全局变量 进程之间的通信-Queue 在初始化Queue()对象时（例如 q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头） Queue.qsize()：返回当前队列包含的消息数量 Queue.empty()：如果队列为空，返回True，反之False Queue.full()：如果队列满了，返回True,反之False Queue.get([block[,timeout]])：获取队列中的一条消息，然后将其从队列中移除， block默认值为True。如果block使用默认值，且没有设置 timeout（单位秒）,消息队列如果为空， 此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了 timeout，则会等待 timeout 秒， 若还没读取到任何消息，则抛出 Queue.Empty 异常： Queue.get_nowait() 相当于 Queue.get(False) Queue.put(item,[block[,timeout]])：将 item 消息写入队列，block 默认值为 True; 如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态）， 直到从消息队列腾出空间为止，如果设置了 timeout，则会等待 timeout 秒，若还没空间，则抛出 Queue.Full 异常 如果block值为 False，消息队列如果没有空间可写入，则会立刻抛出 Queue.Full 异常; Queue.put_nowait(item)：相当 Queue.put(item,False) from multiprocessing import Process, Queue import os, time, random # 写数据进程执行的代码： def write(q): for value in ['A', 'B', 'C']: print(\"Put {} to queue...\".format(value)) q.put(value) time.sleep(0.5) # 读数据进程执行的代码 def read(q): while True: if not q.empty(): value = q.get(True) print(\"Get {} from queue.\".format(value)) time.sleep(0.5) else: break if __name__ == '__main__': # 父进程创建Queue，并传给各个子进程 q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw ，写入： pw.start() # 等待pw结束 pw.join() # 启动子进程pr，读取： pr.start() pr.join() # pr 进程里是死循环，无法等待其结束，只能强行终止: print('') print(os.getpid()) print('所有数据都写入并且读完') 进程池 ```python from multiprocessing import Pool import os import time import random def worker(msg): t_start = time.time() print(\"%s开始执行,进程号为%d\" % (msg, os.getpid())) # random.random()随机生成0~1之间的浮点数 time.sleep(random.random() * 2) t_stop = time.time() print(msg, \"执行完毕，耗时%0.2f\" % (t_stop - t_start)) if name == \"main\": po = Pool(3) # 定义一个进程池，最大进程数3 for i in range(0, 8): # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(worker, (i,)) print(\"----start----\") # 关闭进程池，关闭后po不再接收新的请求 po.close() # 等待po中所有子进程执行完成，必须放在close语句之后 po.join() print(\"-----end-----\") - 进程池中使用 Queue 如果要使用 Pool 创建进程，就需要使用 multiprocessing.Manager() 中的 Queue() ,而不是 multiprocessing.Queue() ,否则会得到如下的错误信息： `RuntimeError： Queue objects should only be shared between processs through inheritance` ```python from multiprocessing import Manager, Pool import os, time, random def reader(q): print(\"reader 启动(%s),父进程为（%s)\" % (os.getpid(), os.getpid())) for i in range(q.qsize()): print(\"reader 从Queue获取到消息:%s\" % q.get(True)) def writer(q): print(\"writer 启动（%s),父进程为(%s)\" % (os.getpid(), os.getpid())) for i in \"itcast\": q.put(i) if __name__ == \"__main__\": print(\"(%s)start\" % os.getpid()) q = Manager().Queue() # 使用Manager中的Queue po = Pool() po.apply_async(writer, (q,)) time.sleep(1) po.apply_async(reader, (q,)) po.close() po.join() print(\"(%s)End\" % os.getpid()) Python中的多线程 在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 from random import randint from threading import Thread from time import time, sleep def download(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (filename, time_to_download)) def main(): start = time() t1 = Thread(target=download, args=('Python从入门到住院.pdf',)) t1.start() t2 = Thread(target=download, args=('Peking Hot.avi',)) t2.start() t1.join() t2.join() end = time() print('总共耗费了%.3f秒' % (end - start)) if __name__ == '__main__': main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 from random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename = filename def run(self): print('开始下载%s...' % self._filename) time_to_download = randint(5, 10) sleep(time_to_download) print('%s下载完成! 耗费了%d秒' % (self._filename, time_to_download)) def main(): start = time() # 将多个下载任务放到多个线程中执行 # 通过自定义的线程类创建线程对象 线程启动后会回调执行run方法 t1 = DownloadTask('Python从入门到住院.pdf') t1.start() t2 = DownloadTask('Peking Hot.avi') t2.start() t1.join() t2.join() end = time() print('总共耗费了%.2f秒.' % (end - start)) if __name__ == '__main__': main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 from time import sleep from threading import Thread class Account(object): def __init__(self): self._balance = 0 def deposit(self, money): # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance) if __name__ == '__main__': main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 from time import sleep from threading import Thread, Lock class Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance = self._balance + money sleep(0.01) self._balance = new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money) def main(): account = Account() threads = [] for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance) if __name__ == '__main__': main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明：上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O 现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例 例子1：将耗时间的任务放到线程中以获得更好的用户体验。 如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 import time import tkinter import tkinter.messagebox def download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') def main(): top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', True) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop() if __name__ == '__main__': main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 import time import tkinter import tkinter.messagebox from threading import Thread def main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo('提示', '下载完成!') # 启用下载按钮 button1.config(state=tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state=tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon=True).start() def show_about(): tkinter.messagebox.showinfo('关于', '作者: 骆昊(v1.0)') top = tkinter.Tk() top.title('单线程') top.geometry('200x150') top.wm_attributes('-topmost', 1) panel = tkinter.Frame(top) button1 = tkinter.Button(panel, text='下载', command=download) button1.pack(side='left') button2 = tkinter.Button(panel, text='关于', command=show_about) button2.pack(side='right') panel.pack(side='bottom') tkinter.mainloop() if __name__ == '__main__': main() 例子2：使用多进程对复杂任务进行“分而治之”。 我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 from time import time def main(): total = 0 number_list = [x for x in range(1, 100000001)] start = time() for number in number_list: total += number print(total) end = time() print('Execution time: %.3fs' % (end - start)) if __name__ == '__main__': main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 from multiprocessing import Process, Queue from random import randint from time import time def task_handler(curr_list, result_queue): total = 0 for number in curr_list: total += number result_queue.put(total) def main(): processes = [] number_list = [x for x in range(1, 100000001)] result_queue = Queue() index = 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p = Process(target=task_handler, args=(number_list[index:index + 12500000], result_queue)) index += 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start = time() for p in processes: p.join() # 合并执行结果 total = 0 while not result_queue.empty(): total += result_queue.get() print(total) end = time() print('Execution time: ', (end - start), 's', sep='') if __name__ == '__main__': main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。 示例代码： 异步I/O操作 - asyncio模块 import asyncio import threading # import time @asyncio.coroutine def hello(): print('%s: hello, world!' % threading.current_thread()) # 休眠不会阻塞主线程因为使用了异步I/O操作 # 注意有yield from才会等待休眠操作执行完成 yield from asyncio.sleep(2) # asyncio.sleep(1) # time.sleep(1) print('%s: goodbye, world!' % threading.current_thread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] # 等待两个异步I/O操作执行结束 loop.run_until_complete(asyncio.wait(tasks)) print('game over!') loop.close() 异步I/O操作 - async和await import asyncio import threading # 通过async修饰的函数不再是普通函数而是一个协程 # 注意async和await将在Python 3.7中作为关键字出现 async def hello(): print('%s: hello, world!' % threading.current_thread()) await asyncio.sleep(2) print('%s: goodbye, world!' % threading.current_thread()) loop = asyncio.get_event_loop() tasks = [hello(), hello()] # 等待两个异步I/O操作执行结束 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 异步I/O操作 - asyncio模块 import asyncio async def wget(host): print('wget %s...' % host) connect = asyncio.open_connection(host, 80) # 异步方式等待连接结果 reader, writer = await connect header = 'GET / HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % host writer.write(header.encode('utf-8')) # 异步I/O方式执行写操作 await writer.drain() while True: # 异步I/O方式执行读操作 line = await reader.readline() if line == b'\\r\\n': break print('%s header > %s' % (host, line.decode('utf-8').rstrip())) writer.close() loop = asyncio.get_event_loop() # 通过生成式语法创建一个装了三个协程的列表 hosts_list = ['www.sina.com.cn', 'www.sohu.com', 'www.163.com'] tasks = [wget(host) for host in hosts_list] # 下面的方法将异步I/O操作放入EventLoop直到执行完毕 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 使用协程 - 模拟快递中心派发快递 from time import sleep from random import random def build_deliver_man(man_id): total = 0 while True: total += 1 print('%d号快递员准备接今天的第%d单.' % (man_id, total)) pkg = yield print('%d号快递员收到编号为%s的包裹.' % (man_id, pkg)) sleep(random() * 3) def package_center(deliver_man, max_per_day): num = 1 deliver_man.send(None) # next(deliver_man) while num 使用协程 - 查看协程的状态 from time import sleep from inspect import getgeneratorstate def build_deliver_man(man_id): total = 0 while True: total += 1 print('%d号快递员准备接今天的第%d单.' % (man_id, total)) pkg = yield print('%d号快递员收到编号为%s的包裹.' % (man_id, pkg)) sleep(0.5) def package_center(deliver_man, max_per_day): num = 1 # 创建状态(GEN_CREATED) - 等待开始执行 print(getgeneratorstate(deliver_man)) deliver_man.send(None) # 挂起状态(GEN_SUSPENDED) - 在yield表达式处暂停 print(getgeneratorstate(deliver_man)) # next(deliver_man) while num 使用Process类创建多个进程 # 通过下面程序的执行结果可以证实 父进程在创建子进程时复制了进程及其数据结构 # 每个进程都有自己独立的内存空间 所以进程之间共享数据只能通过IPC的方式 from multiprocessing import Process, Queue from time import sleep def sub_task(string, q): number = q.get() while number: print('%d: %s' % (number, string)) sleep(0.001) number = q.get() def main(): q = Queue(10) for number in range(1, 11): q.put(number) Process(target=sub_task, args=('Ping', q)).start() Process(target=sub_task, args=('Pong', q)).start() if __name__ == '__main__': main() 实现进程间的通信 import multiprocessing import os def sub_task(queue): print('子进程进程号:', os.getpid()) counter = 0 while counter 创建进程调用其他程序 import subprocess import sys def main(): # 通过sys.argv获取命令行参数 if len(sys.argv) > 1: # 第一个命令行参数是程序本身所以从第二个开始取 for index in range(1, len(sys.argv)): try: # 通过subprocess模块的call函数启动子进程 status = subprocess.call(sys.argv[index]) except FileNotFoundError: print('不能执行%s命令' % sys.argv[index]) else: print('请使用命令行参数指定要执行的进程') if __name__ == '__main__': main() 使用多线程的情况 - 模拟多个下载任务 from random import randint from time import time, sleep import atexit import _thread def download_task(filename): print('开始下载%s...' % filename) time_to_download = randint(5, 10) print('剩余时间%d秒.' % time_to_download) sleep(time_to_download) print('%s下载完成!' % filename) def shutdown_hook(start): end = time() print('总共耗费了%.3f秒.' % (end - start)) def main(): start = time() # 将多个下载任务放到多个线程中执行 thread1 = _thread.start_new_thread(download_task, ('Python从入门到住院.pdf',)) thread2 = _thread.start_new_thread(download_task, ('Peking Hot.avi',)) # 注册关机钩子在程序执行结束前计算执行时间 atexit.register(shutdown_hook, start) if __name__ == '__main__': main() # 执行这里的代码会引发致命错误(不要被这个词吓到) 因为主线程结束后下载线程再想执行就会出问题 # 需要说明一下 由于_thread模块属于比较底层的线程操作而且不支持守护线程的概念 # 在实际开发中会有诸多不便 因此我们推荐使用threading模块提供的高级操作进行多线程编程 "},"Python/Python语言基础/13-网络编程入门.html":{"url":"Python/Python语言基础/13-网络编程入门.html","title":"网络编程入门","keywords":"","body":"datetime:2019/5/14 17:35 author:nzb 网络编程入门 计算机网络基础 计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。 计算机网络发展史 1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。 1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。 1990s - 英国人蒂姆·伯纳斯-李发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。 在没有浏览器的年代，上网是这样的。 有了浏览器以后，上网是这样的。 TCP/IP模型 实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问 HTTP（超文本传输协议） HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式 JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： Alice Bob Will you marry me? JSON的例子： { 'from': 'Alice', 'to': 'Bob', 'content': 'Will you marry me?' } requests库 requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。 我们可以先通过pip安装requests及其依赖库。 pip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。 from time import time from threading import Thread import requests # 继承Thread类创建自定义的线程类 class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url = url def run(self): filename = self.url[self.url.rfind('/') + 1:] resp = requests.get(self.url) with open('/Users/Hao/' + filename, 'wb') as f: f.write(resp.content) def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp = requests.get( 'http://api.tianapi.com/meinv/?key=APIKey&num=10') # 将服务器返回的JSON格式的数据解析为字典 data_model = resp.json() for mm_dict in data_model['newslist']: url = mm_dict['picUrl'] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start() if __name__ == '__main__': main() 基于传输层协议的套接字编程 套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字 所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 from socket import socket, SOCK_STREAM, AF_INET from datetime import datetime def main(): # 1.创建套接字对象并指定使用哪种传输服务 # family=AF_INET - IPv4地址 # family=AF_INET6 - IPv6地址 # type=SOCK_STREAM - TCP套接字 # type=SOCK_DGRAM - UDP套接字 # type=SOCK_RAW - 原始套接字 server = socket(family=AF_INET, type=SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind(('192.168.1.2', 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print('服务器启动开始监听...') while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr = server.accept() print(str(addr) + '连接到了服务器.') # 5.发送数据 client.send(str(datetime.now()).encode('utf-8')) # 6.断开连接 client.close() if __name__ == '__main__': main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 from socket import socket def main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client = socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect(('192.168.1.2', 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode('utf-8')) client.close() if __name__ == '__main__': main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： from socket import socket, SOCK_STREAM, AF_INET from base64 import b64encode from json import dumps from threading import Thread def main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient = cclient def run(self): my_dict = {} my_dict['filename'] = 'guido.jpg' # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict['filedata'] = data # 通过dumps函数将字典处理成JSON字符串 json_str = dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode('utf-8')) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server = socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind(('192.168.1.2', 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print('服务器启动开始监听...') with open('guido.jpg', 'rb') as f: # 将二进制数据处理成base64再解码成字符串 data = b64encode(f.read()).decode('utf-8') while True: client, addr = server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start() if __name__ == '__main__': main() 客户端代码： from socket import socket from json import loads from base64 import b64decode def main(): client = socket() client.connect(('192.168.1.2', 5566)) # 定义一个保存二进制数据的对象 in_data = bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data = client.recv(1024) while data: # 将收到的数据拼接起来 in_data += data data = client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict = loads(in_data.decode('utf-8')) filename = my_dict['filename'] filedata = my_dict['filedata'].encode('utf-8') with open('/Users/Hao/' + filename, 'wb') as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print('图片已保存.') if __name__ == '__main__': main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明：上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字 传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 "},"Python/Python语言基础/14-网络应用开发.html":{"url":"Python/Python语言基础/14-网络应用开发.html","title":"网络应用开发","keywords":"","body":"datetime:2019/5/14 17:51 author:nzb 网络应用开发 发送电子邮件 在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText def main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!') if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart import urllib def main(): # 创建一个带附件的邮件消息对象 message = MIMEMultipart() # 创建文本内容 text_content = MIMEText('附件中有本月数据请查收', 'plain', 'utf-8') message['Subject'] = Header('本月数据', 'utf-8') # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/hello.txt', 'rb') as f: txt = MIMEText(f.read(), 'base64', 'utf-8') txt['Content-Type'] = 'text/plain' txt['Content-Disposition'] = 'attachment; filename=hello.txt' message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open('/Users/Hao/Desktop/汇总数据.xlsx', 'rb') as f: xls = MIMEText(f.read(), 'base64', 'utf-8') xls['Content-Type'] = 'application/vnd.ms-excel' xls['Content-Disposition'] = 'attachment; filename=month-data.xlsx' message.attach(xls) # 创建SMTP对象 smtper = SMTP('smtp.126.com') # 开启安全连接 # smtper.starttls() sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com'] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, 'secretpass') # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print('发送完成!') if __name__ == '__main__': main() 发送短信 发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 import urllib.parse import http.client import json def main(): host = \"106.ihuyi.com\" sms_send_uri = \"/webservice/sms.php?method=Submit\" # 下面的参数需要填入自己注册的账号和对应的密码 params = urllib.parse.urlencode({'account': '你自己的账号', 'password' : '你自己的密码', 'content': '您的验证码是：147258。请不要把验证码泄露给其他人。', 'mobile': '接收者的手机号', 'format':'json' }) print(params) headers = {'Content-type': 'application/x-www-form-urlencoded', 'Accept': 'text/plain'} conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request('POST', sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read() jsonstr = response_str.decode('utf-8') print(json.loads(jsonstr)) conn.close() if __name__ == '__main__': main() "},"Python/Python语言基础/15-图像和办公文档处理.html":{"url":"Python/Python语言基础/15-图像和办公文档处理.html","title":"图像和文档处理","keywords":"","body":"datetime:2019/5/14 17:55 author:nzb 图像和办公文档处理 用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。 操作图像 计算机图像相关知识 颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 | 名称 | RGBA值 | 名称 | RGBA值 | | :---: | :------------------: | :----: | :----------------: | | White | (255, 255, 255, 255) | Red | (255, 0, 0, 255) | | Green | (0, 255, 0, 255) | Blue | (0, 0, 255, 255) | | Gray | (128, 128, 128, 255) | Yellow | (255, 255, 0, 255) | | Black | (0, 0, 0, 255) | Purple | (128, 0, 128, 255) | 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 用Pillow操作图像 Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。 pip install pillow Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。 >>> from PIL import Image >>> >>> image = Image.open('./res/guido.jpg') >>> image.format, image.size, image.mode ('JPEG', (500, 750), 'RGB') >>> image.show() 剪裁图像 >>> image = Image.open('./res/guido.jpg') >>> rect = 80, 20, 310, 360 >>> image.crop(rect).show() 生成缩略图 >>> image = Image.open('./res/guido.jpg') >>> size = 128, 128 >>> image.thumbnail(size) >>> image.show() 缩放和黏贴图像 >>> image1 = Image.open('./res/luohao.png') >>> image2 = Image.open('./res/guido.jpg') >>> rect = 80, 20, 310, 360 >>> guido_head = image2.crop(rect) >>> width, height = guido_head.size >>> image1.paste(guido_head.resize((int(width / 1.5), int(height / 1.5))), (172, 40)) 旋转和翻转 >>> image = Image.open('./res/guido.png') >>> image.rotata(180).show() >>> image.transpose(Image.FLIP_LEFT_RIGHT).show() 操作像素 >>> image = Image.open('./res/guido.jpg') >>> for x in range(80, 310): ... for y in range(20, 360): ... image.putpixel((x, y), (128, 128, 128)) ... >>> image.show() 滤镜效果 >>> from PIL import Image, ImageFilter >>> >>> image = Image.open('./res/guido.jpg') >>> image.filter(ImageFilter.CONTOUR).show() 处理Excel电子表格 Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，当然实际工作中，我们可能会用LibreOffice Calc和OpenOffice Calc来处理Excel的电子表格文件，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。关于openpyxl的使用手册和使用文档可以查看它的官方文档。 处理Word文档 利用python-docx模块，Pytho 可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。 处理PDF文档 PDF是Portable Document Format的缩写，使用.pdf作为文件扩展名。接下来我们就研究一下如何通过Python实现从PDF读取文本内容和从已有的文档生成新的PDF文件。 "},"Python/Python语言基础/16-logging日志模块.html":{"url":"Python/Python语言基础/16-logging日志模块.html","title":"logging日志模块","keywords":"","body":"datetime:2021/11/14 17:55 author:nzb logging 模块 基于 logging 实现日志，每天的日志记录到一个文件中。 例如：开发一个网站，4CPU 开 4个 进程(或 8个) 假设： 启动网站，创建 4个 进程，每个进程中都打开文件 a1.log， 每个进程中都有 # 每个进程都有各自文件对象 file_object = open(\"a1.log\", 'a', encoding='utf-8') 用户访问 # 其中 1个 进程接收并加以处理，执行自己的 write file_object.write('日志...') 同时来 4个 # 其中 4个 进程接收并处理，执行自己的 write file_object.write('日志...') logging 模块实现机制(自动切割日志的功能) 启动网站，创建 4个 进程，每个进程中都打开文件 a1.log， 每个进程中都有 # 每个进程都有各自文件对象 file_object = open(\"a1.log\", 'a', encoding='utf-8') 用户访问 # 其中 1个 进程接收并加以处理，执行自己的 write file_object.write('日志...') 同时来 4个 # 其中 4个 进程接收并处理，执行自己的 write file_object.write('日志...') 问题1：多进程写日志会导致删除 例如 11-18日 默认都会记录到 a1.log 文件中 到了 11-19日 判断 a1-11-19.log 文件是否存在，如果存在，就删除(导致多进程会一直删除文件)(优化，文件不存在，可以重命名；文件存在，继续在 a1.log 中写入日志) a1.log -> a1-11-19.log # 到 11.19 后 a1.log 重命名为 a1-11-19.log 然后再写入 a1.log 源码找原因 ```python import time import os from logging.handlers import BaseRotatingHandler class TimedRotatingFileHandler(BaseRotatingHandler): \"\"\" Handler for logging to a file, rotating the log file at certain timed intervals. If backupCount is > 0, when rollover is done, no more than backupCount files are kept - the oldest ones are deleted. \"\"\" def doRollover(self): \"\"\" do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. \"\"\" if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) # # 新文件名，a1-11-19.log # dfn = self.rotation_filename(self.baseFilename + \".\" + # time.strftime(self.suffix, timeTuple)) # # 判断是否存在，存在删除，问题就出在这，多进程时会删除其他进程创建备份的 # if os.path.exists(dfn): # os.remove(dfn) # # 重命名 # self.rotate(self.baseFilename, dfn) # 修复 dfn = self.rotation_filename(self.baseFilename + \".\" + time.strftime(self.suffix, timeTuple)) # 判断是否存在，不存在重命名 if not os.path.exists(dfn): self.rotate(self.baseFilename, dfn) if self.backupCount > 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt 问题2：日志文件不能做相关操作(比如：删除或修改日志文件，日志就不创建文件继续打印了，需要重新执行该程序，才会重新创建文件写入日志) # 类比 WatchedFileHandler 提供解决思路 import os import time from stat import ST_INO, ST_DEV file_obj = open('xxx.log', 'a', encoding='utf-8') sres = os.fstat(file_obj.fileno()) dev, ino = sres[ST_DEV], sres[ST_INO] while True: # WatchedFileHandler 处理 handler 的处理机制 # 删除文件之后报错 try: # stat the file by path, checking for existence new_sres = os.stat(\"xxx.log\") except FileNotFoundError: sres = None if not new_sres or new_sres[ST_DEV] != dev or new_sres[ST_INO] != ino: print(\"文件被删除或修改了\") # 重新打开，获取标志数据 file_obj = open('xxx.log', 'a', encoding='utf-8') sres = os.fstat(file_obj.fileno()) dev, ino = sres[ST_DEV], sres[ST_INO] file_obj.write(\"111\\n\") file_obj.flush() time.sleep(1) 多进程和文件修改(删除)后 2 个结合重写 handler logging Handler 源码解析(TimedRotatingFileHandler为例) import os import time from _stat import ST_INO from logging.handlers import TimedRotatingFileHandler import logging from stat import ST_DEV LOGGING_CONFIG = { \"version\": 1, \"disable_existing_loggers\": True, \"formatters\": { \"standard\": { \"format\": '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s', \"style\": \"%\" } }, \"handlers\": { \"error_file\": { \"class\": \"logging.handlers.CustomizeHandler\", # 自定义处理类 \"formatter\": \"standard\", \"filename\": \"a1.log\", \"when\": \"S\", # 根据天拆分日志, \"interval\": 10, # 1天 \"backupCount\": 2, # 备份数 \"encoding\": \"utf-8\" } }, \"loggers\": { \"\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True }, \"error\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True } } } \"\"\" 继承从下往上 1、实例化 CustomizeHandler 对象 logging.Filterer.__init__() logging.Handler.__init__() logging.StreamHandler.__init__() logging.FileHandler.__init__() BaseRotatingHandler.__init__() TimedRotatingFileHandler.__init__() # 接受了很多关键字参数，这些都是配置字典里面 handlers 里面的值 CustomizeHandler.__init__() # 看2、3点，发现关键点在于 self.baseFilename # 日志文件的绝对路径 self.stream = stream # 打开的文件对象 # 看第 4 点，需要写日志时 handler对象.emit(\"日志内容\") 把检测文件标识的代码移植到 emit 里面 2、FileHandler.__init__() class FileHandler(StreamHandler): def __init__(self, filename, mode='a', encoding=None, delay=False, errors=None): filename = os.fspath(filename) #keep the absolute path, otherwise derived classes which use this #may come a cropper when the current directory changes # 日志文件的绝对路径 self.baseFilename = os.path.abspath(filename) self.mode = mode self.encoding = encoding self.errors = errors self.delay = delay if delay: #We don't open the stream, but we still need to call the #Handler constructor to set level, formatter, lock etc. Handler.__init__(self) self.stream = None else: # self._open() 是打开文件对象返回的句柄 StreamHandler.__init__(self, self._open()) def _open(self): return open(self.baseFilename, self.mode, encoding=self.encoding, errors=self.errors) 3、StreamHandler.__init__() class StreamHandler(Handler): terminator = '\\n' def __init__(self, stream=None): Handler.__init__(self) if stream is None: stream = sys.stderr self.stream = stream # 关键点，这里赋值了 self.stream = 文件句柄 4、开始写日志：handler对象.emit(\"日志内容\") class BaseRotatingHandler(logging.FileHandler): def emit(self, record): try: # 判断是否已经过了设置的时间(比如第二天)，就重命名 if self.shouldRollover(record): self.doRollover() # 执行父类的写日志 logging.FileHandler.emit(self, record) except Exception: self.handleError(record) class FileHandler(StreamHandler): def emit(self, record): # 如果文件句柄为空，重新打开文件赋值 self.stream if self.stream is None: self.stream = self._open() # 执行父类的写日志 StreamHandler.emit(self, record) class StreamHandler(Handler): def emit(self, record): try: msg = self.format(record) # 按你设置的 formatter 格式化日志 stream = self.stream stream.write(msg + self.terminator) # 文件写入日志 self.flush() except RecursionError: # See issue 36272 raise except Exception: self.handleError(record) \"\"\" class CustomizeHandler(TimedRotatingFileHandler): def __init__(self, *args, **kwargs): \"\"\" 借鉴 WatchedFileHandler 的机制检测文件 :param args: :param kwargs: \"\"\" super().__init__(*args, **kwargs) self.dev, self.ino = -1, -1 self._statstream() # WatchedFileHandler 方法 def _statstream(self): if self.stream: sres = os.fstat(self.stream.fileno()) self.dev, self.ino = sres[ST_DEV], sres[ST_INO] # WatchedFileHandler 方法 def reopenIfNeeded(self): \"\"\" Reopen log file if needed. Checks if the underlying file has changed, and if it has, close the old stream and reopen the file to get the current stream. \"\"\" # Reduce the chance of race conditions by stat'ing by path only # once and then fstat'ing our new fd if we opened a new log stream. # See issue #14632: Thanks to John Mulligan for the problem report # and patch. try: # stat the file by path, checking for existence sres = os.stat(self.baseFilename) except FileNotFoundError: sres = None # compare file system stat with that of our stream file handle if not sres or sres[ST_DEV] != self.dev or sres[ST_INO] != self.ino: if self.stream is not None: # we have an open file handle, clean it up self.stream.flush() self.stream.close() self.stream = None # See Issue #21742: _open () might fail. # open a new file handle and get new stat info from that fd self.stream = self._open() self._statstream() def doRollover(self): \"\"\" do a rollover; in this case, a date/time stamp is appended to the filename when the rollover happens. However, you want the file to be named for the start of the interval, not the current time. If there is a backup count, then we have to get a list of matching filenames, sort them and remove the one with the oldest suffix. \"\"\" if self.stream: self.stream.close() self.stream = None # get the time that this sequence started at and make it a TimeTuple currentTime = int(time.time()) dstNow = time.localtime(currentTime)[-1] t = self.rolloverAt - self.interval if self.utc: timeTuple = time.gmtime(t) else: timeTuple = time.localtime(t) dstThen = timeTuple[-1] if dstNow != dstThen: if dstNow: addend = 3600 else: addend = -3600 timeTuple = time.localtime(t + addend) dfn = self.rotation_filename(self.baseFilename + \".\" + time.strftime(self.suffix, timeTuple)) if not os.path.exists(dfn): # 修复多进程删除日志文件，只有不存在再重命名 self.rotate(self.baseFilename, dfn) if self.backupCount > 0: for s in self.getFilesToDelete(): os.remove(s) if not self.delay: self.stream = self._open() newRolloverAt = self.computeRollover(currentTime) while newRolloverAt 思考：上面重写的 handler 类，会不会出现问题？ 答案：会的，比如多进程，第二天的时候所有的进程卡在时间特别短的时候，一起重命名，就会出现问题 解决：为什么不每天得日志都写入一个当天的日志，而不是重命名 每天写入当天日志 \"\"\" 继承从下往上 1、实例化 CustomizeHandler 对象 logging.Filterer.__init__() logging.Handler.__init__() logging.StreamHandler.__init__() logging.FileHandler.__init__() WatchedFileHandler.__init__() # 检测文件是否修改，删除的处理类 CustomizeOneDayOneLogHandler.__init__() \"\"\" from logging.handlers import WatchedFileHandler LOGGING_CONFIG = { \"version\": 1, \"disable_existing_loggers\": True, \"formatters\": { \"standard\": { \"format\": '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s', \"style\": \"%\" } }, \"handlers\": { \"error_file\": { \"class\": \"logging.handlers.TimedRotatingFileHandler\", \"formatter\": \"standard\", \"filepath\": \"logs\", \"encoding\": \"utf-8\" } }, \"loggers\": { \"\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True }, \"error\": { \"handlers\": [\"error_file\"], \"level\": \"ERROR\", \"propagate\": True } } } class CustomizeOneDayOneLogHandler(WatchedFileHandler): \"\"\" 每天创建一个日志，每天的日志都打入当天的日志文件 文件名：a-2021-10-20.log, 不会出现 a-2021-10-20.log.2021-10-21 这样的 \"\"\" def __init__(self, file_path, file_name_prefix, mode='a', encoding=None, delay=False, errors=None): \"\"\" :param file_path: 日志文件路径 :param file_name_prefix: 日志文件前缀，就是 logging.getLogger(__name__) 获取，只是重下了 log 类继承 Logger，详细看下面 :param mode: :param encoding: :param delay: :param errors: \"\"\" if not os.path.exists(file_path): os.makedirs(file_path) self.file_path = file_path self.file_name_prefix = file_name_prefix self.file_name = self.get_file_name() filename = os.path.join(file_path, self.file_name) # errors py3.9 有这个参数，3.8、3.7没有(更早版本也可能是) # super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay, errors=errors) super(CustomizeOneDayOneLogHandler, self).__init__(filename=filename, mode=mode, encoding=encoding, delay=delay) def get_file_name(self): \"\"\" TODO 怎么切分可以这里实现，做成那个时间切分的参数配置 :return: 日志名称 \"\"\" # 一天分一次 return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime(\"%Y-%m-%d\")) # 一分钟分一次 # return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime('%Y-%m-%d-%H-%M')) def emit(self, record): \"\"\" Emit a record. If underlying file has changed, reopen the file before emitting the record to it. \"\"\" current_file_name = self.get_file_name() # 文件不一致，新建文件 + 重新打开 + 重新获取 os.stat if current_file_name != self.file_name: self.file_name = current_file_name # 重新赋值，当前的文件名应该是最新的日期 self.baseFilename = os.path.abspath(os.path.join(self.file_path, current_file_name)) if self.stream: self.stream.flush() self.stream.close() self.stream = self._open() self._statstream() super(CustomizeOneDayOneLogHandler, self).emit(record) 项目中使用 #!/usr/bin/env python # -*- coding:utf8 -*- __date__ = \"2021/10/20 11:20\" __doc__ = \"\"\"\"\"\" # 定义三种日志输出格式 开始 import datetime import glob import os import sys import time import traceback from logging import Logger from logging.handlers import WatchedFileHandler import logging.config standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' '[%(levelname)s][%(message)s]' # 其中 name 为 getlogger 指定的名字 simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s' # 第一种：每天一个日志文件 class CustomizeOneDayOneLogHandler(WatchedFileHandler): \"\"\" 每天创建一个日志，每天的日志都打入当天的日志文件 文件名：a-2021-10-20.log, 不会出现 a-2021-10-20.log.2021-10-21 这样的 \"\"\" def __init__(self, file_path, file_name_prefix, backup_count: int = 5, mode='a', encoding=None, delay=False, errors=None): \"\"\" :param file_path: 日志文件路径 :param file_name_prefix: 日志文件前缀 :param backup_count: 日志备份数量 :param mode: :param encoding: :param delay: :param errors: \"\"\" if not os.path.exists(file_path): os.makedirs(file_path) self.file_path = file_path self.file_name_prefix = file_name_prefix self.backup_count = backup_count self.file_name = self.get_file_name() filename = os.path.join(file_path, self.file_name) # errors py3.9 有这个参数，3.8、3.7没有(更早版本也可能是) # super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay, errors=errors) super().__init__(filename=filename, mode=mode, encoding=encoding, delay=delay) # 初始化的时候清理下，防止创建了文件不写入，导致空日志文件过多 self.auto_clear() def get_file_name(self) -> str: \"\"\" TODO 怎么切分可以这里实现，做成那个时间切分的参数配置 :return: 日志名称 \"\"\" # 一天分一次 return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime(\"%F\")) # 一分钟分一次 # return \"{}-{}.log\".format(self.file_name_prefix, datetime.datetime.now().strftime('%F-%H-%M')) def emit(self, record): \"\"\" Emit a record. If underlying file has changed, reopen the file before emitting the record to it. \"\"\" current_file_name = self.get_file_name() if current_file_name != self.file_name: self.file_name = current_file_name self.baseFilename = os.path.abspath(os.path.join(self.file_path, current_file_name)) if self.stream: self.stream.flush() self.stream.close() self.stream = self._open() self._statstream() self.auto_clear() super().emit(record) def auto_clear(self): \"\"\" 自动清理 log 文件 :return: \"\"\" file_list = sorted(glob.glob(os.path.join(self.file_path, self.file_name_prefix + '*')), key=lambda x: time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(os.path.getctime(x))), reverse=True) for file_ in file_list[self.backup_count:]: os.remove(file_) class MyLog(Logger): def error(self, msg, exc_info=True, extra=None, *args): \"\"\" 重写父类方法,exc_info默认为True \"\"\" if self.isEnabledFor(level=40): # 父类抄来,使用默认值 self._log(40, msg, args, exc_info=True, extra=None) def info(self, msg, *args, **kwargs): \"\"\" 防止在 exception里写 log.info(error) 抓取一切报错堆栈 Log 'msg % args' with severity 'INFO'. To pass exception information, use the keyword argument exc_info with a true value, e.g. logger.info(\"Houston, we have a %s\", \"interesting problem\", exc_info=1) \"\"\" error_msg = traceback.format_exc() # Windows 和 Linux 不一样？ # if not error_msg == 'None\\n': if not error_msg == 'NoneType: None\\n': error_msg = str(msg) + error_msg self._log(20, error_msg, args, **kwargs) if self.isEnabledFor(20): # 父类抄来,使用默认值 self._log(20, msg, args, **kwargs) class LogUtil(object): def __init__(self, file_name_prefix, backup_count: int = 5, console_out: bool = False): \"\"\" :param file_name_prefix: 日志名称前缀 :param backup_count: 备份数量 :param console_out: 是否在控制台输出 \"\"\" self.file_name_prefix = file_name_prefix if sys.platform.startswith(\"linux\"): self.base_dir = '/app/logs' else: self.base_dir = './logs' # 本地调试 formatter = logging.Formatter('[%(levelname)s] [%(asctime)s] [%(filename)s-line:%(lineno)d] %(message)s') # 按天存放 同类型log最多保留5个 self.log_file_handler = CustomizeOneDayOneLogHandler(self.base_dir, self.file_name_prefix, backup_count=backup_count, encoding='utf-8') self.log_file_handler.setFormatter(formatter) self.logger = MyLog(name=self.log_file_handler.file_name) self.logger.setLevel(logging.DEBUG) self.logger.addHandler(self.log_file_handler) # 输出到文件 if console_out: # 往屏幕上输出 console_handler = logging.StreamHandler() console_handler.setFormatter(formatter) # 设置屏幕上显示的格式 self.logger.addHandler(console_handler) # 输出到控制台 log_test1 = LogUtil(\"test1\", console_out=True).logger log_test2 = LogUtil(\"test2\", console_out=True).logger if __name__ == '__main__': while True: time.sleep(5) log_test1.info(\"aaaaaaaaaaa\") # time.sleep(0.1) # log_test2.info(\"bbbbbbbbbbb\") # try: # a = 1/ 0 # except Exception as e: # # log_test1.error(\"error\") # log_test1.info(\"info\") "},"Python/Python语言进阶/01-常用数据结构和算法.html":{"url":"Python/Python语言进阶/01-常用数据结构和算法.html","title":"常用数据结构","keywords":"","body":"datetime:2019/5/15 17:46 author:nzb 数据结构和算法 十大经典算法 算法：解决问题的方法和步骤 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。 渐近时间复杂度的大O标记： - 常量时间复杂度 - 布隆过滤器 / 哈希存储 - 对数时间复杂度 - 折半查找（二分查找） - 线性时间复杂度 - 顺序查找 / 桶排序 - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序） - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序） - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算 - 几何级数时间复杂度 - 汉诺塔 - 阶乘时间复杂度 - 旅行经销商问题 - NP 排序算法（选择、冒泡和归并）和查找算法（顺序和折半） def select_sort(origin_items, comp=lambda x, y: x # 第一种 def bubble_sort(origin_items, comp=lambda x, y: x > y): \"\"\"高质量冒泡排序(搅拌排序)\"\"\" items = origin_items[:] for i in range(len(items) - 1): swapped = False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] = items[j + 1], items[j] swapped = True if swapped: swapped = False for j in range(len(items) - 2 - i, i, -1): if comp(items[j - 1], items[j]): items[j], items[j - 1] = items[j - 1], items[j] swapped = True if not swapped: break return items # 第二种 def bubble_sort(origin_items, comp=lambda x, y: x > y): \"\"\"高质量冒泡排序(搅拌排序)\"\"\" items = origin_items[:] for i in range(1, len(items)): # 循环次数 for j in range(0, len(items) - i): # 循环索引 if comp(items[j], items[j + 1]): items[j], items[j+1] = items[j+1], items[j] return items ```Python 第一种 def merge_sort(items, comp=lambda x, y: x \"\"\"归并排序(分治法)\"\"\" if len(items) def merge(items1, items2, comp): \"\"\"合并(将两个有序的列表合并成一个有序的列表)\"\"\" items = [] index, index2 = 0, 0 while index1 tmp] return self.quick_sort(less) + [tmp] + self.quick_sort(more) ``` ```Python def seq_search(items, key): \"\"\"顺序查找\"\"\" for index, item in enumerate(items): if item == key: return index return -1 ``` ```Python def bin_search(items, key): \"\"\"折半查找\"\"\" start, end = 0, len(items) - 1 while start items[mid]: start = mid + 1 elif key 使用生成式（推导式）语法 prices = { 'AAPL': 191.88, 'GOOG': 1186.96, 'IBM': 149.24, 'ORCL': 48.44, 'ACN': 166.89, 'FB': 208.09, 'SYMC': 21.29 } # 用股票价格大于100元的股票构造一个新的字典 prices2 = {key: value for key, value in prices.items() if value > 100} print(prices2) 说明：生成式（推导式）可以用来生成列表、集合和字典。 嵌套的列表 names = ['关羽', '张飞', '赵云', '马超', '黄忠'] courses = ['语文', '数学', '英语'] # 录入五个学生三门课程的成绩 # 错误 - 参考http://pythontutor.com/visualize.html#mode=edit # scores = [[None] * len(courses)] * len(names) scores = [[None] * len(courses) for _ in range(len(names))] for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] = float(input(f'请输入{name}的{course}成绩: ')) print(scores) Python Tutor - VISUALIZE CODE AND GET LIVE HELP heapq、itertools等的用法 \"\"\" 从列表中找出最大的或最小的N个元素 堆结构(大根堆/小根堆) \"\"\" import heapq list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92] list2 = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] print(heapq.nlargest(3, list1)) print(heapq.nsmallest(3, list1)) print(heapq.nlargest(2, list2, key=lambda x: x['price'])) print(heapq.nlargest(2, list2, key=lambda x: x['shares'])) \"\"\" 迭代工具 - 排列 / 组合 / 笛卡尔积 \"\"\" import itertools itertools.permutations('ABCD') itertools.combinations('ABCDE', 3) itertools.product('ABCD', '123') collections模块下的工具类 \"\"\" 找出序列中出现次数最多的元素 \"\"\" from collections import Counter words = [ 'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes', 'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the', 'eyes', \"don't\", 'look', 'around', 'the', 'eyes', 'look', 'into', 'my', 'eyes', \"you're\", 'under' ] counter = Counter(words) print(counter.most_common(3)) 常用算法： 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。 穷举法例子：百钱百鸡和五人分鱼。 # 公鸡5元一只 母鸡3元一只 小鸡1元三只 # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只 for x in range(20): for y in range(33): z = 100 - x - y if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0: print(x, y, z) # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉 # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份 # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份 # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼 fish = 1 while True: total = fish enough = True for _ in range(5): if (total - 1) % 5 == 0: total = (total - 1) // 5 * 4 else: enough = False break if enough: print(fish) break fish += 1 贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。 | 名称 | 价格（美元） | 重量（kg） | | :----: | :----------: | :--------: | | 电脑 | 200 | 20 | | 收音机 | 20 | 4 | | 钟 | 175 | 10 | | 花瓶 | 50 | 2 | | 书 | 10 | 1 | | 油画 | 90 | 9 | ```Python \"\"\" 贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 输入： 20 6 电脑 200 20 收音机 20 4 钟 175 10 花瓶 50 2 书 10 1 油画 90 9 \"\"\" class Thing(object): \"\"\"物品\"\"\" def __init__(self, name, price, weight): self.name = name self.price = price self.weight = weight @property def value(self): \"\"\"价格重量比\"\"\" return self.price / self.weight def input_thing(): \"\"\"输入物品信息\"\"\" name_str, price_str, weight_str = input().split() return name_str, int(price_str), int(weight_str) def main(): \"\"\"主函数\"\"\" max_weight, num_of_things = map(int, input().split()) all_things = [] for _ in range(num_of_things): all_things.append(Thing(*input_thing())) all_things.sort(key=lambda x: x.value, reverse=True) total_weight = 0 total_price = 0 for thing in all_things: if total_weight + thing.weight = 0 and row = 0 and col 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如： > > 输入：1 -2 3 5 -3 2 > > 输出：8 > > 输入：0 -2 3 5 -1 2 > > 输出：9 > > 输入：-9 -2 -3 -5 -3 > > 输出：-2 ```Python def main(): items = list(map(int, input().split())) size = len(items) overall, partial = {}, {} overall[size - 1] = partial[size - 1] = items[size - 1] for i in range(size - 2, -1, -1): partial[i] = max(items[i], partial[i + 1] + items[i]) overall[i] = max(partial[i], overall[i + 1]) print(overall[0]) if __name__ == '__main__': main() ``` "},"Python/Python语言进阶/02-函数的高级用法.html":{"url":"Python/Python语言进阶/02-函数的高级用法.html","title":"函数的高级用法","keywords":"","body":"datetime:2019/5/16 13:23 author:nzb 函数的使用方式 将函数视为“一等公民” 函数可以赋值给变量 函数可以作为函数的参数 函数可以作为函数的返回值 高阶函数的用法（filter、map以及它们的替代品） items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10)))) items2 = [x ** 2 for x in range(1, 10) if x % 2] 位置参数、可变参数、关键字参数、命名关键字参数 参数的元信息（代码可读性问题） 匿名函数和内联函数的用法（lambda函数） 闭包和作用域问题 闭包 函数内的属性，都是有生命周期，都是在函数执行期间 内部函数对外部函数作用域里变量的引用 闭包内的闭包函数私有化了变量，完成了数据的封装，类似面向对象 作用域 Python搜索变量的LEGB顺序（Local --> Embedded --> Global --> Built-in） global和nonlocal关键字的作用 global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。 nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。 装饰器函数（使用装饰器和取消装饰器）语法糖 @ 最简单的例子： def func1(func): # 外部闭包函数的参数是被装饰的函数对象 def func2(): print('aaabbb') return func() # 返回了外部函数接收的被装饰函数的调用 return func2 # return func # 返回了函数对象 # return func() # 返回的是一个函数调用 # func1(myfunc)() # 接收别装饰的函数作为参数，而且还要继续调用一次 # func2() -> print('aaabbb') -> return myfunc() @func1 def myfunc(): print('你好') # 不影响原有函数的功能，还能添加新的功能 myfunc() # func1(myfunc)() 装饰器函数带参数（与下面一样）多一层包装来接收装饰器的参数 def arg_func(sex): def func1(b_func): def func2(): if sex == 'man': print('你是男士') if sex == 'woman': print('你是女士') return b_func() return func2 return func1 @arg_func(sex='man') def man(): print('好好上班') @arg_func(sex='woman') def woman(): print('好好上班') man() woman() 例子：输出函数执行时间的装饰器。 def record_time(func): \"\"\"自定义装饰函数的装饰器\"\"\" @wraps(func) def wrapper(*args, **kwargs): # 被装饰的函数带参数（最常见） start = time() result = func(*args, **kwargs) # 被装饰的函数带参数（最常见） print(f'{func.__name__}: {time() - start}秒') return result return wrapper 如果装饰器不希望跟print函数耦合，可以编写带参数的装饰器。 ```Python from functools import wraps from time import time def record(output): \"\"\"自定义带参数的装饰器\"\"\" def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decorate ``` ```Python from functools import wraps from time import time class Record(): \"\"\"自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用)\"\"\" def __init__(self, output): self.output = output def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time() result = func(*args, **kwargs) self.output(func.__name__, time() - start) return result return wrapper ``` > 说明：由于对带装饰功能的函数添加了@wraps装饰器，可以通过`func.__wrapped__`方式获得被装饰之前的函数或类来取消装饰器的作用。 例子：用装饰器来实现单例模式。 ```Python from functools import wraps def singleton(cls): \"\"\"装饰类的装饰器\"\"\" instances = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President(): \"\"\"总统(单例类)\"\"\" pass ``` > 说明：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？ ```Python from functools import wraps def singleton(cls): \"\"\"线程安全的单例装饰器\"\"\" instances = {} locker = Lock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with locker: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] return wrapper ``` "},"Python/Python语言进阶/03-面向对象高级知识.html":{"url":"Python/Python语言进阶/03-面向对象高级知识.html","title":"面向对象高级知识","keywords":"","body":"datetime:2019/5/16 15:26 author:nzb 面向对象相关知识 三大支柱：封装、继承、多态 例子：工资结算系统。 \"\"\" 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成 \"\"\" from abc import ABCMeta, abstractmethod class Employee(metaclass=ABCMeta): \"\"\"员工(抽象类)\"\"\" def __init__(self, name): self.name = name @abstractmethod def get_salary(self): \"\"\"结算月薪(抽象方法)\"\"\" pass class Manager(Employee): \"\"\"部门经理\"\"\" def get_salary(self): return 15000.0 class Programmer(Employee): \"\"\"程序员\"\"\" def __init__(self, name, working_hour=0): self.working_hour = working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hour class Salesman(Employee): \"\"\"销售员\"\"\" def __init__(self, name, sales=0.0): self.sales = sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05 class EmployeeFactory(): \"\"\"创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）\"\"\" @staticmethod def create(emp_type, *args, **kwargs): \"\"\"创建员工\"\"\" emp_type = emp_type.upper() emp = None if emp_type == 'M': emp = Manager(*args, **kwargs) elif emp_type == 'P': emp = Programmer(*args, **kwargs) elif emp_type == 'S': emp = Salesman(*args, **kwargs) return emp def main(): \"\"\"主函数\"\"\" emps = [ EmployeeFactory.create('M', '曹操'), EmployeeFactory.create('P', '荀彧', 120), EmployeeFactory.create('P', '郭嘉', 85), EmployeeFactory.create('S', '典韦', 123000), ] for emp in emps: print('%s: %.2f元' % (emp.name, emp.get_salary())) if __name__ == '__main__': main() 类与类之间的关系 is-a关系：继承 has-a关系：关联 / 聚合 / 合成 use-a关系：依赖 例子：扑克游戏。 \"\"\" 经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择 \"\"\" from enum import Enum, unique import random @unique class Suite(Enum): \"\"\"花色\"\"\" SPADE, HEART, CLUB, DIAMOND = range(4) def __lt__(self, other): return self.value 对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆） 垃圾回收和循环引用以及弱引用 Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。 typedef struct_object { /* 引用计数 */ int ob_refcnt; /* 对象指针 */ struct_typeobject *ob_type; } PyObject; /* 增加引用计数的宏定义 */ #define Py_INCREF(op) ((op)->ob_refcnt++) /* 减少引用计数的宏定义 */ #define Py_DECREF(op) \\ //减少计数 if (--(op)->ob_refcnt != 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 导致引用计数+1的情况： 对象被创建，例如a = 23 对象被引用，例如b = a 对象被作为参数，传入到一个函数中，例如f(a) 对象作为一个元素，存储在容器中，例如list1 = [a, a] 导致引用计数-1的情况： 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a = 24 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象 引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。 # 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收 # 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效 # 如果不想造成循环引用可以使用弱引用 list1 = [] list2 = [] list1.append(list2) list2.append(list1) 以下情况会导致垃圾回收： 调用gc.collect() gc模块的计数器达到阀值 程序退出 如果循环引用中两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，这个问题在Python 3.6中得到了解决。 也可以通过weakref模块构造弱引用的方式来解决循环引用的问题。 Python的内存管理机制及调优手段？ 内存管理机制: 引用计数、垃圾回收、内存池 引用计数：引用计数是一种非常高效的内存管理手段，当一个Python对象被引用时其引用计数增加1, def DisplayItems(self): print \"show all items---\" for item in self.__list: print item if hasattr(Parent, 'x'): print(getattr(Parent, 'x')) setattr(Parent, 'x',3) print(getattr(Parent,'x')) 当其不再被一个变量引用时则计数减1,当引用计数等于0时对象被删除。弱引用不会增加引用计数 垃圾回收：Python的垃圾回收机制采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。 1.引用计数 引用计数也是一种垃圾收集机制，而且也是一种最直观、最简单的垃圾收集技术。当Python的某个对象 的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建 对象，它被分配给某个引用，对象的引用计数变为1，如果引用被删除，对象的引用计数为0,那么该对 象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了。 2.标记清除 3.分代回收 内存池 当创建大量消耗小内存的对象时，频繁调用 new/malloc 会导致大量的内存碎片，致使效率降低。内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。 调优手段 1.手动垃圾回收 2.调高垃圾回收阈值 3.避免循环引用 内存泄露是什么？如何避免？ 内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消 失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控 制，从而造成了内存的浪费。 有 del() 函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来 删除一个对象的引用计数就可以有效防止内存泄露问题。 通过Python扩展模块gc 来查看不能回收的对象的详细信息。 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露 魔法属性和方法（请参考《Python魔法方法指南》） 有几个小问题请大家思考： 自定义的对象能不能使用运算符做运算？ 自定义的对象能不能放到set中？能去重吗？ 自定义的对象能不能作为dict的键？ 自定义的对象能不能使用上下文语法？ 混入（Mixin） 例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。 class SetOnceMappingMixin(): \"\"\"自定义混入类\"\"\" __slots__ = () def __setitem__(self, key, value): if key in self: raise KeyError(str(key) + ' already set') return super().__setitem__(key, value) class SetOnceDict(SetOnceMappingMixin, dict): \"\"\"自定义字典\"\"\" pass my_dict= SetOnceDict() try: my_dict['username'] = 'jackfrued' my_dict['username'] = 'hellokitty' except KeyError: pass print(my_dict) 元编程和元类 例子：用元类实现单例模式。 import threading class SingletonMeta(type): \"\"\"自定义元类\"\"\" def __init__(cls, *args, **kwargs): cls.__instance = None cls.__lock = threading.Lock() super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: with cls.__lock: if cls.__instance is None: cls.__instance = super().__call__(*args, **kwargs) return cls.__instance class President(metaclass=SingletonMeta): \"\"\"总统(单例类)\"\"\" pass 面向对象设计原则 单一职责原则 （SRP）- 一个类只做该做的事情（类的设计要高内聚） 开闭原则 （OCP）- 软件实体应该对扩展开发对修改关闭 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化） 里氏替换原则（LSP） - 任何时候可以用子类对象替换掉父类对象 接口隔离原则（ISP）- 接口要小而专不要大而全（Python中没有接口的概念） 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码 最少知识原则（迪米特法则，LoD）- 不要给没有必然联系的对象发消息 说明：上面加粗的字母放在一起称为面向对象的SOLID原则。 GoF设计模式 创建型模式：单例、工厂、建造者、原型 结构型模式：适配器、门面（外观）、代理 行为型模式：迭代器、观察者、状态、策略 例子：可插拔的哈希算法。 ```Python class StreamHasher(): \"\"\"哈希摘要生成器(策略模式)\"\"\" def init(self, alg='md5', size=4096): self.size = size alg = alg.lower() self.hasher = getattr(__import__('hashlib'), alg.lower())() def call(self, stream): return self.to_digest(stream) def to_digest(self, stream): \"\"\"生成十六进制形式的摘要\"\"\" for buf in iter(lambda: stream.read(self.size), b''): self.hasher.update(buf) return self.hasher.hexdigest() def main(): \"\"\"主函数\"\"\" hasher1 = StreamHasher() with open('Python-3.7.1.tgz', 'rb') as stream: print(hasher1.to_digest(stream)) hasher2 = StreamHasher('sha1') with open('Python-3.7.1.tgz', 'rb') as stream: print(hasher2(stream)) if name == 'main': main() ``` "},"Python/Python语言进阶/04-迭代器和生成器.html":{"url":"Python/Python语言进阶/04-迭代器和生成器.html","title":"迭代器和生成器","keywords":"","body":"datetime:2019/5/16 15:32 author:nzb 迭代器和生成器 和迭代器相关的魔术方法（__iter__和__next__） 两种创建生成器的方式（生成器表达式和yield关键字） ```Python def fib(num): \"\"\"生成器\"\"\" a, b = 0, 1 for _ in range(num): a, b = b, a + b yield a class Fib(object): \"\"\"迭代器\"\"\" def __init__(self, num): self.num = num self.a, self.b = 0, 1 self.idx = 0 def __iter__(self): return self def __next__(self): if self.idx 生成器，迭代器的区别？ 迭代器：遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple,dictionary, set 等）。 另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用成员函数 next()（Python 2） 或函数 next() function （Python 3） 。当没有元素时，则引发 StopIteration 此例外。若要实现自己的迭代器， 则只要实现 next()（Python 2）或 next ()（Python 3） 生成器（Generator）：只是在需要返回数据的时候使用yield语句。每次 next() 被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值） 区别： 生成器能做到迭代器能做的所有事，而且因为自动创建 iter() 和 next() 方法，生成器显得特别简洁，而且生成器也是高效的， 使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。 列表推导式、字典推导式以及生成器 import random l = [i for i in range(10)] d = {k:random.randint(4,9) for k in ['a', 'c', 'd']} g = (i for i in range(10)) print(\"列表推导式：{}，类型：{}\".format(l, type(l))) print(\"字典推导式：{}，类型：{}\".format(d, type(d))) print(\"生成器：{}，类型：{}\".format(g, type(g))) # 结果 # 列表推导式：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]，类型： # 字典推导式：{'a': 5, 'c': 6, 'd': 9}，类型： # 生成器： at 0x0000023498EF9390>，类型： "},"Python/Python语言进阶/05-并发和异步编程.html":{"url":"Python/Python语言进阶/05-并发和异步编程.html","title":"并发和异步编程","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 并发编程 Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。 ```Python 面试题：进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程 线程 - 操作系统分配CPU的基本单位 并发编程（concurrent programming） 1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行 2. 改善用户体验 - 让耗时间的操作不会造成程序的假死 import glob import os import threading from PIL import Image PREFIX = 'thumbnails' def generate_thumbnail(infile, size, format='PNG'): \"\"\"生成指定图片文件的缩略图\"\"\" file, ext = os.path.splitext(infile) file = file[file.rfind('/') + 1:] outfile = f'{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}' img = Image.open(infile) img.thumbnail(size, Image.ANTIALIAS) img.save(outfile, format) def main(): \"\"\"主函数\"\"\" if not os.path.exists(PREFIX): os.mkdir(PREFIX) for infile in glob.glob('images/*.png'): for size in (32, 64, 128): # 创建并启动线程 threading.Thread( target=generate_thumbnail, args=(infile, (size, size)) ).start() if __name__ == '__main__': main() ``` 多个线程竞争资源的情况 ```Python # 多线程程序如果没有竞争资源处理起来通常也比较简单 # 当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱 # 说明：临界资源就是被多个线程竞争的资源 import time import threading from concurrent.futures import ThreadPoolExecutor class Account(object): \"\"\"银行账户\"\"\" def __init__(self): self.balance = 0.0 self.lock = threading.Lock() def deposit(self, money): # 通过锁保护临界资源 with self.lock: new_balance = self.balance + money time.sleep(0.001) self.balance = new_balance class AddMoneyThread(threading.Thread): \"\"\"自定义线程类\"\"\" def __init__(self, account, money): self.account = account self.money = money # 自定义线程的初始化方法中必须调用父类的初始化方法 super().__init__() def run(self): # 线程启动之后要执行的操作 self.account.deposit(self.money) def main(): \"\"\"主函数\"\"\" account = Account() # 创建线程池 pool = ThreadPoolExecutor(max_workers=10) futures = [] for _ in range(100): # 创建线程的第1种方式 # threading.Thread( # target=account.deposit, args=(1, ) # ).start() # 创建线程的第2种方式 # AddMoneyThread(account, 1).start() # 创建线程的第3种方式 # 调用线程池中的线程来执行特定的任务 future = pool.submit(account.deposit, 1) futures.append(future) # 关闭线程池 pool.shutdown() for future in futures: future.result() print(account.balance) if __name__ == '__main__': main() ``` 修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用`threading`模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示： ```Python # 多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock） # 多个线程竞争多个资源（线程数>资源数） - 信号量（Semaphore） # 多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition from concurrent.futures import ThreadPoolExecutor from random import randint from time import sleep import threading class Account(): \"\"\"银行账户\"\"\" def __init__(self, balance=0): self.balance = balance lock = threading.Lock() self.condition = threading.Condition(lock) def withdraw(self, money): \"\"\"取钱\"\"\" with self.condition: while money > self.balance: self.condition.wait() new_balance = self.balance - money sleep(0.001) self.balance = new_balance def deposit(self, money): \"\"\"存钱\"\"\" with self.condition: new_balance = self.balance + money sleep(0.001) self.balance = new_balance self.condition.notify_all() def add_money(account): while True: money = randint(5, 10) account.deposit(money) print(threading.current_thread().name, ':', money, '====>', account.balance) sleep(0.5) def sub_money(account): while True: money = randint(10, 30) account.withdraw(money) print(threading.current_thread().name, ':', money, ' 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。 ```Python 多进程和进程池的使用 多线程因为GIL的存在不能够发挥CPU的多核特性 对于计算密集型任务应该考虑使用多进程 time python3 example22.py real 0m11.512s user 0m39.319s sys 0m0.169s 使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍 这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU import concurrent.futures import math PRIMES = [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419 ] * 5 def is_prime(n): \"\"\"判断素数\"\"\" if n % 2 == 0: return False sqrt_n = int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i == 0: return False return True def main(): \"\"\"主函数\"\"\" with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print('%d is prime: %s' % (number, prime)) if __name__ == '__main__': main() ``` > 说明：**多线程和多进程的比较**。 > > 以下情况需要使用多线程： > > 1. 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 > 2. 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。 > > 以下情况需要使用多进程： > > 1. 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 > 2. 程序的输入可以并行的分成块，并且可以将运算结果合并。 > 3. 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者future对象来获取任务执行的结果。Python 3通过asyncio模块和await和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。 ```Python 异步I/O - async / await import asyncio def num_generator(m, n): \"\"\"指定范围的数字生成器\"\"\" yield from range(m, n + 1) async def prime_filter(m, n): \"\"\"素数过滤器\"\"\" primes = [] for i in num_generator(m, n): flag = True for j in range(2, int(i ** 0.5 + 1)): if i % j == 0: flag = False break if flag: print('Prime =>', i) primes.append(i) await asyncio.sleep(0.001) return tuple(primes) async def square_mapper(m, n): \"\"\"平方映射器\"\"\" squares = [] for i in num_generator(m, n): print('Square =>', i * i) squares.append(i * i) await asyncio.sleep(0.001) return squares def main(): \"\"\"主函数\"\"\" loop = asyncio.get_event_loop() future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100)) future.add_done_callback(lambda x: print(x.result())) loop.run_until_complete(future) loop.close() if __name__ == '__main__': main() ``` > 说明：上面的代码使用`get_event_loop`函数获得系统默认的事件循环，通过`gather`函数可以获得一个`future`对象，`future`对象的`add_done_callback`可以添加执行完成时的回调函数，`loop`对象的`run_until_complete`方法可以等待通过`future`对象获得协程执行结果。 Python中有一个名为`aiohttp`的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟`asyncio`模块一起工作，并提供了对`Future`对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。 ```Python import asyncio import re import aiohttp PATTERN = re.compile(r'\\(?P.*)\\') async def fetch_page(session, url): async with session.get(url, ssl=False) as resp: return await resp.text() async def show_title(url): async with aiohttp.ClientSession() as session: html = await fetch_page(session, url) print(PATTERN.search(html).group('title')) def main(): urls = ('https://www.python.org/', 'https://git-scm.com/', 'https://www.jd.com/', 'https://www.taobao.com/', 'https://www.douban.com/') loop = asyncio.get_event_loop() tasks = [show_title(url) for url in urls] loop.run_until_complete(asyncio.wait(tasks)) loop.close() if __name__ == '__main__': main() ``` > 说明：**异步I/O与多进程的比较**。 > > 当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。 Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。 要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。 "},"Python/Python语言进阶/06-asyncio异步编程.html":{"url":"Python/Python语言进阶/06-asyncio异步编程.html","title":"asynico异步编程","keywords":"","body":"datetime:2021/11/12 11:00 author:nzb asyncio 异步编程 如今编程都往异步发展，尽可能高效利用系统资源，比如：FastAPI、Tornado、Sanic、Django 3、aiohttp 等。所以，咱怎么能落后呢！！！ 1 协程 想学 asyncio，得先了解协程，协程是根本呀！ 协程（Coroutine），也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行。例如： def func1(): print(1) ... print(2) def func2(): print(3) ... print(4) func1() func2() 上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：1、2、3、4。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：1、3、2、4。 在Python中有多种方式可以实现协程，例如： greenlet：是一个第三方模块，用于实现协程代码（Gevent协程就是基于 greenlet 实现） yield：生成器，借助生成器的特点也可以实现协程代码。 asyncio：在 Python3.4 中引入的模块用于编写协程代码。 async & awiat：在 Python3.5 中引入的两个关键字，结合 asyncio 模块可以更方便的编写协程代码。 1.1 greenlet greentlet 是一个第三方模块，需要提前安装 pip3 install greenlet 才能使用。 from greenlet import greenlet def func1(): print(1) # 第1步：输出 1 gr2.switch() # 第3步：切换到 func2 函数 print(2) # 第6步：输出 2 gr2.switch() # 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行 def func2(): print(3) # 第4步：输出 3 gr1.switch() # 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行 print(4) # 第8步：输出 4 gr1 = greenlet(func1) gr2 = greenlet(func2) gr1.switch() # 第1步：去执行 func1 函数 注意：switch 中也可以传递参数用于在切换执行时相互传递值。 1.2 yield 基于 Python 的生成器的 yield 和 yield form 关键字实现协程代码。 def func1(): yield 1 yield from func2() yield 2 def func2(): yield 3 yield 4 f1 = func1() for item in f1: print(item) 注意：yield form 关键字是在 Python3.3 中引入的。 1.3 asyncio 在 Python3.4 之前官方未提供协程的类库，一般大家都是使用 greenlet 等其他来实现。在 Python3.4 发布后官方正式支持协程，即：asyncio 模块。 import asyncio @asyncio.coroutine def func1(): print(1) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(2) @asyncio.coroutine def func2(): print(3) yield from asyncio.sleep(2) # 遇到IO耗时操作，自动化切换到tasks中的其他任务 print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2()) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 注意：基于 asyncio 模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能。 1.4 async & awit async & awit 关键字在 Python3.5 版本中正式引入，基于他编写的协程代码其实就是上一示例的加强版，让代码可以更加简便。 Python3.8 之后 @asyncio.coroutine 装饰器就会被移除，推荐使用 async & awit关键字实现协程代码。 import asyncio async def func1(): print(1) await asyncio.sleep(2) print(2) async def func2(): print(3) await asyncio.sleep(2) print(4) tasks = [ asyncio.ensure_future(func1()), asyncio.ensure_future(func2()) ] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 1.5 小结 关于协程有多种实现方式，目前主流使用是 Python 官方推荐的 asyncio 模块和 async & await 关键字的方式，例如：在 tonado、sanic、fastapi、django3 中均已支持。 接下来，也会针对 asyncio模块 + async & await 关键字进行更加详细的讲解。 2 协程的意义 通过上面，已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行。 但是，协程来回切换执行的意义何在呢？（网上看到很多文章舔协程，协程牛逼之处是哪里呢？） 计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。 IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。 2.1 爬虫案例 例如：用代码实现下载 url_list 中的图片。 方式一：同步编程实现 # 下载图片使用第三方模块requests，请提前安装：pip3 install requests import requests def download_image(url): print(\"开始下载:\", url) # 发送网络请求，下载图片 response = requests.get(url) print(\"下载完成\") # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] for item in url_list: download_image(item) 方式二：基于协程的异步编程实现 # 下载图片使用第三方模块aiohttp，请提前安装：pip3 install aiohttp # !/usr/bin/env python # -*- coding:utf-8 -*- import aiohttp import asyncio async def fetch(session, url): print(\"发送请求：\", url) async with session.get(url, verify_ssl=False) as response: content = await response.content.read() file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(content) async def main(): async with aiohttp.ClientSession() as session: url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(tasks) if __name__ == '__main__': asyncio.run(main()) 上述两种的执行对比之后会发现，基于协程的异步编程要比同步编程的效率高了很多。因为： 同步编程，按照顺序逐一排队执行，如果图片下载时间为 2分钟，那么全部执行完则需要 6分钟。 异步编程，几乎同时发出了 3个下载任务的请求（遇到 IO 请求自动切换去发送其他任务请求），如果图片下载时间为 2分钟，那么全部执行完毕也大概需要 2分钟左右就可以了。 2.2 小结 协程一般应用在有 IO操作的程序中，因为协程可以利用 IO等待的时间去执行一些其他的代码，从而提升代码执行效率。 生活中不也是这样的么，假设 你是一家制造汽车的老板，员工点击设备的【开始】按钮之后，在设备前需等待 30分钟，然后点击【结束】按钮，此时作为老板的你一定希望这个员工在等待的那 30分钟的时间去做点其他的工作。 3 异步编程 基于 async & await 关键字的协程可以实现异步编程，这也是目前 python 异步相关的主流技术。想要真正的了解 Python 中内置的异步编程，根据下文的顺序一点点来看。 3.1 事件循环 事件循环，可以把他当做是一个 while 循环，这个 while 循环在周期性的运行并执行一些任务，在特定条件下终止循环。 # 伪代码 任务列表 = [ 任务1, 任务2, 任务3,... ] while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将'可执行'和'已完成'的任务返回 for 就绪任务 in 已准备就绪的任务列表: 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表: 在任务列表中移除 已完成的任务 如果 任务列表 中的任务都已完成，则终止循环 在编写程序时候可以通过如下代码来获取和创建事件循环。 import asyncio loop = asyncio.get_event_loop() 3.2 协程和异步编程 协程函数，定义形式为 async def 的函数。 协程对象，调用 协程函数 所返回的对象。 # 定义一个协程函数 async def func(): pass # 调用协程函数，返回一个协程对象 result = func() 注意：调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象。 3.2.1 基本应用 程序中，如果想要执行协程函数的内部代码，需要 事件循环 和 协程对象 配合才能实现，如： import asyncio async def func(): print(\"协程内部代码\") # 调用协程函数，返回一个协程对象。 result = func() # 方式一 # loop = asyncio.get_event_loop() # 创建一个事件循环 # loop.run_until_complete(result) # 将协程当做任务提交到事件循环的任务列表中，协程执行完成之后终止。 # 方式二 # 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。 # asyncio.run 函数在 Python 3.7 中加入 asyncio 模块， asyncio.run(result) 这个过程可以简单理解为：将协程当做任务添加到 事件循环 的任务列表，然后事件循环检测列表中的协程是否 已准备就绪（默认可理解为就绪状态），如果准备就绪则执行其内部代码。 3.2.2 await await 是一个只能在协程函数中使用的关键字，用于遇到 IO 操作时挂起 当前协程（任务），当前协程（任务）挂起过程中 事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行 await 之后的代码。代码如下： 示例1： import asyncio async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。 # 当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await asyncio.sleep(2) print(\"IO请求结束，结果为：\", response) result = func() asyncio.run(result) 示例2： import asyncio async def others(): print(\"start\") await asyncio.sleep(2) print('end') return '返回值' async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await others() print(\"IO请求结束，结果为：\", response) asyncio.run(func()) 示例3： import asyncio async def others(): print(\"start\") await asyncio.sleep(2) print('end') return '返回值' async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response1 = await others() print(\"IO请求结束，结果为：\", response1) response2 = await others() print(\"IO请求结束，结果为：\", response2) asyncio.run(func()) 上述的所有示例都只是创建了一个任务，即：事件循环的任务列表中只有一个任务，所以在 IO 等待时无法演示切换到其他任务效果。 在程序想要创建多个任务对象，需要使用 Task 对象来实现。 3.2.3 Task对象 Tasks are used to schedule coroutines concurrently. When a coroutine is wrapped into a Task with functions like asyncio.create_task() the coroutine is automatically scheduled to run soon。 Tasks用于并发调度协程，通过 asyncio.create_task(协程对象) 的方式创建 Task 对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 asyncio.create_task() 函数以外，还可以用低层级的 loop.create_task() 或 ensure_future() 函数。不建议手动实例化 Task 对象。 本质上是将协程对象封装成task对象，并将协程立即加入事件循环，同时追踪协程的状态。 注意：asyncio.create_task() 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 asyncio.ensure_future() 函数。 示例1： import asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \"返回值\" async def main(): print(\"main开始\") # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 task1 = asyncio.create_task(func()) # 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 task2 = asyncio.create_task(func()) print(\"main结束\") # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。 # 此处的await是等待相对应的协程全都执行完毕并获取结果 ret1 = await task1 ret2 = await task2 print(ret1, ret2) asyncio.run(main()) 示例2： import asyncio async def func(): print(1) await asyncio.sleep(2) print(2) return \"返回值\" async def main(): print(\"main开始\") # 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。 # 在调用 task_list = [ asyncio.create_task(func(), name=\"n1\"), asyncio.create_task(func(), name=\"n2\") ] print(\"main结束\") # 当执行某协程遇到IO操作时，会自动化切换执行其他任务。 # 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done # 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。 done, pending = await asyncio.wait(task_list, timeout=None) print(done, pending) asyncio.run(main()) 注意：asyncio.wait 源码内部会对列表中的每个协程执行 ensure_future 从而封装为Task对象，所以在和wait配合使用时task_list的值为[func(),func()] 也是可以的。 示例3： import asyncio async def func(): print(\"执行协程函数内部代码\") # 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。 response = await asyncio.sleep(2) print(\"IO请求结束，结果为：\", response) coroutine_list = [func(), func()] # 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ] # 此处不能直接 asyncio.create_task，因为将 Task 立即加入到事件循环的任务列表。 # 但此时事件循环还未创建，所以会报错。事件循环创建在 asyncio.run 里面才创建。 # 使用 asyncio.wait 将列表封装为一个协程，并调用 asyncio.run 实现执行两个协程 # asyncio.wait 内部会对列表中的每个协程执行 ensure_future，封装为 Task 对象。 done, pending = asyncio.run(asyncio.wait(coroutine_list)) 3.2.4 asyncio.Future 对象 A Futureis a special low-level awaitable object that represents an eventual result of an asynchronous operation. asyncio中的Future对象是一个相对更偏向底层的可等待对象，通常我们不会直接用到这个对象，而是直接使用Task对象来完成任务的并和状态的追踪。（ Task 是 Futrue的子类 ） Future为我们提供了异步编程中的 最终结果 的处理（Task类也具备状态处理的功能）。 示例1： async def main(): # 获取当前事件循环 loop = asyncio.get_running_loop() # # 创建一个任务（Future对象），这个任务什么都不干。 fut = loop.create_future() # 等待任务最终结果（Future对象），没有结果则会一直等下去。 await fut asyncio.run(main()) 示例2： import asyncio async def set_after(fut): await asyncio.sleep(2) fut.set_result(\"666\") async def main(): # 获取当前事件循环 loop = asyncio.get_running_loop() # 创建一个任务（Future对象），没绑定任何行为，则这个任务永远不知道什么时候结束。 fut = loop.create_future() # 创建一个任务（Task对象），绑定了set_after函数，函数内部在2s之后，会给fut赋值。 # 即手动设置future任务的最终结果，那么fut就可以结束了。 await loop.create_task(set_after(fut)) # 等待 Future对象获取 最终结果，否则一直等下去 data = await fut print(data) asyncio.run(main()) Future 对象本身函数进行绑定，所以想要让事件循环获取 Future 的结果，则需要手动设置。而 Task 对象继承了 Future 对象，其实就对 Future 进行扩展，他可以实现在对应绑定的函数执行完成之后，自动执行 set_result，从而实现自动结束。 虽然，平时使用的是 Task 对象，但对于结果的处理本质是基于 Future 对象来实现的。 扩展：支持 await 对象语法的对象可成为可等待对象，所以 协程对象、Task 对象、Future 对象 都可以被成为可等待对象。 3.2.5 futures.Future对象 在Python的concurrent.futures模块中也有一个Future对象，这个对象是基于线程池和进程池实现异步操作时使用的对象。 import time from concurrent.futures import Future from concurrent.futures.thread import ThreadPoolExecutor from concurrent.futures.process import ProcessPoolExecutor def func(value): time.sleep(1) print(value) pool = ThreadPoolExecutor(max_workers=5) # 或 pool = ProcessPoolExecutor(max_workers=5) for i in range(10): fut = pool.submit(func, i) print(fut) 两个Future对象是不同的，他们是为不同的应用场景而设计，例如：concurrent.futures.Future 不支持await语法 等。 官方提示两对象之间不同： unlike asyncio Futures, concurrent.futures.Future instances cannot be awaited. asyncio.Future.result() and asyncio.Future.exception() do not accept the timeout argument. asyncio.Future.result() and asyncio.Future.exception() raise an InvalidStateError exception when the Future is not done. Callbacks registered with asyncio.Future.add_done_callback() are not called immediately. They are scheduled with loop.call_soon() instead. asyncio Future is not compatible with the concurrent.futures.wait() and concurrent.futures.as_completed() functions. 在 Python 提供了一个将futures.Future 对象包装成asyncio.Future对象的函数 asynic.wrap_future。 为什么python会提供这种功能？ 其实，一般在程序开发中我们要么统一使用 asycio 的协程实现异步操作、要么都使用进程池和线程池实现异步操作。但如果协程的异步和进程池/线程池的异步混搭时，那么就会用到此功能了。 import time import asyncio import concurrent.futures def func1(): # 某个耗时操作 time.sleep(2) return \"SB\" async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop's executor ( 默认ThreadPoolExecutor ) # 第一步：内部会先调用 ThreadPoolExecutor 的 submit 方法去线程池中申请一个线程去执行func1函数，并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asycio.Future对象。 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为 asycio.Future对象 才能使用。 fut = loop.run_in_executor(None, func1) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom thread pool', result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print('custom process pool', result) asyncio.run(main()) 应用场景：当项目以协程式的异步编程开发时，如果要使用一个第三方模块，而第三方模块不支持协程方式异步编程时，就需要用到这个功能，例如： import asyncio import requests async def download_image(url): # 发送网络请求，下载图片（遇到网络下载图片的IO请求，自动化切换到其他任务） print(\"开始下载:\", url) loop = asyncio.get_event_loop() # requests模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print('下载完成') # 图片保存到本地文件 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as file_object: file_object.write(response.content) if __name__ == '__main__': url_list = [ 'https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg', 'https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg', 'https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg' ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) 3.2.6 异步迭代器 什么是异步迭代器 实现了 __aiter__() 和 __anext__() 方法的对象。__anext__ 必须返回一个 awaitable 对象。async for 会处理异步迭代器的__anext__() 方法所返回的可等待对象，直到其引发一个 StopAsyncIteration 异常。由 PEP 492 引入。 什么是异步可迭代对象？ 可在 async for 语句中被使用的对象。必须通过它的 __aiter__() 方法返回一个 asynchronous iterator。由 PEP 492 引入。 import asyncio class Reader(object): \"\"\" 自定义异步迭代器（同时也是异步可迭代对象） \"\"\" def __init__(self): self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return val async def func(): # 创建异步可迭代对象 async_iter = Reader() # async for 必须要放在async def函数内，否则语法错误。 async for item in async_iter: print(item) asyncio.run(func()) 异步迭代器其实没什么太大的作用，只是支持了async for语法而已。 3.2.6 异步上下文管理器 此种对象通过定义 __aenter__() 和 __aexit__() 方法来对 async with 语句中的环境进行控制。由 PEP 492 引入。 import asyncio class AsyncContextManager: def __init__(self): self.conn = None async def do_something(self): # 异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库链接 await asyncio.sleep(1) async def func(): async with AsyncContextManager() as f: result = await f.do_something() print(result) asyncio.run(func()) 这个异步的上下文管理器还是比较有用的，平时在开发过程中 打开、处理、关闭 操作时，就可以用这种方式来处理。 3.3 小结 在程序中只要看到async和await关键字，其内部就是基于协程实现的异步编程，这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发。 以上就是异步编程的常见操作，内容参考官方文档。 中文版 英文版 4 uvloop Python标准库中提供了asyncio模块，用于支持基于协程的异步编程。 uvloop 是 asyncio 中的事件循环的替代方案，替换后可以使得asyncio性能提高。事实上，uvloop要比nodejs、gevent等其他python异步框架至少要快2倍，性能可以比肩Go语言。 安装uvloop pip3 install uvloop 在项目中想要使用uvloop替换asyncio的事件循环也非常简单，只要在代码中这么做就行。 import asyncio import uvloop asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) # 编写asyncio的代码，与之前写的代码一致。 # 内部的事件循环自动化会变为uvloop asyncio.run(...) 注意：知名的 asgi uvicorn 内部就是使用的 uvloop 的事件循环。 5 实战案例 5.1 异步Redis 当通过python去操作redis时，链接、设置值、获取值 这些都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。 安装Python异步操作redis模块 pip3 install aioredis 示例1：异步操作 Redis #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import aioredis async def execute(address, password): print(\"开始执行\", address) # 网络IO操作：创建redis连接 redis = await aioredis.create_redis(address, password=password) # 网络IO操作：在redis中设置哈希值car，内部在设三个键值对，即： redis = { car:{key1:1,key2:2,key3:3}} await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 网络IO操作：去redis中获取值 result = await redis.hgetall('car', encoding='utf-8') print(result) redis.close() # 网络IO操作：关闭redis连接 await redis.wait_closed() print(\"结束\", address) asyncio.run(execute('redis://47.93.4.198:6379', \"root!2345\")) 示例2：连接多个redis做操作（遇到IO会切换其他任务，提供了性能）。 import asyncio import aioredis async def execute(address, password): print(\"开始执行\", address) # 网络IO操作：先去连接 47.93.4.197:6379，遇到IO则自动切换任务，去连接47.93.4.198:6379 redis = await aioredis.create_redis_pool(address, password=password) # 网络IO操作：遇到IO会自动切换任务 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 网络IO操作：遇到IO会自动切换任务 result = await redis.hgetall('car', encoding='utf-8') print(result) redis.close() # 网络IO操作：遇到IO会自动切换任务 await redis.wait_closed() print(\"结束\", address) task_list = [ execute('redis://47.93.4.197:6379', \"root!2345\"), execute('redis://47.93.4.198:6379', \"root!2345\") ] asyncio.run(asyncio.wait(task_list)) 更多redis操作参考aioredis官网 5.2 异步 MySQL 当通过python去操作MySQL时，连接、执行SQL、关闭都涉及网络IO请求，使用asycio异步的方式可以在IO等待时去做一些其他任务，从而提升性能。 安装Python异步操作redis模块 pip3 install aiomysql 示例1： import asyncio import aiomysql async def execute(): # 网络IO操作：连接MySQL conn = await aiomysql.connect(host='127.0.0.1', port=3306, user='root', password='123', db='mysql', ) # 网络IO操作：创建CURSOR cur = await conn.cursor() # 网络IO操作：执行SQL await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：获取SQL结果 result = await cur.fetchall() print(result) # 网络IO操作：关闭链接 await cur.close() conn.close() asyncio.run(execute()) 示例2： #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import aiomysql async def execute(host, password): print(\"开始\", host) # 网络IO操作：先去连接 47.93.40.197，遇到IO则自动切换任务，去连接47.93.40.198:6379 conn = await aiomysql.connect(host=host, port=3306, user='root', password=password, db='mysql') # 网络IO操作：遇到IO会自动切换任务 cur = await conn.cursor() # 网络IO操作：遇到IO会自动切换任务 await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：遇到IO会自动切换任务 result = await cur.fetchall() print(result) # 网络IO操作：遇到IO会自动切换任务 await cur.close() conn.close() print(\"结束\", host) task_list = [ execute('47.93.40.197', \"root!2345\"), execute('47.93.40.197', \"root!2345\") ] asyncio.run(asyncio.wait(task_list)) 5.3 FastAPI 框架 FastAPI 是一款用于构建API的高性能web框架，框架基于Python3.6+的 type hints搭建。 接下里的异步示例以FastAPI和uvicorn来讲解（uvicorn是一个支持异步的asgi）。 安装FastAPI web 框架 pip3 install fastapi 安装uvicorn，本质上为web提供socket server的支持的asgi（一般支持异步称asgi、不支持异步称wsgi） pip3 install uvicorn 示例： # !/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn import aioredis from aioredis import Redis from fastapi import FastAPI app = FastAPI() REDIS_POOL = aioredis.ConnectionsPool('redis://47.193.14.198:6379', password=\"root123\", minsize=1, maxsize=10) @app.get(\"/\") def index(): \"\"\" 普通操作接口 \"\"\" return {\"message\": \"Hello World\"} @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" print(\"请求来了\") await asyncio.sleep(3) # 连接池获取一个连接 conn = await REDIS_POOL.acquire() redis = Redis(conn) # 设置值 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 读取值 result = await redis.hgetall('car', encoding='utf-8') print(result) # 连接归还连接池 REDIS_POOL.release(conn) return result if __name__ == '__main__': uvicorn.run(\"demo:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 在有多个用户并发请求的情况下，异步方式来编写的接口可以在IO等待过程中去处理其他的请求，提供性能。 例如：同时有两个用户并发来向接口 http://127.0.0.1:5000/red 发送请求，服务端只有一个线程，同一时刻只有一个请求被处理。 异步处理可以提供并发是因为：当视图函数在处理第一个请求时，第二个请求此时是等待被处理的状态，当第一个请求遇到IO等待时，会自动切换去接收并处理第二个请求，当遇到IO时自动化切换至其他请求，一旦有请求IO执行完毕，则会再次回到指定请求向下继续执行其功能代码。 基于上下文管理，来实现自动化管理的案例： 示例1：redis #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn import aioredis from aioredis import Redis from fastapi import FastAPI app = FastAPI() REDIS_POOL = aioredis.ConnectionsPool('redis://47.193.14.198:6379', password=\"root123\", minsize=1, maxsize=10) @app.get(\"/\") def index(): \"\"\" 普通操作接口 \"\"\" return {\"message\": \"Hello World\"} @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" print(\"请求来了\") async with REDIS_POOL.get() as conn: redis = Redis(conn) # 设置值 await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 读取值 result = await redis.hgetall('car', encoding='utf-8') print(result) return result if __name__ == '__main__': uvicorn.run(\"fast3:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 示例2：mysql #!/usr/bin/env python # -*- coding:utf-8 -*- import asyncio import uvicorn from fastapi import FastAPI import aiomysql app = FastAPI() # 创建数据库连接池 pool = aiomysql.Pool(host='127.0.0.1', port=3306, user='root', password='123', db='mysql', minsize=1, maxsize=10, echo=False, pool_recycle=-1, loop=asyncio.get_event_loop()) @app.get(\"/red\") async def red(): \"\"\" 异步操作接口 \"\"\" # 去数据库连接池申请链接 async with pool.acquire() as conn: async with conn.cursor() as cur: # 网络IO操作：执行SQL await cur.execute(\"SELECT Host,User FROM user\") # 网络IO操作：获取SQL结果 result = await cur.fetchall() print(result) # 网络IO操作：关闭链接 return {\"result\": \"ok\"} if __name__ == '__main__': uvicorn.run(\"fast2:app\", host=\"127.0.0.1\", port=5000, log_level=\"info\") 5.4 爬虫 在编写爬虫应用时，需要通过网络IO去请求目标数据，这种情况适合使用异步编程来提升性能，接下来我们使用支持异步编程的aiohttp模块来实现。 安装aiohttp模块 pip3 install aiohttp 示例： import aiohttp import asyncio async def fetch(session, url): print(\"发送请求：\", url) async with session.get(url, verify_ssl=False) as response: text = await response.text() print(\"得到结果：\", url, len(text)) async def main(): async with aiohttp.ClientSession() as session: url_list = [ 'https://python.org', 'https://www.baidu.com', 'https://www.pythonav.com' ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(tasks) if __name__ == '__main__': asyncio.run(main()) 总结 为了提升性能越来越多的框架都在向异步编程靠拢，例如：sanic、tornado、django3.0、django channels组件 等，用更少资源可以做处理更多的事，何乐而不为呢。 "},"Python/第三方库/Django/01-快速上手.html":{"url":"Python/第三方库/Django/01-快速上手.html","title":"快速上手","keywords":"","body":"datetime:2019/6/10 9:55 author:nzb 快速上手 Web开发的早期阶段，开发者需要手动编写每个页面，例如一个新闻门户网站，每天都要修改它的HTML页面，随着网站规模和体量的增大，这种方式就变得极度糟糕。为了解决这个问题，开发人员想到了用外部程序来为Web服务器生成动态内容，也就是说HTML页面以及页面中的动态内容不再通过手动编写而是通过程序自动生成。最早的时候，这项技术被称为CGI（公共网关接口），当然随着时间的推移，CGI暴露出的问题也越来越多，例如大量重复的样板代码，总体性能较为低下等，因此在时代呼唤新英雄的背景下，PHP、ASP、JSP这类Web应用开发技术在上世纪90年代中后期如雨后春笋般涌现。通常我们说的Web应用是指通过浏览器来访问网络资源的应用程序，因为浏览器的普及性以及易用性，Web应用使用起来方便简单，免除了安装和更新应用程序带来的麻烦，而且也不用关心用户到底用的是什么操作系统，甚至不用区分是PC端还是移动端。 Web应用机制和术语 下图向我们展示了Web应用的工作流程，其中涉及到的术语如下表所示。 说明：相信有经验的读者会发现，这张图中其实还少了很多东西，例如反向代理服务器、数据库服务器、防火墙等，而且图中的每个节点在实际项目部署时可能是一组节点组成的集群。当然，如果你对这些没有什么概念也不要紧，继续下去就行了，后面会给大家一一讲解的。 术语 解释 URL/URI 统一资源定位符/统一资源标识符，网络资源的唯一标识 域名 与Web服务器地址对应的一个易于记忆的字符串名字 DNS 域名解析服务，可以将域名转换成对应的IP地址 IP地址 网络上的主机的身份标识，通过IP地址可以区分不同的主机 HTTP 超文本传输协议，构建在TCP之上的应用级协议，万维网数据通信的基础 反向代理 代理客户端向服务器发出请求，然后将服务器返回的资源返回给客户端 Web服务器 接受HTTP请求，然后返回HTML文件、纯文本文件、图像等资源给请求者 Nginx 高性能的Web服务器，也可以用作反向代理，负载均衡 和 HTTP缓存 HTTP协议 这里我们稍微费一些笔墨来谈谈上面提到的HTTP。HTTP（超文本传输协议）是构建于TCP（传输控制协议）之上应用级协议，它利用了TCP提供的可靠的传输服务实现了Web应用中的数据交换。按照维基百科上的介绍，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，也就是说这个协议是浏览器和Web服务器之间传输的数据的载体。关于这个协议的详细信息以及目前的发展状况，大家可以阅读阮一峰老师的《HTTP 协议入门》、《互联网协议入门》系列以及《图解HTTPS协议》进行了解。下图是我于2009年9月10日凌晨4点在四川省网络通信技术重点实验室用开源协议分析工具Ethereal（抓包工具WireShark的前身）截取的访问百度首页时的HTTP请求和响应的报文（协议数据），由于Ethereal截取的是经过网络适配器的数据，因此可以清晰的看到从物理链路层到应用层的协议数据。 HTTP请求（请求行+请求头+空行+[消息体]）： HTTP响应（响应行+响应头+空行+消息体）： 说明：但愿这两张如同泛黄的照片般的截图能帮助你了解HTTP到底是什么样子的。 Django概述 Python的Web框架有上百个，比它的关键字还要多。所谓Web框架，就是用于开发Web服务器端应用的基础设施（通常指封装好的模块和一系列的工具）。事实上，即便没有Web框架，我们仍然可以通过socket或CGI来开发Web服务器端应用，但是这样做的成本和代价在实际开发中通常是不能接受的。通过Web框架，我们可以化繁为简，同时降低创建、更新、扩展应用程序的工作量。Python的Web框架中比较有名的有：Flask、Django、Tornado、Sanic、Pyramid、Bottle、Web2py、web.py等。 在基于Python的Web框架中，Django是所有重量级选手中最有代表性的一位，开发者可以基于Django快速的开发可靠的Web应用程序，因为它减少了Web开发中不必要的开销，对常用的设计和开发模式进行了封装，并对MVC架构提供了支持（MTV）。许多成功的网站和App都是基于Django框架构建的，国内比较有代表性的网站包括：知乎、豆瓣网、果壳网、搜狐闪电邮箱、101围棋网、海报时尚网、背书吧、堆糖、手机搜狐网、咕咚、爱福窝、果库等。 Django诞生于2003年，它是一个在真正的应用中成长起来的项目，由劳伦斯出版集团旗下在线新闻网站的内容管理系统（CMS）研发团队编写（主要是Adrian Holovaty和Simon Willison），以比利时的吉普赛爵士吉他手Django Reinhardt来命名，在2005年夏天作为开源框架发布。使用Django能用很短的时间构建出功能完备的网站，因为它代替程序员完成了所有乏味和重复的劳动，剩下真正有意义的核心业务给程序员，这一点就是对DRY（Don't Repeat Yourself）理念的最好践行。 5分钟快速上手 准备工作 检查Python环境：Django 1.11需要Python 2.7或Python 3.4以上的版本；Django 2.0需要Python 3.4以上的版本；Django 2.1需要Python 3.5以上的版本。 $ python3 --version $ python3 >>> import sys >>> sys.version >>> sys.version_info 创建项目文件夹并切换到该目录，例如我们要实例一个OA（办公自动化）项目。 $ mkdir oa $ cd oa 创建并激活虚拟环境。 $ python3 -m venv venv $ source venv/bin/activate 说明：上面使用了Python自带的venv模块完成了虚拟环境的创建，当然也可以使用其他的工具，例如：virtualenv或pipenv等。要激活虚拟环境，在Windows系统下是通过\"venv/Scripts/activate\"`执行批处理文件来实现。 更新包管理工具pip。 (venv)$ pip install -U pip 或 (venv)$ python -m pip install -U pip 注意：请注意终端提示符发生的变化，前面的(venv)说明我们已经进入虚拟环境，而虚拟环境下的python和pip已经是Python 3的解释器和包管理工具了。 安装Django。 (venv)$ pip install django 或指定版本号来安装对应的Django的版本。 (venv)$ pip install django==1.11 检查Django的版本。 (venv)$ python -m django --version (venv)$ django-admin --version 或 (venv)$ python >>> import django >>> django.get_version() 当然，也可以通过pip来查看安装的依赖库及其版本，如： (venv)$ pip freeze (venv)$ pip list 下图展示了Django版本和Python版本的对应关系，如果在安装时没有指定版本号，将自动选择最新的版本（在写作这段内容时，最新的版本是2.0；目前最新的版本已经更新到2.2）。 | Django版本 | Python版本 | | ---------- | ----------------------- | | 1.8 | 2.7、3.2、3.3、3.4、3.5 | | 1.9、1.10 | 2.7、3.4、3.5 | | 1.11 | 2.7、3.4、3.5、3.6、3.7 | | 2.0 | 3.4、3.5、3.6、3.7 | | 2.1、2.2 | 3.5、3.6、3.7 | 使用django-admin创建项目，项目命名为oa。 (venv)$ django-admin startproject oa . 注意：上面的命令最后的那个点，它表示在当前路径下创建项目。 执行上面的命令后看看生成的文件和文件夹，它们的作用如下所示： manage.py： 一个让你用各种方式管理 Django 项目的命令行工具。 oa/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 oa/settings.py：Django 项目的配置文件。 oa/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。 oa/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。 启动服务器运行项目。 (venv)$ python manage.py runserver 在浏览器中输入http://127.0.0.1:8000访问我们的服务器，效果如下图所示。 说明1：刚刚启动的是Django自带的用于开发和测试的服务器，它是一个用纯Python编写的轻量级Web服务器，但它并不是真正意义上的生产级别的服务器，千万不要将这个服务器用于和生产环境相关的任何地方。 说明2：用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍Python代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。 说明3：可以通过python manage.py help命令查看可用命令列表；在启动服务器时，也可以通过python manage.py runserver 1.2.3.4:5678来指定绑定的IP地址和端口。 说明4：可以通过Ctrl+C来终止服务器的运行。 接下来我们修改项目的配置文件settings.py，Django是一个支持国际化和本地化的框架，因此刚才我们看到的默认首页也是支持国际化的，我们将默认语言修改为中文，时区设置为东八区。 (venv)$ vim oa/settings.py # 此处省略上面的内容 # 设置语言代码 LANGUAGE_CODE = 'zh-hans' # 设置时区 TIME_ZONE = 'Asia/Chongqing' # 此处省略下面的内容 刷新刚才的页面。 动态页面 创建名为hrs（人力资源系统）的应用，一个Django项目可以包含一个或多个应用。 (venv)$ python manage.py startapp hrs 执行上面的命令会在当前路径下创建hrs目录，其目录结构如下所示： __init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 admin.py：可以用来注册模型，用于在Django的管理界面管理模型。 apps.py：当前应用的配置。 migrations：存放与模型有关的数据库迁移信息。 __init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。 models.py：存放应用的数据模型，即实体类及其之间的关系（MVC/MVT中的M）。 tests.py：包含测试应用各项功能的测试类和测试函数。 views.py：处理请求并返回响应的函数（MVC中的C，MVT中的V）。 修改应用目录下的视图文件views.py。 (venv)$ vim hrs/views.py ```Python from django.http import HttpResponse def index(request): return HttpResponse('Hello, Django!') 3. 在应用目录创建一个urls.py文件并映射URL。 ```Shell (venv)$ touch hrs/urls.py (venv)$ vim hrs/urls.py from django.urls import path from hrs import views urlpatterns = [ path('', views.index, name='index'), ] 说明：上面使用的path函数是Django 2.x中新添加的函数，除此之外还可以使用支持正则表达式的URL映射函数re_path函数；Django 1.x中是用名为url函数来设定URL映射。 切换到项目目录，修改该目录下的urls.py文件，对应用中设定的URL进行合并。 (venv) $ vim oa/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('hrs/', include('hrs.urls')), ] 重新运行项目，并打开浏览器中访问http://localhost:8000/hrs。 (venv)$ python manage.py runserver 修改views.py生成动态内容。 (venv)$ vim hrs/views.py ```Python from io import StringIO from django.http import HttpResponse depts_list = [ {'no': 10, 'name': '财务部', 'location': '北京'}, {'no': 20, 'name': '研发部', 'location': '成都'}, {'no': 30, 'name': '销售部', 'location': '上海'}, ] def index(request): output = StringIO() output.write('\\n') output.write('\\n') output.write('\\t\\n') output.write('\\t首页') output.write('\\n') output.write('\\n') output.write('\\t部门信息\\n') output.write('\\t\\n') output.write('\\t\\n') output.write('\\t\\t\\n') output.write('\\t\\t\\t部门编号\\n') output.write('\\t\\t\\t部门名称\\n') output.write('\\t\\t\\t所在地\\n') output.write('\\t\\t\\n') for dept in depts_list: output.write('\\t\\t\\n') output.write(f'\\t\\t\\t{dept[\"no\"]}\\n') output.write(f'\\t\\t\\t{dept[\"name\"]}\\n') output.write(f'\\t\\t\\t{dept[\"location\"]}\\n') output.write('\\t\\t\\n') output.write('\\t\\n') output.write('\\n') output.write('\\n') return HttpResponse(output.getvalue()) 7. 刷新页面查看程序的运行结果。 ![](./res/show-depts.png) #### 使用视图模板 上面通过拼接HTML代码的方式生成动态视图的做法在实际开发中是无能接受的，这一点大家一定能够想到。为了解决这个问题，我们可以提前准备一个模板页，所谓模板页就是一个带占位符的HTML页面，当我们将程序中获得的数据替换掉页面中的占位符时，一个动态页面就产生了。 我们可以用Django框架中template模块的Template类创建模板对象，通过模板对象的render方法实现对模板的渲染。所谓的渲染就是用数据替换掉模板页中的占位符，当然这里的渲染称为后端渲染，即在服务器端完成页面的渲染再输出到浏览器中，这种做法的主要坏处是当并发访问量较大时，服务器会承受较大的负担，所以今天有很多的Web应用都使用了前端渲染，即服务器只为浏览器提供所需的数据（通常是JSON格式），在浏览器中通过JavaScript获取这些数据并渲染到页面上，这些内容在后面为大家呈现。 Django框架通过shortcuts模块的快捷函数`render`简化了渲染模板的操作，具体的用法如下所示。 1. 先回到manage.py文件所在的目录创建名为templates文件夹。 ```Shell (venv)$ mkdir templates 创建模板页index.html。 (venv)$ touch templates/index.html (venv)$ vim templates/index.html 首页 部门信息 部门编号 部门名称 所在地 { % for dept in depts_list % } { { dept.no } } { { dept.name } } { { dept.location } } { % endfor % } 在上面的模板页中我们使用了{ { greeting } }这样的模板占位符语法，也使用了{ % for % }这样的模板指令，这些都是Django模板语言（DTL）的一部分。如果对此不熟悉并不要紧，我们会在后续的内容中进一步的讲解，而且我们刚才也说到了，还有更好的选择就是使用前端渲染，当然这是后话。 回到应用目录，修改views.py文件。 (venv)$ vim hrs/views.py ```Python from django.shortcuts import render depts_list = [ {'no': 10, 'name': '财务部', 'location': '北京'}, {'no': 20, 'name': '研发部', 'location': '成都'}, {'no': 30, 'name': '销售部', 'location': '上海'}, ] def index(request): return render(request, 'index.html', {'depts_list': depts_list}) 到此为止，我们还没有办法让views.py中的`render`函数找到模板文件index.html，为此我们需要修改settings.py文件，配置模板文件所在的路径。 4. 切换到项目目录修改settings.py文件。 ```Shell (venv)$ vim oa/settings.py # 此处省略上面的内容 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] # 此处省略下面的内容 重新运行项目或直接刷新页面查看结果。 (venv)$ python manage.py runserver 总结 至此，我们已经利用Django框架完成了一个非常小的Web应用，虽然它并没有任何的实际价值，但是可以通过这个项目对Django框架有一个感性的认识。当然，实际开发中我们可以用PyCharm来创建项目，如果使用专业版的PyCharm，可以直接创建Django项目。使用PyCharm的好处在于编写代码时可以获得代码提示、错误修复、自动导入等功能，从而提升开发效率，但是专业版的PyCharm需要按年支付相应的费用，社区版的PyCharm中并未包含对Django框架直接的支持，但是我们仍然可以使用它来创建Django项目，只是在使用上没有专业版的方便。关于PyCharm的使用，可以参考《玩转PyCharm》一文。 此外，学习Django最好的资料肯定是它的官方文档，除此之外图灵社区出版的《Django基础教程》也是非常适合初学者的读物。 "},"Python/第三方库/Django/02-深入模型.html":{"url":"Python/第三方库/Django/02-深入模型.html","title":"深入模型","keywords":"","body":"datetime:2019/6/10 10:01 author:nzb 深入模型 在上一个章节中，我们提到了Django是基于MVC架构的Web框架，MVC架构追求的是“模型”和“视图”的解耦合。所谓“模型”说得更直白一些就是数据，所以通常也被称作“数据模型”。在实际的项目中，数据模型通常通过数据库实现持久化操作，而关系型数据库在很长一段时间都是持久化的首选方案，下面我们以MySQL为例来说明如何使用关系型数据库来实现持久化操作。 配置关系型数据库MySQL 我们继续来完善上一个章节中的OA项目，首先从配置项目使用的数据库开始。 修改项目的settings.py文件，首先将我们之前创建的应用hrs添加已安装的项目中，然后配置MySQL作为持久化方案。 (venv)$ cd oa/settings.py # 此处省略上面的代码 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'hrs', ] DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'oa', 'HOST': 'localhost', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', } } # 此处省略下面的代码 在配置ENGINE属性时，常用的可选值包括： 'django.db.backends.sqlite3'：SQLite嵌入式数据库。 'django.db.backends.postgresql'：BSD许可证下发行的开源关系型数据库产品。 'django.db.backends.mysql'：转手多次目前属于甲骨文公司的经济高效的数据库产品。 'django.db.backends.oracle'：甲骨文公司的关系型数据库旗舰产品。 其他的配置可以参考官方文档中数据库配置的部分。 NAME属性代表数据库的名称，如果使用SQLite它对应着一个文件，在这种情况下NAME的属性值应该是一个绝对路径；使用其他关系型数据库，则要配置对应的HOST（主机）、PORT（端口）、USER（用户名）、PASSWORD（口令）等属性。 安装MySQL客户端工具，Python 3中使用PyMySQL，Python 2中用MySQLdb。 (venv)$ pip install pymysql 如果使用Python 3需要修改项目的__init__.py文件并加入如下所示的代码，这段代码的作用是将PyMySQL视为MySQLdb来使用，从而避免Django找不到连接MySQL的客户端工具而询问你：“Did you install mysqlclient? ”（你安装了mysqlclient吗？）。 import pymysql pymysql.install_as_MySQLdb() 运行manage.py并指定migrate参数实现数据库迁移，为应用程序创建对应的数据表，当然在此之前需要先启动MySQL数据库服务器并创建名为oa的数据库，在MySQL中创建数据库的语句如下所示。 drop database if exists oa; create database oa default charset utf8; (venv)$ cd .. (venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying sessions.0001_initial... OK 可以看到，Django帮助我们创建了10张表，这些都是使用Django框架需要的东西，稍后我们就会用到这些表。除此之外，我们还应该为我们自己的应用创建数据模型。如果要在hrs应用中实现对部门和员工的管理，我们可以创建如下所示的数据模型。 (venv)$ vim hrs/models.py ```Python from django.db import models class Dept(models.Model): \"\"\"部门类\"\"\" no = models.IntegerField(primary_key=True, db_column='dno', verbose_name='部门编号') name = models.CharField(max_length=20, db_column='dname', verbose_name='部门名称') location = models.CharField(max_length=10, db_column='dloc', verbose_name='部门所在地') class Meta: db_table = 'tb_dept' class Emp(models.Model): \"\"\"员工类\"\"\" no = models.IntegerField(primary_key=True, db_column='eno', verbose_name='员工编号') name = models.CharField(max_length=20, db_column='ename', verbose_name='员工姓名') job = models.CharField(max_length=10, verbose_name='职位') # 自参照完整性多对一外键关联 mgr = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='主管编号') sal = models.DecimalField(max_digits=7, decimal_places=2, verbose_name='月薪') comm = models.DecimalField(max_digits=7, decimal_places=2, null=True, blank=True, verbose_name='补贴') # 多对一外键关联 dept = models.ForeignKey(Dept, db_column='dno', on_delete=models.PROTECT, verbose_name='所在部门') class Meta: db_table = 'tb_emp' > 说明：上面定义模型时使用了字段类及其属性，其中IntegerField对应数据库中的integer类型，CharField对应数据库的varchar类型，DecimalField对应数据库的decimal类型，ForeignKey用来建立多对一外键关联。字段属性primary_key用于设置主键，max_length用来设置字段的最大长度，db_column用来设置数据库中与字段对应的列，verbose_name则设置了Django后台管理系统中该字段显示的名称。如果对这些东西感到很困惑也不要紧，文末提供了字段类、字段属性、元数据选项等设置的相关说明，不清楚的读者可以稍后查看对应的参考指南。 5. 通过模型创建数据表。 ```Shell (venv)$ python manage.py makemigrations hrs Migrations for 'hrs': hrs/migrations/0001_initial.py - Create model Dept - Create model Emp (venv)$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, hrs, sessions Running migrations: Applying hrs.0001_initial... OK 执行完数据模型迁移操作之后，可以在通过图形化的MySQL客户端工具查看到E-R图（实体关系图）。 在后台管理模型 创建超级管理员账号。 (venv)$ python manage.py createsuperuser Username (leave blank to use 'hao'): jackfrued Email address: jackfrued@126.com Password: Password (again): Superuser created successfully. 启动Web服务器，登录后台管理系统。 (venv)$ python manage.py runserver 访问http://127.0.0.1:8000/admin，会来到如下图所示的登录界面。 登录后进入管理员操作平台。 至此我们还没有看到之前创建的模型类，需要在应用的admin.py文件中模型进行注册。 注册模型类。 (venv)$ vim hrs/admin.py from django.contrib import admin from hrs.models import Emp, Dept admin.site.register(Dept) admin.site.register(Emp) 注册模型类后，就可以在后台管理系统中看到它们。 对模型进行CRUD操作。 可以在管理员平台对模型进行C（新增）R（查看）U（更新）D（删除）操作，如下图所示。 添加新的部门。 查看所有部门。 更新和删除部门。 注册模型管理类。 再次修改admin.py文件，通过注册模型管理类，可以在后台管理系统中更好的管理模型。 ```Python from django.contrib import admin from hrs.models import Emp, Dept class DeptAdmin(admin.ModelAdmin): list_display = ('no', 'name', 'location') ordering = ('no', ) class EmpAdmin(admin.ModelAdmin): list_display = ('no', 'name', 'job', 'mgr', 'sal', 'comm', 'dept') search_fields = ('name', 'job') admin.site.register(Dept, DeptAdmin) admin.site.register(Emp, EmpAdmin) ![](./res/admin-model-depts.png) ![](./res/admin-model-emps.png) 为了更好的查看模型数据，可以为Dept和Emp两个模型类添加`__str__`魔法方法。 ```Python from django.db import models class Dept(models.Model): \"\"\"部门类\"\"\" # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 class Emp(models.Model): \"\"\"员工类\"\"\" # 此处省略上面的代码 mgr = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, verbose_name='直接主管') # 此处省略下面的代码 # 此处省略上面的代码 def __str__(self): return self.name # 此处省略下面的代码 修改代码后刷新查看Emp模型的页面，效果如下图所示。 模型管理类详细配置 models.py # _*_ encoding:utf-8 _*_ from datetime import datetime from DjangoUeditor.models import UEditorField from django.db import models from organization.models import CourseOrg, Teacher # Create your models here. class Course(models.Model): course_org = models.ForeignKey(CourseOrg, verbose_name=u'课程机构', null=True, blank=True, on_delete=models.CASCADE) name = models.CharField(max_length=50, verbose_name=u'课程名称') desc = models.CharField(max_length=300, verbose_name=u'课程描述') # 使用富文本编辑器插件, ueditor的上传路径固定在ueditor目录下。文件名查看官方文档的变量设置 detail = UEditorField(verbose_name=u'课程详情', width=600, height=300, imagePath=\"courses/ueditor/\", filePath=\"courses/ueditor/\", default=u'') is_banner = models.BooleanField(default=False, verbose_name=u'是否轮播') teacher = models.ForeignKey(Teacher, verbose_name=u'讲师', null=True, blank=True, on_delete=models.CASCADE) degree = models.CharField(verbose_name=u'难度', choices=(('cj', u'初级'), ('zj', u'中级'), ('gj', u'高级')), max_length=2) learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') students = models.IntegerField(default=0, verbose_name=u'学习人数') fav_nums = models.IntegerField(default=0, verbose_name=u'收藏人数') image = models.ImageField(upload_to='courses/%Y/%m', verbose_name=u'封面图', max_length=100, null=True, blank=True) click_nums = models.IntegerField(default=0, verbose_name=u'点击数') category = models.CharField(default=u'后端开发', max_length=20, verbose_name=u'课程类别') tag = models.CharField(default='', verbose_name=u'课程标签', max_length=10,) youneed_know = models.CharField(max_length=300, verbose_name=u'课程须知', default='') what_you_learn = models.CharField(default='', max_length=300, verbose_name=u'老师告诉你能学到什么') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程' verbose_name_plural = verbose_name # # def __unicode__(self): # return self.name def get_lesson_nums(self): \"\"\" 获取章节数 :return: 章节数 \"\"\" return self.lesson_set.all().count() # 给个显示名字 get_lesson_nums.short_description = u'章节数' # 跳转函数 def go_to(self): from django.utils.safestring import mark_safe return mark_safe(\"跳转\") go_to.short_description = u'跳转' def get_learn_users(self): \"\"\" 获取学习用户 :return: 学习用户 \"\"\" return self.usercourse_set.all()[:5] def get_lesson(self): \"\"\" 获取课程所有章节 :return: \"\"\" return self.lesson_set.all() # def get_user(self): # \"\"\" # 获取课程所有章节 # :return: # \"\"\" # return self.lesson_set.all() def __str__(self): return self.name class BannerCourse(Course): \"\"\"轮播课程model继承于Course,拥有Course所有方法和属性\"\"\" class Meta: verbose_name = u'轮播课程' verbose_name_plural = verbose_name # proxy必须设置为True,就不会另外生产一张表而是和Course同一张表 proxy = True class Lesson(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'章节名') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'章节' verbose_name_plural = verbose_name def get_lesson_video(self): \"\"\" 获取章节视频信息 \"\"\" return self.video_set.all() def __str__(self): return self.name class Video(models.Model): lesson = models.ForeignKey(Lesson, verbose_name=u'章节', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'视频名') url = models.CharField(default='', max_length=200, verbose_name=u'访问地址') learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'视频' verbose_name_plural = verbose_name def __str__(self): return self.name class CourseResource(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'名称') download = models.FileField(upload_to='course/%Y/%m', verbose_name=u'资源文件', max_length=100) add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程资源' verbose_name_plural = verbose_name def __str__(self): return self.name adminx.py import xadmin from .models import Course, Lesson, Video, CourseResource, BannerCourse #配置主题功能 class BaseSetting(object): enable_themes = True use_bootswatch = True #全局头部脚步配置 class GlobalSettings(object): site_title = '慕课网' site_footer = '慕课在线网' menu_style = 'accordion' # inline模式，只能一层嵌套，不能多层嵌套，但可以多个 class LessonInline(object): model = Lesson extra = 0 class CourseResourceInline(object): model = CourseResource extra = 0 class CourseAdmin(object): \"\"\" 课程管理器 \"\"\" # 显示的字段，还可以显示函数，可以加入model中定义的函数如获取章节数：get_lesson_nums,go_to list_display = ['name', 'course_org', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time', 'get_lesson_nums', 'go_to'] # 搜索功能 search_fields = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums'] # 过滤器 list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] # ico图标 model_icon = 'fa fa-file' # 当有一个model有一个外键指向它时，它是ajax加载方式完成，数据量过大时很有用，可进行搜索而不是下拉式 relfield_style = 'fk-ajax' # 排序规则 ordering = ['-click_nums'] # 设置某些字段为只读 readonly_fields = ['click_nums'] # 设置某些字段不显示,和上面的设置会冲突，所以某个字段只能设置其中一个 exclude = ['fav_nums'] # 展示页面中直接修改功能 list_editable = ['degree','desc'] # inlines 设置 inlines = [LessonInline, CourseResourceInline] # 自定义刷新时间,配置多个页面中可选 refresh_times = [3, 5] # 插件配置 # 1、指明某个字段用的是什么样式，下面就是指明detail是ueditor样式 style_fields = {\"detail\": \"ueditor\"} # 2、Excel导入导出功能,True为开启 list_export = ['xls', 'xml', 'json'] import_excel = True # 重载方法过滤课程 def queryset(self): qs = super(CourseAdmin, self).queryset() qs = qs.filter(is_banner=False) return qs def save_models(self): # 在保存课程的时候统计机构的课程数 obj = self.new_obj # 查询前先保存才能增加新增的数量 obj.save() if obj.course_org is not None: course_org = obj.course_org course_org.course_nums = Course.objects.filter(course_org=course_org).count() course_org.save() def post(self, request, *args, **kwargs): # 导入逻辑 if 'excel' in request.FILES: pass return super(CourseAdmin, self).post(request, args, kwargs) class BannerCourseAdmin(object): \"\"\" 轮播课程管理器，和上面的课程管理器管理的是同一张表 \"\"\" list_display = ['name', 'course_org', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] search_fields = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums'] list_filter = ['name', 'desc', 'detail', 'degree', 'learn_times', 'students', 'fav_nums', 'image', 'click_nums', 'add_time'] model_icon = 'fa fa-file' # 排序规则 ordering = ['-click_nums'] # 设置某些字段为只读 readonly_fields = ['click_nums'] # 设置某些字段不显示,和上面的设置会冲突，所以某个字段只能设置其中一个 exclude = ['fav_nums'] # inlines 设置 inlines = [LessonInline, CourseResourceInline] # 重载方法过滤课程 def queryset(self): qs = super(BannerCourseAdmin, self).queryset() qs = qs.filter(is_banner=True) return qs class LessonAdmin(object): list_display = ['course', 'name', 'add_time'] search_fields = ['course', 'name'] list_filter = ['course__name', 'name', 'add_time'] #course__name外键设置 model_icon = 'fa fa-file-o' class VideoAdmin(object): list_display = ['lesson', 'name', 'add_time'] search_fields = ['lesson', 'name'] list_filter = ['lesson__name', 'name', 'add_time']#course__name外键设置 model_icon = 'fa fa-file-video-o' class CourseResourceAdmin(object): list_display = ['course', 'name', 'download', 'add_time'] search_fields = ['course', 'name', 'download'] list_filter = ['course__name', 'name', 'download', 'add_time'] model_icon = 'fa fa-file-archive-o' xadmin.site.register(Course, CourseAdmin) xadmin.site.register(BannerCourse, BannerCourseAdmin) xadmin.site.register(Lesson, LessonAdmin) xadmin.site.register(Video, VideoAdmin) xadmin.site.register(CourseResource, CourseResourceAdmin) xadmin.site.register(views.BaseAdminView, BaseSetting) xadmin.site.register(views.CommAdminView, GlobalSettings) Django_xadmin开启excel导入功能 # 文件路径：xadmin/plugins/execl.py from xadmin.sites import site from xadmin.views import BaseAdminPlugin, ListAdminView from django.template import loader from xadmin.plugins.utils import get_context_dict #excel 导入 class ListImportExcelPlugin(BaseAdminPlugin): import_excel = False def init_request(self, *args, **kwargs): return bool(self.import_excel) def block_top_toolbar(self, context, nodes): nodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html', context=get_context_dict(context))) xadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView) ```html # 模板文件：xadmin/templates/xadmin/excel/model_list.top_toolbar.import.html { % load i18n % } 导入1 导入 Excel function fileChange(target){ //检测上传文件的类型 var imgName = document.all.submit_upload.value; var ext,idx; if (imgName == ''){ document.all.submit_upload_b.disabled=true; alert(\"请选择需要上传的 xls 文件!\"); return; } else { idx = imgName.lastIndexOf(\".\"); if (idx != -1){ ext = imgName.substr(idx+1).toUpperCase(); ext = ext.toLowerCase( ); {# alert(\"ext=\"+ext);#} if (ext != 'xls' && ext != 'xlsx'){ document.all.submit_upload_b.disabled=true; alert(\"只能上传 .xls 类型的文件!\"); return; } } else { document.all.submit_upload_b.disabled=true; alert(\"只能上传 .xls 类型的文件!\"); return; } } } { % csrf_token % } &times; 导入 Excel { % trans \"Close\" % } 导入 ``` ```python # adminx.py文件 class maintenanceRecordListAdmin(object): list_display = [...] search_fields = [...] list_filter = [...] list_editable = [...] readonly_fields = [...] #excel导入导出功能 list_export = ['xls', 'xml', 'json'] import_excel = True def post(self, request, *args, **kwargs): # 导入逻辑 if 'excel' in request.FILES: pass return super(maintenanceRecordListAdmin, self).post(request, args, kwargs) ### 使用ORM完成模型的CRUD操作 在了解了Django提供的模型管理平台之后，我们来看看如何从代码层面完成对模型的CRUD（Create / Read / Update / Delete）操作。我们可以通过manage.py开启Shell交互式环境，然后使用Django内置的ORM框架对模型进行CRUD操作。 ```Shell (venv)$ python manage.py shell Python 3.6.4 (v3.6.4:d48ecebad5, Dec 18 2017, 21:07:28) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. (InteractiveConsole) >>> 新增 >>> from hrs.models import Dept, Emp >>> dept = Dept(40, '研发2部', '深圳') >>> dept.save() 更新 >>> dept.name = '研发3部' >>> dept.save() 查询 查询所有对象。 >>> Dept.objects.all() , , , ]> 过滤数据。 >>> Dept.objects.filter(name='研发3部') # 查询部门名称为“研发3部”的部门 ]> >>> >>> Dept.objects.filter(name__contains='研发') # 查询部门名称包含“研发”的部门(模糊查询) , ]> >>> >>> Dept.objects.filter(no__gt=10).filter(no__lt=40) # 查询部门编号大于10小于40的部门 , ]> >>> >>> Dept.objects.filter(no__range=(10, 30)) # 查询部门编号在10到30之间的部门 , , ]> 查询单个对象。 >>> Dept.objects.get(pk=10) >>> >>> Dept.objects.get(no=20) >>> >>> Dept.objects.get(no__exact=30) >>> >>> Dept.objects.filter(no=10).first() 排序数据。 >>> Dept.objects.order_by('no') # 查询所有部门按部门编号升序排列 , , , ]> >>> >>> Dept.objects.order_by('-no') # 查询所有部门按部门编号降序排列 , , , ]> 切片数据。 >>> Dept.objects.order_by('no')[0:2] # 按部门编号排序查询1~2部门 , ]> >>> >>> Dept.objects.order_by('no')[2:4] # 按部门编号排序查询3~4部门 , ]> 高级查询。 >>> Emp.objects.filter(dept__no=10) # 根据部门编号查询该部门的员工 , , ]> >>> >>> Emp.objects.filter(dept__name__contains='销售') # 查询名字包含“销售”的部门的员工 ]> >>> >>> Dept.objects.get(pk=10).emp_set.all() # 通过部门反查部门所有的员工 , , ]> 说明1：由于员工与部门之间存在多对一外键关联，所以也能通过部门反向查询该部门的员工（从一对多关系中“一”的一方查询“多”的一方），反向查询属性默认的名字是类名小写_set（如上面例子中的emp_set），当然也可以在创建模型时通过ForeingKey的related_name属性指定反向查询属性的名字。如果不希望执行反向查询可以将related_name属性设置为'+'或以'+'开头的字符串。 说明2：查询多个对象的时候返回的是QuerySet对象，QuerySet使用了惰性查询，即在创建QuerySet对象的过程中不涉及任何数据库活动，等真正用到对象时（求值QuerySet）才向数据库发送SQL语句并获取对应的结果，这一点在实际开发中需要引起注意！ 说明3：可以在QuerySet上使用update()方法一次更新多个对象。 删除 >>> Dept.objects.get(pk=40).delete() (1, {'hrs.Dept': 1}) Django模型最佳实践 正确的为模型和关系字段命名。 设置适当的related_name属性。 用OneToOneField代替ForeignKeyField(unique=True)。 通过“迁移操作”（migrate）来添加模型。 用NoSQL来应对需要降低范式级别的场景。 如果布尔类型可以为空要使用NullBooleanField。 在模型中放置业务逻辑。 用.DoesNotExists取代ObjectDoesNotExists。 在数据库中不要出现无效数据。 不要对QuerySet调用len()函数。 将QuerySet的exists()方法的返回值用于if条件。 用DecimalField来存储货币相关数据而不是FloatField。 定义__str__方法。 不要将数据文件放在同一个目录中。 说明：以上内容来自于STEELKIWI网站的Best Practice working with Django models in Python，有兴趣的小伙伴可以阅读原文。 模型定义参考 字段 对字段名称的限制 字段名不能是Python的保留字，否则会导致语法错误 字段名不能有多个连续下划线，否则影响ORM查询操作 Django模型字段类 字段类 说明 AutoField 自增ID字段 BigIntegerField 64位有符号整数 BinaryField 存储二进制数据的字段，对应Python的bytes类型 BooleanField 存储True或False CharField 长度较小的字符串 DateField 存储日期，有auto_now和auto_now_add属性 DateTimeField 存储日期和日期，两个附加属性同上 DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数 DurationField 存储时间跨度 EmailField 与CharField相同，可以用EmailValidator验证 FileField 文件上传字段 FloatField 存储浮点数 ImageField 其他同FileFiled，要验证上传的是不是有效图像 IntegerField 存储32位有符号整数。 GenericIPAddressField 存储IPv4或IPv6地址 NullBooleanField 存储True、False或null值 PositiveIntegerField 存储无符号整数（只能存储正数） SlugField 存储slug（简短标注） SmallIntegerField 存储16位有符号整数 TextField 存储数据量较大的文本 TimeField 存储时间 URLField 存储URL的CharField UUIDField 存储全局唯一标识符 自定义字段（了解为主） class UnsignedIntegerField(models.IntegerField): def db_type(self, connection): return 'integer UNSIGNED' 自定义char类型字段： class FixedCharField(models.Field): \"\"\" 自定义的char类型的字段类 \"\"\" def __init__(self, max_length, *args, **kwargs): super().__init__(max_length=max_length, *args, **kwargs) self.length = max_length def db_type(self, connection): \"\"\" 限定生成数据库表的字段类型为char，长度为length指定的值 \"\"\" return 'char(%s)' % self.length class Class(models.Model): id = models.AutoField(primary_key=True) title = models.CharField(max_length=25) # 使用上面自定义的char类型的字段 cname = FixedCharField(max_length=25) 字段属性 通用字段属性 选项 说明 null 数据库中对应的字段是否允许为NULL，默认为False blank 后台模型管理验证数据时，是否允许为NULL，默认为False choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值 db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称 db_index 设置为True时将在该字段创建索引 db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE default 字段的默认值 editable 字段在后台模型管理或ModelForm中是否显示，默认为True error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date help_text 表单小组件旁边显示的额外的帮助文本。 primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。 unique 设置为True时，表中字段的值必须是唯一的 verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称 ForeignKey属性 1. limit_choices_to：值是一个Q对象或返回一个Q对象，用于限制后台显示哪些对象。 2. related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为`'+'`，或者以`'+'`结尾。 3. to_field：指定关联的字段，默认关联对象的主键字段。 4. db_constraint：是否为外键创建约束，默认值为True。 5. on_delete：外键关联的对象被删除时对应的动作，可取的值包括django.db.models中定义的： - CASCADE：级联删除。 - PROTECT：抛出ProtectedError异常，阻止删除引用的对象。 - SET_NULL：把外键设置为null，当null属性被设置为True时才能这么做。 - SET_DEFAULT：把外键设置为默认值，提供了默认值才能这么做。 ManyToManyField属性 1. symmetrical：是否建立对称的多对多关系。 2. through：指定维持多对多关系的中间表的Django模型。 3. throughfields：定义了中间模型时可以指定建立多对多关系的字段。 4. db_table：指定维持多对多关系的中间表的表名。 模型元数据选项 选项 说明 abstract 设置为True时模型是抽象父类 app_label 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定 db_table 模型使用的数据表名称 db_tablespace 模型使用的数据表空间 default_related_name 关联对象回指这个模型时默认使用的名称，默认为_set get_latest_by 模型中可排序字段的名称。 managed 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除 order_with_respect_to 标记对象为可排序的 ordering 对象的默认排序 permissions 创建对象时写入权限表的额外权限 default_permissions 默认为('add', 'change', 'delete') unique_together 设定组合在一起时必须独一无二的字段名(联合唯一索引) index_together 设定一起建立索引的多个字段名(联合索引) verbose_name 为对象设定人类可读的名称 verbose_name_plural 设定对象的复数名称 查询参考 按字段查找可以用的条件： 1. exact / iexact：精确匹配/忽略大小写的精确匹配查询 2. contains / icontains / startswith / istartswith / endswith / iendswith：基于`like`的模糊查询 3. in：集合运算 4. gt / gte / lt / lte：大于/大于等于/小于/小于等于关系运算 5. range：指定范围查询（SQL中的`between…and…`） 6. year / month / day / week_day / hour / minute / second：查询时间日期 7. isnull：查询空值（True）或非空值（False） 8. search：基于全文索引的全文检索 9. regex / iregex：基于正则表达式的模糊匹配查询 Q对象（用于执行复杂查询）的使用： >>> from django.db.models import Q >>> Emp.objects.filter( ... Q(name__startswith='张'), ... Q(sal__gte=5000) | Q(comm__gte=1000) ... ) # 查询名字以“张”开头且工资大于等于5000或补贴大于等于1000的员工 ]> 模型定义例子 from datetime import datetime from DjangoUeditor.models import UEditorField from django.db import models from organization.models import CourseOrg, Teacher # Create your models here. class Course(models.Model): course_org = models.ForeignKey(CourseOrg, verbose_name=u'课程机构', null=True, blank=True, on_delete=models.CASCADE) name = models.CharField(max_length=50, verbose_name=u'课程名称') desc = models.CharField(max_length=300, verbose_name=u'课程描述') # 使用富文本编辑器插件, ueditor的上传路径固定在ueditor目录下。文件名查看官方文档的变量设置 detail = UEditorField(verbose_name=u'课程详情', width=600, height=300, imagePath=\"courses/ueditor/\", filePath=\"courses/ueditor/\", default=u'') is_banner = models.BooleanField(default=False, verbose_name=u'是否轮播') teacher = models.ForeignKey(Teacher, verbose_name=u'讲师', null=True, blank=True, on_delete=models.CASCADE) degree = models.CharField(verbose_name=u'难度', choices=(('cj', u'初级'), ('zj', u'中级'), ('gj', u'高级')), max_length=2) learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') students = models.IntegerField(default=0, verbose_name=u'学习人数') fav_nums = models.IntegerField(default=0, verbose_name=u'收藏人数') image = models.ImageField(upload_to='courses/%Y/%m', verbose_name=u'封面图', max_length=100, null=True, blank=True) click_nums = models.IntegerField(default=0, verbose_name=u'点击数') category = models.CharField(default=u'后端开发', max_length=20, verbose_name=u'课程类别') tag = models.CharField(default='', verbose_name=u'课程标签', max_length=10,) youneed_know = models.CharField(max_length=300, verbose_name=u'课程须知', default='') what_you_learn = models.CharField(default='', max_length=300, verbose_name=u'老师告诉你能学到什么') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程' verbose_name_plural = verbose_name def get_lesson_nums(self): \"\"\" 获取章节数 :return: 章节数 \"\"\" return self.lesson_set.all().count() # 给个显示名字 get_lesson_nums.short_description = u'章节数' # 跳转函数 def go_to(self): from django.utils.safestring import mark_safe return mark_safe(\"跳转\") go_to.short_description = u'跳转' def get_learn_users(self): \"\"\" 获取学习用户 :return: 学习用户 \"\"\" return self.usercourse_set.all()[:5] def get_lesson(self): \"\"\" 获取课程所有章节 :return: \"\"\" return self.lesson_set.all() def __str__(self): return self.name class BannerCourse(Course): \"\"\"轮播课程model继承于Course,拥有Course所有方法和属性\"\"\" class Meta: verbose_name = u'轮播课程' verbose_name_plural = verbose_name # proxy必须设置为True,就不会另外生产一张表而是和Course同一张表 proxy = True class Lesson(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'章节名') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'章节' verbose_name_plural = verbose_name def get_lesson_video(self): \"\"\" 获取章节视频信息 \"\"\" return self.video_set.all() def __str__(self): return self.name class Video(models.Model): lesson = models.ForeignKey(Lesson, verbose_name=u'章节', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'视频名') url = models.CharField(default='', max_length=200, verbose_name=u'访问地址') learn_times = models.IntegerField(default=0, verbose_name=u'学习时长') add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'视频' verbose_name_plural = verbose_name def __str__(self): return self.name class CourseResource(models.Model): course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE) name = models.CharField(max_length=100, verbose_name=u'名称') download = models.FileField(upload_to='course/%Y/%m', verbose_name=u'资源文件', max_length=100) add_time = models.DateTimeField(default=datetime.now, verbose_name=u'添加时间') class Meta: verbose_name = u'课程资源' verbose_name_plural = verbose_name def __str__(self): return self.name "},"Python/第三方库/Django/03-静态资源和Ajax请求.html":{"url":"Python/第三方库/Django/03-静态资源和Ajax请求.html","title":"静态资源和Ajax请求","keywords":"","body":"datetime:2019/6/10 11:32 author:nzb AJAX AJAX准备知识：JSON 什么是JSON? JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 * JSON 具有自我描述性，更易理解 *JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 啥都别多说了，上图吧！ 合格的json对象： [\"one\", \"two\", \"three\"] { \"one\": 1, \"two\": 2, \"three\": 3 } {\"names\": [\"张三\", \"李四\"] } [ { \"name\": \"张三\"}, {\"name\": \"李四\"} ]　 不合格的json对象： { name: \"张三\", 'age': 32 } // 属性名必须使用双引号 [32, 64, 128, 0xFFF] // 不能使用十六进制值 { \"name\": \"张三\", \"age\": undefined } // 不能使用undefined { \"name\": \"张三\", \"birthday\": new Date('Fri, 26 Aug 2011 07:13:10 GMT'), \"getName\": function() {return this.name;} // 不能使用函数和日期对象 } stringify与parse方法 JavaScript中关于JSON对象和字符串转换的两个方法： JSON.parse(): 用于将一个 JSON 字符串转换为 JavaScript 对象　 JSON.parse('{\"name\":\"Q1mi\"}'); JSON.parse('{name:\"Q1mi\"}') ; // 错误 JSON.parse('[18,undefined]') ; // 错误 JSON.stringify(): 用于将 JavaScript 值转换为 JSON 字符串。　 JSON.stringify({\"name\":\"Q1mi\"}) 和XML的比较 JSON 格式于2001年由 Douglas Crockford 提出，目的就是取代繁琐笨重的 XML 格式。 JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON迅速被接受，已经成为各大网站交换数据的标准格式，并被写入ECMAScript 5，成为标准的一部分。 XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。 用XML表示中国部分省市数据如下： 中国 黑龙江 哈尔滨 大庆 广东 广州 深圳 珠海 台湾 台北 高雄 新疆 乌鲁木齐 用JSON表示如下： { \"name\": \"中国\", \"province\": [{ \"name\": \"黑龙江\", \"cities\": { \"city\": [\"哈尔滨\", \"大庆\"] } }, { \"name\": \"广东\", \"cities\": { \"city\": [\"广州\", \"深圳\", \"珠海\"] } }, { \"name\": \"台湾\", \"cities\": { \"city\": [\"台北\", \"高雄\"] } }, { \"name\": \"新疆\", \"cities\": { \"city\": [\"乌鲁木齐\"] } }] } 由上面的两端代码可以看出，JSON 简单的语法格式和清晰的层次结构明显要比 XML 容易阅读，并且在数据交换方面，由于 JSON 所使用的字符要比 XML 少得多，可以大大得节约传输数据所占用得带宽。 AJAX简介 发送请求的方式： 直接在地址栏输入URL回车 GET请求 a标签 GET请求 form表单 GET/POST请求 AJAX GET/POST请求 AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步的Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。（这一特点给用户的感受是在不知不觉中完成请求和响应过程） AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求； 异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。 示例 页面输入两个整数，通过AJAX传输到后端计算出结果并返回。 AJAX局部刷新实例 + = $(\"#b1\").on(\"click\", function () { $.ajax({ url:\"/ajax_add/\", type:\"GET\", data:{\"i1\":$(\"#i1\").val(),\"i2\":$(\"#i2\").val()}, success:function (data) { $(\"#i3\").val(data); } }) }) def ajax_demo1(request): return render(request, \"ajax_demo1.html\") def ajax_add(request): i1 = int(request.GET.get(\"i1\")) i2 = int(request.GET.get(\"i2\")) ret = i1 + i2 return JsonResponse(ret, safe=False) urlpatterns = [ ... url(r'^ajax_add/', views.ajax_add), url(r'^ajax_demo1/', views.ajax_demo1), ... ] AJAX常见应用场景 搜索引擎根据用户输入的关键字，自动提示检索关键字。 还有一个很重要的应用场景就是注册时候的用户名的查重。 其实这里就使用了AJAX技术！当文件框发生了输入变化时，使用AJAX技术向服务器发送一个请求，然后服务器会把查询到的结果响应给浏览器，最后再把后端返回的结果展示出来。 整个过程中页面没有刷新，只是刷新页面中的局部位置而已！ 当请求发出后，浏览器还可以进行其他操作，无需等待服务器的响应！ 当输入用户名后，把光标移动到其他表单项上时，浏览器会使用AJAX技术向服务器发出请求，服务器会查询名为lemontree7777777的用户是否存在，最终服务器返回true表示名为lemontree7777777的用户已经存在了，浏览器在得到结果后显示“用户名已被注册！”。 整个过程中页面没有刷新，只是局部刷新了； 在请求发出后，浏览器不用等待服务器响应结果就可以进行其他操作； AJAX的优缺点 优点： AJAX使用JavaScript技术向服务器发送异步请求； AJAX请求无须刷新整个页面； 因为服务器响应内容不再是整个页面，而是页面中的部分内容，所以AJAX性能高； jQuery实现的AJAX 最基本的jQuery发送AJAX请求示例： ajax test AJAX 测试 $(\"#ajaxTest\").click(function () { $.ajax({ url: \"/ajax_test/\", type: \"POST\", data: {username: \"Q1mi\", password: 123456}, success: function (data) { alert(data) } }) }) views.py def ajax_test(request): user_name = request.POST.get(\"username\") password = request.POST.get(\"password\") print(user_name, password) return HttpResponse(\"OK\") $.ajax参数 data参数中的键值对，如果值值不为字符串，需要将其转换成字符串类型。 $(\"#b1\").on(\"click\", function () { $.ajax({ url:\"/ajax_add/\", type:\"GET\", data:{\"i1\":$(\"#i1\").val(),\"i2\":$(\"#i2\").val(),\"hehe\": JSON.stringify([1, 2, 3])}, success:function (data) { $(\"#i3\").val(data); } }) }) $.ajax参数data ajax有三种传递传递data的方式： 1、json格式 2、标准参数模式 3、json字符串格式 1.json对象格式： {“username”:”chen”,”nickname”:”alien”} $.ajax({ type:\"post\", url:\"/test/saveUser\", data:{\"username\":\"chen\",\"nickname\":\"alien\"}, dataType:\"json\", //指定响应的data数据类型为JSON对象。 success: function(data){ console.log(data); } }); - 如：当前的Ajax请求是一个POST请求，对请求体中的数据 使用默认的数据编码，格式如：key1 = value2&key2 = value2 a中的数据变成这样的格式：key1 = value2&key2 = value2 ，包装在Http请求体中传送给后台。 - dataType:\"json\" - dataType:“json” ：用来指定服务器返回的data数据类型必须是JSON类型。然后jQuery就会把后端返回的json字符串尝试通过JSON.parse()解析为js对象。 - 如果不指定dataType，jQuery 将自动根据 HTTP 包的 MIME 信息来智能判断，若MIME信息的值为JSON，则jQuery会自动的把data数据转换成JS对象的json，接着Script把data传递给回调函数进行JS的脚本操作。 2、标准参数模式 “username=Liudehua & age=50” $.ajax({ type:\"post\", url:\"/test/saveUser\", data:\"username=chen&nickname=alien\", dataType:\"json\", success: function(data){ console.log(data); } }); - $(“#form1”).serialize() 就是把表单的数据拼成这个格式（key1 = value2&key2 = value2）的字符串，然后放在Http请求体中传给后台！ 3.json字符串 ————>只用于post请求 “{“username”:”chen”,”nickname”:”alien”}”————>JSON对象格式的字符串 JSON.stringify({“username”:”chen”,”nickname”:”alien”})————>把JSON对象转成JSON格式的字符串。 $.ajax({ type:\"post\", url:\"/test/saveUser\", data:JSON.stringify({\"username\":\"chen\",\"nickname\":\"alien\"}), contentType:\"json/application\" dataType:\"json\", success: function(data){ console.log(data); } }); ** 第三种这种方式不能用于 Get请求。 原因： 1、因为此种方式发送的请求，后端必须得用@RequestBody进行接收，且接收的是Http请求体中的数据，Get请求没有请求体。 2、而且此方式的Ajax 必须要添加 contentType:”json/application”这个字段信息。 ** 注意： 1、若为GET请求，则会把data的数据 附加在 URL 后， 格式如：localhost://findAll ? key1=value1&key2=value2 若为POST请求，则就会把data的数据 放在请求体中。 格式如：key1 = value2&key2 = value2 2、dataType：指定服务器端返回的数据类型。 若不指定，且后端返回的是Json，前端就会自动识别返回的数据是JSON。 JS实现AJAX var b2 = document.getElementById(\"b2\"); b2.onclick = function () { // 原生JS var xmlHttp = new XMLHttpRequest(); xmlHttp.open(\"POST\", \"/ajax_test/\", true); xmlHttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xmlHttp.send(\"username=q1mi&password=123456\"); xmlHttp.onreadystatechange = function () { if (xmlHttp.readyState === 4 && xmlHttp.status === 200) { alert(xmlHttp.responseText); } }; }; AJAX请求如何设置csrf_token 方式1 通过获取隐藏的input标签中的csrfmiddlewaretoken值，放置在data中发送。 $.ajax({ url: \"/cookie_ajax/\", type: \"POST\", data: { \"username\": \"Q1mi\", \"password\": 123456, \"csrfmiddlewaretoken\": $(\"[name = 'csrfmiddlewaretoken']\").val() // 使用jQuery取出csrfmiddlewaretoken的值，拼接到data中 }, success: function (data) { console.log(data); } }) 方式2 通过获取返回的cookie中的字符串 放置在请求头中发送。 注意：需要引入一个jquery.cookie.js插件。 $.ajax({ url: \"/cookie_ajax/\", type: \"POST\", headers: {\"X-CSRFToken\": $.cookie('csrftoken')}, // 从Cookie取csrftoken，并设置到请求头中 data: {\"username\": \"Q1mi\", \"password\": 123456}, success: function (data) { console.log(data); } }) 或者用自己写一个getCookie方法： function getCookie(name) { var cookieValue = null; if (document.cookie && document.cookie !== '') { var cookies = document.cookie.split(';'); for (var i = 0; i 每一次都这么写太麻烦了，可以使用$.ajaxSetup()方法为ajax请求统一设置。 function csrfSafeMethod(method) { // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function (xhr, settings) { if (!csrfSafeMethod(settings.type) && !this.crossDomain) { xhr.setRequestHeader(\"X-CSRFToken\", csrftoken); } } }); 注意： 如果使用从cookie中取csrftoken的方式，需要确保cookie存在csrftoken值。 如果你的视图渲染的HTML文件中没有包含 { % csrf_token % }，Django可能不会设置CSRFtoken的cookie。 这个时候需要使用ensure_csrf_cookie()装饰器强制设置Cookie。 django.views.decorators.csrf import ensure_csrf_cookie @ensure_csrf_cookie def login(request): pass 更多细节详见：Djagno官方文档中关于CSRF的内容 AJAX上传文件 XMLHttpRequest 是一个浏览器接口，通过它，我们可以使得 Javascript 进行 HTTP (S) 通信。XMLHttpRequest 在现在浏览器中是一种常用的前后台交互数据的方式。2008年 2 月，XMLHttpRequest Level 2 草案提出来了，相对于上一代，它有一些新的特性，其中 FormData 就是 XMLHttpRequest Level 2 新增的一个对象，利用它来提交表单、模拟表单提交，当然最大的优势就是可以上传二进制文件。下面就具体 首先看一下formData的基本用法：FormData对象，可以把所有表单元素的name与value组成一个queryString，提交到后台。只需要把 form 表单作为参数传入 FormData 构造函数即可： 介绍一下如何利用 FormData 来上传文件。 // 上传文件示例 $(\"#b3\").click(function () { var formData = new FormData(); formData.append(\"csrfmiddlewaretoken\", $(\"[name='csrfmiddlewaretoken']\").val()); formData.append(\"f1\", $(\"#f1\")[0].files[0]); $.ajax({ url: \"/upload/\", type: \"POST\", processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 data: formData, success:function (data) { console.log(data) } }) }) 或者使用 var form = document.getElementById(\"form1\"); var fd = new FormData(form); 这样也可以直接通过ajax 的 send() 方法将 fd 发送到后台。 注意：由于 FormData 是 XMLHttpRequest Level 2 新增的接口，现在 低于IE10 的IE浏览器不支持 FormData。 练习（用户名是否已被注册） 功能介绍 在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回这个用户名是否已经被注册过。 案例分析 页面中给出注册表单； 在username input标签中绑定onblur事件处理函数。 当input标签失去焦点后获取 username表单字段的值，向服务端发送AJAX请求； django的视图函数中处理该请求，获取username值，判断该用户在数据库中是否被注册，如果被注册了就返回“该用户已被注册”，否则响应“该用户名可以注册”。 ajax中参数traditional的作用 　　 在使用ajax向后台传值的时候，有的时候一个字段需要传多个值，这种情况下会想到用数组形式来传，比如： $.ajax({ type: \"post\", async: true, data: { \"records\": [\"123\",\"456\",\"789\"] }, url: \"xxxxx\", error: function(request) {}, success: function(data) {} }); 但是通过测试很快就会发现java后台无法取到参数，因为jQuery需要调用jQuery.param序列化参数，jQuery.param(obj, traditional )默认情况下traditional为false， 即jquery会深度序列化参数对象，以适应如PHP和Ruby on Rails框架，但servelt api无法处理，我们可以通过设置traditional 为true阻止深度序列化，然后序列化结果如下： records: [\"123\", \"456\", \"789\"] => records=123&p=456&p=789 随即，我们就可以在后台通过request.getParameterValues()来获取参数的值数组了，如下： $.ajax({ type: \"post\", async: true, traditional: true, data: { \"records\": [\"123\",\"456\",\"789\"] }, url: \"xxxxx\", error: function(request) {}, success: function(data) {} }); 序列化 Django内置的serializers def books_json(request): book_list = models.Book.objects.all()[0:10] from django.core import serializers ret = serializers.serialize(\"json\", book_list) return HttpResponse(ret) 补充一个SweetAlert插件示例 点击下载Bootstrap-sweetalert项目。 $(\".btn-danger\").on(\"click\", function () { swal({ title: \"你确定要删除吗？\", text: \"删除可就找不回来了哦！\", type: \"warning\", showCancelButton: true, confirmButtonClass: \"btn-danger\", confirmButtonText: \"删除\", cancelButtonText: \"取消\", closeOnConfirm: false }, function () { var deleteId = $(this).parent().parent().attr(\"data_id\"); $.ajax({ url: \"/delete_book/\", type: \"post\", data: {\"id\": deleteId}, success: function (data) { if (data.status === 1) { swal(\"删除成功!\", \"你可以准备跑路了！\", \"success\"); } else { swal(\"删除失败\", \"你可以再尝试一下！\", \"error\") } } }) }); }) 静态资源和Ajax请求(100天) 基于前面两个章节讲解的知识，我们已经可以使用Django框架来实现Web应用的开发了。接下来我们就尝试实现一个投票应用，具体的需求是用户进入应用首先查看到“学科介绍”页面，该页面显示了一个学校所开设的所有学科；通过点击某个学科，可以进入“老师介绍”页面，该页面展示了该学科所有老师的详细情况，可以在该页面上给老师点击“好评”或“差评”，但是会先跳转到“登录页”要求用户登录，登录成功才能投票；对于未注册的用户，可以在“登录页”点击“新用户注册”进入“注册页”完成用户注册，注册成功后会跳转到“登录页”，注册失败会获得相应的提示信息。 准备工作 由于之前已经详细的讲解了如何创建Django项目以及项目的相关配置，因此我们略过这部分内容，唯一需要说明的是，从上面对投票应用需求的描述中我们可以分析出三个业务实体：学科、老师和用户。学科和老师之间通常是一对多关联关系（一个学科有多个老师，一个老师通常只属于一个学科），用户因为要给老师投票，所以跟老师之间是多对多关联关系（一个用户可以给多个老师投票，一个老师也可以收到多个用户的投票）。首先修改应用下的models.py文件来定义数据模型，先给出学科和老师的模型。 from django.db import models class Subject(models.Model): \"\"\"学科\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') name = models.CharField(max_length=31, verbose_name='名称') intro = models.CharField(max_length=511, verbose_name='介绍') def __str__(self): return self.name class Meta: db_table = 'tb_subject' verbose_name_plural = '学科' class Teacher(models.Model): \"\"\"老师\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') name = models.CharField(max_length=15, verbose_name='姓名') gender = models.BooleanField(default=True, choices=((True, '男'), (False, '女')), verbose_name='性别') birth = models.DateField(null=True, verbose_name='出生日期') intro = models.CharField(max_length=511, default='', verbose_name='') good_count = models.IntegerField(default=0, verbose_name='好评数') bad_count = models.IntegerField(default=0, verbose_name='差评数') photo = models.CharField(max_length=255, verbose_name='照片') subject = models.ForeignKey(to=Subject, on_delete=models.PROTECT, db_column='sno', verbose_name='所属学科') def __str__(self): return self.name class Meta: db_table = 'tb_teacher' verbose_name_plural = '老师' 模型定义完成后，可以通过“生成迁移”和“执行迁移”来完成关系型数据库中二维表的创建，当然这需要提前启动数据库服务器并创建好对应的数据库，同时我们在项目中已经安装了PyMySQL而且完成了相应的配置，这些内容此处不再赘述。 (venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ... 注意：为了给vote应用生成迁移，需要先修改Django项目的配置文件settings.py，在INSTALLED_APPS中添加vote应用。 完成模型迁移之后，我们可以通过下面的SQL语句来添加学科和老师测试的数据。 INSERT INTO `tb_subject` (`no`,`name`,`intro`) VALUES (1, 'Python全栈+人工智能', 'Python是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。'), (2, 'JavaEE+分布式服务', 'Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。'), (3, 'HTML5大前端', 'HTML5 将成为 HTML、XHTML 以及 HTML DOM 的新标准。'), (4, '全栈软件测试', '在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程'), (5, '全链路UI/UE', '全链路要求设计师关注整个业务链中的每一个环节，将设计的价值融入每一个和用户的接触点中，让整个业务的用户体验质量得到几何级数的增长。'); INSERT INTO `tb_teacher` (`no`,`name`,`gender`,`birth`,`intro`,`good_count`,`bad_count`,`photo`,`sno`) VALUES (1, '骆昊', 1, '1980-11-28', '10年以上软硬件产品设计、研发、架构和管理经验，2003年毕业于四川大学，四川大学Java技术俱乐部创始人，四川省优秀大学毕业生，在四川省网络通信技术重点实验室工作期间，参与了2项国家自然科学基金项目、1项中国科学院中长期研究项目和多项四川省科技攻关项目，在国际会议和国内顶级期刊上发表多篇论文（1篇被SCI收录，3篇被EI收录），大规模网络性能测量系统DMC-TS的设计者和开发者，perf-TTCN语言的发明者。国内最大程序员社区CSDN的博客专家，在Github上参与和维护了多个高质量开源项目，精通C/C++、Java、Python、R、Swift、JavaScript等编程语言，擅长OOAD、系统架构、算法设计、协议分析和网络测量，主持和参与过电子政务系统、KPI考核系统、P2P借贷平台等产品的研发，一直践行“用知识创造快乐”的教学理念，善于总结，乐于分享。', 0, 0, 'images/luohao.png', 1), (2, '王海飞', 1, '1993-05-24', '5年以上Python开发经验，先后参与了O2O商城、CRM系统、CMS平台、ERP系统等项目的设计与研发，曾在全国最大最专业的汽车领域相关服务网站担任Python高级研发工程师、项目经理等职务，擅长基于Python、Java、PHP等开发语言的企业级应用开发，全程参与了多个企业级应用从需求到上线所涉及的各种工作，精通Django、Flask等框架，熟悉基于微服务的企业级项目开发，拥有丰富的项目实战经验。善于用浅显易懂的方式在课堂上传授知识点，在授课过程中经常穿插企业开发的实际案例并分析其中的重点和难点，通过这种互动性极强的教学模式帮助学员找到解决问题的办法并提升学员的综合素质。', 0, 0, 'images/wangdachui.png', 1), (3, '余婷', 0, '1992-03-12', '5年以上移动互联网项目开发经验和教学经验，曾担任上市游戏公司高级软件研发工程师和移动端（iOS）技术负责人，参了多个企业级应用和游戏类应用的移动端开发和后台服务器开发，拥有丰富的开发经验和项目管理经验，以个人开发者和协作开发者的身份在苹果的AppStore上发布过多款App。精通Python、C、Objective-C、Swift等开发语言，熟悉iOS原生App开发、RESTful接口设计以及基于Cocos2d-x的游戏开发。授课条理清晰、细致入微，性格活泼开朗、有较强的亲和力，教学过程注重理论和实践的结合，在学员中有良好的口碑。', 0, 0, 'images/yuting.png', 1), (4, '肖世荣', 1, '1977-07-02', '10年以上互联网和移动互联网产品设计、研发、技术架构和项目管理经验，曾在中国移动、symbio、ajinga.com、万达信息等公司担任架构师、项目经理、技术总监等职务，长期为苹果、保时捷、耐克、沃尔玛等国际客户以及国内的政府机构提供信息化服务，主导的项目曾获得“世界科技先锋”称号，个人作品“许愿吧”曾在腾讯应用市场生活类App排名前3，拥有百万级用户群体，运营的公众号“卵石坊”是国内知名的智能穿戴设备平台。精通Python、C++、Java、Ruby、JavaScript等开发语言，主导和参与了20多个企业级项目（含国家级重大项目和互联网创新项目），涉及的领域包括政务、社交、电信、卫生和金融，有极为丰富的项目实战经验。授课深入浅出、条理清晰，善于调动学员的学习热情并帮助学员理清思路和方法。', 0, 0, 'images/xiaoshirong.png', 1), (5, '张无忌', 1, '1987-07-07', '出生起便在冰火岛过着原始生活，踏入中土后因中玄冥神掌命危而带病习医，忍受寒毒煎熬七年最后因福缘际会练成“九阳神功”更在之后又练成了“乾坤大挪移”等盖世武功，几乎无敌于天下。 生性随和，宅心仁厚，精通医术和药理。20岁时便凭着盖世神功当上明教教主，率领百万教众及武林群雄反抗蒙古政权元朝的高压统治，最后推翻了元朝。由于擅长乾坤大挪移神功，上课遇到问题就转移话题，属于拉不出屎怪地球没有引力的类型。', 0, 0, 'images/zhangwuji.png', 5), (6, '韦一笑', 1, '1975-12-15', '外号“青翼蝠王”，为明教四大护教法王之一。 身披青条子白色长袍，轻功十分了得。由于在修炼至阴至寒的“寒冰绵掌”时出了差错，经脉中郁积了至寒阴毒，只要运上内力，寒毒就会发作，如果不吸人血解毒，全身血脉就会凝结成冰，后得张无忌相助，以其高明医术配以“九阳神功”，终将寒毒驱去，摆脱了吸吮人血这一命运。由于轻功绝顶，学生一问问题就跑了。', 0, 0, 'images/weiyixiao.png', 3); 当然也可以直接使用Django提供的后台管理应用来添加学科和老师信息，这需要先注册模型类和模型管理类。 from django.contrib import admin from django.contrib.admin import ModelAdmin from vote.models import Teacher, Subject class SubjectModelAdmin(ModelAdmin): \"\"\"学科模型管理\"\"\" list_display = ('no', 'name') ordering = ('no', ) class TeacherModelAdmin(ModelAdmin): \"\"\"老师模型管理\"\"\" list_display = ('no', 'name', 'gender', 'birth', 'good_count', 'bad_count', 'subject') ordering = ('no', ) search_fields = ('name', ) admin.site.register(Subject, SubjectModelAdmin) admin.site.register(Teacher, TeacherModelAdmin) 接下来，我们就可以修改views.py文件，通过编写视图函数先实现“学科介绍”页面。 def show_subjects(request): \"\"\"查看所有学科\"\"\" subjects = Subject.objects.all() return render(request, 'subject.html', {'subjects': subjects}) 至此，我们还需要一个模板页，模板的配置以及模板页中模板语言的用法在之前已经进行过简要的介绍，如果不熟悉可以看看下面的代码，相信这并不是一件困难的事情。 学科信息 /* 此处略去了层叠样式表的选择器 */ 千锋互联所有学科信息 { % for subject in subjects % } { { subject.name } } { { subject.intro } } { % endfor % } 在上面的模板中，我们为每个学科添加了一个超链接，点击超链接可以查看该学科的讲师信息，为此需要再编写一个视图函数来处理查看指定学科老师信息。 def show_teachers(request): \"\"\"查看指定学科的老师\"\"\" try: sno = int(request.GET['sno']) subject = Subject.objects.get(no=sno) teachers = Teacher.objects.filter(subject__no=sno) context = {'subject': subject, 'teachers': teachers} return render(request, 'teacher.html', context) except (KeyError, ValueError, Subject.DoesNotExist): return redirect('/') 显示老师信息的模板页。 { % load static % } 老师信息 /* 此处略去了层叠样式表的选择器 */ { { subject.name } }学科老师信息 { % if teachers % } { % for teacher in teachers % } 姓名：{ { teacher.name } } 性别：{ { teacher.gender | yesno:'男,女' } } 出生日期：{ { teacher.birth } } { { teacher.intro } } 好评（{ { teacher.good_count } }） 差评（{ { teacher.bad_count } }） { % endfor % } { % else % } 暂时没有该学科的老师信息 { % endif % } &lt;&lt;&nbsp;返回学科 加载静态资源 在上面的模板页面中，我们使用了标签来加载老师的照片，其中使用了引用静态资源的模板指令{ % static % }，要使用该指令，首先要使用{ % load static % }指令来加载静态资源，我们将这段代码放在了页码开始的位置。在上面的项目中，我们将静态资源置于名为static的文件夹中，在该文件夹下又创建了三个文件夹：css、js和images，分别用来保存外部层叠样式表、外部JavaScript文件和图片资源。为了能够找到保存静态资源的文件夹，我们还需要修改Django项目的配置文件settings.py，如下所示： # 此处省略上面的代码 STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ] STATIC_URL = '/static/' # 此处省略下面的代码 接下来修改urls.py文件，配置用户请求的URL和视图函数的对应关系。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path('', views.show_subjects), path('teachers/', views.show_teachers), path('admin/', admin.site.urls), ] 启动服务器运行项目，进入首页查看学科信息。 点击学科查看老师信息。 Ajax请求 接下来就可以实现“好评”和“差评”的功能了，很明显如果能够在不刷新页面的情况下实现这两个功能会带来更好的用户体验，因此我们考虑使用Ajax技术来实现“好评”和“差评”，Ajax技术我们在之前的章节中已经介绍过了，此处不再赘述。 首先修改项目的urls.py文件，为“好评”和“差评”功能映射对应的URL。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ path('', views.show_subjects), path('teachers/', views.show_teachers), path('praise/', views.prise_or_criticize), path('criticize/', views.prise_or_criticize), path('admin/', admin.site.urls), ] 设计视图函数praise_or_criticize来支持“好评”和“差评”功能，该视图函数通过Django封装的JsonResponse类将字典序列化成JSON字符串作为返回给浏览器的响应内容。 def praise_or_criticize(request): \"\"\"好评\"\"\" try: tno = int(request.GET['tno']) teacher = Teacher.objects.get(no=tno) if request.path.startswith('/prise'): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {'code': 200, 'hint': '操作成功'} except (KeyError, ValueError, Teacher.DoseNotExist): data = {'code': 404, 'hint': '操作失败'} return JsonResponse(data) 修改显示老师信息的模板页，引入jQuery库来实现事件处理、Ajax请求和DOM操作。 $(() => { $('.comment>a').on('click', (evt) => { evt.preventDefault(); let a = $(evt.target) let span = a.next() $.getJSON(a.attr('href'), (json) => { if (json.code == 200) { span.text(parseInt(span.text()) + 1) } else { alert(json.hint) } }) }) }) 小结 到此为止，这个投票项目的核心功能已然完成，在下面的章节中我们会要求用户必须登录才能投票，没有账号的用户可以通过注册功能注册一个账号。 "},"Python/第三方库/Django/04-Django模板系统.html":{"url":"Python/第三方库/Django/04-Django模板系统.html","title":"Django模板系统","keywords":"","body":"datetime:2019/6/10 15:35 author:nzb Django模板系统 官方文档 常见语法 只需要记两种特殊符号： { { } }和 { % % } 变量相关的用{ {} }，逻辑相关的用{ %% }。 变量 在Django的模板语言中按此语法使用：{ { 变量名 } }。 当模版引擎遇到一个变量，它将计算这个变量，然后用结果替换掉它本身。 变量的命名包括任何字母数字以及下划线 (\"_\")的组合。 变量名称中不能有空格或标点符号。 点（.）在模板语言中有特殊的含义。当模版系统遇到点(\".\")，它将以这样的顺序查询： 字典查询（Dictionary lookup） 属性或方法查询（Attribute or method lookup） 数字索引查询（Numeric index lookup） 注意事项： 如果计算结果的值是可调用的，它将被无参数的调用。 调用的结果将成为模版的值。 如果使用的变量不存在， 模版系统将插入 string_if_invalid 选项的值， 它被默认设置为'' (空字符串) 。 # 几个例子： # view中代码： def template_test(request): l = [11, 22, 33] d = {\"name\": \"alex\"} class Person(object): def __init__(self, name, age): self.name = name self.age = age def dream(self): return \"{} is dream...\".format(self.name) Alex = Person(name=\"Alex\", age=34) Egon = Person(name=\"Egon\", age=9000) Eva_J = Person(name=\"Eva_J\", age=18) person_list = [Alex, Egon, Eva_J] return render(request, \"template_test.html\", {\"l\": l, \"d\": d, \"person_list\": person_list}) # 模板中支持的写法： {# 取l中的第一个参数 #} { { l.0 } } {# 取字典中key的值 #} { { d.name } } {# 取对象的name属性 #} { { person_list.0.name } } {# .操作只能调用不带参数的方法 #} { { person_list.0.dream } } Filters(过滤器) 在Django的模板语言中，通过使用 过滤器 来改变变量的显示。 过滤器的语法： { { value|filter_name:参数 } } 使用管道符\"|\"来应用过滤器。 例如：{ { name|lower } }会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 注意事项： 过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。 过滤器可以接受参数，例如：{ { sss|truncatewords:30 } }，这将显示sss的前30个词。 过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：{ { list|join:', ' } } '|'左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器。 default 如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值。 { { value|default:\"nothing\"} } length 返回值的长度，作用于字符串和列表。 { { value|length } } 返回value的长度，如 value=['a', 'b', 'c', 'd']的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 '13 KB', '4.1 MB', '102 bytes', 等等）。例如： { { value|filesizeformat } } 如果 value 是 123456789，输出将会是 117.7 MB。 slice 切片 { {value|slice:\"2:-1\"} } date 格式化 { { value|date:\"Y-m-d H:i:s\"} } 可用的参数： 格式化字符 描述 示例输出 a 'a.m.'或'p.m.'（请注意，这与PHP的输出略有不同，因为这包括符合Associated Press风格的期间） 'a.m.' A 'AM'或'PM'。 'AM' b 月，文字，3个字母，小写。 'jan' B 未实现。 c ISO 8601格式。 （注意：与其他格式化程序不同，例如“Z”，“O”或“r”，如果值为naive datetime，则“c”格式化程序不会添加时区偏移量（请参阅datetime.tzinfo） 。 2008-01-02T10:30:00.000123+02:00或2008-01-02T10:30:00.000123如果datetime是天真的 d 月的日子，带前导零的2位数字。 '01'到'31' D 一周中的文字，3个字母。 “星期五” e 时区名称 可能是任何格式，或者可能返回一个空字符串，具体取决于datetime。 ''、'GMT'、'-500'、'US/Eastern'等 E 月份，特定地区的替代表示通常用于长日期表示。 'listopada'（对于波兰语区域，而不是'Listopad'） f 时间，在12小时的小时和分钟内，如果它们为零，则分钟停留。 专有扩展。 '1'，'1:30' F 月，文，长。 '一月' g 小时，12小时格式，无前导零。 '1'到'12' G 小时，24小时格式，无前导零。 '0'到'23' h 小时，12小时格式。 '01'到'12' H 小时，24小时格式。 '00'到'23' i 分钟。 '00'到'59' I 夏令时间，无论是否生效。 '1'或'0' j 没有前导零的月份的日子。 '1'到'31' l 星期几，文字长。 '星期五' L 布尔值是否是一个闰年。 True或False m 月，2位数字带前导零。 '01'到'12' M 月，文字，3个字母。 “扬” n 月无前导零。 '1'到'12' N 美联社风格的月份缩写。 专有扩展。 'Jan.'，'Feb.'，'March'，'May' o ISO-8601周编号，对应于使用闰年的ISO-8601周数（W）。 对于更常见的年份格式，请参见Y。 '1999年' O 与格林威治时间的差异在几小时内。 '+0200' P 时间为12小时，分钟和'a.m。'/'p.m。'，如果为零，分钟停留，特殊情况下的字符串“午夜”和“中午”。 专有扩展。 '1 am'，'1:30 pm' / t3>，'midnight'，'noon'，'12：30 pm' / T10> r RFC 5322格式化日期。 'Thu, 21 Dec 2000 16:01:07 +0200' s 秒，带前导零的2位数字。 '00'到'59' S 一个月的英文序数后缀，2个字符。 'st'，'nd'，'rd'或'th' t 给定月份的天数。 28 to 31 T 本机的时区。 'EST'，'MDT' u 微秒。 000000 to 999999 U 自Unix Epoch以来的二分之一（1970年1月1日00:00:00 UTC）。 w 星期几，数字无前导零。 '0'（星期日）至'6'（星期六） W ISO-8601周数，周数从星期一开始。 1，53 y 年份，2位数字。 '99' Y 年，4位数。 '1999年' z 一年中的日子 0到365 Z 时区偏移量，单位为秒。 UTC以西时区的偏移量总是为负数，对于UTC以东时，它们总是为正。 -43200到43200 safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 比如： value = \"点我\" { { value|safe} } truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“...”）结尾。 参数：截断的字符数 { { value|truncatechars:9} } truncatewords 在一定数量的字后截断字符串。 { { value|truncatewords:9} } cut 移除value中所有的与给出的变量相同的字符串 { { value|cut:' ' } } 如果value为'i love you'，那么将输出'iloveyou'. join 使用字符串连接列表，例如Python的str.join(list) timesince 将日期格式设为自该日期起的时间（例如，“4天，6小时”）。 采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在）。 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”： { { blog_date|timesince:comment_date } } 分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。 timeuntil 似于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则{ { conference_date | timeuntil } }将返回“4周”。 使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”： { { conference_date|timeuntil:from_date } } 自定义filter 自定义过滤器只是带有一个或两个参数的Python函数: 变量（输入）的值 - -不一定是一个字符串 参数的值 - 这可以有一个默认值，或完全省略 例如，在过滤器{ {var | foo:'bar'} }中，过滤器foo将传递变量var和参数“bar”。 自定义filter代码文件摆放位置： app01/ __init__.py models.py templatetags/ # 在app01下面新建一个package package __init__.py app01_filters.py # 建一个存放自定义filter的文件 views.py 编写自定义filter: from django import template register = template.Library() @register.filter(name=\"cut\") def cut(value, arg): return value.replace(arg, \"\") @register.filter(name=\"addSB\") def add_sb(value): return \"{} SB\".format(value) 使用自定义filter: {# 先导入我们自定义filter那个文件 #} { % load app01_filters % } {# 使用我们自定义的filter #} { { somevariable|cut:\"0\" } } { { d.name|addSB } } Tags for循环 普通for循环 { % for user in user_list % } { { user.name } } { % endfor % } for循环可用的一些参数： Variable Description forloop.counter 当前循环的索引值（从1开始） forloop.counter0 当前循环的索引值（从0开始） forloop.revcounter 当前循环的倒序索引值（从1开始） forloop.revcounter0 当前循环的倒序索引值（从0开始） forloop.first 当前循环是不是第一次循环（布尔值） forloop.last 当前循环是不是最后一次循环（布尔值） forloop.parentloop 本层循环的外层循环 for ... empty { % for user in user_list % } { { user.name } } { % empty % } 空空如也 { % endfor % } if判断 if,elif和else { % if user_list % } 用户人数：{ { user_list|length } } { % elif black_list % } 黑名单数：{ { black_list|length } } { % else % } 没有用户 { % endif % } 当然也可以只有if和else { % if user_list|length > 5 % } 七座豪华SUV { % else % } 黄包车 { % endif % } if语句支持 and 、or、==、>、=、in、not in、is、is not判断。 with 定义一个中间变量，多用于给一个复杂的变量起别名。 注意等号左右不要加空格。 { % with total=business.employees.count % } { { total } } employee{ { total|pluralize } } { % endwith % } 或 { % with business.employees.count as total % } { { total } } employee{ { total|pluralize } } { % endwith % } csrf_token 这个标签用于跨站请求伪造保护。 在页面的form表单里面写上{ % csrf_token % } 注释 {# ... #} 注意事项 Django的模板语言不支持连续判断，即不支持以下写法： { % if a > b > c % } ... { % endif % } Django的模板语言中属性的优先级大于方法 def xx(request): d = {\"a\": 1, \"b\": 2, \"c\": 3, \"items\": \"100\"} return render(request, \"xx.html\", {\"data\": d}) 如上，我们在使用render方法渲染一个页面的时候，传的字典d有一个key是items并且还有默认的 d.items() 方法，此时在模板语言中: { { data.items } } 默认会取d的items key的值。 母版 Title { % block page-css % } { % endblock % } 这是母板的标题 { % block page-main % } { % endblock % } 母板底部内容 { % block page-js % } { % endblock % } 继承母版 在子页面中在页面最上方使用下面的语法来继承母板。 { % extends 'layouts.html' % } 块(block) 通过在母板中使用{ % block xxx % }来定义\"块\"。 在子页面中通过定义母板中的block名来对应替换母板中相应的内容。 { % block page-main % } 世情薄 人情恶 雨送黄昏花易落 { % endblock % } 组件 可以将常用的页面内容如导航条，页尾信息等组件保存在单独的文件中，然后在需要使用的地方按如下语法导入即可。 { % include 'navbar.html' % } 静态文件相关 { % static % } { % load static % } 引用JS文件时使用： { % load static % } 某个文件多处被用到可以存为一个变量 { % load static % } { % static \"images/hi.jpg\" as myphoto % } { % get_static_prefix % } { % load static % } 或者 { % load static % } { % get_static_prefix as STATIC_PREFIX % } simple_tag 和自定义filter类似，只不过接收更灵活的参数。 定义注册simple tag @register.simple_tag(name=\"plus\") def plus(a, b, c): return \"{} + {} + {}\".format(a, b, c) 使用自定义simple tag { % load app01_demo % } {# simple tag #} { % plus \"1\" \"2\" \"abc\" % } inclusion_tag 多用于返回html代码片段 示例： templatetags/my_inclusion.py from django import template register = template.Library() @register.inclusion_tag('result.html') def show_results(n): n = 1 if n templates/snippets/result.html { % for choice in data % } { { choice } } { % endfor % } templates/index.html inclusion_tag test { % load inclusion_tag_test % } { % show_results 10 % } 模板中或序列化中choice类型字段的值 模板中 { { obj.get_column_display } } 序列化中 column = serializers.CharField(source='get_column_display') "},"Python/第三方库/Django/05-Django的View.html":{"url":"Python/第三方库/Django/05-Django的View.html","title":"Django的View(视图)","keywords":"","body":"datetime:2019/6/11 11:10 author:nzb Django的View(视图) 一个视图函数（类），简称视图，是一个简单的Python 函数（类），它接受Web请求并且返回Web响应。 响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片。 无论视图本身包含什么逻辑，都要返回响应。代码写在哪里也无所谓，只要它在你当前项目目录下面。 除此之外没有更多的要求了——可以说“没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为views.py的文件中。 一个简单的视图 # 下面是一个以HTML文档的形式返回当前日期和时间的视图： from django.http import HttpResponse import datetime def current_datetime(request): now = datetime.datetime.now() html = \"It is now %s.\" % now return HttpResponse(html) 让我们来逐行解释下上面的代码： 首先，我们从 django.http模块导入了HttpResponse类，以及Python的datetime库。 接着，我们定义了current_datetime函数。它就是视图函数。每个视图函数都使用HttpRequest对象作为第一个参数，并且通常称之为request。 注意，视图函数的名称并不重要；不需要用一个统一的命名方式来命名，以便让Django识别它。我们将其命名为current_datetime，是因为这个名称能够比较准确地反映出它实现的功能。 这个视图会返回一个HttpResponse对象，其中包含生成的响应。每个视图函数都负责返回一个HttpResponse对象。 Django使用请求和响应对象来通过系统传递状态。 当浏览器向服务端请求一个页面时，Django创建一个HttpRequest对象，该对象包含关于请求的元数据。然后，Django加载相应的视图，将这个HttpRequest对象作为第一个参数传递给视图函数。 每个视图负责返回一个HttpResponse对象。 CBV和FBV 我们之前写过的都是基于函数的view，就叫FBV。还可以把view写成基于类的。 就拿我们之前写过的添加班级为例： FBV版 # FBV版添加班级 def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") CBV版 # CBV版添加班级 from django.views import View class AddClass(View): def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") # 注意： # 使用CBV时，urls.py中也做对应的修改： # urls.py中 url(r'^add_class/$', views.AddClass.as_view()), 给视图加装饰器 使用装饰器装饰FBV # FBV本身就是一个函数，所以和给普通的函数加装饰器无差： def wrapper(func): def inner(*args, **kwargs): start_time = time.time() ret = func(*args, **kwargs) end_time = time.time() print(\"used:\", end_time-start_time) return ret return inner # FBV版添加班级 @wrapper def add_class(request): if request.method == \"POST\": class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") return render(request, \"add_class.html\") 使用装饰器装饰CBV # 类中的方法与独立函数不完全相同，因此不能直接将函数装饰器应用于类中的方法 ，我们需要先将其转换为方法装饰器。 # Django中提供了method_decorator装饰器用于将函数装饰器转换为方法装饰器。 # CBV版添加班级 from django.views import View from django.utils.decorators import method_decorator class AddClass(View): @method_decorator(wrapper) def get(self, request): return render(request, \"add_class.html\") def post(self, request): class_name = request.POST.get(\"class_name\") models.Classes.objects.create(name=class_name) return redirect(\"/class_list/\") # 使用CBV时要注意，请求过来后会先执行dispatch()这个方法，如果需要批量对具体的请求处理方法，如get，post等做一些操作的时候，这里我们可以手动改写dispatch方法，这个dispatch方法就和在FBV上加装饰器的效果一样。 class Login(View): def dispatch(self, request, *args, **kwargs): print('before') obj = super(Login,self).dispatch(request, *args, **kwargs) print('after') return obj def get(self,request): return render(request,'login.html') def post(self,request): print(request.POST.get('user')) return HttpResponse('Login.post') Request对象和Response对象 request对象 当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。 Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 官方文档 请求相关的常用值 path_info 返回用户访问url，不包括域名 method 请求中使用的HTTP方法的字符串表示，全大写表示。 GET 包含所有HTTP GET参数的类字典对象 POST 包含所有HTTP POST参数的类字典对象 body 请求体，byte类型 request.POST的数据就是从body里面提取到的 属性 所有的属性应该被认为是只读的，除非另有说明。 属性： 　　django将请求报文中的请求行、头部信息、内容主体封装成 HttpRequest 类中的属性。 除了特殊说明的之外，其他均为只读的。 0. HttpRequest.scheme 表示请求方案的字符串（通常为http或https） 1. HttpRequest.body 　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。 　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。 　　另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。 2. HttpRequest.path 　　一个字符串，表示请求的路径组件（不含域名）。 　　例如：\"/music/bands/the_beatles/\" 3. HttpRequest.method 　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。 　　例如：\"GET\"、\"POST\" 4. HttpRequest.encoding 　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 'utf-8'）。 这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。 接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。 如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。 5. HttpRequest.GET 　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。 6. HttpRequest.POST 　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。 　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。 因此，不应该使用 if request.POST 来检查使用的是否是POST 方法；应该使用 if request.method == \"POST\" 　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 7. HttpRequest.COOKIES 　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。 8. HttpRequest.FILES 　　一个类似于字典的对象，包含所有的上传文件信息。 FILES 中的每个键为 中的name，值则为对应的数据。 　　注意，FILES 只有在请求的方法为POST 且提交的 带有enctype=\"multipart/form-data\" 的情况下才会 包含数据。否则，FILES 将为一个空的类似于字典的对象。 9. HttpRequest.META 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如\"GET\" 或\"POST\"。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时， 都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_ 前缀。 所以，一个叫做 X-Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。 10. HttpRequest.user 　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。 例如： if request.user.is_authenticated(): # Do something for logged-in users. else: # Do something for anonymous users. 　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。 ------------------------------------------------------------------------------------- 匿名用户 class models.AnonymousUser django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点： id 永远为None。 username 永远为空字符串。 get_username() 永远返回空字符串。 is_staff 和 is_superuser 永远为False。 is_active 永远为 False。 groups 和 user_permissions 永远为空。 is_anonymous() 返回True 而不是False。 is_authenticated() 返回False 而不是True。 set_password()、check_password()、save() 和delete() 引发 NotImplementedError。 New in Django 1.8: 新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。 11. HttpRequest.session 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。 完整的细节参见会话的文档。 request属性相关 上传文件示例 def upload(request): \"\"\" 保存上传文件前，数据需要存放在某个位置。默认当上传文件小于2.5M时，django会将上传文件的全部内容读进内存。从内存读取一次，写磁盘一次。 但当上传文件很大时，django会把上传文件写到临时文件中，然后存放到系统临时文件夹中。 :param request: :return: \"\"\" if request.method == \"POST\": # 从请求的FILES中获取上传文件的文件名，file为页面上type=files类型input的name属性值 filename = request.FILES[\"file\"].name # 在项目目录下新建一个文件 with open(filename, \"wb\") as f: # 从上传的文件对象中一点一点读 for chunk in request.FILES[\"file\"].chunks(): # 写入本地文件 f.write(chunk) return HttpResponse(\"上传OK\") 方法 1.HttpRequest.get_host() 　　根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。 如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。 　　USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。 　　例如：\"127.0.0.1:8000\" 　　注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。 2.HttpRequest.get_full_path() 　　返回 path，如果可以将加上查询字符串。 　　例如：\"/music/bands/the_beatles/?print=true\" 3.HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 　　返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。 　　如果提供 default 参数，将不会引发异常并返回 default 的值。 　　可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。 复制代码 >>> request.get_signed_cookie('name') 'Tony' >>> request.get_signed_cookie('name', salt='name-salt') 'Tony' # 假设在设置cookie的时候使用的是相同的salt >>> request.get_signed_cookie('non-existing-cookie') ... KeyError: 'non-existing-cookie' # 没有相应的键时触发异常 >>> request.get_signed_cookie('non-existing-cookie', False) False >>> request.get_signed_cookie('cookie-that-was-tampered-with') ... BadSignature: ... >>> request.get_signed_cookie('name', max_age=60) ... SignatureExpired: Signature age 1677.3839159 > 60 seconds >>> request.get_signed_cookie('name', False, max_age=60) False 复制代码 4.HttpRequest.is_secure() 　　如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。 5.HttpRequest.is_ajax() 　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。 　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。 注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用： request.POST.getlist(\"hobby\") Response对象 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 使用 传递字符串 from django.http import HttpResponse response = HttpResponse(\"Here's the text of the Web page.\") response = HttpResponse(\"Text only, please.\", content_type=\"text/plain\") 设置或删除响应头信息 response = HttpResponse() response['Content-Type'] = 'text/html; charset=UTF-8' del response['Content-Type'] 属性 HttpResponse.content：响应内容 HttpResponse.charset：响应内容的编码 HttpResponse.status_code：响应的状态码 JsonResponse对象 JsonResponse是HttpResponse的子类，专门用来生成JSON编码的响应。 from django.http import JsonResponse response = JsonResponse({'foo': 'bar'}) print(response.content) b'{\"foo\": \"bar\"}' 默认只能传递字典类型，如果要传递非字典类型需要设置一下safe关键字参数。 response = JsonResponse([1, 2, 3], safe=False) Django shortcut functions 官方文档 render() 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。 参数： request： 用于生成响应的请求对象。 template_name：要使用的模板的完整名称，可选的参数 context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。 content_type：生成的文档要使用的MIME类型。默认为 DEFAULT_CONTENT_TYPE 设置的值。默认为'text/html' status：响应的状态码。默认为200。 　　　useing: 用于加载模板的模板引擎的名称。 一个简单的例子： from django.shortcuts import render def my_view(request): # 视图的代码写在这里 return render(request, 'myapp/index.html', {'foo': 'bar'}) 上面的代码等于： from django.http import HttpResponse from django.template import loader def my_view(request): # 视图代码写在这里 t = loader.get_template('myapp/index.html') c = {'foo': 'bar'} return HttpResponse(t.render(c, request)) redirect() 参数可以是： 一个模型：将调用模型的get_absolute_url() 函数 一个视图，可以带有参数：将使用urlresolvers.reverse 来反向解析名称 一个绝对的或相对的URL，将原封不动的作为重定向的位置。 默认返回一个临时的重定向；传递permanent=True 可以返回一个永久的重定向。 示例: 你可以用多种方式使用redirect() 函数。 传递一个具体的ORM对象（了解即可） 将调用具体ORM对象的get_absolute_url() 方法来获取重定向的URL： from django.shortcuts import redirect def my_view(request): ... object = MyModel.objects.get(...) return redirect(object) 传递一个视图的名称 def my_view(request): ... return redirect('some-view-name', foo='bar') 传递要重定向到的一个具体的网址 def my_view(request): ... return redirect('/some/url/') 当然也可以是一个完整的网址 def my_view(request): ... return redirect('http://example.com/') 默认情况下，redirect() 返回一个临时重定向。以上所有的形式都接收一个permanent 参数；如果设置为True，将返回一个永久的重定向： def my_view(request): ... object = MyModel.objects.get(...) return redirect(object, permanent=True) 扩展阅读： 临时重定向（响应状态码：302）和永久重定向（响应状态码：301）对普通用户来说是没什么区别的，它主要面向的是搜索引擎的机器人。 A页面临时重定向到B页面，那搜索引擎收录的就是A页面。 A页面永久重定向到B页面，那搜索引擎收录的就是B页面。 "},"Python/第三方库/Django/06-Django的路由系统.html":{"url":"Python/第三方库/Django/06-Django的路由系统.html","title":"Django的路由系统","keywords":"","body":"datetime:2019/6/11 16:27 author:nzb Django的路由系统 Django 1.11版本 URLConf官方文档 URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL与要为该URL调用的视图函数之间的映射表。 你就是以这种方式告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。 URLconfs配置 基本格式 from django.conf.urls import url urlpatterns = [ url(正则表达式, views视图函数，参数，别名), ] 注意： Django 2.0版本中的路由系统已经替换成下面的写法(官方文档)： from django.urls import path urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles//', views.year_archive), path('articles///', views.month_archive), path('articles////', views.article_detail), ] 参数说明 正则表达式：一个正则表达式字符串 views视图函数：一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 参数：可选的要传递给视图函数的默认参数（字典形式） 别名：一个可选的name参数 正则表达式详解 基本配置 from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/([0-9]{4})/$', views.year_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive), url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail), ] 注意事项 urlpatterns中的元素按照书写顺序从上往下逐一匹配正则表达式，一旦匹配成功则不再继续。 若要从URL中捕获一个值，只需要在它周围放置一对圆括号（分组匹配）。 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是^articles 而不是 ^/articles。 每个正则表达式前面的'r' 是可选的但是建议加上。 补充说明 是否开启URL访问地址后面不为/跳转至带有/的路径的配置项 APPEND_SLASH=True Django settings.py配置文件中默认没有 APPEND_SLASH 这个参数，但 Django 默认这个参数为 APPEND_SLASH = True。 其作用就是自动在网址结尾加'/'。 其效果就是： 我们定义了urls.py： from django.conf.urls import url from app01 import views urlpatterns = [ url(r'^blog/$', views.blog), ] 访问 http://www.example.com/blog 时，默认将网址自动转换为 http://www.example/com/blog/ 。 如果在settings.py中设置了 APPEND_SLASH=False，此时我们再请求 http://www.example.com/blog 时就会提示找不到页面。 分组命名匹配 上面的示例使用简单的正则表达式分组匹配（通过圆括号）来捕获URL中的值并以位置参数形式传递给视图。 在更高级的用法中，可以使用分组命名匹配的正则表达式组来捕获URL中的值并以关键字参数形式传递给视图。 在Python的正则表达式中，分组命名正则表达式组的语法是(?Ppattern)，其中name是组的名称，pattern是要匹配的模式。 下面是以上URLconf 使用命名组的重写： from django.conf.urls import url from . import views urlpatterns = [ url(r'^articles/2003/$', views.special_case_2003), url(r'^articles/(?P[0-9]{4})/$', views.year_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/$', views.month_archive), url(r'^articles/(?P[0-9]{4})/(?P[0-9]{2})/(?P[0-9]{2})/$', views.article_detail), ] 这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。 例如，针对url /articles/2017/12/相当于按以下方式调用视图函数： views.month_archive(request, year=\"2017\", month=\"12\") 区别 分组匹配 --> 相当于给视图函数传递位置参数(*args) 分组命名匹配 --> 相当于给视图函数传递关键字参数(**kwargs) 例子： url(r'^articles/2003/$', views.special_case_2003), 分组匹配 url(r'^articles/(?P[0-9]{4})/$', views.year_archive), 分组命名匹配 在实际应用中，使用分组命名匹配的方式可以让你的URLconf 更加明晰且不容易产生参数顺序问题的错误，但是有些开发人员则认为分组命名组语法太丑陋、繁琐。 至于究竟应该使用哪一种，你可以根据自己的喜好来决定。 URLconf匹配的位置 URLconf 在请求的URL 上查找，将它当做一个普通的Python 字符串。不包括GET和POST参数以及域名。 例如，http://www.example.com/myapp/ 请求中，URLconf 将查找myapp/。 在http://www.example.com/myapp/?page=3 请求中，URLconf 仍将查找myapp/。 URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个URL的POST、GET、HEAD等等 —— 都将路由到相同的函数。 捕获的参数永远都是字符串 每个在URLconf中捕获的参数都作为一个普通的Python字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行URLconf 中： url(r'^articles/(?P[0-9]{4})/$', views.year_archive), 传递到视图函数views.year_archive() 中的year 参数永远是一个字符串类型。 视图函数中指定默认值 urls.py中: from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/$', views.page), url(r'^blog/page(?P[0-9]+)/$', views.page), ] # views.py中，可以为num指定默认值 def page(request, num=\"1\"): pass 在上面的例子中，两个URL模式指向相同的view - views.page - 但是第一个模式并没有从URL中捕获任何东西。 如果第一个模式匹配上了，page()函数将使用其默认参数num=“1”,如果第二个模式匹配，page()将使用正则表达式捕获到的num值。 include其他的URLconfs #At any point, your urlpatterns can “include” other URLconf modules. This #essentially “roots” a set of URLs below other ones. #For example, here’s an excerpt of the URLconf for the Django website itself. #It includes a number of other URLconfs: from django.conf.urls import include, url urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^blog/', include('blog.urls')), # 可以包含其他的URLconfs文件 ] 传递额外的参数给视图函数（了解） URLconfs 具有一个钩子，让你传递一个Python 字典作为额外的参数传递给视图函数。 django.conf.urls.url() 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。 例如： from django.conf.urls import url from . import views urlpatterns = [ url(r'^blog/(?P[0-9]{4})/$', views.year_archive, {'foo': 'bar'}), ] 在这个例子中，对于/blog/2005/请求，Django 将调用views.year_archive(request, year='2005', foo='bar')。 这个技术在Syndication 框架中使用，来传递元数据和选项给视图。 命名URL和URL反向解析 本质就是给url匹配模式起别名，然后用别名通过reverse函数反向生成url，在HTML和视图函数中使用，就不会因为后期url的改变而出现404。 在使用Django 项目时，一个常见的需求是获得URL的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。 人们强烈希望不要硬编码这些URL（费力、不可扩展且容易产生错误）或者设计一种与URLconf 毫不相关的专门的URL 生成机制，因为这样容易导致一定程度上产生过期的URL。 换句话讲，需要的是一个DRY 机制。除了其它有点，它还允许设计的URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的URL。 获取一个URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。 Django 提供一个办法是让URL 映射是URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它： 根据用户/浏览器发起的URL 请求，它调用正确的Django 视图，并从URL 中提取它的参数需要的值。 根据Django 视图的标识和将要传递给它的参数的值，获取与之关联的URL。 第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做反向解析URL、反向URL 匹配、反向URL 查询或者简单的URL 反查。 在需要URL 的地方，对于不同层级，Django 提供不同的工具用于URL 反查： 在模板中：使用url模板标签。 在Python 代码中：使用django.core.urlresolvers.reverse() 函数。 在更高层的与处理Django 模型实例相关的代码中：使用get_absolute_url() 方法。 上面说了一大堆，你可能并没有看懂。（那是官方文档的生硬翻译）。 咱们简单来说就是可以给我们的URL匹配规则起个名字，一个URL匹配模式起一个名字。 这样我们以后就不需要写死URL代码了，只需要通过名字来调用当前的URL。 举个简单的例子： url(r'^home', views.home, name='home'), # 给我的url匹配模式起名为 home url(r'^index/(\\d*)', views.index, name='index'), # 给我的url匹配模式起名为index 这样： 在模板里面可以这样引用： { % url 'home' % } 在views函数中可以这样引用： from django.urls import reverse reverse(\"index\", args=(\"2018\", )) 例子： 考虑下面的URLconf： from django.conf.urls import url from . import views urlpatterns = [ # ... url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'), # ... ] 根据这里的设计，某一年nnnn对应的归档的URL是/articles/nnnn/。 你可以在模板的代码中使用下面的方法获得它们： 2012 Archive { % for yearvar in year_list % } { { yearvar } } Archive { % endfor % } 在Python 代码中，这样使用： from django.urls import reverse from django.shortcuts import redirect def redirect_to_year(request): # ... year = 2006 # ... return redirect(reverse('news-year-archive', args=(year,))) 如果出于某种原因决定按年归档文章发布的URL应该调整一下，那么你将只需要修改URLconf 中的内容。 在某些场景中，一个视图是通用的，所以在URL 和视图之间存在多对一的关系。对于这些情况，当反查URL 时，只有视图的名字还不够。 注意： 为了完成上面例子中的URL 反查，你将需要使用命名的URL 模式。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的Python 名称。 当命名你的URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的URL 模式叫做comment，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个URL。 在URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用myapp-comment 而不是comment。 命名空间模式 即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 举个例子： project中的urls.py from django.conf.urls import url, include urlpatterns = [ url(r'^app01/', include('app01.urls', namespace='app01')), url(r'^app02/', include('app02.urls', namespace='app02')), ] app01中的urls.py from django.conf.urls import url from app01 import views app_name = 'app01' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] app02中的urls.py from django.conf.urls import url from app02 import views app_name = 'app02' urlpatterns = [ url(r'^(?P\\d+)/$', views.detail, name='detail') ] 现在，我的两个app中 url名称重复了，我反转URL的时候就可以通过命名空间的名称得到我当前的URL。 语法： '命名空间名称:URL名称' 模板中使用： { % url 'app01:detail' pk=12 pp=99 % } views中的函数中使用 v = reverse('app01:detail', kwargs={'pk':11}) 这样即使app中URL的命名相同，我也可以反转得到正确的URL了。 "},"Python/第三方库/Django/07-Django-ORM相关操作.html":{"url":"Python/第三方库/Django/07-Django-ORM相关操作.html","title":"Django ORM相关操作","keywords":"","body":"datetime:2019/6/12 16:47 author:nzb Django ORM相关操作 一般操作 官方文档 必知必会13条 all(): 查询所有结果 filter(**kwargs): 它包含了与所给筛选条件相匹配的对象 get(**kwargs): 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。 exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象 values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列，需要哪些字段就写进去。 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 order_by(*field): 对查询结果排序 reverse(): 对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。 distinct(): 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。) count(): 返回数据库中匹配查询(QuerySet)的对象数量。 first(): 返回第一条记录 last(): 返回最后一条记录 exists(): 如果QuerySet包含数据，就返回True，否则返回False values()方法例子： 返回QuerySet对象的方法有 all() filter() exclude() order_by() reverse() distinct() 特殊QuerySet values() 返回一个可迭代的字典序列 values_list() 返回一个可迭代的元祖序列 返回具体对象的 get() first() last() 返回布尔值的方法有 exists() 返回数字的方法有 count() 单表查询之神奇的双下划线 models.Tb1.objects.filter(id__lt=10, id__gt=1) # 获取id大于1 且 小于10的值 models.Tb1.objects.filter(id__in=[11, 22, 33]) # 获取id等于11、22、33的数据 models.Tb1.objects.exclude(id__in=[11, 22, 33]) # not in models.Tb1.objects.filter(name__contains=\"ven\") # 获取name字段包含\"ven\"的 models.Tb1.objects.filter(name__icontains=\"ven\") # icontains大小写不敏感 models.Tb1.objects.filter(id__range=[1, 3]) # id范围是1到3的，等价于SQL的bettwen and 类似的还有：startswith，istartswith, endswith, iendswith　 date字段还可以： models.Class.objects.filter(first_day__year=2017) ForeignKey操作 正向查找 对象查找(跨表) 这是对对象进行操作，不能values()和values_list() 语法： 对象.关联字段.字段 示例： book_obj = models.Book.objects.first() # 第一本书对象 print(book_obj.publisher) # 得到这本书关联的出版社对象 print(book_obj.publisher.name) # 得到出版社对象的名称 字段查找(跨表) 这是对QuerySet进行操作，可以 values()和values_list() 语法： 关联字段__字段 示例： print(models.Book.objects.values_list(\"publisher__name\")) # 双下划线表示跨表 反向操作 对象查找 语法： obj.表名_set 示例： publisher_obj = models.Publisher.objects.first() # 找到第一个出版社对象 books = publisher_obj.book_set.all() # 找到第一个出版社出版的所有书 titles = books.values_list(\"title\") # 找到第一个出版社出版的所有书的书名 如果外键字段设置了：related_name：用于获取关联对象的关联管理器对象（反向查询），如果不允许反向，该属性应该被设置为'+'，或者以'+'结尾。 例子： course = models.ForeignKey(Course, verbose_name=u'课程', on_delete=models.CASCADE, related_name='course') 语法： 未设置： **obj.表名_set** 设置： **obj.course** 字段查找 语法： 表名__字段 示例： titles = models.Publisher.objects.values_list(\"book__title\") OneToOneField 当一张表的某些字段查询的比较繁琐，另外一些字段查询的不是特别繁琐，把不怎么常用的字段单独拿出来做成一张表，然后用一对一关联起来。 优势： 既保证数据能完整的保存下来，有能保证大部分的检索更快。 用法： OneToOneField(to=\"\") 例子： 作者 class Author(models.Model): name = models.CharField(max_length=12) age = models.IntegerField() phone = models.IntegerField() detail = models.OneToOneField(to=\"AuthorDetail\") def __str__(self): return self.name 作者详情 class AuthorDetail(models.Model): 爱好 hobby = models.CharField(max_length=32) 地址 addr = models.CharField(max_length=128) ManyToManyField class RelatedManager \"关联管理器\"是在一对多或者多对多的关联上下文中使用的管理器。 它存在于下面两种情况： 外键关系的反向查询 多对多关联关系 简单来说就是当 点后面的对象 可能存在多个的时候就可以使用以下的方法。 方法 create() 创建一个新的对象，保存对象，并将它添加到关联对象集之中，返回新创建的对象。 >>> import datetime >>> models.Author.objects.first().book_set.create(title=\"番茄物语\", publish_date=datetime.date.today()) add() 把指定的model对象添加到关联对象集中。 添加对象 >>> author_objs = models.Author.objects.filter(id__lt=3) >>> models.Book.objects.first().authors.add(*author_objs) 添加id >>> models.Book.objects.first().authors.add(*[1, 2]) set() 更新model对象的关联对象。 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.set([2, 3]) remove() 从关联对象集中移除执行的model对象 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.remove(3) clear() 从关联对象集中移除一切对象。 >>> book_obj = models.Book.objects.first() >>> book_obj.authors.clear() 注意： 对于ForeignKey对象，clear()和remove()方法仅在null=True时存在。 举个例子： ForeignKey字段没设置null=True时， class Book(models.Model): title = models.CharField(max_length=32) publisher = models.ForeignKey(to=Publisher) 没有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() Traceback (most recent call last): File \"\", line 1, in AttributeError: 'RelatedManager' object has no attribute 'clear' 当ForeignKey字段设置null=True时， class Book(models.Model): name = models.CharField(max_length=32) publisher = models.ForeignKey(to=Class, null=True) 此时就有clear()和remove()方法： >>> models.Publisher.objects.first().book_set.clear() 注意： 对于所有类型的关联字段，add()、create()、remove()和clear(),set()都会马上更新数据库。换句话说，在关联的任何一端，都不需要再调用save()方法。 自己创建第三张表 多对多的方式 ORM自动创建第三种表 自己创建第三张表，利用外键分别关联作者和书 关联查询比较麻烦，因为没办法使用ORM提供的便利方法 自己创建第三张表，使用ORM 的ManyToManyField() 使用此种方式创建多对多表的时候，没有add()、remove()等方法 而是直接操作第三张表 使用方法(依情况而定)： 如果你第三张表没有额外的字段，就用第一种 如果你第三张表有额外的字段，就用第三种或第一种 # 作者 class Author(models.Model): name = models.CharField(max_length=12) age = models.IntegerField() phone = models.IntegerField() # 通过through=\"AuthorBook\",through_fields=(\"author\", \"book\") 来指定使用我创建的第三张表来构建多对多的关系，而不是django自动创建的 book = models.ManyToManyField(to=\"Book\", through=\"AuthorBook\", through_fields=(\"author\", \"book\")) # through_field中，第一个字段，多对多设置在哪一张表里，第三张表通过什么字段找到这张表，就把这个字段写在前面，有关联关系的才要写进去 detail = models.OneToOneField(to=\"AuthorDetail\") def __str__(self): return self.name # 书 class Book(models.Model): name = models.CharField(max_length=50) # 自己创建作者和书关联的第三张表 # 此时，在ORM层面 作者和书就没有多对多的关系了 class AuthorBook(models.Model): # 作者id author = models.ForeignKey(to=\"Author\") # 书id book = models.ForeignKey(to=\"Book\") # 其他字段 info = models.CharField(max_length=12) class Meta: # 作者id和书id联合唯一 unique_together = ('author', 'book') 聚合查询和分组查询 聚合 aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。 键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 用到的内置函数： from django.db.models import Avg, Sum, Max, Min, Count 示例： >>> from django.db.models import Avg, Sum, Max, Min, Count >>> models.Book.objects.all().aggregate(Avg(\"price\")) {'price__avg': 13.233333} 如果你想要为聚合值指定一个名称，可以向聚合子句提供它。 >>> models.Book.objects.aggregate(average_price=Avg('price')) {'average_price': 13.233333} 如果你希望生成不止一个聚合，你可以向aggregate()子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询： >>> models.Book.objects.all().aggregate(Avg(\"price\"), Max(\"price\"), Min(\"price\")) {'price__avg': 13.233333, 'price__max': Decimal('19.90'), 'price__min': Decimal('9.90')} 分组 我们在这里先复习一下SQL语句的分组。 假设现在有一张公司职员表： 我们使用原生SQL语句，按照部分分组求平均工资： select dept,AVG(salary) from employee group by dept; ORM查询: from django.db.models import Avg Employee.objects.values(\"dept\").annotate(avg=Avg(\"salary\").values(\"dept\", \"avg\") # values()就是取哪些字段，同时具有分组的作用。 连表查询的分组： SQL查询： select dept.name,AVG(salary) from employee inner join dept on (employee.dept_id=dept.id) group by dept_id; ORM查询： from django.db.models import Avg models.Employee.objects.values('dept_id').annotate(avg=Avg('salary')).values('dept__name', 'avg') # 或 models.Dept.objects.annotate(avg=Avg(\"employee__salary\")).values(\"name\", \"avg\") extra()方法分组 extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None) 有些情况下，Django的查询语法难以简单的表达复杂的 WHERE 子句，对于这种情况, Django 提供了 extra() QuerySet修改机制 — 它能在 QuerySet生成的SQL从句中注入新子句 extra可以指定一个或多个 参数,例如 select, where or tables. 这些参数都不是必须的，但是你至少要使用一个!要注意这些额外的方式对不同的数据库引擎可能存在移植性问题.(因为你在显式的书写SQL语句),除非万不得已,尽量避免这样做 参数之select The select 参数可以让你在 SELECT 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。 queryResult=models.Article 　　　　　　　　　　　.objects.extra(select={'is_recent': \"create_time > '2017-09-05'\"}) 结果集中每个 Entry 对象都有一个额外的属性is_recent, 它是一个布尔值，表示 Article对象的create_time 是否晚于2017-09-05. article_obj=models.Article.objects.filter(nid=1).extra(select={\"standard_time\":\"strftime('%%Y-%%m-%%d',create_time)\"}).values(\"standard_time\",\"nid\",\"title\") print(article_obj) # 参数之where / tables 您可以使用where定义显式SQL WHERE子句 - 也许执行非显式连接。您可以使用tables手动将表添加到SQL FROM子句。 where和tables都接受字符串列表。所有where参数均为“与”任何其他搜索条件。 queryResult=models.Article.objects.extra(where=['nid in (1,3) OR title like \"py%\" ','nid>2']) 运用 按日查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y-%%m-%%d')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 按月查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y-%%m')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 按年查询ret = Spenging.objects.extra(select={'date':\"DATE_FORMAT(date,'%%Y')\"}).values(\"date\").annotate(total=Sum(\"money\")).values(\"date\", \"total\") 更多示例 示例1：统计每一本书的作者个数 >>> book_list = models.Book.objects.all().annotate(author_num=Count(\"author\")) >>> for obj in book_list: ... print(obj.author_num) ... 2 1 1 示例2：统计出每个出版社买的最便宜的书的价格 >>> publisher_list = models.Publisher.objects.annotate(min_price=Min(\"book__price\")) >>> for obj in publisher_list: ... print(obj.min_price) ... 9.90 19.90 方法二： >>> models.Book.objects.values(\"publisher__name\").annotate(min_price=Min(\"price\")) 示例3：统计不止一个作者的图书 >>> models.Book.objects.annotate(author_num=Count(\"author\")).filter(author_num__gt=1) ]> 示例4：根据一本图书作者数量的多少对查询集 QuerySet进行排序 >>> models.Book.objects.annotate(author_num=Count(\"author\")).order_by(\"author_num\") , , ]> 示例5：查询各个作者出的书的总价格 >>> models.Author.objects.annotate(sum_price=Sum(\"book__price\")).values(\"name\", \"sum_price\") 示例6：查询动态最多的组织并排序 >>> model.Organization.objects.filter(is_del=False, userdynamic__is_pass=2).annotate(dynamic_nums=Count('userdynamic__org')).order_by('-dynamic_nums').all() F查询和Q查询 F查询 在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？ Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。 示例1： 查询评论数大于收藏数的书籍 from django.db.models import F models.Book.objects.filter(commnet_num__gt=F('keep_num')) Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。 models.Book.objects.filter(commnet_num__lt=F('keep_num')*2) 修改操作也可以使用F函数,比如将每一本书的价格提高30元 models.Book.objects.all().update(price=F(\"price\")+30) 引申： 如果要修改char字段咋办？ 如：把所有书名后面加上：(第一版) >>> from django.db.models.functions import Concat >>> from django.db.models import Value >>> models.Book.objects.all().update(title=Concat(F(\"title\"), Value(\"(\"), Value(\"第一版\"), Value(\")\"))) Q查询 filter() 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。 示例1： 查询作者名是小仙女或小魔女的 models.Book.objects.filter(Q(authors__name=\"小仙女\")|Q(authors__name=\"小魔女\")) 你可以组合& 和| 操作符以及使用括号进行分组来编写任意复杂的Q 对象。同时，Q 对象可以使用~ 操作符取反，这允许组合正常的查询和取反(NOT) 查询。 示例：查询作者名字是小仙女并且不是2018年出版的书的书名。 >>> models.Book.objects.filter(Q(author__name=\"小仙女\") & ~Q(publish_date__year=2018)).values_list(\"title\") 查询函数可以混合使用Q 对象和关键字参数。所有提供给查询函数的参数（关键字参数或Q 对象）都将\"AND”在一起。但是，如果出现Q 对象，它必须位于所有关键字参数的前面。 例如：查询出版年份是2017或2018，书名中带物语的所有书。 >>> models.Book.objects.filter(Q(publish_date__year=2018) | Q(publish_date__year=2017), title__icontains=\"物语\") , , ]> 锁和事务 锁 select_for_update(nowait=False, skip_locked=False) 返回一个锁住行直到事务结束的查询集，如果数据库支持，它将生成一个 SELECT ... FOR UPDATE 语句。 举个例子： entries = Entry.objects.select_for_update().filter(author=request.user) 所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。 一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。 如果这不想要使查询阻塞的话，使用select_for_update(nowait=True)。 如果其它事务持有冲突的锁, 那么查询将引发 DatabaseError 异常。你也可以使用select_for_update(skip_locked=True)忽略锁定的行。 nowait和skip_locked是互斥的，同时设置会导致ValueError。 目前，postgresql，oracle和mysql数据库后端支持select_for_update()。 但是，MySQL不支持nowait和skip_locked参数。 使用不支持这些选项的数据库后端（如MySQL）将nowait=True或skip_locked=True转换为select_for_update()将导致抛出DatabaseError异常，这可以防止代码意外终止。 事务 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() import datetime from app01 import models try: from django.db import transaction with transaction.atomic(): new_publisher = models.Publisher.objects.create(name=\"火星出版社\") models.Book.objects.create(title=\"橘子物语\", publish_date=datetime.date.today(), publisher_id=10) # 指定一个不存在的出版社id except Exception as e: print(str(e)) 其他鲜为人知的操作(了解为主) Django_ORM执行原生SQL 在模型查询API不够用的情况下，我们还可以使用原始的SQL语句进行查询。 Django 提供两种方法使用原始SQL进行查询：一种是使用raw()方法，进行原始SQL查询并返回模型实例；另一种是完全避开模型层，直接执行自定义的SQL语句。 执行原生查询 raw()管理器方法用于原始的SQL查询，并返回模型的实例： 注意：raw()语法查询必须包含主键。 这个方法执行原始的SQL查询，并返回一个django.db.models.query.RawQuerySet 实例。 这个RawQuerySet 实例可以像一般的QuerySet那样，通过迭代来提供对象实例。 举个例子： class Person(models.Model): first_name = models.CharField(...) last_name = models.CharField(...) birth_date = models.DateField(...) 可以像下面这样执行原生SQL语句 >>> for p in Person.objects.raw('SELECT * FROM myapp_person'): ... print(p) raw()查询可以查询其他表的数据。 举个例子： ret = models.Student.objects.raw('select id, tname as hehe from app02_teacher') for i in ret: print(i.id, i.hehe) raw()方法自动将查询字段映射到模型字段。还可以通过translations参数指定一个把查询的字段名和ORM对象实例的字段名互相对应的字典 d = {'tname': 'haha'} ret = models.Student.objects.raw('select * from app02_teacher', translations=d) for i in ret: print(i.id, i.sname, i.haha) 原生SQL还可以使用参数，注意不要自己使用字符串格式化拼接SQL语句，防止SQL注入！ d = {'tname': 'haha'} ret = models.Student.objects.raw('select * from app02_teacher where id > %s', translations=d, params=[1,]) for i in ret: print(i.id, i.sname, i.haha) 直接执行自定义SQL 有时候raw()方法并不十分好用，很多情况下我们不需要将查询结果映射成模型，或者我们需要执行DELETE、 INSERT以及UPDATE操作。在这些情况下，我们可以直接访问数据库，完全避开模型层。 我们可以直接从django提供的接口中获取数据库连接，然后像使用pymysql模块一样操作数据库。 from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) ret = cursor.fetchone() QuerySet方法大全 ################################################################## # PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET # ################################################################## def all(self) # 获取所有的数据对象 def filter(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def exclude(self, *args, **kwargs) # 条件查询 # 条件可以是：参数，字典，Q def select_related(self, *fields) 性能相关：表之间进行join连表操作，一次性获取关联的数据。 总结： 1. select_related主要针一对一和多对一关系进行优化。 2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。 def prefetch_related(self, *lookups) 性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。 总结： 1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。 2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。 def annotate(self, *args, **kwargs) # 用于实现聚合group by查询 from django.db.models import Count, Avg, Max, Min, Sum v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')) # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id')).filter(uid__gt=1) # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 v = models.UserInfo.objects.values('u_id').annotate(uid=Count('u_id',distinct=True)).filter(uid__gt=1) # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) > 1 def distinct(self, *field_names) # 用于distinct去重 models.UserInfo.objects.values('nid').distinct() # select distinct nid from userinfo 注：只有在PostgreSQL中才能使用distinct进行去重 def order_by(self, *field_names) # 用于排序 models.UserInfo.objects.all().order_by('-id','age') def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None) # 构造额外的查询条件或者映射，如：子查询 Entry.objects.extra(select={'new_id': \"select col from sometable where othercol > %s\"}, select_params=(1,)) Entry.objects.extra(where=['headline=%s'], params=['Lennon']) Entry.objects.extra(where=[\"foo='a' OR bar = 'a'\", \"baz = 'a'\"]) Entry.objects.extra(select={'new_id': \"select id from tb where id > %s\"}, select_params=(1,), order_by=['-nid']) def reverse(self): # 倒序 models.UserInfo.objects.all().order_by('-nid').reverse() # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序 def defer(self, *fields): models.UserInfo.objects.defer('username','id') 或 models.UserInfo.objects.filter(...).defer('username','id') #映射中排除某列数据 def only(self, *fields): #仅取某个表中的数据 models.UserInfo.objects.only('username','id') 或 models.UserInfo.objects.filter(...).only('username','id') def using(self, alias): 指定使用的数据库，参数为别名（setting中的设置） ################################################## # PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS # ################################################## def raw(self, raw_query, params=None, translations=None, using=None): # 执行原生SQL models.UserInfo.objects.raw('select * from userinfo') # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名 models.UserInfo.objects.raw('select id as nid from 其他表') # 为原生SQL设置参数 models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,]) # 将获取的到列名转换为指定列名 name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'} Person.objects.raw('SELECT * FROM some_other_table', translations=name_map) # 指定数据库 models.UserInfo.objects.raw('select * from userinfo', using=\"default\") ################### 原生SQL ################### from django.db import connection, connections cursor = connection.cursor() # cursor = connections['default'].cursor() cursor.execute(\"\"\"SELECT * from auth_user where id = %s\"\"\", [1]) row = cursor.fetchone() # fetchall()/fetchmany(..) def values(self, *fields): # 获取每行数据为字典格式 def values_list(self, *fields, **kwargs): # 获取每行数据为元祖 def dates(self, field_name, kind, order='ASC'): # 根据时间进行某一部分进行去重查找并截取指定内容 # kind只能是：\"year\"（年）, \"month\"（年-月）, \"day\"（年-月-日） # order只能是：\"ASC\" \"DESC\" # 并获取转换后的时间 - year : 年-01-01 - month: 年-月-01 - day : 年-月-日 models.DatePlus.objects.dates('ctime','day','DESC') def datetimes(self, field_name, kind, order='ASC', tzinfo=None): # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间 # kind只能是 \"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\" # order只能是：\"ASC\" \"DESC\" # tzinfo时区对象 models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.UTC) models.DDD.objects.datetimes('ctime','hour',tzinfo=pytz.timezone('Asia/Shanghai')) \"\"\" pip3 install pytz import pytz pytz.all_timezones pytz.timezone(‘Asia/Shanghai’) \"\"\" def none(self): # 空QuerySet对象 #################################### # METHODS THAT DO DATABASE QUERIES # #################################### def aggregate(self, *args, **kwargs): # 聚合函数，获取字典类型聚合结果 from django.db.models import Count, Avg, Max, Min, Sum result = models.UserInfo.objects.aggregate(k=Count('u_id', distinct=True), n=Count('nid')) ===> {'k': 3, 'n': 4} def count(self): # 获取个数 def get(self, *args, **kwargs): # 获取单个对象 def create(self, **kwargs): # 创建对象 def bulk_create(self, objs, batch_size=None): # 批量插入 # batch_size表示一次插入的个数 objs = [ models.DDD(name='r11'), models.DDD(name='r22') ] models.DDD.objects.bulk_create(objs, 10) def get_or_create(self, defaults=None, **kwargs): # 如果存在，则获取，否则，创建 # defaults 指定创建时，其他字段的值 obj, created = models.UserInfo.objects.get_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 2}) def update_or_create(self, defaults=None, **kwargs): # 如果存在，则更新，否则，创建 # defaults 指定创建时或更新时的其他字段 obj, created = models.UserInfo.objects.update_or_create(username='root1', defaults={'email': '1111111','u_id': 2, 't_id': 1}) def first(self): # 获取第一个 def last(self): # 获取最后一个 def in_bulk(self, id_list=None): # 根据主键ID进行查找 id_list = [11,21,31] models.DDD.objects.in_bulk(id_list) def delete(self): # 删除 def update(self, **kwargs): # 更新 def exists(self): # 是否有结果 Django终端打印SQL语句 在Django项目的settings.py文件中，在最后复制粘贴如下代码： LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'handlers': { 'console':{ 'level':'DEBUG', 'class':'logging.StreamHandler', }, }, 'loggers': { 'django.db.backends': { 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', }, } } 即为你的Django项目配置上一个名为django.db.backends的logger实例即可查看翻译后的SQL语句。 在Python脚本中调用Django环境 import os if __name__ == '__main__': os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"BMS.settings\") import django django.setup() from app01 import models books = models.Book.objects.all() print(books) PS: BMS为项目名 "},"Python/第三方库/Django/08-Cookie、Session和分页.html":{"url":"Python/第三方库/Django/08-Cookie、Session和分页.html","title":"Cookie、Session和分页","keywords":"","body":"datetime:2019/6/24 9:46 author:nzb Cookie、Session和分页 Cookie Cookie的由来 大家都知道HTTP协议是无状态的。 无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响， 也不会直接影响后面的请求响应情况。 一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的。 状态可以理解为客户端和服务器在某次会话中产生的数据，那无状态的就以为这些数据不会被保留。会话中产生的数据又是我们需要保存的， 也就是说要“保持状态”。因此Cookie就是在这样一个场景下诞生。 什么是Cookie Cookie具体指的是一段小信息，它是服务器发送出来存储在浏览器上的一组组键值对，下次访问服务器时浏览器会自动携带这些键值对，以便服务器提取有用信息。 Cookie的原理 cookie的工作原理是：由服务器产生内容，浏览器收到请求后保存在本地；当浏览器再次访问时，浏览器会自动带上Cookie，这样服务器就能通过Cookie的内容来判断这个是“谁”了。 查看Cookie 我们使用Chrome浏览器，打开开发者工具。 Django中操作Cookie 获取Cookie request.COOKIES['key'] request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 设置Cookie rep = HttpResponse(...) rep ＝ render(request, ...) rep.set_cookie(key,value,...) rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...) 参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 删除Cookie def logout(request): rep = redirect(\"/login/\") rep.delete_cookie(\"user\") # 删除用户浏览器上之前设置的usercookie值 return rep Cookie版登陆校验 def check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.get_signed_cookie(\"login\", salt=\"SSS\", default=None) == \"yes\": # 已经登录的用户... return func(request, *args, **kwargs) else: # 没有登录的用户，跳转刚到登录页面 return redirect(\"/login/?next={}\".format(next_url)) return inner @check_login def login(request): if request.method == \"POST\": username = request.POST.get(\"username\") passwd = request.POST.get(\"password\") if username == \"xxx\" and passwd == \"dashabi\": next_url = request.GET.get(\"next\") if next_url and next_url != \"/logout/\": response = redirect(next_url) else: response = redirect(\"/class_list/\") response.set_signed_cookie(\"login\", \"yes\", salt=\"SSS\") return response return render(request, \"login.html\") Session Session的由来 Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。 另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 Django中Session相关方法 # 获取、设置、删除Session中数据 request.session['k1'] request.session.get('k1',None) request.session['k1'] = 123 request.session.setdefault('k1',123) # 存在则不设置 del request.session['k1'] # 所有 键、值、键值对 request.session.keys() request.session.values() request.session.items() request.session.iterkeys() request.session.itervalues() request.session.iteritems() # 会话session的key request.session.session_key # 将所有Session失效日期小于当前日期的数据删除 request.session.clear_expired() # 检查会话session的key在数据库中是否存在 request.session.exists(\"session_key\") # 删除当前会话的所有Session数据 request.session.delete() 　　 # 删除当前的会话数据并删除会话的Cookie。 request.session.flush() 这用于确保前面的会话数据不可以再次被用户的浏览器访问 例如，django.contrib.auth.logout() 函数中就会调用它。 # 设置会话Session和Cookie的超时时间 request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 Session流程解析 Session版登陆验证 from functools import wraps def check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.session.get(\"user\"): return func(request, *args, **kwargs) else: return redirect(\"/login/?next={}\".format(next_url)) return inner def login(request): if request.method == \"POST\": user = request.POST.get(\"user\") pwd = request.POST.get(\"pwd\") if user == \"alex\" and pwd == \"alex1234\": # 设置session request.session[\"user\"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get(\"next\") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect(\"/index/\") return render(request, \"login.html\") @check_login def logout(request): # 删除所有当前请求相关的session request.session.delete() return redirect(\"/login/\") @check_login def index(request): current_user = request.session.get(\"user\", None) return render(request, \"index.html\", {\"user\": current_user}) Django中的Session配置 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用。 1. 数据库Session SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认） 2. 缓存Session SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎 SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置 3. 文件Session SESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎 SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库 SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎 5. 加密Cookie Session SESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎 其他公用设置项： SESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认） SESSION_COOKIE_PATH ＝ \"/\" # Session的cookie保存的路径（默认） SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认） SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认） SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认） SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认） SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认） SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） CBV中加装饰器相关 CBV实现的登录视图 class LoginView(View): def get(self, request): \"\"\" 处理GET请求 \"\"\" return render(request, 'login.html') def post(self, request): \"\"\" 处理POST请求 \"\"\" user = request.POST.get('user') pwd = request.POST.get('pwd') if user == 'alex' and pwd == \"alex1234\": next_url = request.GET.get(\"next\") # 生成随机字符串 # 写浏览器cookie -> session_id: 随机字符串 # 写到服务端session： # { # \"随机字符串\": {'user':'alex'} # } request.session['user'] = user if next_url: return redirect(next_url) else: return redirect('/index/') return render(request, 'login.html') 要在CBV视图中使用我们上面的check_login装饰器，有以下三种方式： from django.utils.decorators import method_decorator 1. 加在CBV视图的get或post方法上 from django.utils.decorators import method_decorator class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") @method_decorator(check_login) def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 2. 加在dispatch方法上 from django.utils.decorators import method_decorator class HomeView(View): @method_decorator(check_login) def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 因为CBV中首先执行的就是dispatch方法，所以这么写相当于给get和post方法都加上了登录校验。 3. 直接加在视图类上，但method_decorator必须传 name 关键字参数 如果get方法和post方法都需要登录校验的话就写两个装饰器。 from django.utils.decorators import method_decorator @method_decorator(check_login, name=\"get\") @method_decorator(check_login, name=\"post\") class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 补充 CSRF Token相关装饰器在CBV只能加到dispatch方法上，或者加在视图类上然后name参数指定为dispatch方法。 备注： csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。 csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。 from django.views.decorators.csrf import csrf_exempt, csrf_protect from django.utils.decorators import method_decorator class HomeView(View): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 或者 from django.views.decorators.csrf import csrf_exempt, csrf_protect from django.utils.decorators import method_decorator @method_decorator(csrf_exempt, name='dispatch') class HomeView(View): def dispatch(self, request, *args, **kwargs): return super(HomeView, self).dispatch(request, *args, **kwargs) def get(self, request): return render(request, \"home.html\") def post(self, request): print(\"Home View POST method...\") return redirect(\"/index/\") 分页 当数据库中数据有很多，我们通常会在前端页面做分页展示。 分页的数据可以在前端页面实现，也可以在后端实现分页。 后端实现分页的原理就是每次只请求一页数据。 准备工作 我们使用脚本批量创建一些测试数据（将下面的代码保存到bulk_create.py文件中放到Django项目的根目录，直接执行即可。）： import os if __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"about_orm.settings\") import django django.setup() from app01 import models bulk_obj = (models.Publisher(name='沙河第{}出版社'.format(i)) for i in range(300)) models.Publisher.objects.bulk_create(bulk_obj) 自定义分页 稳扎稳打版 def publisher_list(request): # 从URL中取当前访问的页码数 try: current_page = int(request.GET.get('page')) except Exception as e: # 取不到或者页码数不是数字都默认展示第1页 current_page = 1 # 总数据量 total_count = models.Publisher.objects.count() # 定义每页显示多少条数据 per_page = 10 # 计算出总页码数 total_page, more = divmod(total_count, per_page) if more: total_page += 1 # 定义页面上最多显示多少页码(为了左右对称，一般设为奇数) max_show = 11 half_show = max_show // 2 # 计算一下页面显示的页码范围 if total_page = total_page: # 右边越界 page_end = total_page page_start = total_page - max_show elif current_page - half_show ') # 加首页 first_li = '首页' page_html_list.append(first_li) # 加上一页 if current_page == 1: prev_li = '&laquo;' else: prev_li = '&laquo;'.format(current_page - 1) page_html_list.append(prev_li) for i in range(page_start, page_end + 1): if i == current_page: li_tag = '{0}'.format(i) else: li_tag = '{0}'.format(i) page_html_list.append(li_tag) # 加下一页 if current_page == total_page: next_li = '&raquo;' else: next_li = '&raquo;'.format(current_page + 1) page_html_list.append(next_li) # 加尾页 page_end_li = '尾页'.format(total_page) page_html_list.append(page_end_li) page_html_list.append('') page_html = \"\".join(page_html_list) return render(request, \"publisher_list.html\", {\"publisher_list\": publisher_list, \"page_html\": page_html}) 封装保存版 class Pagination(object): \"\"\"自定义分页（Bootstrap版）\"\"\" def __init__(self, current_page, total_count, base_url, per_page=10, max_show=11): \"\"\" :param current_page: 当前请求的页码 :param total_count: 总数据量 :param base_url: 请求的URL :param per_page: 每页显示的数据量，默认值为10 :param max_show: 页面上最多显示多少个页码，默认值为11 \"\"\" try: self.current_page = int(current_page) except Exception as e: # 取不到或者页码数不是数字都默认展示第1页 self.current_page = 1 # 定义每页显示多少条数据 self.per_page = per_page # 计算出总页码数 total_page, more = divmod(total_count, per_page) if more: total_page += 1 self.total_page = total_page # 定义页面上最多显示多少页码(为了左右对称，一般设为奇数) self.max_show = max_show self.half_show = max_show // 2 self.base_url = base_url @property def start(self): return (self.current_page-1) * self.per_page @property def end(self): return self.current_page * self.per_page def page_html(self): # 计算一下页面显示的页码范围 if self.total_page = self.total_page: # 右边越界 page_end = self.total_page page_start = self.total_page - self.max_show elif self.current_page - self.half_show ') # 加首页 first_li = '首页'.format(self.base_url) page_html_list.append(first_li) # 加上一页 if self.current_page == 1: prev_li = '&laquo;' else: prev_li = '&laquo;'.format( self.base_url, self.current_page - 1) page_html_list.append(prev_li) for i in range(page_start, page_end + 1): if i == self.current_page: li_tag = '{1}'.format(self.base_url, i) else: li_tag = '{1}'.format(self.base_url, i) page_html_list.append(li_tag) # 加下一页 if self.current_page == self.total_page: next_li = '&raquo;' else: next_li = '&raquo;'.format( self.base_url, self.current_page + 1) page_html_list.append(next_li) # 加尾页 page_end_li = '尾页'.format(self.base_url, self.total_page) page_html_list.append(page_end_li) page_html_list.append('') return \"\".join(page_html_list) 封装保存版使用示例 def publisher_list(request): # 从URL中取当前访问的页码数 current_page = int(request.GET.get('page')) # 比len(models.Publisher.objects.all())更高效 total_count = models.Publisher.objects.count() page_obj = Pagination(current_page, total_count, request.path_info) data = models.Publisher.objects.all()[page_obj.start:page_obj.end] page_html = page_obj.page_html() return render(request, \"publisher_list.html\", {\"publisher_list\": data, \"page_html\": page_html}) Django内置分页 内置分页view部分 from django.shortcuts import render from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger L = [] for i in range(999): L.append(i) def index(request): current_page = request.GET.get('p') paginator = Paginator(L, 10) # per_page: 每页显示条目数量 # count: 数据总个数 # num_pages:总页数 # page_range:总页数的索引范围，如: (1,10),(1,200) # page: page对象 try: posts = paginator.page(current_page) # has_next 是否有下一页 # next_page_number 下一页页码 # has_previous 是否有上一页 # previous_page_number 上一页页码 # object_list 分页之后的数据列表 # number 当前页 # paginator paginator对象 except PageNotAnInteger: posts = paginator.page(1) except EmptyPage: posts = paginator.page(paginator.num_pages) return render(request, 'index.html', {'posts': posts}) 内置分页HTML部分 { % for item in posts % } { { item } } { % endfor % } { % if posts.has_previous % } Previous { % endif % } Page { { posts.number } } of { { posts.paginator.num_pages } }. { % if posts.has_next % } Next { % endif % } Cookie和Session(100天) 实现用户跟踪 如今，一个网站如果不通过某种方式记住你是谁以及你之前在网站的活动情况，失去的就是网站的可用性和便利性，继而很有可能导致网站用户的流式，所以记住一个用户（更专业的说法叫用户跟踪）对绝大多数Web应用来说都是必需的功能。 在服务器端，我们想记住一个用户最简单的办法就是创建一个对象，通过这个对象就可以把用户相关的信息都保存起来，这个对象就是我们常说的session（用户会话对象）。那么问题来了，HTTP本身是一个无连接（每次请求和响应的过程中，服务器一旦完成对客户端请求的响应之后就断开连接）、无状态（客户端再次发起对服务器的请求时，服务器无法得知这个客户端之前的任何信息）的协议，即便服务器通过session对象保留了用户数据，还得通过某种方式来确定当前的请求与之前保存过的哪一个session是有关联的。相信很多人都能想到，我们可以给每个session对象分配一个全局唯一的标识符来识别session对象，我们姑且称之为sessionid，每次客户端发起请求时，只要携带上这个sessionid，就有办法找到与之对应的session对象，从而实现在两次请求之间记住该用户的信息，也就是我们之前说的用户跟踪。 要让客户端记住并在每次请求时带上sessionid又有以下几种做法： URL重写。所谓URL重写就是在URL中携带sessionid，例如：http://www.example.com/index.html?sessionid=123456，服务器通过获取sessionid参数的值来取到与之对应的session对象。 隐藏域（隐式表单域）。在提交表单的时候，可以通过在表单中设置隐藏域向服务器发送额外的数据。例如：。 本地存储。现在的浏览器都支持多种本地存储方案，包括：cookie、localStorage、sessionStorage、IndexedDB等。在这些方案中，cookie是历史最为悠久也是被诟病得最多的一种方案，也是我们接下来首先为大家讲解的一种方案。简单的说，cookie是一种以键值对方式保存在浏览器临时文件中的数据，每次请求时，请求头中会携带本站点的cookie到服务器，那么只要将sessionid写入cookie，下次请求时服务器只要读取请求头中的cookie就能够获得这个sessionid，如下图所示。 在HTML5时代要，除了cookie，还可以使用新的本地存储API来保存数据，就是刚才提到的localStorage、sessionStorage、IndexedDB等技术，如下图所示。 Django框架对session的支持 在创建Django项目时，默认的配置文件settings.py文件中已经激活了一个名为SessionMiddleware的中间件（关于中间件的知识我们在下一个章节做详细的讲解，这里只需要知道它的存在即可），因为这个中间件的存在，我们可以直接通过请求对象的session属性来操作会话对象。session属性是一个像字典一样可以读写数据的容器对象，因此我们可以使用“键值对”的方式来保留用户数据。与此同时，SessionMiddleware中间件还封装了对cookie的操作，在cookie中保存了sessionid，就如同我们之前描述的那样。 在默认情况下，Django将session的数据序列化后保存在关系型数据库中，在Django 1.6以后的版本中，默认的序列化数据的方式是JSON序列化，而在此之前一直使用Pickle序列化。JSON序列化和Pickle序列化的差别在于前者将对象序列化为字符串（字符形式），而后者将对象序列化为字节串（二进制形式），因为安全方面的原因，JSON序列化成为了目前Django框架默认序列化数据的方式，这就要求在我们保存在session中的数据必须是能够JSON序列化的，否则就会引发异常。还有一点需要说明的是，使用关系型数据库保存session中的数据在大多数时候并不是最好的选择，因为数据库可能会承受巨大的压力而成为系统性能的瓶颈，在后面的章节中我们会告诉大家如何将session的数据保存到缓存服务中。 我们继续完善之前的投票应用，前一个章节中我们实现了用户的登录和注册，下面我们首先完善登录时对验证码的检查。 def get_captcha(request): \"\"\"验证码\"\"\" captcha_text = random_captcha_text() request.session['captcha'] = captcha_text image_data = Captcha.instance().generate(captcha_text) return HttpResponse(image_data, content_type='image/png') 注意上面代码中的第4行，我们将随机生成的验证码字符串保存到session中，稍后用户登录时，我们要将保存在session中的验证码字符串和用户输入的验证码字符串进行比对，如果用户输入了正确的验证码才能够执行后续的登录流程，代码如下所示。 def login(request: HttpRequest): \"\"\"登录\"\"\" hint = '' if request.method == 'POST': form = LoginForm(request.POST) if form.is_valid(): # 对验证码的正确性进行验证 captcha_from_user = form.cleaned_data['captcha'] captcha_from_sess = request.session.get('captcha', '') if captcha_from_sess.lower() != captcha_from_user.lower(): hint = '请输入正确的验证码' else: username = form.cleaned_data['username'] password = form.cleaned_data['password'] user = User.objects.filter(username=username, password=password).first() if user: # 登录成功后将用户编号和用户名保存在session中 request.session['userid'] = user.no request.session['username'] = user.username return redirect('/') else: hint = '用户名或密码错误' else: hint = '请输入有效的登录信息' return render(request, 'login.html', {'hint': hint}) 上面的代码中，我们设定了登录成功后会在session中保存用户的编号（userid）和用户名（username），页面会重定向到首页。接下来我们可以稍微对首页的代码进行调整，在页面的右上角显示出登录用户的用户名。我们将这段代码单独写成了一个名为header.html的HTML文件，首页中可以通过在标签中添加{ % include 'header.html' % }来包含这个页面，代码如下所示。 { % if request.session.userid % } { { request.session.username } } 注销 { % else % } 登录&nbsp;&nbsp; { % endif % } 注册 如果用户没有登录，页面会显示登录和注册的超链接；而用户登录成功后，页面上会显示用户名和注销的链接，注销链接对应的视图函数如下所示，URL的映射与之前讲过的类似，不再赘述。 def logout(request): \"\"\"注销\"\"\" request.session.flush() return redirect('/') 上面的代码通过session对象flush方法来销毁session，一方面清除了服务器上session对象保存的用户数据，一方面将保存在浏览器cookie中的sessionid删除掉，稍后我们会对如何读写cookie的操作加以说明。 我们可以通过项目使用的数据库中名为django_session 的表来找到所有的session，该表的结构如下所示： session_key session_data expire_date c9g2gt5cxo0k2evykgpejhic5ae7bfpl MmI4YzViYjJhOGMyMDJkY2M5Yzg3... 2019-05-25 23:16:13.898522 其中，第1列就是浏览器cookie中保存的sessionid；第2列是经过BASE64编码后的session中的数据，如果使用Python的base64对其进行解码，解码的过程和结果如下所示。 >>> import base64 >>> base64.b64decode('MmI4YzViYjJhOGMyMDJkY2M5Yzg3ZWIyZGViZmUzYmYxNzdlNDdmZjp7ImNhcHRjaGEiOiJzS3d0Iiwibm8iOjEsInVzZXJuYW1lIjoiamFja2ZydWVkIn0=') '2b8c5bb2a8c202dcc9c87eb2debfe3bf177e47ff:{\"captcha\":\"sKwt\",\"no\":1,\"username\":\"jackfrued\"}' 第3列是session的过期时间，session过期后浏览器保存的cookie中的sessionid就会失效，但是数据库中的这条对应的记录仍然会存在，如果想清除过期的数据，可以使用下面的命令。 python manage.py clearsessions Django框架默认的session过期时间为两周（1209600秒），如果想修改这个时间，可以在项目的配置文件中添加如下所示的代码。 # 配置会话的超时时间为1天（86400秒） SESSION_COOKIE_AGE = 86400 有很多对安全性要求较高的应用都必须在关闭浏览器窗口时让会话过期，不再保留用户的任何信息，如果希望在关闭浏览器窗口时就让会话过期（cookie中的sessionid失效），可以加入如下所示的配置。 # 设置为True在关闭浏览器窗口时session就过期 SESSION_EXPIRE_AT_BROWSER_CLOSE = True 如果不希望将session的数据保存在数据库中，可以将其放入缓存中，对应的配置如下所示，缓存的配置和使用我们在后面讲解。 # 配置将会话对象放到缓存中存储 SESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 配置使用哪一组缓存来保存会话 SESSION_CACHE_ALIAS = 'default' 如果要修改session数据默认的序列化方式，可以将默认的JSONSerializer修改为PickleSerializer。 SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer' 在视图函数中读写cookie Django封装的HttpRequest和HttpResponse对象分别提供了读写cookie的操作。 HttpRequest封装的属性和方法： COOKIES属性 - 该属性包含了HTTP请求携带的所有cookie。 get_signed_cookie方法 - 获取带签名的cookie，如果签名验证失败，会产生BadSignature异常。 HttpResponse封装的方法： set_cookie方法 - 该方法可以设置一组键值对并将其最终将写入浏览器。 set_signed_cookie方法 - 跟上面的方法作用相似，但是会对cookie进行签名来达到防篡改的作用。因为如果篡改了cookie中的数据，在不知道密钥和盐>)的情况下是无法生成有效的签名，这样服务器在读取cookie时会发现数据与签名不一致从而产生BadSignature异常。需要说明的是，这里所说的密钥就是我们在Django项目配置文件中指定的SECRET_KEY，而盐是程序中设定的一个字符串，你愿意设定为什么都可以，只要是一个有效的字符串。 上面提到的方法，如果不清楚它们的具体用法，可以自己查阅一下Django的官方文档，没有什么资料比官方文档能够更清楚的告诉你这些方法到底如何使用。 刚才我们说过了，激活SessionMiddleware之后，每个HttpRequest对象都会绑定一个session属性，它是一个类似字典的对象，除了保存用户数据之外还提供了检测浏览器是否支持cookie的方法，包括： set_test_cookie方法 - 设置用于测试的cookie。 test_cookie_worked方法 - 检测测试cookie是否工作。 delete_test_cookie方法 - 删除用于测试的cookie。 set_expiry方法 - 设置会话的过期时间。 get_expire_age/get_expire_date方法 - 获取会话的过期时间。 clear_expired方法 - 清理过期的会话。 下面是在执行登录之前检查浏览器是否支持cookie的代码。 def login(request): if request.method == 'POST': if request.session.test_cookie_worked(): request.session.delete_test_cookie() # Add your code to perform login process here else: return HttpResponse(\"Please enable cookies and try again.\") request.session.set_test_cookie() return render_to_response('login.html') Cookie的替代品 之前我们说过了，cookie的名声一直都不怎么好，当然我们在实际开发中是不会在cookie中保存用户的敏感信息（如用户的密码、信用卡的账号等）的，而且保存在cookie中的数据一般也会做好编码和签名的工作。即便如此，HTML5中还是给出了用于替代cookie的技术方案，其中使用得最为广泛的就是localStorage和sessionStorage，相信从名字上你就能听出二者的差别，存储在localStorage的数据可以长期保留；而存储在sessionStorage的数据会在浏览器关闭时会被清除 。关于这些cookie替代品的用法，建议大家查阅MDN来进行了解。 "},"Python/第三方库/Django/09-Form和ModelForm组件.html":{"url":"Python/第三方库/Django/09-Form和ModelForm组件.html","title":"Form、ModelForm组件","keywords":"","body":"datetime:2019/6/27 10:07 author:nzb Form和ModelForm组件 Form介绍 我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。 与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息.。 Django form组件就实现了上面所述的功能。 总结一下，其实form组件的主要功能如下: 生成页面可用的HTML标签 对用户提交的数据进行校验 保留上次输入内容 普通方式手写注册功能 views.py # 注册 def register(request): error_msg = \"\" if request.method == \"POST\": username = request.POST.get(\"name\") pwd = request.POST.get(\"pwd\") # 对注册信息做校验 if len(username) login.html 注册页面 { % csrf_token % } 用户名: 密码： { { error_msg } } 使用form组件实现注册功能 views.py 先定义好一个RegForm类： from django import forms # 按照Django form组件的要求自己写一个类 class RegForm(forms.Form): name = forms.CharField(label=\"用户名\") pwd = forms.CharField(label=\"密码\") 再写一个视图函数： # 使用form组件实现注册方式 def register2(request): form_obj = RegForm() if request.method == \"POST\": # 实例化form对象的时候，把post提交过来的数据直接传进去 form_obj = RegForm(request.POST) # 调用form_obj校验数据的方法 if form_obj.is_valid(): return HttpResponse(\"注册成功\") return render(request, \"register2.html\", {\"form_obj\": form_obj}) login2.html 注册2 { % csrf_token % } { { form_obj.name.label } } { { form_obj.name } } { { form_obj.name.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } 看网页效果发现 也验证了form的功能： 前端页面是form类的对象生成的 -->生成HTML标签功能 当用户名和密码输入为空或输错之后 页面都会提示 -->用户提交校验功能 当用户输错之后 再次输入 上次的内容还保留在input框 -->保留上次输入内容 Form那些事 常用字段与插件 创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML; initial 初始值，input框里面的初始值。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\" **# 设置默认值** ) pwd = forms.CharField(min_length=6, label=\"密码\") error_messages 重写错误信息。 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" }, widget=forms.widgets.TextInput(attrs={'class': 'c1'}, render_value=True) ) pwd = forms.CharField(min_length=6, label=\"密码\") password class LoginForm(forms.Form): ... pwd = forms.CharField( min_length=6, label=\"密码\", widget=forms.widgets.PasswordInput( attrs={'class': 'c1'}, # **标签属性** render_value=True) # **表单值是否返回** ) radioSelect 单radio值为字符串 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ) pwd = forms.CharField(min_length=6, label=\"密码\") gender = forms.ChoiceField( choices=((1, \"男\"), (2, \"女\"), (3, \"保密\")), label=\"性别\", initial=3, widget=forms.widgets.RadioSelect() ) 单选Select class LoginForm(forms.Form): ... hobby = forms.ChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=3, widget=forms.widgets.Select() ) 多选Select class LoginForm(forms.Form): ... hobby = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"), ), label=\"爱好\", initial=[1, 3], widget=forms.widgets.SelectMultiple() ) 单选checkbox class LoginForm(forms.Form): ... keep = forms.ChoiceField( label=\"是否记住密码\", initial=\"checked\", widget=forms.widgets.CheckboxInput() ) 多选checkbox class LoginForm(forms.Form): ... hobby = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=[1, 3], widget=forms.widgets.CheckboxSelectMultiple() ) choice字段注意事项 在使用选择标签时，需要注意choices的选项可以配置从数据库中获取，但是由于是静态字段获取的值无法实时更新，需要重写构造方法从而实现choice实时更新。 方式一： from django.forms import Form from django.forms import widgets from django.forms import fields class MyForm(Form): user = fields.ChoiceField( # choices=((1, '上海'), (2, '北京'),), initial=2, widget=widgets.Select ) def __init__(self, *args, **kwargs): super(MyForm,self).__init__(*args, **kwargs) # self.fields['user'].choices = ((1, '上海'), (2, '北京'),) # 或 self.fields['user'].choices = models.Classes.objects.all().values_list('id','caption') 方式二： from django import forms from django.forms import fields from django.forms import models as form_model class FInfo(forms.Form): authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all()) # 多选 # authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all()) # 单选 Django Form所有内置字段 Field required=True, 是否允许为空 widget=None, HTML插件 label=None, 用于生成Label标签或显示内容 initial=None, 初始值 help_text='', 帮助信息(在标签旁边显示) error_messages=None, 错误信息 {'required': '不能为空', 'invalid': '格式错误'} validators=[], 自定义验证规则 localize=False, 是否支持本地化 disabled=False, 是否可以编辑 label_suffix=None Label内容后缀 CharField(Field) max_length=None, 最大长度 min_length=None, 最小长度 strip=True 是否移除用户输入空白 IntegerField(Field) max_value=None, 最大值 min_value=None, 最小值 FloatField(IntegerField) ... DecimalField(IntegerField) max_value=None, 最大值 min_value=None, 最小值 max_digits=None, 总长度 decimal_places=None, 小数位长度 BaseTemporalField(Field) input_formats=None 时间格式化 DateField(BaseTemporalField) 格式：2015-09-01 TimeField(BaseTemporalField) 格式：11:12 DateTimeField(BaseTemporalField)格式：2015-09-01 11:12 DurationField(Field) 时间间隔：%d %H:%M:%S.%f ... RegexField(CharField) regex, 自定制正则表达式 max_length=None, 最大长度 min_length=None, 最小长度 error_message=None, 忽略，错误信息使用 error_messages={'invalid': '...'} EmailField(CharField) ... FileField(Field) allow_empty_file=False 是否允许空文件 ImageField(FileField) ... 注：需要PIL模块，pip3 install Pillow 以上两个字典使用时，需要注意两点： - form表单中 enctype=\"multipart/form-data\" - view函数中 obj = MyForm(request.POST, request.FILES) URLField(Field) ... BooleanField(Field) ... NullBooleanField(BooleanField) ... ChoiceField(Field) ... choices=(), 选项，如：choices = ((0,'上海'),(1,'北京'),) required=True, 是否必填 widget=None, 插件，默认select插件 label=None, Label内容 initial=None, 初始值 help_text='', 帮助提示 ModelChoiceField(ChoiceField) ... django.forms.models.ModelChoiceField queryset, # 查询数据库中的数据 empty_label=\"---------\", # 默认空显示内容 to_field_name=None, # HTML中value的值对应的字段 limit_choices_to=None # ModelForm中对queryset二次筛选 ModelMultipleChoiceField(ModelChoiceField) ... django.forms.models.ModelMultipleChoiceField TypedChoiceField(ChoiceField) coerce = lambda val: val 对选中的值进行一次转换 empty_value= '' 空值的默认值 MultipleChoiceField(ChoiceField) ... TypedMultipleChoiceField(MultipleChoiceField) coerce = lambda val: val 对选中的每一个值进行一次转换 empty_value= '' 空值的默认值 ComboField(Field) fields=() 使用多个验证，如下：即验证最大长度20，又验证邮箱格式 fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),]) MultiValueField(Field) PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用 SplitDateTimeField(MultiValueField) input_date_formats=None, 格式列表：['%Y--%m--%d', '%m%d/%Y', '%m/%d/%y'] input_time_formats=None 格式列表：['%H:%M:%S', '%H:%M:%S.%f', '%H:%M'] FilePathField(ChoiceField) 文件选项，目录下文件显示在页面中 path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 required=True, widget=None, label=None, initial=None, help_text='' GenericIPAddressField protocol='both', both,ipv4,ipv6支持的IP格式 unpack_ipv4=False 解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用 SlugField(CharField) 数字，字母，下划线，减号（连字符） ... UUIDField(CharField) uuid类型 字段校验 RegexValidator验证器 from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.validators import RegexValidator class MyForm(Form): user = fields.CharField( validators=[RegexValidator(r'^[0-9]+$', '请输入数字'), RegexValidator(r'^159[0-9]+$', '数字必须以159开头')], ) 自定义验证函数 import re from django.forms import Form from django.forms import widgets from django.forms import fields from django.core.exceptions import ValidationError # 自定义验证规则 def mobile_validate(value): mobile_re = re.compile(r'^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$') if not mobile_re.match(value): raise ValidationError('手机号码格式错误') class PublishForm(Form): title = fields.CharField(max_length=20, min_length=5, error_messages={'required': '标题不能为空', 'min_length': '标题最少为5个字符', 'max_length': '标题最多为20个字符'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': '标题5-20个字符'})) # 使用自定义验证规则 phone = fields.CharField(validators=[mobile_validate, ], error_messages={'required': '手机不能为空'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'手机号码'})) email = fields.EmailField(required=False, error_messages={'required': u'邮箱不能为空','invalid': u'邮箱格式错误'}, widget=widgets.TextInput(attrs={'class': \"form-control\", 'placeholder': u'邮箱'})) Hook方法 除了上面两种方式，我们还可以在Form类中定义钩子函数，来实现自定义的验证功能。 局部钩子 我们在Fom类中定义 clean_字段名() 方法，就能够实现对特定字段进行校验。 举个例子： class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" }, widget=forms.widgets.TextInput(attrs={\"class\": \"form-control\"}) ) ... # 定义局部钩子，用来校验username字段 def clean_username(self): value = self.cleaned_data.get(\"username\") if \"666\" in value: raise ValidationError(\"光喊666是不行的\") else: return value 全局钩子 我们在Fom类中定义 clean() 方法，就能够实现对字段进行全局校验。 class LoginForm(forms.Form): ... password = forms.CharField( min_length=6, label=\"密码\", widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True) ) re_password = forms.CharField( min_length=6, label=\"确认密码\", widget=forms.widgets.PasswordInput(attrs={'class': 'form-control'}, render_value=True) ) ... # 定义全局的钩子，用来校验密码和确认密码字段是否相同 def clean(self): password_value = self.cleaned_data.get('password') re_password_value = self.cleaned_data.get('re_password') if password_value == re_password_value: return self.cleaned_data else: self.add_error('re_password', '两次密码不一致') raise ValidationError('两次密码不一致') 补充进阶 应用Bootstrap样式 login { % csrf_token % } { { form_obj.username.label } } { { form_obj.username } } { { form_obj.username.errors.0 } } { { form_obj.pwd.label } } { { form_obj.pwd } } { { form_obj.pwd.errors.0 } } { { form_obj.gender.label } } { % for radio in form_obj.gender % } { { radio.tag } }{ { radio.choice_label } } { % endfor % } 注册 批量添加样式 class LoginForm(forms.Form): username = forms.CharField( min_length=8, label=\"用户名\", initial=\"张三\", error_messages={ \"required\": \"不能为空\", \"invalid\": \"格式错误\", \"min_length\": \"用户名最短8位\" } ... def __init__(self, *args, **kwargs): super(LoginForm, self).__init__(*args, **kwargs) for field in iter(self.fields): self.fields[field].widget.attrs.update({ 'class': 'form-control' }) ModelForm 通常在Django项目中，我们编写的大部分都是与Django 的模型紧密映射的表单。 举个例子，你也许会有个Book 模型，并且你还想创建一个form表单用来添加和编辑书籍信息到这个模型中。 在这种情况下，在form表单中定义字段将是冗余的，因为我们已经在模型中定义了那些字段。 基于这个原因，Django 提供一个辅助类来让我们可以从Django 的模型创建Form，这就是ModelForm。 ModelForm定义 form与model的终极结合。 class BookForm(forms.ModelForm): class Meta: model = models.Book fields = \"__all__\" labels = { \"title\": \"书名\", \"price\": \"价格\" } widgets = { \"password\": forms.widgets.PasswordInput(attrs={\"class\": \"c1\"}), } class Meta下常用参数 model = models.Book # 对应的Model中的类 fields = \"__all__\" # 字段，如果是__all__,就是表示列出所有的字段 exclude = None # 排除的字段 labels = None # 提示信息 help_texts = None # 帮助提示信息 widgets = None # 自定义插件 error_messages = None # 自定义错误信息 ModelForm的验证 与普通的Form表单验证类型类似，ModelForm表单的验证在调用is_valid() 或访问errors 属性时隐式调用。 我们可以像使用Form类一样自定义局部钩子方法和全局钩子方法来实现自定义的校验规则。 如果我们不重写具体字段并设置validators属性的话，ModelForm是按照模型中字段的validators来校验的。 save()方法 每个ModelForm还具有一个save()方法。 这个方法根据表单绑定的数据创建并保存数据库对象。 ModelForm的子类可以接受现有的模型实例作为关键字参数instance；如果提供此功能，则save()将更新该实例。 如果没有提供，save() 将创建模型的一个新实例： >>> from myapp.models import Book >>> from myapp.forms import BookForm # 根据POST数据创建一个新的form对象 >>> form_obj = BookForm(request.POST) # 创建书籍对象 >>> new_ book = form_obj.save() # 基于一个书籍对象创建form对象 >>> edit_obj = Book.objects.get(id=1) # 使用POST提交的数据更新书籍对象 >>> form_obj = BookForm(request.POST, instance=edit_obj) >>> form_obj.save() 表单的应用(100天) 我们继续来完成上一章节中的项目，实现“用户注册”和“用户登录”的功能，并限制只有登录的用户才能为老师投票。Django框架中提供了对表单的封装，而且提供了多种不同的使用方式。 首先添加用户模型。 class User(models.Model): \"\"\"用户\"\"\" no = models.AutoField(primary_key=True, verbose_name='编号') username = models.CharField(max_length=20, unique=True, verbose_name='用户名') password = models.CharField(max_length=32, verbose_name='密码') regdate = models.DateTimeField(auto_now_add=True, verbose_name='注册时间') class Meta: db_table = 'tb_user' verbose_name_plural = '用户' 通过生成迁移和执行迁移操作，在数据库中创建对应的用户表。 (venv)$ python manage.py makemigrations vote ... (venv)$ python manage.py migrate ... 定制一个非常简单的注册模板页面。 用户注册 /* 此处省略层叠样式表选择器 */ 用户注册 { { hint } } { % csrf_token % } 用户名： 密码： 确认密码： 返回登录 注意，在上面的表单中，我们使用了模板指令{ % csrf_token % }为表单添加一个隐藏域（type属性值为hidden的input标签），它的作用是在表单中生成一个随机令牌（token）来防范跨站请求伪造（通常简称为CSRF），这也是Django在提交表单时的硬性要求，除非我们设置了免除CSRF令牌。下图是一个关于CSRF简单生动的例子，它来自于维基百科。 用户在提交注册表单时，我们还需要对用户的输入进行验证，例如我们的网站要求用户名必须由字母、数字、下划线构成且长度在4-20个字符之间，密码的长度为8-20个字符，确认密码必须跟密码保持一致。这些验证操作首先可以通过浏览器中的JavaScript代码来完成，但是即便如此，在服务器端仍然要对用户输入再次进行验证来避免将无效的数据库交给数据库，因为用户可能会禁用浏览器的JavaScript功能，也有可能绕过浏览器的输入检查将注册数据提交给服务器，所以服务器端的用户输入检查仍然是必要的。 我们可以利用Django框架封装的表单功能来对用户输入的有效性进行检查，虽然Django封装的表单还能帮助我们定制出页面上的表单元素，但这显然是一种灵活性很差的设计，这样的功能在实际开发中基本不考虑，所以表单主要的作用就在于数据验证，具体的做法如下所示。 USERNAME_PATTERN = re.compile(r'\\w{4,20}') class RegisterForm(forms.ModelForm): repassword = forms.CharField(min_length=8, max_length=20) def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('用户名由字母、数字和下划线构成且长度为4-20个字符') return username def clean_password(self): password = self.cleaned_data['password'] if len(password) 20: raise ValidationError('无效的密码，密码长度为8-20个字符') return to_md5_hex(self.cleaned_data['password']) def clean_repassword(self): repassword = to_md5_hex(self.cleaned_data['repassword']) if repassword != self.cleaned_data['password']: raise ValidationError('密码和确认密码不一致') return repassword class Meta: model = User exclude = ('no', 'regdate') 上面，我们定义了一个与User模型绑定的表单（继承自ModelForm），我们排除了用户编号（no）和注册日期（regdate）这两个属性，并添加了一个repassword属性用来接收从用户表单传给服务器的确认密码。我们在定义User模型时已经对用户名的最大长度进行了限制，上面我们又对确认密码的最小和最大长度进行了限制，但是这些都不足以完成我们对用户输入的验证。上面以clean_打头的方法就是我们自定义的验证规则。很明显，clean_username是对用户名的检查，而clean_password是对密码的检查。由于数据库二维表中不应该保存密码的原文，所以对密码做了一个简单的MD5摘要处理，实际开发中如果只做出这样的处理还不太够，因为即便使用了摘要，仍然有利用彩虹表反向查询破解用户密码的风险，如何做得更好我们会在后续的内容中讲到。为字符串生成MD5摘要的代码如下所示。 def to_md5_hex(message): return hashlib.md5(message.encode()).hexdigest() 新增一个视图函数实现用户注册的功能。 def register(request): page, hint = 'register.html', '' if request.method == 'POST': form = RegisterForm(request.POST) if form.is_valid(): form.save() page = 'login.html' hint = '注册成功，请登录' else: hint = '请输入有效的注册信息' return render(request, page, {'hint': hint}) 如果用户发起GET请求，将直接跳转到注册的页面；如果用户以POST方式提交注册表单，则创建自定义的注册表单对象并获取用户输入。可以通过表单对象的is_valid方法对表单进行验证，如果用户输入没有问题，该方法返回True，否则返回False；由于我们定义的RegisterForm继承自ModelForm，因此也可以直接使用表单对象的save方法来保存模型。下面是注册请求的URL配置。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path('register/', views.register, name='register'), # 此处省略下面的代码 ] 说明：path函数可以通过name参数给URL绑定一个逆向解析的名字，也就是说，如果需要可以从后面给的名字逆向解析出对应的URL。 我们再来定制一个非常简单的登录页。 用户登录 /* 此处省略层叠样式表选择器 */ 用户登录 { { hint } } { % csrf_token % } 用户名： 密码： 验证码： 注册新用户 上面的登录页中，我们要求用户提供验证码，验证码全称是全自动区分计算机和人类的公开图灵测试，它是一种用来区分系统的使用者是计算机还是人类的程序。简单的说就是程序出一个只有人类能够回答的问题，由系统使用者来解答，由于计算机理论上无法解答程序提出的问题，所以回答出问题的用户就可以被认为是人类。大多数的网站都使用了不同类型的验证码技术来防范用程序自动注册用户或模拟用户登录（暴力破解用户密码），因为验证码具有一次消费性，而没有通过图灵测试的程序是不能够完成注册或登录的。 在Python程序中生成验证码并不算特别复杂，但需要三方库Pillow的支持（PIL的分支），因为要对验证码图片进行旋转、扭曲、拉伸以及加入干扰信息来防范那些用OCR（光学文字识别）破解验证码的程序。下面的代码封装了生成验证码图片的功能，大家可以直接用这些代码来生成图片验证码，不要“重复发明轮子”。 \"\"\" 图片验证码 \"\"\" import os import random from io import BytesIO from PIL import Image from PIL import ImageFilter from PIL.ImageDraw import Draw from PIL.ImageFont import truetype class Bezier(object): \"\"\"贝塞尔曲线\"\"\" def __init__(self): self.tsequence = tuple([t / 20.0 for t in range(21)]) self.beziers = {} def make_bezier(self, n): \"\"\"绘制贝塞尔曲线\"\"\" try: return self.beziers[n] except KeyError: combinations = pascal_row(n - 1) result = [] for t in self.tsequence: tpowers = (t ** i for i in range(n)) upowers = ((1 - t) ** i for i in range(n - 1, -1, -1)) coefs = [c * a * b for c, a, b in zip(combinations, tpowers, upowers)] result.append(coefs) self.beziers[n] = result return result class Captcha(object): \"\"\"验证码\"\"\" def __init__(self, width, height, fonts=None, color=None): self._image = None self._fonts = fonts if fonts else \\ [os.path.join(os.path.dirname(__file__), 'fonts', font) for font in ['ArialRB.ttf', 'ArialNI.ttf', 'Georgia.ttf', 'Kongxin.ttf']] self._color = color if color else random_color(0, 200, random.randint(220, 255)) self._width, self._height = width, height @classmethod def instance(cls, width=200, height=75): prop_name = f'_instance_{width}_{height}' if not hasattr(cls, prop_name): setattr(cls, prop_name, cls(width, height)) return getattr(cls, prop_name) def background(self): \"\"\"绘制背景\"\"\" Draw(self._image).rectangle([(0, 0), self._image.size], fill=random_color(230, 255)) def smooth(self): \"\"\"平滑图像\"\"\" return self._image.filter(ImageFilter.SMOOTH) def curve(self, width=4, number=6, color=None): \"\"\"绘制曲线\"\"\" dx, height = self._image.size dx /= number path = [(dx * i, random.randint(0, height)) for i in range(1, number)] bcoefs = Bezier().make_bezier(number - 1) points = [] for coefs in bcoefs: points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)]) for ps in zip(*path))) Draw(self._image).line(points, fill=color if color else self._color, width=width) def noise(self, number=50, level=2, color=None): \"\"\"绘制扰码\"\"\" width, height = self._image.size dx, dy = width / 10, height / 10 width, height = width - dx, height - dy draw = Draw(self._image) for i in range(number): x = int(random.uniform(dx, width)) y = int(random.uniform(dy, height)) draw.line(((x, y), (x + level, y)), fill=color if color else self._color, width=level) def text(self, captcha_text, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None): \"\"\"绘制文本\"\"\" color = color if color else self._color fonts = tuple([truetype(name, size) for name in fonts for size in font_sizes or (65, 70, 75)]) draw = Draw(self._image) char_images = [] for c in captcha_text: font = random.choice(fonts) c_width, c_height = draw.textsize(c, font=font) char_image = Image.new('RGB', (c_width, c_height), (0, 0, 0)) char_draw = Draw(char_image) char_draw.text((0, 0), c, font=font, fill=color) char_image = char_image.crop(char_image.getbbox()) for drawing in drawings: d = getattr(self, drawing) char_image = d(char_image) char_images.append(char_image) width, height = self._image.size offset = int((width - sum(int(i.size[0] * squeeze_factor) for i in char_images[:-1]) - char_images[-1].size[0]) / 2) for char_image in char_images: c_width, c_height = char_image.size mask = char_image.convert('L').point(lambda i: i * 1.97) self._image.paste(char_image, (offset, int((height - c_height) / 2)), mask) offset += int(c_width * squeeze_factor) @staticmethod def warp(image, dx_factor=0.3, dy_factor=0.3): \"\"\"图像扭曲\"\"\" width, height = image.size dx = width * dx_factor dy = height * dy_factor x1 = int(random.uniform(-dx, dx)) y1 = int(random.uniform(-dy, dy)) x2 = int(random.uniform(-dx, dx)) y2 = int(random.uniform(-dy, dy)) warp_image = Image.new( 'RGB', (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2))) warp_image.paste(image, (abs(x1), abs(y1))) width2, height2 = warp_image.size return warp_image.transform( (width, height), Image.QUAD, (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1)) @staticmethod def offset(image, dx_factor=0.1, dy_factor=0.2): \"\"\"图像偏移\"\"\" width, height = image.size dx = int(random.random() * width * dx_factor) dy = int(random.random() * height * dy_factor) offset_image = Image.new('RGB', (width + dx, height + dy)) offset_image.paste(image, (dx, dy)) return offset_image @staticmethod def rotate(image, angle=25): \"\"\"图像旋转\"\"\" return image.rotate(random.uniform(-angle, angle), Image.BILINEAR, expand=1) def generate(self, captcha_text='', fmt='PNG'): \"\"\"生成验证码(文字和图片)\"\"\" self._image = Image.new('RGB', (self._width, self._height), (255, 255, 255)) self.background() self.text(captcha_text, self._fonts, drawings=['warp', 'rotate', 'offset']) self.curve() self.noise() self.smooth() image_bytes = BytesIO() self._image.save(image_bytes, format=fmt) return image_bytes.getvalue() def pascal_row(n=0): \"\"\"生成Pascal三角第n行\"\"\" result = [1] x, numerator = 1, n for denominator in range(1, n // 2 + 1): x *= numerator x /= denominator result.append(x) numerator -= 1 if n & 1 == 0: result.extend(reversed(result[:-1])) else: result.extend(reversed(result)) return result def random_color(start=0, end=255, opacity=255): \"\"\"获得随机颜色\"\"\" red = random.randint(start, end) green = random.randint(start, end) blue = random.randint(start, end) if opacity is None: return red, green, blue return red, green, blue, opacity 说明：上面的代码在生成验证码图片时用到了三种字体文件，使用上面的代码时需要添加字体文件到应用目录下的fonts目录中。 下面的视图函数用来生成验证码并通过HttpResponse对象输出到用户浏览器中。 ALL_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' def get_captcha_text(length=4): selected_chars = random.choices(ALL_CHARS, k=length) return ''.join(selected_chars) def get_captcha(request): \"\"\"获得验证码\"\"\" captcha_text = get_captcha_text() image = Captcha.instance().generate(captcha_text) return HttpResponse(image, content_type='image/png') 生成的验证码如下图所示。 为了验证用户提交的登录表单，我们再定义个表单类。 class LoginForm(forms.Form): username = forms.CharField(min_length=4, max_length=20) password = forms.CharField(min_length=8, max_length=20) captcha = forms.CharField(min_length=4, max_length=4) def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('无效的用户名') return username def clean_password(self): return to_md5_hex(self.cleaned_data['password']) 跟之前我们定义的注册表单类略有区别，登录表单类直接继承自Form没有跟模型绑定，定义了三个字段分别对应登录表单中的用户名、密码和验证码。接下来是处理用户登录的视图函数。 def login(request): hint = '' if request.method == 'POST': form = LoginForm(request.POST) if form.is_valid(): username = form.cleaned_data['username'] password = form.cleaned_data['password'] user = User.objects.filter(username=username, password=password).first() if user: return redirect('/') else: hint = '用户名或密码错误' else: hint = '请输入有效的登录信息' return render(request, 'login.html', {'hint': hint}) 映射URL。 from django.contrib import admin from django.urls import path from vote import views urlpatterns = [ # 此处省略上面的代码 path('login/', views.login, name='login'), # 此处省略下面的代码 ] 需要指出，上面我们设定用户登录成功时直接返回首页，而且在用户登录时并没有验证用户输入的验证码是否正确，这些我们留到下一个单元再为大家讲解。另外，如果要在Django自带的管理后台中进行表单验证，可以在admin.py的模型管理类中指定form属性为自定义的表单即可，例如： class UserForm(forms.ModelForm): password = forms.CharField(min_length=8, max_length=20, widget=forms.PasswordInput, label='密码') def clean_username(self): username = self.cleaned_data['username'] if not USERNAME_PATTERN.fullmatch(username): raise ValidationError('用户名由字母、数字和下划线构成且长度为4-20个字符') return username def clean_password(self): password = self.cleaned_data['password'] return to_md5_hex(self.cleaned_data['password']) class Meta: model = User exclude = ('no', ) class UserAdmin(admin.ModelAdmin): list_display = ('no', 'username', 'password', 'email', 'tel') ordering = ('no', ) form = UserForm list_per_page = 10 admin.site.register(User, UserAdmin) "},"Python/第三方库/Django/10-中间件.html":{"url":"Python/第三方库/Django/10-中间件.html","title":"中间件","keywords":"","body":"datetime:2019/6/28 14:13 author:nzb Django中间件 前戏 我们在前面的课程中已经学会了给视图函数加装饰器来判断是用户是否登录，把没有登录的用户请求跳转到登录页面。 我们通过给几个特定视图函数加装饰器实现了这个需求。但是以后添加的视图函数可能也需要加上装饰器，这样是不是稍微有点繁琐。 学完今天的内容之后呢，我们就可以用更适宜的方式来实现类似给所有请求都做相同操作的功能了 中间件 中间件介绍 什么是中间件? 官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。 每个中间件组件都负责做一些特定的功能。 但是由于其影响的是全局，所以需要谨慎使用，使用不当会影响性能。 说的直白一点中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法， Django框架会在请求的特定的时间去执行这些方法。 我们一直都在使用中间件，只是没有注意到而已，打开Django项目的Settings.py文件，看到下图的MIDDLEWARE配置项。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] MIDDLEWARE配置项是一个列表，列表中是一个个字符串，这些字符串其实是一个个类，也就是一个个中间件。 我们之前已经接触过一个csrf相关的中间件了？我们一开始让大家把他注释掉，再提交post请求的时候，就不会被forbidden了， 后来学会使用csrf_token之后就不再注释这个中间件了。 那接下来就学习中间件中的方法以及这些方法什么时候被执行。 自定义中间件 中间件可以定义五个方法，分别是：（主要的是process_request和process_response） process_request(self,request) process_view(self, request, view_func, view_args, view_kwargs) process_template_response(self,request,response) process_exception(self, request, exception) process_response(self, request, response) 以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象， 则直接将该对象返回给用户。 自定义一个中间件 from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response process_request process_request有一个参数，就是request，这个request和视图函数中的request是一样的。 它的返回值可以是None也可以是HttpResponse对象。返回值是None的话，按正常流程继续走，交给下一个中间件处理，如果是HttpResponse对象， Django将不执行视图函数，而将相应对象返回给浏览器。 我们来看看多个中间件时，Django是如何执行其中的process_request方法的。 from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass 在settings.py的MIDDLEWARE配置项中注册上述两个自定义中间件： MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'middlewares.MD1', # 自定义中间件MD1 'middlewares.MD2' # 自定义中间件MD2 ] 此时，我们访问一个视图，会发现终端中打印如下内容： MD1里面的 process_request MD2里面的 process_request app01 中的 index视图 把MD1和MD2的位置调换一下，再访问一个视图，会发现终端中打印的内容如下： MD2里面的 process_request MD1里面的 process_request app01 中的 index视图 看结果我们知道：视图函数还是最后执行的，MD2比MD1先执行自己的process_request方法。 在打印一下两个自定义中间件中process_request方法中的request参数，会发现它们是同一个对象。 由此总结一下： 1、中间件的process_request方法是在执行视图函数之前执行的。 2、当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。 3、不同中间件之间传递的request都是同一个对象 多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行， 而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。 process_response 它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。 该方法的返回值也必须是HttpResponse对象。 给上述的M1和M2加上process_response方法： from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response 访问一个视图，看一下终端的输出： MD2里面的 process_request MD1里面的 process_request app01 中的 index视图 MD1里面的 process_response MD2里面的 process_response 看结果可知： process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册) 多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行， 而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。 process_view process_view(self, request, view_func, view_args, view_kwargs) 该方法有四个参数 request是HttpRequest对象。 view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。） view_args是将传递给视图的位置参数的列表. view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。 Django会在调用视图函数之前调用process_view方法。 它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。 给MD1和MD2添加process_view方法: from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) 访问index视图函数，看一下输出结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 MD1里面的 process_response MD2里面的 process_response process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序从前到后顺序执行的 process_exception process_exception(self, request, exception) 该方法两个参数: 一个HttpRequest对象 一个exception是视图函数异常产生的Exception对象。 这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。 给MD1和MD2添加上这个方法： from django.utils.deprecation import MiddlewareMixin class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD2 中的process_exception\") 如果视图函数中无异常，process_exception方法不执行。 想办法，在视图函数中抛出一个异常： def index(request): print(\"app01 中的 index视图\") raise ValueError(\"呵呵\") return HttpResponse(\"O98K\") 在MD1的process_exception中返回一个响应对象： class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") return HttpResponse(str(exception)) # 返回一个响应对象 看输出结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 呵呵 MD1 中的process_exception MD1里面的 process_response MD2里面的 process_response 注意，这里并没有执行MD2的process_exception方法，因为MD1中的process_exception方法直接返回了一个响应对象。 proc process_template_response(用的比较少) process_template_response(self, request, response) 它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。 process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法 （或者表明该对象是一个TemplateResponse对象或等价方法）。 class MD1(MiddlewareMixin): def process_request(self, request): print(\"MD1里面的 process_request\") def process_response(self, request, response): print(\"MD1里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD1 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD1 中的process_exception\") return HttpResponse(str(exception)) def process_template_response(self, request, response): print(\"MD1 中的process_template_response\") return response class MD2(MiddlewareMixin): def process_request(self, request): print(\"MD2里面的 process_request\") pass def process_response(self, request, response): print(\"MD2里面的 process_response\") return response def process_view(self, request, view_func, view_args, view_kwargs): print(\"-\" * 80) print(\"MD2 中的process_view\") print(view_func, view_func.__name__) def process_exception(self, request, exception): print(exception) print(\"MD2 中的process_exception\") def process_template_response(self, request, response): print(\"MD2 中的process_template_response\") return response views.py中： def index(request): print(\"app01 中的 index视图\") def render(): print(\"in index/render\") return HttpResponse(\"O98K\") rep = HttpResponse(\"OK\") rep.render = render return rep 访问index视图，终端输出的结果： MD2里面的 process_request MD1里面的 process_request -------------------------------------------------------------------------------- MD2 中的process_view index -------------------------------------------------------------------------------- MD1 中的process_view index app01 中的 index视图 MD1 中的process_template_response MD2 中的process_template_response in index/render MD1里面的 process_response MD2里面的 process_response 从结果看出： 视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的， 接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。 中间件的执行流程 上一部分，我们了解了中间件中的5个方法，它们的参数、返回值以及什么时候执行，现在总结一下中间件的执行流程。 请求到达中间件之后，先按照正序执行每个注册中间件的process_reques方法，process_request方法返回的值是None，就依次执行， 如果返回的值是HttpResponse对象，不再执行后面的process_request方法，而是执行当前对应中间件的process_response方法， 将HttpResponse对象返回给浏览器。也就是说：如果MIDDLEWARE中注册了6个中间件，执行过程中，第3个中间件返回了一个HttpResponse对象， 那么第4,5,6中间件的process_request和process_response方法都不执行，顺序执行3,2,1中间件的process_response方法。 process_request方法都执行完后，匹配路由，找到要执行的视图函数，先不执行视图函数，先执行中间件中的process_view方法， process_view方法返回None，继续按顺序执行，所有process_view方法执行完后执行视图函数。 加入中间件3 的process_view方法返回了HttpResponse对象，则4,5,6的process_view以及视图函数都不执行，直接从最后一个中间件， 也就是中间件6的process_response方法开始倒序执行。 process_template_response和process_exception两个方法的触发是有条件的，执行顺序也是倒序。总结所有的执行流程如下： 中间件版登陆验证 中间件版的登录验证需要依靠session，所以数据库中要有django_session表。 urls.py from django.conf.urls import url from app01 import views urlpatterns = [ url(r'^index/$', views.index), url(r'^login/$', views.login, name='login'), ] views.py from django.shortcuts import render, HttpResponse, redirect def index(request): return HttpResponse('this is index') def home(request): return HttpResponse('this is home') def login(request): if request.method == \"POST\": user = request.POST.get(\"user\") pwd = request.POST.get(\"pwd\") if user == \"Q1mi\" and pwd == \"123456\": # 设置session request.session[\"user\"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get(\"next\") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect(\"/index/\") return render(request, \"login.html\") login.html 登录页面 用户名： 密 码： middlewares.py class AuthMD(MiddlewareMixin): white_list = ['/login/', ] # 白名单 balck_list = ['/black/', ] # 黑名单 def process_request(self, request): from django.shortcuts import redirect, HttpResponse next_url = request.path_info print(request.path_info, request.get_full_path()) if next_url in self.white_list or request.session.get(\"user\"): return elif next_url in self.balck_list: return HttpResponse('This is an illegal URL') else: return redirect(\"/login/?next={}\".format(next_url)) 在settings.py中注册 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'middlewares.AuthMD', ] AuthMD中间件注册后，所有的请求都要走AuthMD的process_request方法。 访问的URL在白名单内或者session中有user用户名，则不做阻拦走正常流程； 如果URL在黑名单中，则返回This is an illegal URL的字符串； 正常的URL但是需要登录后访问，让浏览器跳转到登录页面。 注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。 附：Django请求流程图 中间件的应用(100天) 实现登录验证 我们继续来完善投票应用。在上一个章节中，我们在用户登录成功后通过session保留了用户信息，接下来我们可以应用做一些调整，要求在为老师投票时必须要先登录，登录过的用户可以投票，否则就将用户引导到登录页面，为此我们可以这样修改视图函数。 def praise_or_criticize(request: HttpRequest): \"\"\"投票\"\"\" if 'username' in request.session: try: tno = int(request.GET.get('tno', '0')) teacher = Teacher.objects.get(no=tno) if request.path.startswith('/praise'): teacher.good_count += 1 else: teacher.bad_count += 1 teacher.save() data = {'code': 200, 'message': '操作成功'} except (ValueError, Teacher.DoesNotExist): data = {'code': 404, 'message': '操作失败'} else: data = {'code': 401, 'message': '请先登录'} return JsonResponse(data) 前端页面在收到{'code': 401, 'message': '请先登录'}后，可以将用户引导到登录页面，修改后的teacher.html页面的JavaScript代码部门如下所示。 $(() => { $('.comment > a').on('click', (evt) => { evt.preventDefault() let a = $(evt.target) $.getJSON(a.attr('href'), (json) => { if (json.code == 200) { let span = a.next() span.text(parseInt(span.text()) + 1) } else if (json.code == 401) { location.href = '/login/?backurl=' + location.href } else { alert(json.message) } }) }) }) 注意：为了在登录成功之后能够回到刚才投票的页面，我们在跳转登录时设置了一个backurl参数，把当前浏览器中的URL作为返回的页面地址。 这样我们已经实现了用户必须登录才能投票的限制，但是一个新的问题来了。如果我们的应用中有很多功能都需要用户先登录才能执行，例如将前面导出Excel报表和查看统计图表的功能都加以登录限制，那么我们是不是需要在每个视图函数中添加代码来检查session中是否包含了登录用户的信息呢？答案是否定的，如果这样做了，我们的视图函数中必然会充斥着大量的重复代码。编程大师Martin Fowler曾经说过：代码有很多种坏味道，重复是最坏的一种。在Django项目中，我们可以把验证用户是否登录这样的重复性代码放到中间件中。 Django中间件概述 中间件是安插在Web应用请求和响应过程之间的组件，它在整个Web应用中扮演了拦截过滤器的角色，通过中间件可以拦截请求和响应，并对请求和响应进行过滤（简单的说就是执行额外的处理）。通常，一个中间件组件只专注于完成一件特定的事，例如：Django框架通过SessionMiddleware中间件实现了对session的支持，又通过AuthenticationMiddleware中间件实现了基于session的请求认证。通过把多个中间件组合在一起，我们可以完成更为复杂的任务，Django框架就是这么做的。 Django项目的配置文件中就包含了对中间件的配置，代码如下所示。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] 我们稍微为大家解释一下这些中间件的作用： CommonMiddleware - 基础设置中间件，可以处理以下一些配置参数。 DISALLOWED_USER_AGENTS - 不被允许的用户代理（浏览器） APPEND_SLASH - 是否追加/ USE_ETAG - 浏览器缓存相关 SecurityMiddleware - 安全相关中间件，可以处理和安全相关的配置项。 SECURE_HSTS_SECONDS - 强制使用HTTPS的时间 SECURE_HSTS_INCLUDE_SUBDOMAINS - HTTPS是否覆盖子域名 SECURE_CONTENT_TYPE_NOSNIFF - 是否允许浏览器推断内容类型 SECURE_BROWSER_XSS_FILTER - 是否启用跨站脚本攻击过滤器 SECURE_SSL_REDIRECT - 是否重定向到HTTPS连接 SECURE_REDIRECT_EXEMPT - 免除重定向到HTTPS SessionMiddleware - 会话中间件。 CsrfViewMiddleware - 通过生成令牌，防范跨请求份伪的造中间件。 XFrameOptionsMiddleware - 通过设置请求头参数，防范点击劫持攻击的中间件。 在请求的过程中，上面的中间件会按照书写的顺序从上到下执行，然后是URL解析，最后请求才会来到视图函数；在响应的过程中，上面的中间件会按照书写的顺序从下到上执行，与请求时中间件执行的顺序正好相反。 自定义中间件 Django中的中间件有两种实现方式：基于类的实现方式和基于函数的实现方式，后者更接近于装饰器的写法。装饰器实际上是代理模式的应用，将横切关注功能（与正常业务逻辑没有必然联系的功能，例如：身份认证、日志记录、编码转换之类的功能）置于代理中，由代理对象来完成被代理对象的行为并添加额外的功能。中间件对用户请求和响应进行拦截过滤并增加额外的处理，在这一点上它跟装饰器是完全一致的，所以基于函数的写法来实现中间件就跟装饰器的写法几乎一模一样。下面我们用自定义的中间件来实现用户登录验证的功能。 \"\"\" middlewares.py \"\"\" from django.http import JsonResponse from django.shortcuts import redirect # 需要登录才能访问的资源路径 LOGIN_REQUIRED_URLS = { '/praise/', '/criticize/', '/excel/', '/teachers_data/', } def check_login_middleware(get_resp): def wrapper(request, *args, **kwargs): # 请求的资源路径在上面的集合中 if request.path in LOGIN_REQUIRED_URLS: # 会话中包含userid则视为已经登录 if 'userid' not in request.session: # 判断是不是Ajax请求 if request.is_ajax(): # Ajax请求返回JSON数据提示用户登录 return JsonResponse({'code': 10003, 'hint': '请先登录'}) else: backurl = request.get_full_path() # 非Ajax请求直接重定向到登录页 return redirect(f'/login/?backurl={backurl}') return get_resp(request, *args, **kwargs) return wrapper 修改配置文件，激活中间件使其生效。 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'debug_toolbar.middleware.DebugToolbarMiddleware', 'vote.middlewares.check_login_middleware', ] 注意上面这个中间件列表中元素的顺序，当收到来自用户的请求时，中间件按照从上到下的顺序依次执行，这行完这些中间件以后，请求才会最终到达视图函数。当然，在这个过程中，用户的请求可以被拦截，就像上面我们自定义的中间件那样，如果用户在没有登录的情况下访问了受保护的资源，中间件会将请求直接重定向到登录页，后面的中间件和视图函数将不再执行。在响应用户请求的过程中，上面的中间件会按照从下到上的顺序依次执行，这样的话我们还可以对响应做进一步的处理。 中间件执行的顺序是非常重要的，对于有依赖关系的中间件必须保证被依赖的中间件要置于依赖它的中间件的前面，就好比我们刚才自定义的中间件要放到SessionMiddleware的后面，因为我们要依赖这个中间件为请求绑定的session对象才能判定用户是否登录。 小结 至此，除了对用户投票数量加以限制的功能外，这个投票应用就算基本完成了，整个项目的完整代码请参考https://github.com/jackfrued/django1902，其中用户注册时使用的手机验证码功能请大家使用自己注册的短信平台替代它。如果需要投票应用完整的视频讲解，可以在首页扫码打赏后留言联系作者获取视频下载地址，谢谢大家的理解和支持。 "},"Python/第三方库/Django/Django-REST-framework.html":{"url":"Python/第三方库/Django/Django-REST-framework.html","title":"Django-REST-framework","keywords":"","body":"Django生命周期 a、wsgi wsgi：协议：web server getway interface web服务网关接口 wsgiref:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(django) werkzeug:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架) tornado:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架) uwsgi:是实现了wsgi协议的一个模块，模块本质：一个socket服务器 Django生命周期:(rest_framework) CBV,基于反射实现根据请求方式不同，执行不同的方法。 原理： 1、路由 url -> as_view()里的view方法 -> dispath方法（反射执行其他：GET/POST/DELETE/PUT） 2、流程 class StudentView(View): def dispath(self, request, *args, **kwargs): print('before') # 自己添加需求 ret = super(Student, self).dispath(request, *args, **kwargs) print('after') def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') Django的rest_framework： 中间件 1、最多几个方法： process_request； process_view； process_response； process_exception； process_render_template； 执行流程： 首先进来执行所有的process_request然后路由匹配（找到函数不执行跳回去），然后再执行所有的process_view，然后再执行 视图函数，然后再执行process_response，如果报错执行process_exception，如果返回render则执行process_render_template。 2、用中间件做过什么： --利用它实现csrf_token，利用process_view中处理或装饰器 2.1、为什么用process_view而不用process_request? 因为用process_request的话如果用的是装饰器这需要到达路由匹配到函数才能知道是否加了装饰器， 而process_view已经路由匹配到函数，知道函数是否加了装饰器 --基于角色的权限控制 --用户认证 --csrf(说原理） --session(说原理） --黑名单 --日志记录 3、csrf --检查视图函数是否被 @csrf_exempt(免除csrf认证) --去请求体或cookie中获取token FBV: 情况一：FBV中，全局配置 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] from django.views.decorators.csrf import csrf_exempt @csrf_exempt # 该函数无需认证 def users(request): return HttpResponse('...') 情况二：全局注释，FBV中某些函数需要 from django.views.decorators.csrf import csrf_protect @csrf_protect # 该函数需认证 def users(request): return HttpResponse('...') CBV: # 单独在get，post。。。等中无效 方式一： from django.views.decorators.csrf import csrf_exempt,csrf_protect from django.utils.decorates import method_decorator class StudentView(View): @method_decorator(csrf_exempt) def dispath(self, request, *args, **kwargs): ret = super(Student, self).dispath(request, *args, **kwargs) def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') 方式二： from django.views.decorators.csrf import csrf_exempt,csrf_protect from django.utils.decorates import method_decorator @method_decorator(csrf_exempt, name='dispath') class StudentView(View): def get(self, request, *args, **kwargs): return HttpResponse('GET') def post(self, request, *args, **kwargs): return HttpResponse('POST') def put(self, request, *args, **kwargs): return HttpResponse('PUT') def delete(self, request, *args, **kwargs): return HttpResponse('DELETE') 4、CBV 5、restful 3.1、10条规范 3.2、自己的认识 6、djangorestframework 5.1、如何验证（基于数据库实现用户认证） 5.2、源码流程（面向对象回顾流程） Django-Rest-framework组件 一、认证 1、使用 1.1、创建类：继承BaseAuthentication：实现：authenticate这个方法 1.2、返回值： 1.2.1、None，下一个认证类执行，全部都返回None，则返回匿名用户。 1.2.3、抛出异常，raise exceptions.AuthenticationFailed('用户认证失败') 1.2.3、返回元组，（元素1，元素2） 分别赋值给request.user，request.auth 1.3、局部使用： 需要认证的View:加上authentication_classes = [Authentication,] 1.4、全局使用：（使用路径） REST_FRAMEWORK = { # 全局使用的认证类 \"authentication_classes\": ['app01.utils.auth.Authentication',], # 匿名用户设置 # \"UNAUTHENTICATED_USER\": lambda :\"匿名用户\" \"UNAUTHENTICATED_USER\": None, # 推荐使用，匿名，因为request.user = None \"UNAUTHENTICATED_TOKEN\": None, # 匿名，因为request.auth = None } 2、源码流程 dispath -> 封装request -> 获取定义的认证类（全局/局部）,通过列表生成器创建对象 -> initial -> perform_authentication -> request.user -> Request里的user方法 -> _authenticate -> 最后执行自定义的认证类里的authenticate方法 3、示例 # 认证 # 访问进来第一步执行as_view()里面的view()里面的dispath,当前类没有找父类 class MyAuthentication(object): \"\"\" 认证源码流程 1.访问进来第一步执行dispath,当前类没有找父类 2.封装Request： initialize_request(request, *args, **kwargs) 3. initial(request, *args, **kwargs) # 这当中我们设置的raise异常都会在当前函数的下面捕获 4. perform_authentication(request) 5. request.user ————>去封装request的类里面找user()方法 6.user方法里面: _authenticate() 7._authenticate()里面循环认证类的所有对象 调用每个对象的authenticate()方法就是我们自己定义的 MyAuthentication里面的 authenticate() 8.最后反射到我们定义的View的get,post等等方法执行里面逻辑。 \"\"\" def authenticate(self, request): token = request._request.GET.get('token') # 获取用户名和密码，去数据库校验 if not token: raise exceptions.AuthenticationFailed('用户认证失败') # 返回元组（校验后的数据） return (\"nzb\", None) def authenticate_header(self, val): \"\"\" 认证失败给浏览器返回的响应头 :param val: :return: \"\"\" pass 二、权限 问题：不同的视图不同的权限 1、使用 class MyPermission(object): def has_permission(self, request, view): print(request.user) if request.user.user_type != 1: return False return True class OrderView(APIView): permission_classes = [MyPermission,] def get(self, request, *args, **kwargs): ret = {'code': 10000,'msg': None, 'data':None} try: ret['data'] = {'msg':'test'} except Exception as e: pass return JsonResponse(ret) 2、权限梳理 3.1、基本使用 3.1.1、类，必须继承rest-framework提供的类：BasePermission，必须实现：has_permission方法 from rest_framework.permissions import BasePermission class SvipPermission(BasePermission): # 定义错误信息 message = \"必须是SVIP才能访问\" def has_permission(self, request, view): # print(request.user) if request.user.user_type != 3: return False return True 3.1.2、返回值，True,有权访问，False,无权访问 3.1.3、局部使用： 需要认证的View:加上permission_classes = [SvipPermission,] 3.1.4、全局使用：（使用路径） REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\":['app01.utils.permission.SvipPermission',], } 3、源码流程 跟认证相似，执行完认证执行权限，类里面的has_permission方法。 三、频率控制(节流) 1、使用 -类，继承：BaseThrottle，实现：allow_request、wait方法 -类，继承：SimpleRateThrottle，实现：get_cache_key、scope = \"Lufei\" (配置文件中的key) 1.1、局部使用 class AuthView(APIView): \"\"\"用户认证\"\"\" # 因为全局配置了，但当前View认证，所以设置为空 authentication_classes = [] permission_classes = [] throttle_classes = [VisitThorttle, ] def post(self, request, *args, **kwargs): 1.2、全局使用 REST_FRAMEWORK = { # 访问频率控制 'DEFAULT_THROTTLE_CLASSES': ['app01.utils.throttle.UserThorttle', ], 'DEFAULT_THROTTLE_RATES': { 'Lufei': '3/m', # 匿名用户配置 一分钟三次 'LufeiUser': '3/m', # 用户配置 一分钟三次 } } import time VISIT_RECORD = {} # 放入缓存里 class VisitThorttle(object): def __init__(self): self.history = None def allow_request(self, request, view): \"\"\"60s内只能访问3次\"\"\" # 1、获取用户ip remote_addr = request._request.META.get('REMOTE_ADDR') ctime = time.time() if remote_addr not in VISIT_RECORD: VISIT_RECORD[remote_addr] = [ctime, ] return True self.history = VISIT_RECORD.get(remote_addr) # 把超出时间外的时间数据pop掉 while self.history and self.history[-1] 四、版本(全局配置就行) 1、URL中通过GET传参数 class ParamVersion(object): def determine_version(self, request, *args, **kwargs): version = request.query_params.get('version') return version class OrderView(APIView): versioning_class = ParamVersion ... 2、在URL中传参（推荐使用,正则表达式） # 版本配置类 \"DEFAULT_VERSIONING_CLASS\": 'rest_framework.versioning.URLPathVersioning', \"DEFAULT_VERSION\": 'v1', # 默认版本 \"ALLOWED_VERSIONS\": ['v1', 'v2'], # 允许版本 \"VERSION_PARAM\": 'version', # 版本参数 例：re_path('(?P[v1|v2]+)/', include(router.urls)) # 获取版本 # print(request.version) # 获取处理版本的对象 # print(request.versioning_scheme) # request.versioning_scheme # 反向生成url # print(request.versioning_scheme.reverse(viewname='order', request=request)) 五、解析器(全局配置就行) 1、前戏：django:request.POST/ request.body request.POST要有值需要满足以下2个要求： 1.1、请求头要求： Content-Type:application/x-www-form-urlencoded PS：如果请求头中的Content-Type:application/x-www-form-urlencoded，request.POST中才有值（去request.body中解析数据） 1.2、数据格式要求： name=alex&age=18&gender=男 如： a.form表单提交：默认带的是Content-Type:application/x-www-form-urlencoded b.ajax提交： $.ajax({ url:... type:POST data:{'name':'alex','age':18} # 内部转化成name=alex&age=18&gender=男，携带Content-Type:application/x-www-form-urlencoded提交 ... }) 情况一： $.ajax({ url:... type:POST headres:{'Content-Type':'application/json'} data:{'name':'alex','age':18} # 内部转化成name=alex&age=18&gender=男 ... # body有值，POST没有 }) 情况二： $.ajax({ url:... type:POST headres:{'Content-Type':'application/json'} data:JSON.stringfy({'name':'alex','age':18}) # {'name':'alex','age':18} ... # body有值，POST没有，但是可以用json.loads(request.body)得到 }) 2、rest-framework解析器，对请求体进行解析 2.1、全局配置 2.2、使用 class ParserView(APIView): \"\"\" JSONParser:表示只能解析content-type:application/json头,(最常用) FormParser:表示只能解析content-type:application/x-www-form-urlencoded头 \"\"\" def post(self, request, *args, **kwargs): \"\"\" 允许用户发送JSON格式数据 a.content-type:application/json b.{'name':'alex','age':18} :param request: :param args: :param kwargs: :return: \"\"\" # 获取解析后的结果，用了request.data才去解析 \"\"\" 1.获取用户请求 2.获取用户请求体 3.根据用户请求体和parser_classes = [JSONParser,]中支持的请求头进行比较 4.JSONParser对象处理请求体 5.request.data来触发的 \"\"\" print(request.data) return HttpResponse('ParserView') 2.3、想实现上传功能的话，局部视图配置 parser_classes = [FileUploadParser] 然后取文件： request.FILES 3、源码流程&本质： 3.1、本质 请求体 状态码 请求方法 3.2、源码流程 --dispath:request封装 --request.data 六、序列化 1、序列化： 1.1、写类，继承于Serializer(自定义生成字段)、ModelSerializer(自动生成字段，也是继承于Serializer) 1.2、字段： 1.2.1、name=serializers.CharField(source=\"xxx.xx.xx\") 1.2.2、roles = serializers.SerializerMethodField() # 自定义显示 class UserInfoSerializer(serializers.ModelSerializer): roles = serializers.SerializerMethodField() # 字段自定义显示 class Meta: model = UserInfo # fields = \"__all__\" fields = ['id', 'username', 'password', 'xxx', 'roles', 'group'] def get_roles(self, row): role_obj_list = row.roles.all() ret = [] for item in role_obj_list: ret.append({'id':item.id, 'name':item.name}) return ret 1.2.3、自定义字段类不常用 1.3、自动化序列化连表 class UserInfoSerializer(serializers.ModelSerializer): class Meta: model = UserInfo fields = \"__all__\" # fields = ['id', 'username', 'password', 'xxx', 'roles', 'group'] depth = 1 # 官方建议0~10，尽量不要超过3层 1.4、生成链接 class UserInfoSerializer(serializers.ModelSerializer): group = serializers.HyperlinkedIdentityField(view_name='group', lookup_field='group_id', lookup_url_kwarg='pk') class Meta: model = UserInfo fields = \"__all__\" fields = ['id', 'username', 'password', 'roles', 'group'] depth = 0 # 官方建议0~10，尽量不要超过3层 class UserInfoView(APIView): \"\"\"用户中心（普通用户，vip）\"\"\" # authentication_classes = [Authentication, ] # 当前permission_classes存在就不会去取配置文件里的设置 permission_classes = [VipPermission, ] def get(self, request, *args, **kwargs): users = UserInfo.objects.all() ser = UserInfoSerializer(instance=users, many=True, context={'request': request}) # print(ser.data) ret = json.dumps(ser.data, ensure_ascii=False) return HttpResponse(ret) 1.5、源码流程 单个结果，对象使用Serializer类处理 多个结果，QuerySet，ListSerializer类处理 # ser.data是入口 2、请求数据校验 class XXXValidator(object): def __init__(self, base): self.base = base def __call__(self, value): if not value.startswith(self.base): message = '名称必须以 %s 开头' % self.base raise serializers.ValidationError(message) class UserGroupSerializer(serializers.Serializer): name = serializers.CharField(error_messages={'required': '姓名不能为空'}, validators=[XXXValidator('nzb'),]) class UserGroupView(APIView): authentication_classes = [] permission_classes = [] def post(self, request, *args, **kwargs): # print(request.data) ser = UserGroupSerializer(data=request.data) if ser.is_valid(): # 取数据 print(ser.validated_data) # 单独取某些 print(ser.validated_data['name']) else: print(ser.errors) return HttpResponse('提交数据') 七、分页 数据量大时，怎么规避，1、只显示200页，2、只有上一页和下一页 1、分页，看第几页，每页显示n条数据； 2、分页，在n个位置，向后查看n条数据； 3、加密分页，只能看上一页和下一页。(记住id的最大值和最小值) 第一种分页 class MyPagination(PageNumberPagination): # 自定义分页类 page_size = 2 page_query_param = 'page' page_size_query_param = 'size' max_page_size = 5 第二种分页 class MyPagination(LimitOffsetPagination): # 自定义分页类 page_size = 2 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 5 第三种分页 class MyPagination(CursorPagination): # 自定义分页类 page_size = 2 cursor_query_param = 'cursor' max_limit = 5 ordering = 'id' page_size_query_param = None max_page_size = None class Pager1View(APIView): authentication_classes = [] permission_classes = [] def get(self, request, *args, **kwargs): # 获取所以数据 roles = Role.objects.all() # ret = json.dumps(ser.data, ensure_ascii=False) # return HttpResponse(ret) # rest_framework 渲染 # 创建分页对象 pg = MyPagination() # 在数据中获取分页的数据 pager_roles = pg.paginate_queryset(queryset=roles, request=request, view=self) # 对数据进行序列化 ser = PagerSerializer(instance=pager_roles, many=True) # return Response(ser.data) # 生成上一页下一页链接(加密分页很有用) return pg.get_paginated_response(ser.data) 总结： 1、数据量大，如何做分页？ 1.1、数据库性能相关转到rest_framework是怎么处理 1.2、 八、视图 1、过去 class XxxView(View)： pass 2、现在 class XxxView(APIView): APIView继承于VIew pass 3、没什么用的类：GenericAPIView（不使用） from app01.utils.serializers.pager import PagerSerializer from rest_framework.generics import GenericAPIView class View1View(GenericAPIView): # 继承GenericAPIView需要queryset相当于上面的roles queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] def get(self, request, *args, **kwargs): # 获取数据 roles = self.get_queryset() # Role.objects.all() # 分页 [1,100] pager_roles = self.paginate_queryset(roles) # 序列化 ser = self.get_serializer(instance=pager_roles, many=True) return Response(ser.data) 4、GenericViewSet(ViewSetMixin, generics.GenericAPIView): 路由： re_path('(?P[v1|v2]+)/v1/', views.View1View.as_view({'get': 'list'}), name='view1'), 视图： from app01.utils.serializers.pager import PagerSerializer from rest_framework.viewsets import GenericViewSet class View1View(GenericViewSet): queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] def list(self, request, *args, **kwargs): # 获取数据 roles = self.get_queryset() # Role.objects.all() # 分页 [1,100] pager_roles = self.paginate_queryset(roles) # 序列化 ser = self.get_serializer(instance=pager_roles, many=True) return Response(ser.data) 5、ModelViewSet(最强大) 路由： re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put': 'update','patch': 'partial_update'}), name='view1'), 视图： from app01.utils.serializers.pager import PagerSerializer from rest_framework.viewsets import GenericViewSet, ModelViewSet from rest_framework.mixins import ListModelMixin, CreateModelMixin # class View1View(ListModelMixin,GenericViewSet,CreateModelMixin): class View1View(ModelViewSet): queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination authentication_classes = [] permission_classes = [] PS:class View1View(CreateModelMixin): 6、总结： 6.1、增删改查：ModelViewSet 6.2、增删：CreateModelMixin，DestroyModelMixin，GenericViewSet 6.4、复杂逻辑：GenericViewSet 或 APIView PS：权限： GenericAPIView.get_object check_object_permissions has_object_permission 九、路由 1、 re_path('(?P[v1|v2]+)/auth/', views.AuthView.as_view(), name='auth'), 2、 re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), 3、 # http://127.0.0.1:8000/api01/v1/v1/ re_path('(?P[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), # http://127.0.0.1:8000/api01/v1/v1.json re_path('(?P[v1|v2]+)/v1\\.(?P\\w+)$', views.View1View.as_view({'get': 'list', 'post':'create'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)$', views.View1View.as_view({'get': 'retrieve', 'delete':'destroy', 'put': 'update', 'patch': 'partial_update'}), name='view1'), re_path('(?P[v1|v2]+)/v1/(?P\\d+)\\.(?P\\w+)', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put': 'update','patch': 'partial_update'}), name='view1'), 4、自动生成路由 from app01 import views from rest_framework import routers # rest_framework路由 router = routers.DefaultRouter() router.register(r'xxx', views.View1View) router.register(r'rt', views.View1View) urlpatterns = [ # rest_framework路由 re_path('(?P[v1|v2]+)/', include(router.urls)) ] 十、渲染器 from rest_framework.renderers import JSONRenderer, BrowsableAPIRenderer, AdminRenderer, HTMLFormRenderer # class View1View(ListModelMixin,GenericViewSet,CreateModelMixin): class View1View(ModelViewSet): # 渲染器,使用JSONRenderer就行，BrowsableAPIRenderer只是界面好看 # renderer_classes = [JSONRenderer, BrowsableAPIRenderer] authentication_classes = [] permission_classes = [] queryset = Role.objects.all() serializer_class = PagerSerializer pagination_class = PageNumberPagination 全局配置： 'DEFAULT_RENDERER_CLASSES':['rest_framework.renderers.JSONRenderer','rest_framework.renderers.BrowsableAPIRenderer'] 十一、django组件content_type Django内置的一个组件，帮助开发者做连表操作。【混搭】 models里定义的时候，实现一表对多表操作 例： # 利用content-type实现一表对应多表 # models.py from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation from django.db import models from django.contrib.contenttypes.models import ContentType class Course(models.Model): \"\"\" 普通课程 \"\"\" name = models.CharField(max_length=32) # 仅用于反向查找 price_policy_list = GenericRelation('PricePolicy') class DegreeCourse(models.Model): \"\"\" 学位课程 \"\"\" name = models.CharField(max_length=32) # 仅用于反向查找 price_policy_list = GenericRelation('PricePolicy') class PricePolicy(models.Model): \"\"\"价格策略\"\"\" price = models.IntegerField() period = models.IntegerField() # 自定义 # table_name = models.CharField(verbose_name=u'关联的表名称') # object_id = models.CharField(verbose_name=u'关联表中的数据id') # 使用Django的组件content-type content_type = models.ForeignKey(ContentType, verbose_name=u'关联普通课或学位课表', on_delete=models.CASCADE) # 11、12就是上面两个表 object_id = models.IntegerField(verbose_name=u'关联表中的数据id') # 帮助你快速实现content-type操作 content_object = GenericForeignKey('content_type', 'object_id') # 视图view里面的逻辑, views.py: # 插入一条价格策略,为学位课“Python”添加一个价格策略：一个月9.9 # 1、加一个字段后，使用content-type # obj = DegreeCourse.objects.filter(name='Python').first() # PricePolicy.objects.create(price=9.9, period=30, content_object=obj) # 2、根据课程ID找到课程，并获取所有的价格策略 # course = DegreeCourse.objects.filter(id=1).first() # price_policy = course.price_policy_list.all() 十二、小知识点 1、前后端分离如何解决跨域 --jsonp --cors -响应头放在中间件 2、__init__和__new__的区别： __new__：是返回对象 __init__：是__new__返回的对象的构造方法 例： class Foo(object): def __init__(self, a1): print(a1) self.a = a1 def __new__(cls, *args, **kwargs): \"\"\" 1.根据类创建对象，并返回 2.执行返回值的__init__ \"\"\" # 如果返回的是nzb字符串，则执行字符串的构造方法__init__,上面__init__里面的输出a1为nzb(因为字符串没有构造方法) return 'nzb' # 默认,实例化当前类的对象返回, 然后去执行构造方法 return object.__new__(cls) obj = Foo(123) print(obj) "},"Python/第三方库/Django/Django开发经验/02-Django-restframework登录相关.html":{"url":"Python/第三方库/Django/Django开发经验/02-Django-restframework登录相关.html","title":"登录相关","keywords":"","body":"datetime:2020/5/13 10:33 author:nzb 登录相关（基于jwt token登录；单个用户表或多个用户表） urls.py path(\"login/\", CustomLoginJSONWebToken.as_view()), settings.py # 验证中间件 MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', # 'corsheaders.middleware.CorsPostCsrfMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'middlewares.ValidTokenMiddleware', # 换台设备需重新登录 ] # drf框架的配置信息 REST_FRAMEWORK = { # 默认分页 'DEFAULT_PAGINATION_CLASS': 'utils.PagePagination', 'DATETIME_FORMAT': '%Y-%m-%d %H:%M:%S', # 自定义token内含值 'JWT_PAYLOAD_HANDLER': 'utils.custom_payload_handler', # 异常处理 'EXCEPTION_HANDLER': 'utils.exception_handler.exception_handler', # 见01-重写异常处理手柄 # 用户登陆认证方式 'DEFAULT_AUTHENTICATION_CLASSES': ( #单个用户表配置 # 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', # 'rest_framework.authentication.SessionAuthentication', # 'rest_framework.authentication.BasicAuthentication', # 多个用户表配置 'authentication.CustomAuthenticate', # 自定义 JSON Token Authentication ), # 获取用户的secret_key # 没用，需要也是放到下面的 JWT_AUTH 中，不设置是获取上面的 SECRET_KEY 用于签名加密（不能泄露） # 'JWT_GET_USER_SECRET_KEY': 'utils.jwt_get_user_secret', } # jwt载荷中的有效期设置(from rest_framework_jwt) token_time = datetime.timedelta(days=365) JWT_AUTH = { 'JWT_EXPIRATION_DELTA': token_time, # 有效期设置 'JWT_REFRESH_EXPIRATION_DELTA': token_time, # 刷新有效期 'JWT_RESPONSE_PAYLOAD_HANDLER': '.utils.custom_jwt_response_payload_handler', # 自定义返回认证通过后的数据 } utils.py from django.contrib.auth import authenticate, get_user_model from rest_framework_jwt.utils import jwt_encode_handler from rest_framework_jwt.settings import api_settings def custom_payload_handler(user): '''自定义token内含值 :param user: user auth model :return: 计算token的基本信息 ''' # jwt token payload的基本信息： user_id 用户主键id, 用户first_name, 用户电话号码 phone payload = { 'user_id': user.pk, 'username': user.username, 'exp': datetime.datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA, # 'phone': user.phone 'user_secret': str(uuid.uuid4()) #　uuid } if api_settings.JWT_ALLOW_REFRESH: payload['orig_iat'] = timegm( datetime.datetime.utcnow().utctimetuple() ) if api_settings.JWT_AUDIENCE is not None: payload['aud'] = api_settings.JWT_AUDIENCE if api_settings.JWT_ISSUER is not None: payload['iss'] = api_settings.JWT_ISSUER return payload def generate_user_token(user): \"\"\"生成用户token\"\"\" user_model = get_user_model() payload = custom_payload_handler(user) token = jwt_encode_handler(payload) return token def custom_jwt_response_payload_handler(token, user=None): \"\"\" 自定义jwt认证成功返回的数据 :token 返回的jwt :user 当前登录的用户信息[对象] :request 当前本次客户端提交过来的数据 Example: return { 'token': token, 'user': UserSerializer(user, context={'request': request}).data } \"\"\" data = { 'code': 10000, 'results': { 'token': token, 'id': user.id, 'username': user.username, ．．．． } } return data def jwt_get_secret_key(payload=None): \"\"\"获取用户的secret_key（例如uuid） For enhanced security you may want to use a secret key based on user. This way you have an option to logout only this user if: - token is compromised - password is changed - etc. \"\"\" return user.user_secret # 分页 class PagePagination(LimitOffsetPagination): \"\"\"分页\"\"\" # page_size = 1 limit_query_param = 'limit' offset_query_param = 'offset' max_limit = 20 def get_paginated_response(self, data): ret = dict([ ('code', 10000, ('errMsg', ''), ('count', self.count), ('previous', self.get_previous_link()), ('next', self.get_next_link()), ]) if isinstance(data, dict): ret.update(**data) else: ret.update({ 'results': data }) return Response(OrderedDict(ret)) views.py from rest_framework_jwt.views import JSONWebTokenAPIView from rest_framework_jwt.settings import api_settings from utils import custom_jwt_response_payload_handler class CustomLoginJSONWebToken(JSONWebTokenAPIView): \"\"\" 自定义登录 \"\"\" serializer_class = CustomJSONWebTokenSerializer def post(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data) if serializer.is_valid(): user = serializer.object.get('user') or request.user token = serializer.object.get('token') #　可自定义返回认证成功后的数据,settings中的JWT_AUTH中的JWT_RESPONSE_PAYLOAD_HANDLER设置 # 这里还可以写需要的相应逻辑 response_data = custom_jwt_response_payload_handler(token, user, request) response = Response(response_data) if api_settings.JWT_AUTH_COOKIE: expiration = (datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA) response.set_cookie(api_settings.JWT_AUTH_COOKIE, token, expires=expiration, httponly=True) return response return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) serializers.py from rest_framework_jwt.serializers import JSONWebTokenSerializer from django.contrib.auth import authenticate, get_user_model from utils import generate_user_token class CustomJSONWebTokenSerializer(JSONWebTokenSerializer): \"\"\"自定义账号密码登录序列号\"\"\" def validate(self, attrs): # 密码账户验证 username = attrs.get(self.username_field) password = attrs.get('password', None) credentials = { self.username_field: username, 'password': password } if all(credentials.values()): user = authenticate(**credentials) if user: if not user.is_active: msg = {'code': 10996, 'errMsg': '用户被冻结'} raise serializers.ValidationError(msg) # payload = jwt_payload_handler(user) return { # 'token': jwt_encode_handler(payload), 'token': generate_user_token(user), 'user': user } else: # 若认证失败 msg = {'code': 10991, 'errMsg': '用户名和密码错误'} raise serializers.ValidationError(msg) else: msg = {'code': 10997, 'errMsg': 'username和password为必填字段'} raise serializers.ValidationError(msg) from rest_framework_jwt.serializers import VerifyJSONWebTokenSerializer class CustomVerifyJSONWebTokenSerializer(VerifyJSONWebTokenSerializer): \"\"\" 多个用户表时自定义验证 中间件中使用 \"\"\" def _check_user(self, payload): # print(\"-------自定义验证的payload：\", payload) username = jwt_get_username_from_payload(payload) if not username: msg = _('Invalid payload.') raise serializers.ValidationError(msg) # Make sure user exists token_type = payload.get(\"type\", None) if token_type == \"manager\": try: # 表1 user = UserManager.objects.get_by_natural_key(username) except UserManager.DoesNotExist: msg = _(\"User doesn't exist.\") raise serializers.ValidationError(msg) if not user.is_active: msg = _('User account is disabled.') raise serializers.ValidationError(msg) else: try: # 表2 user = UserStuInfo.objects.filter(id=payload.get(\"user_id\", None), sno=payload.get(\"sno\", None), is_del=False).first() except UserStuInfo.DoesNotExist: msg = _(\"User doesn't exist.\") raise serializers.ValidationError(msg) return user authentication.py（多个用户表时的登录验证） from rest_framework_jwt.authentication import JSONWebTokenAuthentication, jwt_get_username_from_payload class CustomAuthenticate(JSONWebTokenAuthentication): \"\"\"多个用户表自定义设置登录选项\"\"\" def authenticate_credentials(self, payload): \"\"\" Returns an active user that matches the payload's user id and email. \"\"\" # User = get_user_model() username = jwt_get_username_from_payload(payload) # if if not username: msg = _('Invalid payload.') raise exceptions.AuthenticationFailed(msg) token_type = payload.get(\"type\", None) if token_type == \"manager\": try: # 举例用户表1 user = UserManager.objects.get_by_natural_key(username) except user.DoesNotExist: msg = _('Invalid signature.') raise exceptions.AuthenticationFailed(msg) if not user.is_active: msg = _('User account is disabled.') raise exceptions.AuthenticationFailed(msg) else: try: # 举例用户表2 user = UserStuInfo.objects.filter(id=payload.get(\"user_id\", None), sno=payload.get(\"sno\", None), is_del=False).first() except user.DoesNotExist: msg = _('Invalid signature.') raise exceptions.AuthenticationFailed(msg) return user middleware.py from uuid import uuid4 import json from django.http import HttpResponse from jwt import InvalidSignatureError from rest_framework.exceptions import ValidationError from django.utils.deprecation import MiddlewareMixin from rest_framework_jwt.utils import jwt_decode_handler from authentication import CustomVerifyJSONWebTokenSerializer # 1.每次登录 response 处理 记录 jwt # 2.每次请求判断 jwt是否与表中相等(相当于用户异设备登录获取了新的jwt) 不等 就修改uuid class ValidTokenMiddleware(MiddlewareMixin): def process_request(self, request): # 用于处理 所有带 jwt 的请求 jwt_token = request.META.get('HTTP_AUTHORIZATION', None) if jwt_token is not None and jwt_token != '': data = { 'token': request.META['HTTP_AUTHORIZATION'].split(' ')[1], } try: # valid_data = VerifyJSONWebTokenSerializer().validate(data) # 原来的 valid_data = CustomVerifyJSONWebTokenSerializer().validate(data) # 多用户自定义后的 user = valid_data['user'] # if user: # print(\"------------请求时用户的uuid:{0}\".format(user.user_secret)) except (InvalidSignatureError, ValidationError): # 找不到用户 data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) # if user.user_jwt != data['token']: # 解析token，这里面就有获取用户的user_secret，~~所以需要重写jwt_get_secret_key（不需要）~~ decode_token = jwt_decode_handler(data['token']) # print(\"------------请求时带的token：{0}\".format(decode_token)) if not user: data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) elif str(user.user_secret) != decode_token.get(\"user_secret\"): user.user_secret = uuid4() user.save() data = json.dumps({\"code\": 10000, \"errMsg\": \"用户未登录\"}) return HttpResponse(data, content_type='application/json', status=400) def process_response(self, request, response): # 仅用于处理 login请求 # print(\"----------\", request.META['PATH_INFO']) MANAGER_LOGIN_PATH = \"/api/teacher/login/\" STUDENT_LOGIN_PATH = \"/api/student/login/\" if request.META['PATH_INFO'] in (MANAGER_LOGIN_PATH, STUDENT_LOGIN_PATH): try: rep_data = response.data except AttributeError as e: print(\"报错信息：\", e.args) results = rep_data.get('results', None) if results: # valid_data = VerifyJSONWebTokenSerializer().validate(results) # 原来的 valid_data = CustomVerifyJSONWebTokenSerializer().validate(results) # 多用户自定义后的 user = valid_data['user'] # user.user_jwt = rep_data['results']['token'] decode_token = jwt_decode_handler(rep_data['results']['token']) # print(\"--------登录后的token:\", decode_token) user.user_secret = decode_token.get(\"user_secret\") user.save() return response else: return response else: return response "},"Python/第三方库/Django/Django开发经验/01-Django-restframework重写异常处理手柄.html":{"url":"Python/第三方库/Django/Django开发经验/01-Django-restframework重写异常处理手柄.html","title":"异常处理手柄","keywords":"","body":"datetime:2020/1/8 16:02 author:nzb 重写异常处理返回 例如： 正常返回 { \"detail\": \"方法 “GET” 不被允许。\" } 重写返回 { \"code\": 10001, \"errMsg\": \"方法 “GET” 不被允许。\" } 源码流程 dispath() 分发 def dispatch(self, request, *args, **kwargs): \"\"\" `.dispatch()` is pretty much the same as Django's regular dispatch, but with extra hooks for startup, finalize, and exception handling. \"\"\" self.args = args self.kwargs = kwargs request = self.initialize_request(request, *args, **kwargs) self.request = request self.headers = self.default_response_headers # deprecate? try: self.initial(request, *args, **kwargs) # Get the appropriate handler method if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 活动到某个视图的某个方法，例如create() # 视图函数里的serializer.is_valid(raise_exception=True), # 会去验证序列化里面自带的验证规则和自定义的验证规则（并抛出异常） response = handler(request, *args, **kwargs) except Exception as exc: # 捕获异常 response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response handle_exception() # 捕获异常后执行 def handle_exception(self, exc): \"\"\" Handle any exception that occurs, by returning an appropriate response, or re-raising the error. \"\"\" if isinstance(exc, (exceptions.NotAuthenticated, exceptions.AuthenticationFailed)): # WWW-Authenticate header for 401 responses, else coerce to 403 auth_header = self.get_authenticate_header(self.request) if auth_header: exc.auth_header = auth_header else: exc.status_code = status.HTTP_403_FORBIDDEN # 获取重写的异常返回函数 exception_handler = self.get_exception_handler() context = self.get_exception_handler_context() response = exception_handler(exc, context) if response is None: self.raise_uncaught_exception(exc) response.exception = True return response # 获取配置文件 def get_exception_handler(self): \"\"\" Returns the exception handler that this view uses. \"\"\" return self.settings.EXCEPTION_HANDLER 重写函数custom_exception_handler() from rest_framework.views import exception_handler def custom_exception_handler(exc,context): \"\"\" 框架自带错误码(常见已知的) ( (400, \"invalid\"), (401, \"authentication_failed\"), (401, \"not_authenticated\"), (403, \"permission_denied\"), (404, \"not_found\"), (405, \"method_not_allowed\"), ) 不常见的 ( (400, \"parse_error\"), (406, \"not_acceptable\"), (415, \"unsupported_media_type\"), (429, \"throttled\") ) \"\"\" response = exception_handler(exc, context) # 获取本来应该返回的exception的response request = context.get(\"request\", None) ... if response is not None: if response.status_code == 403: # 权限 pass elif response.status_code == 401: # 是否登录 pass elif response.status_code == 404: # 资源未找到 response.data['code'] = org_status_code.NOTFOUNDERROR_CODE.get(\"code\", None) response.data['errMsg'] = org_status_code.NOTFOUNDERROR_CODE.get(\"detail\", None) del response.data['detail'] elif response.status_code == 405: # 方法不允许 pass elif response.status_code == 400: # 重写django自带的序列化错误以及自定义的序列化错误 response = process_400_BAD_REQUEST(response) else: pass return response def process_400_BAD_REQUEST(response): \"\"\"映射自带错误和返回自定义错误\"\"\" old_data = response.data for k, v in old_data.items(): new_data = {} # 框架自带错误码(常见已知的) if v[0].code == \"required\": new_data['code'] = org_status_code.NOTNULL_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.NOTNULL_CODE.get(\"detail\", None).format(k) elif v[0].code == \"invalid\": new_data['code'] = org_status_code.TYPEERROR_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.TYPEERROR_CODE.get(\"detail\", None).format(k, v[0]) elif v[0].code == \"incorrect_type\": # 类型错误 new_data['code'] = org_status_code.TYPEERROR_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.TYPEERROR_CODE.get(\"detail\", None).format(k, v[ 0]) # \"{0}字段{1}\".format(k, v[0]) elif v[0].code == \"does_not_exist\": # 外键对象不存在 new_data['code'] = org_status_code.FOREIGNKEYNOEXISTED_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.FOREIGNKEYNOEXISTED_CODE.get(\"detail\", None).format(k, v[ 0]) # \"{0}字段{1}\".format(k, v[0]) elif v[0].code == \"unique\": # 已存在 new_data['code'] = org_status_code.EXISTED_CODE.get(\"code\", None) new_data['errMsg'] = org_status_code.EXISTED_CODE.get(\"detail\", None) elif v[0].code == \"max_length\": # 最大长度 new_data['code'] = org_status_code.MAXLENGTHERROR_CODE.get(\"code\", None) new_data['errMsg'] = v[0].replace(\"这个\", k) elif v[0].code == \"min_length\": # 最小长度 new_data['code'] = org_status_code.MINLENGTHERROR_CODE.get(\"code\", None) new_data['errMsg'] = v[0].replace(\"这个\", k) # 自定义错误码以及未知的错误码 else: if isinstance(v[0].code, int): # 自定义的错误 new_data['code'] = v[0].code new_data['errMsg'] = v[0] else: response.data = old_data return response response.data = new_data return response settings.py配置 REST_FRAMEWORK = { 'DATETIME_FORMAT': '%Y/%m/%d %H:%M:%S', 'JWT_ALLOW_REFRESH': True, 'DEFAULT_AUTHENTICATION_CLASSES': ( \"rest_framework_jwt.authentication.JSONWebTokenAuthentication\", # 'utils.authentication.CustomAuthenticate', # 自定义 JSON Token Authentication # 'rest_framework.authentication.BasicAuthentication', # 'rest_framework.authentication.SessionAuthentication', ), 'EXCEPTION_HANDLER': 'utils.exceptions.custom_exception_handler', # 自定义重写的异常处理返回 'SEARCH_PARAM': 'kw', } "},"Python/第三方库/Django/Django开发经验/03-Django-restframework过滤类相关.html":{"url":"Python/第三方库/Django/Django开发经验/03-Django-restframework过滤类相关.html","title":"过滤相关","keywords":"","body":"datetime:2020/5/13 13:45 author:nzb 过滤类相关 class NumberInFilter(django_filters.BaseInFilter, django_filters.NumberFilter): pass class MyFilter(django_filters.rest_framework.FilterSet): id_list = NumberInFilter(field_name=\"id\", label=\"xxx\", lookup_expr=\"in\") class Meta: model = TestModel fields = ['id_list'] "},"Python/第三方库/Django/Django开发经验/04-Django-Fastdfs重写存储类.html":{"url":"Python/第三方库/Django/Django开发经验/04-Django-Fastdfs重写存储类.html","title":"存储类重写","keywords":"","body":"datetime:2020/5/14 16:17 author:nzb Django-Fastdfs重写存储类 csnd文章 源码解析 本地存储类 重写存储类 client.conf # connect timeout in seconds # default value is 30s connect_timeout=30 # network timeout in seconds # default value is 30s network_timeout=60 # the base path to store log files # base_path=C:\\Users\\Admin\\PycharmProjects\\alumnus_circle\\venv # FastDFS客户端存放日志文件的目录 base_path = /data/log/fastdfs/fastdfs.log # tracker_server can ocur more than once, and tracker_server format is # \"host:port\", host can be hostname or ip address # 运行tracker服务的机器ip tracker_server = 172.26.6.129:22122 #standard log level as syslog, case insensitive, value list: ### emerg for emergency ### alert ### crit for critical ### error ### warn for warning ### notice ### info ### debug log_level=info # if use connection pool # default value is false # since V4.05 use_connection_pool = false # connections whose the idle time exceeds this time will be closed # unit: second # default value is 3600 # since V4.05 connection_pool_max_idle_time = 3600 # if load FastDFS parameters from tracker server # since V4.05 # default value is false load_fdfs_parameters_from_tracker=false # if use storage ID instead of IP address # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # default value is false # since V4.05 use_storage_id = false # specify storage ids filename, can use relative or absolute path # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # since V4.05 storage_ids_filename = storage_ids.conf #HTTP settings http.tracker_server_port=80 #use \"#include\" directive to include HTTP other settiongs ##include http.conf fdfs-storage.py # _*_ encoding:utf-8 _*_ __author__ = 'nzb' __datetime__ = '2020/1/3 15:18' from django.conf import settings from django.core.files.storage import Storage from django.utils.deconstruct import deconstructible from fdfs_client.client import Fdfs_client @deconstructible class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): \"\"\" 初始化 :param base_url: 用于构造图片完整路径使用，图片服务器的域名 :param client_conf: FastDFS客户端配置文件的路径 \"\"\" if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf def _open(self, name, mode='rb'): \"\"\" 用不到打开文件，所以省略 \"\"\" pass def _save(self, name, content): \"\"\" 在FastDFS中保存文件 :param name: 传入的文件名 :param content: 文件内容 :return: 保存到数据库中的FastDFS的文件名 \"\"\" client = Fdfs_client(self.client_conf) filename = content.name filename_ext = filename.split('.') if len(filename_ext) settings.py# FastDFS # django文件存储 DEFAULT_FILE_STORAGE = 'utils.fastdfs.fdfs_storage.FastDFSStorage' FDFS_URL = 'http://img.example.com/' FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf') 本地存储重命名 helper.py ```python 文件重命名 @deconstructible class RenameFile(object): def init(self, upload_to): self.upload_to = upload_to def call(self, instance, filename: str, args, *kwargs) -> str: filename_ext = filename.split('.') if len(filename_ext) - models.py ```python class FeedBackFile(models.Model): file = models.FileField(verbose_name=\"意见反馈举报附件\", upload_to=RenameFile(\"upload/feedback/\")) create_time = models.DateTimeField(auto_now_add=True, verbose_name=\"创建时间\") class Meta: verbose_name = \"意见反馈附件\" verbose_name_plural = verbose_name 头部判断 ```python import struct 常见文件格式的文件头 ALLOW_FILETYPE = { \"FFD8FF\": \"JPEG (jpg)\", \"89504E47\": \"PNG (png)\", \"47494638\": \"GIF (gif)\", \"49492A00\": \"TIFF (tif)\", \"41433130\": \"CAD (dwg)\", \"D0CF11E0\": \"MS Word/Excel (xls.or.doc)\", \"255044462D312E\": \"Adobe Acrobat (pdf)\", \"504B0304\": \"ZIP Archive (zip)\", \"52617221\": \"RAR Archive (rar)\", \"41564920\": \"AVI (avi)\" } 字节码转16进制字符串 def bytes2hex(bytes): num = len(bytes) hexstr = u\"\" for i in range(num): t = u\"%x\" % bytes[i] if len(t) % 2: hexstr += u\"0\" hexstr += t return hexstr.upper() def validate_file(file): \"\"\" 根据文件头判断文件类型 文件后缀不可信，并且后缀在linux系统下是没有这个概念的，所以通过文件中的头部标识来判断 :param file:IO文件 :return: xxx：文件类型，unknown：未知文件（不支持） \"\"\" # binfile = open(file, 'rb') # 必需二制字读取 tl = ALLOW_FILETYPE ftype = 'unknown' for hcode in tl.keys(): numOfBytes = len(hcode) / 2 # 需要读多少字节 file.seek(0) # 每次读取都要回到文件头，不然会一直往后读取 # hbytes = struct.unpack_from(\"B\" * numOfBytes, binfile.read(numOfBytes)) # 一个 \"B\"表示一个字节 hbytes = struct.unpack_from(\"B\" * int(numOfBytes), file.read(int(numOfBytes))) # 一个 \"B\"表示一个字节 f_hcode = bytes2hex(hbytes) if f_hcode == hcode: ftype = tl[hcode] break file.seek(0) # 回到文件头 return ftype if name == 'main': pass ret = validate_file('./test.jpg') print(ret) ``` "},"Python/第三方库/Django/Django开发经验/05-Django-restframework序列化相关.html":{"url":"Python/第三方库/Django/Django开发经验/05-Django-restframework序列化相关.html","title":"序列化相关","keywords":"","body":"datetime:2020/6/28 14:34 author:nzb 唯一验证 # serialiezers.py from rest_framework import serializers from rest_framework.validators import UniqueTogetherValidator class ExampleSerializer(serializers.ModelSerializer): args1 = serializers.CharField(label=\"参数1\", required=False) class Meta: model = Example exclude = ['create_time'] validators = [UniqueTogetherValidator(queryset=Example.objects.filter(), fields=('project_id', 'project_type', 'user_id'), message='已存在')] def validate(self, attrs): file = attrs.get(\"file\", None) # 文件类型验证 if validate_file(file) == \"unknown\": raise serializers.ValidationError(code=40000, detail=\"不支持的文件类型\") return attrs 文件类型验证 # helper.py import struct # 常见文件格式的文件头 ALLOW_FILETYPE = { \"FFD8FF\": \"JPEG (jpg)\", \"89504E47\": \"PNG (png)\", \"47494638\": \"GIF (gif)\", \"49492A00\": \"TIFF (tif)\", \"41433130\": \"CAD (dwg)\", \"D0CF11E0\": \"MS Word/Excel (xls.or.doc)\", \"255044462D312E\": \"Adobe Acrobat (pdf)\", \"504B0304\": \"ZIP Archive (zip)\", \"52617221\": \"RAR Archive (rar)\", \"41564920\": \"AVI (avi)\" } # 字节码转16进制字符串 def bytes2hex(bytes): num = len(bytes) hexstr = u\"\" for i in range(num): t = u\"%x\" % bytes[i] if len(t) % 2: hexstr += u\"0\" hexstr += t return hexstr.upper() def validate_file(file): \"\"\" 根据文件头判断文件类型 文件后缀不可信，并且后缀在linux系统下是没有这个概念的，所以通过文件中的头部标识来判断 :param file:IO文件 :return: xxx：文件类型，unknown：未知文件（不支持） \"\"\" # binfile = open(file, 'rb') # 必需二制字读取 tl = ALLOW_FILETYPE ftype = 'unknown' for hcode in tl.keys(): numOfBytes = len(hcode) / 2 # 需要读多少字节 file.seek(0) # 每次读取都要回到文件头，不然会一直往后读取 # hbytes = struct.unpack_from(\"B\" * numOfBytes, binfile.read(numOfBytes)) # 一个 \"B\"表示一个字节 hbytes = struct.unpack_from(\"B\" * int(numOfBytes), file.read(int(numOfBytes))) # 一个 \"B\"表示一个字节 f_hcode = bytes2hex(hbytes) if f_hcode == hcode: ftype = tl[hcode] break file.seek(0) # 回到文件头 return ftype "},"Python/第三方库/Django/Django开发经验/06-api接口自动化测试.html":{"url":"Python/第三方库/Django/Django开发经验/06-api接口自动化测试.html","title":"自动化测试","keywords":"","body":"datetime:2020/9/17 14:35 author:nzb api接口自动化测试 配置文件数据库配置 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'sign_server', 'USER': 'root', 'PASSWORD':'123456', 'PORT': 3306, 'HOST': '127.0.0.1', 'TEST':{ # 测试数据库，每次测试都会自动创建，测试完后会自动删除 'NAME': 'test_sign_server', 'CHARSET': 'utf8mb4', 'COLLATION': 'utf8mb4_general_ci' }, 'OPTIONS': { 'charset': 'utf8mb4' } } } 测试示例 from django.test import TestCase import json from pprint import pprint from django.urls import reverse from rest_framework import status from rest_framework.test import APITestCase from sign.models import SignInfo class SignTests(APITestCase): def test_sign(self): \"\"\"签到\"\"\" print(\"开始测试\") url = reverse('sign-list') # url：/api/sign/ for user_id in range(1, 21): data = {'pro_id': 1, \"obj_id\": 1, \"obj_type\": 0, \"user_id\": user_id, \"sign_type\": 0} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) # 用户1第二条记录 data = {'pro_id': 1, \"obj_id\": 2, \"obj_type\": 0, \"user_id\": 1, \"sign_type\": 0} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) ins_id = response.data.get(\"results\", {}).get(\"id\") # 详情 url = reverse('sign-detail', args=[ins_id]) # url：/api/sign/21/ response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"results\", {}).get(\"status\", None), 0, \"用户签到状态错误\") # 修改处理状态 url = reverse('sign-detail', args=[ins_id]) # url：/api/sign/21/ data = {\"status\": 2} response = self.client.put(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(SignInfo.objects.get(id=ins_id).status, 2, \"修改处理状态出错\") # 补签(用户2在补签一个， obj_id=2) url = reverse('sign-list') # url：/api/sign/ data = {'pro_id': 1, \"obj_id\": 2, \"obj_type\": 0, \"user_id\": 2, \"sign_type\": 1, \"extra4\": \"我要补签\", \"extra_explain\": json.dumps({\"extra1\": \"扩展1说明\", \"extra2\": None, \"extra3\": None, \"extra4\": \"补签说明\", \"extra5\": None, \"extra6\": None})} response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"results\", {}).get(\"sign_type\", None), 1, \"补签失败\") self.assertEqual(response.data.get(\"results\", {}).get(\"extra4\", None), \"我要补签\", \"补签的额外字段错误\") self.assertEqual(SignInfo.objects.filter().count(), 22, \"总数量不对\") # 用户1的签到历史 url = reverse('sign-list') + \"?offset=0&limit=1&user_id=1\" # url：/api/sign/?offset=0&limit=1&user_id=1 response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(response.data.get(\"count\"), 2, \"用户1的数量不对\") # 签到扩展字段说明 url = reverse('sign-detail', args=['extra_explain']) + \"?pro_id=1&obj_id=2&obj_type=0\" # url：/api/sign/extra_explain/?pro_id=1&obj_id=2&obj_type=0 response = self.client.get(url) self.assertEqual(response.status_code, status.HTTP_200_OK, response.data) self.assertEqual(response.data.get(\"code\"), 10000, response.data) self.assertEqual(len(response.data.get(\"results\", [])), 1, \"额外参数说明错误\") 路由的反向解析 其中用drf注册的路由系统，反向解析如下 源码 routes = [ # List route. Route( url=r'^{prefix}{trailing_slash}$', mapping={ 'get': 'list', # 列表 'post': 'create' # 创建 }, name='{basename}-list', # 本例中：sign-list， basename：url中的别名 detail=False, initkwargs={'suffix': 'List'} ), # Dynamically generated list routes. Generated using # @action(detail=False) decorator on methods of the viewset. DynamicRoute( url=r'^{prefix}/{url_path}{trailing_slash}$', name='{basename}-{url_name}', # 装饰器的接口：detail=False detail=False, initkwargs={} ), # Detail route. Route( url=r'^{prefix}/{lookup}{trailing_slash}$', mapping={ 'get': 'retrieve', # 详情 'put': 'update', # 更新 'patch': 'partial_update', # 更新 'delete': 'destroy' # 删除 }, name='{basename}-detail', # 本例中：sign-detail， basename：url中的别名 detail=True, initkwargs={'suffix': 'Instance'} ), # Dynamically generated detail routes. Generated using # @action(detail=True) decorator on methods of the viewset. DynamicRoute( url=r'^{prefix}/{lookup}/{url_path}{trailing_slash}$', name='{basename}-{url_name}', # 装饰器的接口：detail=False detail=True, initkwargs={} ), ] 注意 被action修饰的接口尽量不用下划线连接，否则reverse不能反向解析，如果使用了下划线，只能这样url = reverse('sign-detail', args=['extra_explain']) + \"?pro_id=1&obj_id=2&obj_type=0\" detail=True：reverse(\"sign-extra\", args=[1]) 结果：/api/sign/extra/ detail=False：reverse(\"sign-extra\") 结果：/api/sign/1/extra/ 如果测试的接口有用到其他表信息：比如用户表可以直接用表创建用户 "},"Python/第三方库/Django/Django开发经验/07-为接口加速加缓存.html":{"url":"Python/第三方库/Django/Django开发经验/07-为接口加速加缓存.html","title":"接口加速缓存","keywords":"","body":"datetime:2020/9/17 15:22 author:nzb 为接口提速，加缓存 1、为什么要使用缓存 目前，用户对于接口的操作基本都需要查询数据库。获取文章列表需要从数据库查询，获取单篇文章需要从数据库查询，获取评论列表也需要查询数据。但是，对于博客中的很多资源来说，在某个时间段内，他们的内容几乎都不会发生更新。例如文章详情，文章发表后，除非对其内容做了修改，否则内容就不会变化。还有评论列表，如果没人发布新评论，评论列表也不会变化。 要知道查询数据库的操作相对而言是比较缓慢的，而直接从内存中直接读取数据就会快很多，因此缓存系统应运而生。将那些变化不那么频繁的数据缓存到内存中，内存中的数据相当于数据库中的一个副本，用户查询数据时，不从数据库查询而是直接从缓存中读取，数据库的数据发生了变化时再更新缓存，这样，数据查询的性能就大大提升了。 当然数据库性能也没有说的那么不堪，对于大部分访问量不大的个人博客而言，任何关系型数据库都足以应付。但是我们学习 django-rest-framework 不仅仅是为了写博客，也许你在工作中，面对的是流量非常大的系统，这时候缓存就不可或缺。 2、确定需缓存的接口 先来整理一下我们已有的接口，看看哪些接口是需要缓存的： 接口名 URL 需缓存 文章列表 /api/posts/ 是 文章详情 /api/posts/:id/ 是 分类列表 /categories/ 是 标签列表 /tags/ 是 归档日期列表 /posts/archive/dates/ 是 评论列表 /api/posts/:id/comments/ 是 文章搜索结果 /api/search/ 否 补充说明 文章列表：需要缓存，但如果有文章修改、新增或者删除时应使缓存失效。 文章详情：需要缓存，但如果文章内容修改或者删除了应使缓存失效。 分类、标签、归档日期：可以缓存，但同样要注意在相应的数据变化时使缓存失效。 评论列表：可以缓存，新增或者删除评论时应使缓存失效。 搜索接口：因为搜索的关键词是多种多样的，可以缓存常见搜索关键词的搜索结果，但如何确定常见搜索关键词是一个复杂的优化问题，这里我们不做任何缓存处理。 3、配置缓存 django 为我们提供了一套开箱即用的缓存框架，缓存框架对缓存的操作做了抽象，提供了统一的读写缓存的接口。无论底层使用什么样的缓存服务（例如常用的 Redis、Memcached、文件系统等），对上层应用来说，操作逻辑和调用的接口都是一样的。 配置 django 缓存，最重要的就是选择一个缓存服务，即缓存结果存储和读取的地方。本项目中我们决定开发环境使用本地内存（Local Memory）缓存服务，线上环境使用 Redis 缓存。 3.1、开发环境配置 在开发环境的配置文件 settings/local.py 中加入以下的配置项即开启本地内存缓存服务。 CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.locmem.LocMemCache', } } 3.2、线上环境配置 线上环境使用到 Redis 缓存服务，django 并未内置 Redis 缓存服务的支持，不过对于 Redis 来说当然不缺乏第三方库的支持，我们选择 django-redis-cache，先来安装它： pipenv install django-redis-cache 然后在项目的线上环境配置文件 settings/production.py 中加入以下配置： CACHES = { \"default\": { \"BACKEND\": \"redis_cache.RedisCache\", \"LOCATION\": \"redis://:UJaoRZlNrH40BDaWU6fi@redis:6379/0\", \"OPTIONS\": { \"CONNECTION_POOL_CLASS\": \"redis.BlockingConnectionPool\", \"CONNECTION_POOL_CLASS_KWARGS\": {\"max_connections\": 50, \"timeout\": 20}, \"MAX_CONNECTIONS\": 1000, \"PICKLE_VERSION\": -1, }, }, } 这样，django 的缓存功能就启用了。至于如何启动 Redis 服务，请参考教程最后的 Redis 服务部分。 3.3、drf-extensions Cache django 的缓存框架比较底层，drf-extensions 在 django 缓存框架的基础上，针对 django-rest-framework 封装了更多缓存相关的辅助函数和类，我们将借助这个第三方库来大大简化缓存逻辑的实现。 首先安装它： pipenv install drf-extensions 那么 drf-extensions 对缓存提供了哪些辅助函数和类呢？我们需要用到的主要有这些： KeyConstructor 可以理解为缓存键生成类。我们先来看看 API 接口缓存的逻辑，伪代码是这样的： 给定一个 URL, 尝试从缓存中查找这个 URL 接口的响应结果 if 结果在缓存中: return 缓存中的结果 else: 生成响应结果 将响应结果存入缓存 (以便下一次查询) return 生成的响应结果 缓存结果是以 key-value 的键值对形式存储的，这里关键的地方在于存储或者查询缓存结果时，需要生成相应的 key。例如我们可以把 API 请求的 URL 作为缓存的 key，这样同一个接口请求将返回相同的缓存内容。但是在更为复杂的场景下，不能简单使用 URL 作为 key，比如即使是同一个 API 请求，已认证和未认证的用户调用接口得到的结果是不一样的，所以 drf-extensions 使用 KeyConstructor 辅助基类来提供灵活的 key 生成方式。 KeyBit 可以理解为 KeyConstructor 定义的 key 生成规则中的某一项规则定义。例如，同一个 API 请求，已认证和未认证的用户将得到不同的响应结果，我们可以定义 key 的生成规则为请求的 URL + 用户的认证 id。那么 URL 可以看成一个 KeyBit，用户 id 是另一个 KeyBit。 cache_response 装饰器 这个装饰器用来装饰 django-rest-framework 的视图（单个视图函数、视图集中的 action 等），被装饰的视图将具备缓存功能。 4、缓存博客文章 我们首先来使用 cache_response 装饰器缓存文章列表接口，代码如下： blog/views.py from rest_framework_extensions.cache.decorators import cache_response class PostViewSet( mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet ): # ... @cache_response(timeout=5 * 60, key_func=PostListKeyConstructor()) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) @cache_response(timeout=5 * 60, key_func=PostObjectKeyConstructor()) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) 这里我们分别装饰了 list（获取文章列表的 action）和 retrieve（获取单篇文章），timeout 参数用于指定缓存失效时间， key_func 指定缓存 key 的生成类（即 KeyConstructor），当然 PostListKeyConstructor、和 PostObjectKeyConstructor 还未定义，接下来我们就来定义这两个缓存 key 生成类： from rest_framework_extensions.key_constructor.bits import ( ListSqlQueryKeyBit, PaginationKeyBit, RetrieveSqlQueryKeyBit, ) from rest_framework_extensions.key_constructor.constructors import DefaultKeyConstructor class PostListKeyConstructor(DefaultKeyConstructor): list_sql = ListSqlQueryKeyBit() pagination = PaginationKeyBit() updated_at = PostUpdatedAtKeyBit() class PostObjectKeyConstructor(DefaultKeyConstructor): retrieve_sql = RetrieveSqlQueryKeyBit() updated_at = PostUpdatedAtKeyBit() PostListKeyConstructor 用于文章列表接口缓存 key 的生成，它继承自 DefaultKeyConstructor，这个基类中定义了 3 条缓存 key 的 KeyBit： 接口调用的视图方法的 id，例如 blog.views. PostViewSet.list。 客户端请求的接口返回的数据格式，例如 json、xml。 客户端请求的语言类型。 另外我们还添加了 3 条自定义的缓存 key 的 KeyBit： 执行数据库查询的 sql 查询语句 分页请求的查询参数 Post 资源的最新更新时间 以上 6 条分别对应一个 KeyBit，KeyBit 将提供生成缓存键所需要的值，如果任何一个 KeyBit 提供的值发生了变化，生成的缓存 key 就会不同，查询到的缓存结果也就不一样，这个方式为我们提供了一种有效的缓存失效机制。例如 PostUpdatedAtKeyBit 是我们自定义的一个 KeyBit，它提供 Post 资源最近一次的更新时间，如果资源发生了更新，返回的值就会发生变化，生成的缓存 key 就会不同，从而不会让接口读到旧的缓存值。PostUpdatedAtKeyBit的代码如下： blog/views.py from .utils import UpdatedAtKeyBit class PostUpdatedAtKeyBit(UpdatedAtKeyBit): key = \"post_updated_at\" 因为资源更新时间的 KeyBit 是比较通用的（后面我们还会用于评论资源），所以我们定义了一个基类 UpdatedAtKeyBit，代码如下： from datetime import datetime from django.core.cache import cache from rest_framework_extensions.key_constructor.bits import KeyBitBase class UpdatedAtKeyBit(KeyBitBase): key = \"updated_at\" def get_data(self, **kwargs): value = cache.get(self.key, None) if not value: value = datetime.now() # 这边的缓存时间可以和数据的缓存时间一样（或比数据缓存的时间长） # 短了的话（取不到值），获取后生成的数据缓存key跟缓存的key不一样，会重新查询数据库 cache.set(self.key, value=value, timeout=5 * 60) return str(value) get_data 方法返回这个 KeyBit 对应的值，UpdatedAtKeyBit 首先根据设置的 key 从缓存中读取资源最近更新的时间，如果读不到就将资源最近更新的时间设为当前时间，然后返回这个时间。 当然，我们需要自动维护缓存中记录的资源更新时间，这可以通过 django 的 signal 来完成： # 也可以写在blog/signals.py blog/models.py from django.db.models.signals import post_delete, post_save def change_post_updated_at(sender=None, instance=None, *args, **kwargs): cache.set(\"post_updated_at\", datetime.utcnow()) post_save.connect(receiver=change_post_updated_at, sender=Post) post_delete.connect(receiver=change_post_updated_at, sender=Post) 每当有文章（Post）被新增、修改或者删除时，django 会发出 post_save 或者 post_delete 信号，post_save.connect 和 post_delete.connect 设置了这两个信号的接收器为 change_post_updated_at，信号发出后该方法将被调用，往缓存中写入文章资源的更新时间。 整理一下请求被缓存的逻辑： 请求文章列表接口 根据 PostListKeyConstructor 生成缓存 key，如果使用这个 key 读取到了缓存结果，就直接返回读取到的结果，否则从数据库查询结果，并把查询的结果写入缓存。 再次请求文章列表接口，PostListKeyConstructor 将生成同样的缓存 key，这时就可以直接从缓存中读到结果并返回了。 缓存更新的逻辑： 新增、修改或者删除文章，触发 post_delete, post_save 信号，文章资源的更新时间将被修改。 再次请求文章列表接口，PostListKeyConstructor 将生成不同的缓存 key，这个新的 key 不在缓存中，因此将从数据库查询最新结果，并把查询的结果写入缓存。 再次请求文章列表接口，PostListKeyConstructor 将生成同样的缓存 key，这时就可以直接从缓存中读到结果并返回了。 PostObjectKeyConstructor 用于文章详情接口缓存 key 的生成，逻辑和 PostListKeyConstructor 是完全一样。 5、缓存评论列表 有了文章列表的缓存，评论列表的缓存只需要依葫芦画瓢。 KeyBit 定义： blog/views.py class CommentUpdatedAtKeyBit(UpdatedAtKeyBit): key = \"comment_updated_at\" KeyConstructor 定义： blog/views.py class CommentListKeyConstructor(DefaultKeyConstructor): list_sql = ListSqlQueryKeyBit() pagination = PaginationKeyBit() updated_at = CommentUpdatedAtKeyBit() 视图集： @cache_response(timeout=5 * 60, key_func=CommentListKeyConstructor()) @action( methods=[\"GET\"], detail=True, url_path=\"comments\", url_name=\"comment\", pagination_class=LimitOffsetPagination, serializer_class=CommentSerializer, ) def list_comments(self, request, *args, **kwargs): # ... 6、Redis 服务 本地内存缓存服务配置简单，适合在开发环境使用，但无法适应多线程和多进程适的环境，线上环境我们使用 Redis 做缓存。有了 Docker，启动一个 Redis 服务就是一件非常简单的事。 在线上环境的容器编排文件 production.yml 中加入一个 Redis 服务： version: '3' volumes: static: database: esdata: redis_data: services: hellodjango.rest.framework.tutorial: ... depends_on: - elasticsearch - redis redis: image: 'bitnami/redis:5.0' container_name: hellodjango_rest_framework_tutorial_redis ports: - '6379:6379' volumes: - 'redis_data:/bitnami/redis/data' env_file: - .envs/.production 然后在 .envs/.production 文件中添加如下的环境变量，这个值将作为 redis 连接的密码： REDIS_PASSWORD=055EDy65AAhLgBxMp1u1 然后就可以将服务发布上线了。 "},"Python/第三方库/PyQt5/":{"url":"Python/第三方库/PyQt5/","title":"导航","keywords":"","body":"datetime:2019/5/23 15:28 author:nzb PyQt5关系图 创建窗口 创建按钮 垂直布局和水平布局 栅格布局 布局添加标签 布局添加背景图 单选按钮 复选框 创建提示 行编辑 按钮组 布局组 无边框窗口 创建框架qframe 创建分离器 创建滑动条 创建滚动条 创建刻度盘 spinbox 生成随机数 进度条 工具框 菜单栏和工具栏 文档编辑框 文本框字体的选择 字体颜色 打印 打印预览 打印PDF （带选择的）消息框提示框 右键菜单 选项卡（单选下拉框和多选） stack(堆叠小部件)小部件.md) 可停靠的窗口小部件 日历 单选下拉框 首字符模糊填充（查询） 打开更多的窗口 时间编辑 列表部件 列表部件小示例 "},"Python/第三方库/PyQt5/01-窗口.html":{"url":"Python/第三方库/PyQt5/01-窗口.html","title":"窗口","keywords":"","body":"datetime:2019/5/16 16:13 author:nzb 创建窗口 import sys from PyQt5.QtWidgets import QMainWindow, QApplication, QDesktopWidget from PyQt5 import QtGui class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 demo' self.left = 600 self.top = 200 self.width = 800 self.height = 600 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 # self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.resize(800, 600) # 窗口大小 self.center() # 窗口居中 # 展示窗口 self.show() def center(self): \"\"\"窗口居中\"\"\" qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() qr.moveCenter(cp) self.move(qr.topLeft()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/02-按钮.html":{"url":"Python/第三方库/PyQt5/02-按钮.html","title":"按钮","keywords":"","body":"datetime:2019/5/20 14:04 author:nzb 创建按钮 import sys from PyQt5.QtWidgets import QMainWindow, QApplication, QDesktopWidget, QPushButton from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 demo' self.left = 600 self.top = 200 self.width = 800 self.height = 600 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 按钮 self.button() # 展示窗口 self.show() def button(self): \"\"\"按钮\"\"\" btn = QPushButton('click me', self) # btn.resize(100, 34) # 按钮大小 # btn.move(290, 550) # 移动按钮 # 合并 btn.setGeometry(QtCore.QRect(300, 250, 150, 34)) # 按钮图标 btn.setIcon(QtGui.QIcon('../img/Agt Stop.ico')) btn.setIconSize(QtCore.QSize(40, 40)) # 设置图标大小 # 设置按钮提示 btn.setToolTip('按钮提示') # 触发事件 btn.clicked.connect(self.ClickMe) def ClickMe(self): print('Hello World') # 退出 sys.exit() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/03-垂直布局和水平布局.html":{"url":"Python/第三方库/PyQt5/03-垂直布局和水平布局.html","title":"垂直布局和水平布局","keywords":"","body":"datetime:2019/5/20 14:21 author:nzb 垂直布局和水平布局 import sys from PyQt5.QtWidgets import QApplication, QDesktopWidget, QDialog, QPushButton, QVBoxLayout, QGroupBox, QHBoxLayout from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 300 self.height = 100 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 布局 self.createLayout() vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.setLayout(vbox) # 展示窗口 self.show() def createLayout(self): \"\"\"垂直布局和水平布局\"\"\" self.groupBox = QGroupBox('What is your favorite sport?') hboxlayout = QHBoxLayout() btn = QPushButton('Soccer', self) btn.setIcon(QtGui.QIcon('../img/Soccer.ico')) btn.setIconSize(QtCore.QSize(40, 40)) btn.setMinimumHeight((40)) hboxlayout.addWidget(btn) btn1 = QPushButton('Tennis', self) btn1.setIcon(QtGui.QIcon('../img/Tennis.ico')) btn1.setIconSize(QtCore.QSize(40, 40)) btn1.setMinimumHeight((40)) hboxlayout.addWidget(btn1) btn2 = QPushButton('Basketball', self) btn2.setIcon(QtGui.QIcon('../img/Basketball.ico')) btn2.setIconSize(QtCore.QSize(40, 40)) btn2.setMinimumHeight((40)) hboxlayout.addWidget(btn2) self.groupBox.setLayout(hboxlayout) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/04-栅格布局.html":{"url":"Python/第三方库/PyQt5/04-栅格布局.html","title":"栅格布局","keywords":"","body":"datetime:2019/5/20 14:27 author:nzb 栅格布局 import sys from PyQt5.QtWidgets import QApplication, QDialog, QPushButton, QVBoxLayout, QGroupBox, QGridLayout from PyQt5 import QtGui from PyQt5 import QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Grid Layout ' self.left = 600 self.top = 200 self.width = 300 self.height = 100 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 栅格布局 self.createLayout() vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.setLayout(vbox) # 展示窗口 self.show() def createLayout(self): \"\"\"栅格布局\"\"\" self.groupBox = QGroupBox('What is your favorite programming language?') gridLayout = QGridLayout() btn = QPushButton('Python', self) btn.setIcon(QtGui.QIcon('../img/python.ico')) btn.setIconSize(QtCore.QSize(40, 40)) btn.setMinimumHeight((40)) gridLayout.addWidget(btn, 0, 0) btn1 = QPushButton('java', self) btn1.setIcon(QtGui.QIcon('../img/java.ico')) btn1.setIconSize(QtCore.QSize(40, 40)) btn1.setMinimumHeight((40)) gridLayout.addWidget(btn1, 0, 1) btn2 = QPushButton('php', self) btn2.setIcon(QtGui.QIcon('../img/php.ico')) btn2.setIconSize(QtCore.QSize(40, 40)) btn2.setMinimumHeight((40)) gridLayout.addWidget(btn2, 1, 0) btn3 = QPushButton('c++', self) btn3.setIcon(QtGui.QIcon('./img/C++.ico')) btn3.setIconSize(QtCore.QSize(40, 40)) btn3.setMinimumHeight((40)) gridLayout.addWidget(btn3, 1, 1) self.groupBox.setLayout(gridLayout) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/05-布局添加标签Label.html":{"url":"Python/第三方库/PyQt5/05-布局添加标签Label.html","title":"布局添加标签Label","keywords":"","body":"datetime:2019/5/20 14:34 author:nzb 布局添加标签 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 标签 label = QLabel('This is PyQt5 Label.') vbox.addWidget(label) label2 = QLabel('This is big Label.') label2.setFont(QtGui.QFont(\"Sanserif\", 20)) # 设置字体和大小 label2.setStyleSheet(\"color:red\") # 设置颜色 vbox.addWidget(label2) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/06-布局添加背景图.html":{"url":"Python/第三方库/PyQt5/06-布局添加背景图.html","title":"布局添加背景图","keywords":"","body":"datetime:2019/5/20 14:41 author:nzb 布局添加背景图 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 背景图 labelImage = QLabel(self) pixmap = QtGui.QPixmap('../img/default.jpg') labelImage.setPixmap(pixmap) vbox.addWidget(labelImage) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/07-单选框.html":{"url":"Python/第三方库/PyQt5/07-单选框.html","title":"单选框","keywords":"","body":"datetime:2019/5/20 15:02 author:nzb 单选按钮 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QRadioButton, QHBoxLayout from PyQt5 import QtGui, QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Layout Managment' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 vbox = QVBoxLayout() # 单选框 self.radioButton() vbox.addWidget(self.groupBox) self.label = QLabel(self) self.label.setFont(QtGui.QFont(\"Sanserif\", 20)) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def radioButton(self): \"\"\"单选框\"\"\" self.groupBox = QGroupBox(\"What is your favorite sport?\") self.groupBox.setFont(QtGui.QFont(\"Sanserif\", 12)) hboxlayout = QHBoxLayout() self.radiobtn1 = QRadioButton('Soccer') self.radiobtn1.setChecked(True) # 选中状态 self.radiobtn1.setIcon(QtGui.QIcon('../img/Soccer.ico')) self.radiobtn1.setIconSize(QtCore.QSize(40, 40)) self.radiobtn1.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn1.toggled.connect(self.OnRadioBtn) # 选中事件 hboxlayout.addWidget(self.radiobtn1) self.radiobtn2 = QRadioButton('Tennis') self.radiobtn2.setIcon(QtGui.QIcon('../img/Tennis.ico')) self.radiobtn2.setIconSize(QtCore.QSize(40, 40)) self.radiobtn2.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn2.toggled.connect(self.OnRadioBtn) hboxlayout.addWidget(self.radiobtn2) self.radiobtn3 = QRadioButton('Basketball') self.radiobtn3.setIcon(QtGui.QIcon('../img/Basketball.ico')) self.radiobtn3.setIconSize(QtCore.QSize(40, 40)) self.radiobtn3.setFont(QtGui.QFont('Sanserif', 13)) self.radiobtn3.toggled.connect(self.OnRadioBtn) hboxlayout.addWidget(self.radiobtn3) self.groupBox.setLayout(hboxlayout) def OnRadioBtn(self): \"\"\"单选框选中事件\"\"\" radioBtn = self.sender() if radioBtn.isChecked(): self.label.setText(\"You have selected \" + radioBtn.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/08-复选框.html":{"url":"Python/第三方库/PyQt5/08-复选框.html","title":"复选框","keywords":"","body":"datetime:2019/5/20 15:45 author:nzb 复选框 import sys from PyQt5.QtWidgets import QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QCheckBox, QHBoxLayout from PyQt5 import QtGui, QtCore class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Check Box' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.CreateCheckBox() # 复选按钮 vbox = QVBoxLayout() vbox.addWidget(self.groupBox) self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) #设置标签字体字号 vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def CreateCheckBox(self): \"\"\"复选框\"\"\" self.groupBox = QGroupBox(\"What is you favorite programming language?\") self.groupBox.setFont(QtGui.QFont(\"Sanserif\", 13)) # 设置字体字号 hboxLayout = QHBoxLayout() self.check1 = QCheckBox(\"python\") self.check1.setIcon(QtGui.QIcon('../img/python.ico')) self.check1.setIconSize(QtCore.QSize(40, 40)) self.check1.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check1.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check1) self.check2 = QCheckBox(\"java\") self.check2.setIcon(QtGui.QIcon('../img/java.ico')) self.check2.setIconSize(QtCore.QSize(40, 40)) self.check2.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check2.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check2) self.check3 = QCheckBox(\"php\") self.check3.setIcon(QtGui.QIcon('../img/php.ico')) self.check3.setIconSize(QtCore.QSize(40, 40)) self.check3.setFont(QtGui.QFont('Sanserif', 13)) # 设置字体字号 self.check3.toggled.connect(self.onCheckBox_Toggled) # 绑定事件 hboxLayout.addWidget(self.check3) self.groupBox.setLayout(hboxLayout) def onCheckBox_Toggled(self): \"\"\"复选框触发事件\"\"\" if self.check1.isChecked(): self.label.setText('you have select:' + self.check1.text()) if self.check2.isChecked(): self.label.setText('you have select:' + self.check2.text()) if self.check3.isChecked(): self.label.setText('you have select:' + self.check3.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/09-键盘提示.html":{"url":"Python/第三方库/PyQt5/09-键盘提示.html","title":"键盘提示","keywords":"","body":"datetime:2019/5/20 15:58 author:nzb 创建提示 import sys from PyQt5.QtWidgets import QApplication, QDialog, QLabel, QHBoxLayout, QPushButton from PyQt5 import QtGui class UI_demo(QDialog): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 WhaiIsThis Class' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 hbox = QHBoxLayout() label = QLabel(\"Focus and press Shift + F1\") hbox.addWidget(label) button = QPushButton('click me', self) button.setWhatsThis(\"This is a button that you can click on this\") hbox.addWidget(button) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/10-行编辑lineedit.html":{"url":"Python/第三方库/PyQt5/10-行编辑lineedit.html","title":"行编辑Lineedit","keywords":"","body":"datetime:2019/5/20 16:12 author:nzb 行编辑 import sys from PyQt5.QtWidgets import QWidget, QApplication, QDialog, QVBoxLayout, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QLineEdit from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Lineedit' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon('../img/home.ico')) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 行编辑 hbox = QHBoxLayout() self.lineedit = QLineEdit(self) self.lineedit.setFont(QtGui.QFont('Sanserif', 15)) self.lineedit.returnPressed.connect(self.onPressed) hbox.addWidget(self.lineedit) self.lable = QLabel(self) self.lable.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.lable) self.setLayout(hbox) # 展示窗口 self.show() def onPressed(self): \"\"\"输入绑定事件\"\"\" self.lable.setText(self.lineedit.text()) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/11-按钮组.html":{"url":"Python/第三方库/PyQt5/11-按钮组.html","title":"按钮组","keywords":"","body":"datetime:2019/5/20 16:28 author:nzb 按钮组 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 ButtonGroup' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 按钮组 hbox = QHBoxLayout() self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.label) self.buttongroup = QButtonGroup() # 创建按钮组 self.buttongroup.buttonClicked[int].connect(self.on_button_clicked) # 绑定事件 button = QPushButton('python') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/python.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 1) # 添加按钮 hbox.addWidget(button) button = QPushButton('java') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/java.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 2) hbox.addWidget(button) button = QPushButton('php') button.setFont(QtGui.QFont('Sanserif', 15)) button.setIcon(QtGui.QIcon('../img/php.ico')) button.setIconSize(QtCore.QSize(40, 40)) self.buttongroup.addButton(button, 3) hbox.addWidget(button) self.setLayout(hbox) # 展示窗口 self.show() def on_button_clicked(self, id): \"\"\"按钮事件\"\"\" for button in self.buttongroup.buttons(): if button is self.buttongroup.button(id): self.label.setText(button.text() + \" was clicked\") if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/12-布局组.html":{"url":"Python/第三方库/PyQt5/12-布局组.html","title":"布局组","keywords":"","body":"datetime:2019/5/20 17:03 author:nzb 布局组 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Groupbox' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 布局组 # 水平布局 hbox = QHBoxLayout() groupbox = QGroupBox('select you favorite sport') groupbox.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(groupbox) # 垂直布局 vbox = QVBoxLayout() rad1 = QRadioButton('soccer') vbox.addWidget(rad1) rad2 = QRadioButton('tennis') vbox.addWidget(rad2) groupbox.setLayout(vbox) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/13-无边框窗口.html":{"url":"Python/第三方库/PyQt5/13-无边框窗口.html","title":"无边框窗口","keywords":"","body":"datetime:2019/5/20 17:13 author:nzb 无边框窗口 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup, \\ QSizeGrip from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Frameless Window' self.left = 600 self.top = 200 self.width = 500 self.height = 200 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 无边框窗口 flags = QtCore.Qt.WindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint) self.setWindowFlags(flags) vbox = QVBoxLayout() sizegrip = QSizeGrip(self) vbox.addWidget(sizegrip) self.setLayout(vbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/14-框架qframe.html":{"url":"Python/第三方库/PyQt5/14-框架qframe.html","title":"框架Qframe","keywords":"","body":"datetime:2019/5/21 15:13 author:nzb 创建框架qframe import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, QHBoxLayout, QPushButton, QButtonGroup, \\ QSizeGrip, QFrame from PyQt5.QtWidgets import QVBoxLayout, QRadioButton from PyQt5 import QtGui, QtCore class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Qframe' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 设置背景颜色 # 框架qframe hbox = QHBoxLayout() btn = QPushButton('click me') btn.setStyleSheet('color:white') btn.setStyleSheet('background-color:green') frame = QFrame() frame.setFrameShape(QFrame.StyledPanel) frame.setStyleSheet('background-color:red') hbox.addWidget(frame) hbox.addWidget(btn) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/15-分离器.html":{"url":"Python/第三方库/PyQt5/15-分离器.html","title":"分离器","keywords":"","body":"datetime:2019/5/21 15:16 author:nzb 创建分离器 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QPushButton, QButtonGroup, QSizeGrip, QFrame from PyQt5.QtWidgets import QVBoxLayout, QRadioButton, QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Splitters' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 分离器 hbox = QHBoxLayout() left = QFrame() left.setFrameShape(QFrame.StyledPanel) bottom = QFrame() bottom.setFrameShape(QFrame.StyledPanel) splitter1 = QSplitter(Qt.Horizontal) # 水平分离（默认） splitter1.setStyleSheet('background-color:red') lineedit = QLineEdit() lineedit.setStyleSheet('background-color:green') splitter1.addWidget(left) splitter1.addWidget(lineedit) splitter1.setSizes([200, 200]) splitter2 = QSplitter(Qt.Vertical) # 垂直分离 splitter2.addWidget(splitter1) splitter2.addWidget(bottom) splitter2.setStyleSheet('background-color:blue') hbox.addWidget(splitter2) self.setLayout(hbox) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/16-滑动条.html":{"url":"Python/第三方库/PyQt5/16-滑动条.html","title":"滑动条","keywords":"","body":"datetime:2019/5/21 15:44 author:nzb 创建滑动条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QPushButton, QButtonGroup, QFrame, QSlider from PyQt5.QtWidgets import QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Slider' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 滑动条 hbox = QHBoxLayout() # 水平布局 self.slider = QSlider() self.slider.setOrientation(Qt.Horizontal) # 水平滑动（默认垂直） self.slider.setTickPosition(QSlider.TicksBelow) # 刻度 self.slider.setTickInterval(10) # 设置刻度数量 self.slider.setMinimum(0) # 滑动条最小值 self.slider.setMaximum(100) # 滑动条最大值 self.slider.valueChanged.connect(self.changedValue) # 绑定事件 self.label = QLabel('0') self.label.setFont(QtGui.QFont('Sanserif', 15)) hbox.addWidget(self.slider) hbox.addWidget(self.label) self.setLayout(hbox) # 展示窗口 self.show() def changedValue(self): size = self.slider.value() self.label.setText(str(size)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/17-滚动条.html":{"url":"Python/第三方库/PyQt5/17-滚动条.html","title":"滚动条","keywords":"","body":"datetime:2019/5/21 16:00 author:nzb 创建滚动条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QFrame, QScrollArea, QFormLayout, QPushButton, QVBoxLayout from PyQt5.QtWidgets import QSplitter, QLineEdit from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self, val): super().__init__() # 窗口信息 self.title = 'PyQt5 QScroll Area' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.val = val self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 滚动区域 formLayout = QFormLayout() # 表单布局 groupBox = QGroupBox(\"This is group box\") labelList = [] buttonList = [] for i in range(self.val): labelList.append(QLabel(\"Label\")) buttonList.append(QPushButton('click me')) formLayout.addRow(labelList[i], buttonList[i]) groupBox.setLayout(formLayout) scroll = QScrollArea() scroll.setWidget(groupBox) scroll.setWidgetResizable(True) scroll.setFixedHeight(400) layout = QVBoxLayout() layout.addWidget(scroll) self.setLayout(layout) # 展示窗口 self.show() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo(20) sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/18-刻度盘.html":{"url":"Python/第三方库/PyQt5/18-刻度盘.html","title":"刻度盘","keywords":"","body":"datetime:2019/5/21 16:23 author:nzb 创建刻度盘 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, QCheckBox, \\ QHBoxLayout, QFrame, QScrollArea, QFormLayout, QPushButton, QVBoxLayout from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 QDial' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 刻度盘 vbox = QVBoxLayout() self.label = QLabel(self) self.label.setFont(QtGui.QFont('Sanserif', 15)) self.dial = QDial() self.dial.setMinimum(0) self.dial.setMaximum(100) self.dial.setValue(30) self.dial.valueChanged.connect(self.dial_changed) vbox.addWidget(self.dial) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def dial_changed(self): getValue = self.dial.value() self.label.setText(\"Dial is changing：\" + str(getValue)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/19-spinbox.html":{"url":"Python/第三方库/PyQt5/19-spinbox.html","title":"Spinbox","keywords":"","body":"datetime:2019/5/21 16:45 author:nzb spinbox import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self, val): super().__init__() # 窗口信息 self.title = 'PyQt5 QSpinbox' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.val = val self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 转动盒子 vbox = QVBoxLayout() self.spinbox = QSpinBox() self.spinbox.valueChanged.connect(self.spin_changed) vbox.addWidget(self.spinbox) self.label = QLabel() self.label.setFont(QtGui.QFont('Sanserif', 15)) self.label.setAlignment(Qt.AlignCenter) vbox.addWidget(self.label) self.setLayout(vbox) # 展示窗口 self.show() def spin_changed(self): spinValue = self.spinbox.value() self.label.setText(\"current value is :\" + str(spinValue)) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo(20) sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/20-生成随机数.html":{"url":"Python/第三方库/PyQt5/20-生成随机数.html","title":"生成随机数","keywords":"","body":"datetime:2019/5/21 16:59 author:nzb 生成随机数 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt from random import randint class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 QLCDNumber' self.left = 600 self.top = 200 self.width = 500 self.height = 500 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 随机生成数字 self.initUI() # 展示窗口 self.show() def initUI(self): \"\"\"随机生成数字\"\"\" vbox = QVBoxLayout() self.lcd = QLCDNumber() # self.lcd.display(60) # 显示数字 self.lcd.setStyleSheet('background-color:green') vbox.addWidget(self.lcd) self.button = QPushButton('random number generator') self.button.setStyleSheet('background-color:yellow') self.button.clicked.connect(self.LCDHandler) vbox.addWidget(self.button) self.setLayout(vbox) def LCDHandler(self): \"\"\"随机数字\"\"\" random = randint(1, 200) self.lcd.display(random) # 显示数字 if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/21-进度条.html":{"url":"Python/第三方库/PyQt5/21-进度条.html","title":"进度条","keywords":"","body":"datetime:2019/5/21 17:38 author:nzb 进度条 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial, QProgressBar from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt, QThread, pyqtSignal import time class MyThead(QThread): change_value = pyqtSignal(int) def run(self): cnt = 0 while cnt "},"Python/第三方库/PyQt5/22-工具框.html":{"url":"Python/第三方库/PyQt5/22-工具框.html","title":"工具框","keywords":"","body":"datetime:2019/5/21 17:51 author:nzb 工具框 import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGroupBox, \\ QHBoxLayout, QPushButton, QVBoxLayout, QSpinBox, QLCDNumber from PyQt5.QtWidgets import QDial, QToolBox from PyQt5 import QtGui, QtCore from PyQt5.QtCore import Qt, QThread, pyqtSignal class UI_demo(QWidget): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Toolbox' self.left = 600 self.top = 200 self.width = 440 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 self.setStyleSheet('background-color:yellow') # 生成工具盒子 self.initUI() # 展示窗口 self.show() def initUI(self): \"\"\"工具盒子\"\"\" vbox = QVBoxLayout() toolbox = QToolBox() toolbox.setStyleSheet('background-color:green') vbox.addWidget(toolbox) label = QLabel() toolbox.addItem(label, \"Python\") label = QLabel() toolbox.addItem(label, \"Java\") label = QLabel() toolbox.addItem(label, \"PHP\") self.setLayout(vbox) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/23-菜单栏工具栏.html":{"url":"Python/第三方库/PyQt5/23-菜单栏工具栏.html","title":"菜单栏工具栏","keywords":"","body":"datetime:2019/5/22 16:57 author:nzb 菜单栏和工具栏 菜单栏 工具栏 import sys from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QAction from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 MenuBar' self.left = 600 self.top = 200 self.width = 440 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") fileMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") fileMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") fileMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/24-文档编辑框.html":{"url":"Python/第三方库/PyQt5/24-文档编辑框.html","title":"文档编辑框","keywords":"","body":"datetime:2019/5/22 17:09 author:nzb 文档编辑框 import sys from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow, QAction, QTextEdit from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 TextEdit' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") fileMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") fileMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") fileMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/25-字体文本框.html":{"url":"Python/第三方库/PyQt5/25-字体文本框.html","title":"字体文本框","keywords":"","body":"datetime:2019/5/22 17:20 author:nzb 文本框字体的选择 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Font Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/26-颜色文本框.html":{"url":"Python/第三方库/PyQt5/26-颜色文本框.html","title":"颜色文本框","keywords":"","body":"datetime:2019/5/22 17:27 author:nzb 字体颜色 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Color Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/27-打印（文本框）.html":{"url":"Python/第三方库/PyQt5/27-打印（文本框）.html","title":"打印（文本框）","keywords":"","body":"datetime:2019/5/22 17:35 author:nzb 打印 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Print Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) printAction = QAction(QtGui.QIcon(self.iconName), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/28-打印预览.html":{"url":"Python/第三方库/PyQt5/28-打印预览.html","title":"打印预览","keywords":"","body":"datetime:2019/5/22 17:47 author:nzb 打印预览 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 PrintPreview Dialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') copyAction = QAction(QtGui.QIcon(self.iconName), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) cutAction = QAction(QtGui.QIcon(self.iconName), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) saveAction = QAction(QtGui.QIcon(self.iconName), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) printAction = QAction(QtGui.QIcon(self.iconName), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) printpreviewAction = QAction(QtGui.QIcon(self.iconName), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) exitAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) pasteAction = QAction(QtGui.QIcon('../img/Agt Stop.ico'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) fontAction = QAction(QtGui.QIcon(self.iconName), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) colorAction = QAction(QtGui.QIcon(self.iconName), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/29-打印PDF.html":{"url":"Python/第三方库/PyQt5/29-打印PDF.html","title":"打印PDF","keywords":"","body":"datetime:2019/5/23 10:26 author:nzb 打印PDF import sys from PyQt5.QtWidgets import QFileDialog, QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog from PyQt5.QtCore import QFileInfo class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 PDF' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') # 复制 copyAction = QAction(QtGui.QIcon('../img/copy.ico'), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) # 剪切 cutAction = QAction(QtGui.QIcon('../img/cut.png'), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) # 保存 saveAction = QAction(QtGui.QIcon('../img/save.png'), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) # 打印 printAction = QAction(QtGui.QIcon('../img/print.png'), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) # 打印预览 printpreviewAction = QAction(QtGui.QIcon('../img/printpreview.png'), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) # pdf pdfAction = QAction(QtGui.QIcon('../img/pdf.png'), 'PDF', self) pdfAction.triggered.connect(self.pdfExport) fileMenu.addAction(pdfAction) # 退出 exitAction = QAction(QtGui.QIcon('../img/exit.png'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) # 黏贴 pasteAction = QAction(QtGui.QIcon('../img/paste.png'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 字体 fontAction = QAction(QtGui.QIcon('../img/font.png'), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 字体颜色 colorAction = QAction(QtGui.QIcon('../img/color.png'), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) toolbar.addAction(pdfAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) def pdfExport(self): \"\"\"导出PDF\"\"\" fn, _ = QFileDialog.getSaveFileName(self, \"Export PDF\", None, \"PDF files (.pdf);;All Files()\") if fn != '': if QFileInfo(fn).suffix() == \"\": fn += '.pdf' printer = QPrinter(QPrinter.HighResolution) printer.setOutputFormat(QPrinter.PdfFormat) printer.setOutputFileName(fn) self.textEdit.document().print_(printer) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/30-消息框提示框（带选择的）.html":{"url":"Python/第三方库/PyQt5/30-消息框提示框（带选择的）.html","title":"消息框提示框（带选择的）","keywords":"","body":"datetime:2019/5/23 10:44 author:nzb （带选择的）消息框提示框 import sys from PyQt5.QtWidgets import QFileDialog, QApplication, QMainWindow, QAction, QTextEdit, QFontDialog, QColorDialog, QMessageBox from PyQt5 import QtGui,QtCore from PyQt5.QtPrintSupport import QPrintDialog, QPrinter, QPrintPreviewDialog from PyQt5.QtCore import QFileInfo class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Messagebox' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 生成菜单栏 self.CreateMenu() # 生成文档编辑 self.createEditor() # 展示窗口 self.show() def CreateMenu(self): \"\"\"菜单栏\"\"\" mainMenu = self.menuBar() fileMenu = mainMenu.addMenu('File') editMenu = mainMenu.addMenu('Edit') viewMenu = mainMenu.addMenu('View') helpMenu = mainMenu.addMenu('Help') # 复制 copyAction = QAction(QtGui.QIcon('../img/copy.ico'), 'Copy', self) copyAction.setShortcut(\"Ctrl+C\") editMenu.addAction(copyAction) # 剪切 cutAction = QAction(QtGui.QIcon('../img/cut.png'), 'Cut', self) cutAction.setShortcut(\"Ctrl+X\") editMenu.addAction(cutAction) # 保存 saveAction = QAction(QtGui.QIcon('../img/save.png'), 'Save', self) saveAction.setShortcut(\"Ctrl+S\") editMenu.addAction(saveAction) # 打印 printAction = QAction(QtGui.QIcon('../img/print.png'), \"Print\", self) printAction.triggered.connect(self.printDialog) fileMenu.addAction(printAction) # 打印预览 printpreviewAction = QAction(QtGui.QIcon('../img/printpreview.png'), \"PrintPreview\", self) printpreviewAction.triggered.connect(self.printPreviewDialog) fileMenu.addAction(printpreviewAction) # pdf pdfAction = QAction(QtGui.QIcon('../img/pdf.png'), 'PDF', self) pdfAction.triggered.connect(self.pdfExport) fileMenu.addAction(pdfAction) # 退出 exitAction = QAction(QtGui.QIcon('../img/exit.png'), 'Exit', self) exitAction.setShortcut(\"Ctrl+E\") exitAction.triggered.connect(self.exitWindow) fileMenu.addAction(exitAction) # 黏贴 pasteAction = QAction(QtGui.QIcon('../img/paste.png'), 'Paste', self) pasteAction.setShortcut(\"Ctrl+E\") editMenu.addAction(pasteAction) # 字体 fontAction = QAction(QtGui.QIcon('../img/font.png'), \"Font\", self) fontAction.setShortcut(\"Ctrl+F\") fontAction.triggered.connect(self.fontDialog) viewMenu.addAction(fontAction) # 字体颜色 colorAction = QAction(QtGui.QIcon('../img/color.png'), \"Color\", self) colorAction.triggered.connect(self.colorDialog) viewMenu.addAction(colorAction) # 消息框，提示框 helpAction = QAction(QtGui.QIcon('../img/about.ico'), \"About\", self) helpAction.triggered.connect(self.AboutMessageBox) helpMenu.addAction(helpAction) # 带选择的消息框，提示框 choiceAction = QAction(QtGui.QIcon('../img/about.ico'), \"Choice Message\", self) choiceAction.triggered.connect(self.choiceMessageBox) helpMenu.addAction(choiceAction) # 工具栏 toolbar = self.addToolBar(\"Toolbar\") toolbar.addAction(copyAction) toolbar.addAction(cutAction) toolbar.addAction(saveAction) toolbar.addAction(exitAction) toolbar.addAction(pasteAction) toolbar.addAction(fontAction) toolbar.addAction(colorAction) toolbar.addAction(printAction) toolbar.addAction(pdfAction) toolbar.addAction(helpAction) def exitWindow(self): \"\"\"关闭窗口\"\"\" self.close() def createEditor(self): \"\"\"文档编辑\"\"\" self.textEdit = QTextEdit(self) self.setCentralWidget(self.textEdit) def fontDialog(self): \"\"\"字体对话框\"\"\" font, ok = QFontDialog.getFont() if ok: self.textEdit.setFont(font) def colorDialog(self): \"\"\"颜色对话框\"\"\" color = QColorDialog.getColor() self.textEdit.setTextColor(color) def printDialog(self): \"\"\"打印文本框\"\"\" printer = QPrinter(QPrinter.HighResolution) dialog = QPrintDialog(printer, self) if dialog.exec_() == QPrintDialog.Accepted: self.textEdit.print_(printer) def printPreviewDialog(self): \"\"\"打印预览\"\"\" printer = QPrinter(QPrinter.HighResolution) previewDialog = QPrintPreviewDialog(printer, self) previewDialog.paintRequested.connect(self.printPreview) previewDialog.exec_() def printPreview(self, printer): \"\"\"打印预览\"\"\" self.textEdit.print_(printer) def pdfExport(self): \"\"\"导出PDF\"\"\" fn, _ = QFileDialog.getSaveFileName(self, \"Export PDF\", None, \"PDF files (.pdf);;All Files()\") if fn != '': if QFileInfo(fn).suffix() == \"\": fn += '.pdf' printer = QPrinter(QPrinter.HighResolution) printer.setOutputFormat(QPrinter.PdfFormat) printer.setOutputFileName(fn) self.textEdit.document().print_(printer) def AboutMessageBox(self): \"\"\"消息框提示框\"\"\" message = QMessageBox.about(self, \"About application\", \"this is simple texteditor application\") def choiceMessageBox(self): \"\"\"带选择的消息框和提示框\"\"\" message = QMessageBox.question(self, \"Choice Message\", 'Do you like PyQt5?', QMessageBox.Yes | QMessageBox.No) if message == QMessageBox.Yes: self.textEdit.setText(\"Yes I like PyQt5\") else: self.textEdit.setText(\"No I don't like PyQt5\") if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/31-右键菜单.html":{"url":"Python/第三方库/PyQt5/31-右键菜单.html","title":"右键菜单","keywords":"","body":"datetime:2019/5/23 10:53 author:nzb 右键菜单 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QMenu from PyQt5 import QtGui class UI_demo(QMainWindow): \"\"\"用户界面\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 Context Menu' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # 展示窗口 self.show() def contextMenuEvent(self, event): \"\"\"右键菜单\"\"\" contextMenu = QMenu(self) newAction = contextMenu.addAction(\"New\") openAction = contextMenu.addAction(\"Open\") quitAction = contextMenu.addAction(\"Quit\") action = contextMenu.exec_(self.mapToGlobal(event.pos())) if action == quitAction: self.close() if __name__ == \"__main__\": app = QApplication(sys.argv) ex = UI_demo() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/32-选项卡（单选下拉框和多选）.html":{"url":"Python/第三方库/PyQt5/32-选项卡（单选下拉框和多选）.html","title":"选项卡（单选下拉框和多选）","keywords":"","body":"datetime:2019/5/23 11:26 author:nzb 选项卡（单选下拉框和多选） 选项卡 单选和多选 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QGroupBox, QComboBox, QCheckBox, QDialog, QTabWidget, QWidget, QVBoxLayout, QDialogButtonBox, QTabWidget, QLabel, QLineEdit import sys from PyQt5.QtGui import QIcon class Tab(QDialog): \"\"\"选项卡\"\"\" def __init__(self): super().__init__() self.setWindowTitle(\"PyQt5 Tab Widget\") self.setWindowIcon(QIcon('../img/home.ico')) vbox = QVBoxLayout() tabWidget = QTabWidget() # 按钮 buttonbox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel) buttonbox.accepted.connect(self.accept) buttonbox.accepted.connect(self.reject) # 选项卡 tabWidget.addTab(TabContact(), \"Contact Details\") tabWidget.addTab(TabPersonDetails(), 'Personal Details') vbox.addWidget(tabWidget) vbox.addWidget(buttonbox) self.setLayout(vbox) class TabContact(QWidget): def __init__(self): super().__init__() nameLabel = QLabel(\"Name: \") nameEdit = QLineEdit() phoneLabel = QLabel(\"Phone: \") phoneEdit = QLineEdit() emailLabel = QLabel(\"Email: \") emailEdit = QLineEdit() vbox = QVBoxLayout() vbox.addWidget(nameLabel) vbox.addWidget(nameEdit) vbox.addWidget(phoneLabel) vbox.addWidget(phoneEdit) vbox.addWidget(emailLabel) vbox.addWidget(emailEdit) self.setLayout(vbox) class TabPersonDetails(QWidget): def __init__(self): super().__init__() # 单选下拉框 groupbox = QGroupBox(\"select your gender\") list1 = [\"male\", 'female'] combo = QComboBox() combo.addItems(list1) vbox = QVBoxLayout() vbox.addWidget(combo) groupbox.setLayout(vbox) # 多选 groupbox2 = QGroupBox(\"select your favorite programming language\") python = QCheckBox(\"Python\") cpp = QCheckBox(\"C++\") java = QCheckBox(\"Java\") vbox = QVBoxLayout() vbox.addWidget(python) vbox.addWidget(cpp) vbox.addWidget(java) groupbox2.setLayout(vbox) mainLayout = QVBoxLayout() mainLayout.addWidget(groupbox) mainLayout.addWidget(groupbox2) self.setLayout(mainLayout) if __name__ == \"__main__\": app = QApplication(sys.argv) tabDialog = Tab() tabDialog.show() app.exec_() "},"Python/第三方库/PyQt5/34-可停靠的窗口小部件.html":{"url":"Python/第三方库/PyQt5/34-可停靠的窗口小部件.html","title":"可停靠的窗口小部件","keywords":"","body":"datetime:2019/5/23 13:37 author:nzb 可停靠的窗口小部件 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QPushButton, QStackedWidget, QGroupBox, QComboBox, QDialog, QTabWidget, QWidget, QVBoxLayout, QLabel from PyQt5.QtWidgets import QTextEdit, QDockWidget, QMainWindow, QListWidget import sys from PyQt5.QtGui import QIcon from PyQt5.QtCore import Qt class DockDialog(QMainWindow): \"\"\"可停靠的窗口小部件\"\"\" def __init__(self): super().__init__() # 窗口信息 self.title = 'PyQt5 DockDialog' self.left = 600 self.top = 200 self.width = 500 self.height = 400 self.iconName = '../img/home.ico' self.initWindow() def initWindow(self): # 窗口信息 self.setWindowIcon(QtGui.QIcon(self.iconName)) # 图标设置 self.setGeometry(self.left, self.top, self.width, self.height) # 大小位置设置 self.setWindowTitle(self.title) # 窗口标题 # self.createDockWidget() # 展示窗口 self.show() def createDockWidget(self): menubar = self.menuBar() file = menubar.addMenu(\"File\") file.addAction(\"New\") file.addAction(\"Save\") file.addAction(\"Close\") self.dock = QDockWidget(\"Dockable\", self) self.listwidget = QListWidget() list1 = ['Python', 'C++', 'Java'] self.listwidget.addItems(list1) self.dock.setWidget(self.listwidget) self.setCentralWidget(QTextEdit()) self.addDockWidget(Qt.RightDockWidgetArea, self.dock) if __name__ == \"__main__\": app = QApplication(sys.argv) ex = DockDialog() sys.exit(app.exec_()) "},"Python/第三方库/PyQt5/35-日历.html":{"url":"Python/第三方库/PyQt5/35-日历.html","title":"日历","keywords":"","body":"datetime:2019/5/23 13:44 author:nzb 日历 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QDialog, QCalendarWidget, QVBoxLayout, QLabel import sys class Window(QDialog): def __init__(self): super().__init__() self.title = \"PyQt5 QCalender\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.Calender() self.show() def Calender(self): vbox = QVBoxLayout() self.calender = QCalendarWidget() self.calender.selectionChanged.connect(self.onSelectionChanged) self.calender.setGridVisible(True) vbox.addWidget(self.calender) self.label = QLabel() self.label.setFont(QtGui.QFont(\"Sanserif\", 15)) self.label.setStyleSheet('color:green') vbox.addWidget(self.label) self.setLayout(vbox) def onSelectionChanged(self): ca = self.calender.selectedDate() self.label.setText(str(ca)) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) 日历中时间的格式化 from PyQt5.QtCore import QDateTime, QDate,QTime,Qt datetime = QDateTime.currentDateTime() print(datetime.toString()) print(datetime.toString(Qt.ISODate)) print(datetime.toString(Qt.DefaultLocaleLongDate)) # 周四 5月 23 13:46:48 2019 # 2019-05-23T13:46:48 # 2019年5月23日 13:46:48 date = QDate.currentDate() print(date.toString()) print(date.toString(Qt.ISODate)) print(date.toString(Qt.DefaultLocaleLongDate)) # 周四 5月 23 2019 # 2019-05-23 # 2019年5月23日 time = QTime.currentTime() print(time.toString()) print(time.toString(Qt.DefaultLocaleLongDate)) # 13:46:48 # 13:46:48 "},"Python/第三方库/PyQt5/36-单选下拉框.html":{"url":"Python/第三方库/PyQt5/36-单选下拉框.html","title":"单选下拉框","keywords":"","body":"datetime:2019/5/23 14:07 author:nzb 单选下拉框 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys class Window(QDialog): \"\"\"下拉框\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 combobox\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() self.combo = QComboBox() self.combo.addItem(\"Python\") self.combo.addItem(\"Ruby\") self.combo.addItem(\"C++\") self.combo.addItem(\"PHP\") self.combo.currentTextChanged.connect(self.comboChanged) self.label = QLabel() self.label.setFont(QtGui.QFont(\"Sanserif\", 15)) self.label.setStyleSheet(\"color:red\") vbox.addWidget(self.combo) vbox.addWidget(self.label) self.setLayout(vbox) def comboChanged(self): \"\"\"选择事件\"\"\" text = self.combo.currentText() self.label.setText(\"You have selected \" + text) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/37-首字符模糊填充（查询）.html":{"url":"Python/第三方库/PyQt5/37-首字符模糊填充（查询）.html","title":"首字符模糊填充（查询）","keywords":"","body":"datetime:2019/5/23 14:14 author:nzb 首字符模糊填充（查询） from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit class Window(QDialog): \"\"\"模糊查询\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 completer\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"icon.png\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() names = ['China', 'USA', 'Pakistan', 'Japan', 'India', 'American', '测试中文'] completer = QCompleter(names) self.lineedit = QLineEdit() self.lineedit.setCompleter(completer) vbox.addWidget(self.lineedit) self.setLayout(vbox) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/38-打开更多的窗口.html":{"url":"Python/第三方库/PyQt5/38-打开更多的窗口.html","title":"打开更多的窗口","keywords":"","body":"datetime:2019/5/23 14:28 author:nzb 打开更多的窗口 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication,QLabel, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit class Window(QDialog): \"\"\"模糊查询\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QDialog\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.InitUI() self.show() def InitUI(self): vbox = QVBoxLayout() self.btn = QPushButton(\"Open second dialog\") self.btn.setFont(QtGui.QFont(\"Sanserif\", 15)) self.btn.clicked.connect(self.openSecondDialog) vbox.addWidget(self.btn) self.setLayout(vbox) def openSecondDialog(self): \"\"\"打开另一个窗口\"\"\" # 1.只能打开第二个，并且不能移动第一个 # mydialog = QDialog() # mydialog.setModal(True) # mydialog.exec() # 可以无限打开，并且可以在第一个上操作 mydialog = QDialog(self) mydialog.show() App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/39-时间编辑.html":{"url":"Python/第三方库/PyQt5/39-时间编辑.html","title":"时间编辑","keywords":"","body":"datetime:2019/5/23 14:37 author:nzb 时间编辑 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit, QTimeEdit from PyQt5.QtCore import QTime class Window(QWidget): \"\"\"时间编辑\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QDialog\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) self.MyTime() self.show() def MyTime(self): vbox = QVBoxLayout() time = QTime() time.setHMS(13, 15, 40) timeedit = QTimeEdit() timeedit.setFont(QtGui.QFont('Sanserif', 15)) timeedit.setTime(time) vbox.addWidget(timeedit) self.setLayout(vbox) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/40-列表部件.html":{"url":"Python/第三方库/PyQt5/40-列表部件.html","title":"列表部件","keywords":"","body":"datetime:2019/5/23 14:52 author:nzb 列表部件 from PyQt5 import QtGui from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QComboBox, QVBoxLayout, QDialog, QMainWindow, QCalendarWidget, QVBoxLayout, QLabel import sys from PyQt5.QtWidgets import QCompleter, QLineEdit, QTimeEdit, QListWidget from PyQt5.QtCore import QTime class Window(QWidget): \"\"\"列表部件\"\"\" def __init__(self): super().__init__() self.title = \"PyQt5 QListWidget\" self.top = 200 self.left = 500 self.width = 400 self.height = 300 self.InitWindow() def InitWindow(self): self.setWindowIcon(QtGui.QIcon(\"../img/home.ico\")) self.setWindowTitle(self.title) self.setGeometry(self.left, self.top, self.width, self.height) vbox = QVBoxLayout() self.list = QListWidget() self.list.insertItem(0, \"Python\") self.list.insertItem(1, \"PHP\") self.list.insertItem(2, \"Java\") self.list.insertItem(3, \"C++\") self.list.clicked.connect(self.listview_clicked) self.label = QLabel() self.setFont(QtGui.QFont(\"Sanserif\", 15)) vbox.addWidget(self.label) vbox.addWidget(self.list) self.setLayout(vbox) self.show() def listview_clicked(self): item = self.list.currentItem() self.label.setText(str(item.text())) App = QApplication(sys.argv) window = Window() sys.exit(App.exec()) "},"Python/第三方库/PyQt5/41-列表部件小示例.html":{"url":"Python/第三方库/PyQt5/41-列表部件小示例.html","title":"列表部件小示例","keywords":"","body":"datetime:2019/5/23 15:25 author:nzb 列表部件小示例 from PyQt5.QtWidgets import QApplication, QDialog, QLineEdit, QMessageBox, QInputDialog, QListWidget, QVBoxLayout, QPushButton, QHBoxLayout from PyQt5.QtGui import QIcon from PyQt5 import QtGui import sys class ProgrammingDialog(QDialog): def __init__(self, name, prolist = None): super(ProgrammingDialog, self).__init__() self.setWindowTitle(\"PyQt5 simple List project\") self.setWindowIcon(QtGui.QIcon('../img/home.ico')) self.name = name self.list = QListWidget() if prolist is not None: self.list.addItems(prolist) self.list.setCurrentRow(0) vbox = QVBoxLayout() for text, slot in ((\"Add\", self.Add), (\"Edit\", self.Edit), (\"Remove\", self.Remove), (\"Sort\", self.Sort), (\"Close\", self.Close)): button = QPushButton(text) button.clicked.connect(slot) vbox.addWidget(button) hbox = QHBoxLayout() hbox.addWidget(self.list) hbox.addLayout(vbox) self.setLayout(hbox) def Add(self): row = self.list.currentRow() title = \"Add {0}\".format(self.name) string, ok = QInputDialog.getText(self, title, title) if ok and string is not None: self.list.insertItem(row, string) def Edit(self): row = self.list.currentRow() item = self.list.item(row) if item is not None: title = \"Edit {0}\".format(self.name) string, ok = QInputDialog.getText(self, title, title, QLineEdit.Normal, item.text()) if ok and string is not None: item.setText(string) def Remove(self): row = self.list.currentRow() item = self.list.item(row) if item is None: return reply = QMessageBox.question(self, \"Remove{0}\".format( self.name), \"Remove{0} '{1}'?\".format( self.name, str(item.text())), QMessageBox.Yes | QMessageBox.No) if reply == QMessageBox.Yes: item = self.list.takeItem(row) del item def Sort(self): self.list.sortItems() def Close(self): self.close() # self.accept() if __name__ == '__main__': programming = [\"Python\", \"Java\", \"PHP\", \"C++\"] app = QApplication(sys.argv) dialog = ProgrammingDialog(\"Language\", programming) dialog.exec_() "},"Python/第三方库/PySide/01-Qt简介.html":{"url":"Python/第三方库/PySide/01-Qt简介.html","title":"Qt简介","keywords":"","body":"Python Qt 简介 Python图形界面开发的几种方案 程序的用户交互界面，英文称之为 UI (user interface) 当一个应用的 UI 比较复杂的时候，命令行方式就不便用户使用了，这时我们需要图形界面。 如果用 Python 语言开发 跨平台 的图形界面的程序，主要有3种选择： Tkinter 基于Tk的Python库，这是Python官方采用的标准库，优点是作为Python标准库、稳定、发布程序较小，缺点是控件相对较少。适合开发小工具，界面比较简单。 wxPython 基于wxWidgets的Python库，优点是控件比较丰富，缺点是稳定性相对差点、文档少、用户少。 PySide2、PyQt5 基于Qt 的Python库，优点是控件比较丰富、跨平台体验好、文档完善、用户多。 缺点是库比较大，发布出来的程序比较大。适合发布功能比较多的正式产品。 注意：现在已经到 PySide6 了 PySide2、PyQt5 简介 PySide2、PyQt5 都是基于著名的 Qt 库。 Qt库里面有非常强大的图形界面开发库，但是Qt库是C++语言开发的，PySide2、PyQt5可以让我们通过Python语言使用Qt。 但是 PySide2、PyQt5 这两者有什么区别呢？ 可以形象地这样说： PySide2 是Qt的 亲儿子 ， PyQt5 是Qt还没有亲儿子之前的收的 义子 （Riverbank Computing这个公司开发的）。 那为什么 PyQt5 这个义子 反而比 PySide2 这个亲儿子更出名呢？ 原因很简单：PySide2 这亲儿子最近（2018年7月）才出生。 但是亲儿子毕竟是亲儿子，Qt准备大力培养，PySide2 或许更有前途。 已经在使用 PyQt5 的朋友不要皱眉， 两个库的使用 对程序员来说，差别很小：它们的调用接口几乎一模一样。 如果你的程序是PyQt5开发的，通常只要略作修改，比如把导入的名字从 PyQt5 换成 PySide2 就行了。反之亦然。 安装 PySide2 很简单，直接执行 pip install pyside2 即可下载安装。 这个库比较大，大概有100M左右，大家耐心等待。 有的朋友，网络比较慢，可以指定国内的安装源，下载安装。 比如，使用豆瓣源下载安装：pip install pyside2 -i https://pypi.douban.com/simple/ 安装PyQt5 如果你选择PyQt5，直接执行 pip install pyqt5-tools 即可同时安装 PyQt5 和 一些重要的工具，比如 Qt designer。 "},"Python/第三方库/PySide/02-界面设计师QtDesigner.html":{"url":"Python/第三方库/PySide/02-界面设计师QtDesigner.html","title":"界面设计师QtDesigner","keywords":"","body":"界面设计师 Qt Designer Qt Designer 简介 QT程序界面的 一个个窗口、控件，就是像上面那样用相应的代码创建出来的。 但是，把你的脑海里的界面，用代码直接写出来，是有些困难的。 很多时候，运行时呈现的样子，不是我们要的。我们经常还要修改代码调整界面上控件的位置，再运行预览。反复多次这样操作。 可是这样，真的…太麻烦了。 其实，我们可以用QT界面生成器 Qt Designer ，拖拖拽拽就可以直观的创建出程序大体的界面。 怎么运行这个工具呢？ Windows下，运行 Python安装目录下 Scripts\\pyside2-designer.exe 这个可执行文件 如果你安装的是pyqt5， 运行 Python安装目录下 Scripts\\pyqt5designer.exe 这个可执行文件 通过 Qt Designer 设计的界面，最终是保存在一个ui文件中的。 大家可以打开这个ui文件看看，就是一个XML格式的界面定义。 动态加载UI文件 有了界面定义文件，我们的Python程序就可以从文件中加载UI定义，并且动态创建一个相应的窗口对象。 如下： from PySide2.QtWidgets import QApplication, QMessageBox from PySide2.QtUiTools import QUiLoader class Stats: def __init__(self): # 从文件中加载UI定义 # 从 UI 定义中动态 创建一个相应的窗口对象 # 注意：里面的控件对象也成为窗口对象的属性了 # 比如 self.ui.button , self.ui.textEdit self.ui = QUiLoader().load('main.ui') self.ui.button.clicked.connect(self.handleCalc) def handleCalc(self): info = self.ui.textEdit.toPlainText() salary_above_20k = '' salary_below_20k = '' for line in info.splitlines(): if not line.strip(): continue parts = line.split(' ') parts = [p for p in parts if p] name, salary, age = parts if int(salary) >= 20000: salary_above_20k += name + '\\n' else: salary_below_20k += name + '\\n' QMessageBox.about(self.ui, '统计结果', f'''薪资20000 以上的有：\\n{salary_above_20k} \\n薪资20000 以下的有：\\n{salary_below_20k}''' ) app = QApplication([]) stats = Stats() stats.ui.show() app.exec_() 如果你使用的是PyQt5 而不是 PySide2，加载UI文件的代码如下 from PyQt5 import uic class Stats: def __init__(self): # 从文件中加载UI定义 self.ui = uic.loadUi(\"main.ui\") 转化 UI文件为 Python 代码 还有一种使用 UI 文件的方式：先把UI文件直接转化为包含界面定义的 Python 代码文件，然后在你的程序中使用定义界面的类 执行如下的命令把 UI 文件直接转化为包含界面定义的 Python 代码文件 pyside2-uic main.ui > ui_main.py 如果你安装的是PyQt5，执行如下格式的命令转化 pyuic5 main.ui > ui_main.py 然后在你的代码文件中这样使用定义界面的类 from PySide2.QtWidgets import QApplication, QMainWindow from ui_main import Ui_MainWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() # 使用ui文件导入定义界面类 self.ui = Ui_MainWindow() # 初始化界面 self.ui.setupUi(self) # 使用界面定义的控件，也是从ui里面访问 self.ui.webview.load('http://www.baidu.com') app = QApplication([]) mainw = MainWindow() mainw.show() app.exec_() 那么我们该使用哪种方式比较好呢？动态加载还是转化为Python代码？ 建议：通常采用动态加载比较方便，因为改动界面后，不需要转化，直接运行，特别方便。 但是，如果你的程序里面有非qt designer提供的控件， 这时候，需要在代码里面加上一些额外的声明，而且可能还会有奇怪的问题。往往就要采用转化Python代码的方法。 界面布局 Layout 我们前面写的界面程序有个问题，如果你用鼠标拖拽主窗口边框右下角，进行缩放，就会发现里面的控件一直保持原有大小不变。这样会很难看。 我们通常希望，随着主窗口的缩放， 界面里面的控件、控件之间的距离也相应的进行缩放。 Qt是通过界面布局 Layout 类来实现这种功能的。 我们最常用的 Layout布局 有4种，分别是 QHBoxLayout 水平布局：把控件从左到右 水平横着摆放，如下所示 QVBoxLayout 垂直布局：把控件从上到下竖着摆放，如下所示 QGridLayout 表格布局：把多个控件 格子状摆放，有的控件可以 占据多个格子，如下所示 QFormLayout 表单布局：表单就像一个只有两列的表格，非常适合填写注册表单这种类型的界面，如下所示 MainWindow 的 Layout 如果我们选择的主窗口是MainWindow类型，要给MainWindow整体设定Layout，必须先添加一个控件到 centralwidget 下面 ，如下 然后才能右键点击 MainWindow，选择布局，如下 调整控件位置和大小 调整 layout 中控件的大小比例可以通过设定控件的 sizePolicy 给不同的值来调整。 调整控件间距要调整控件上下间距，可以给控件添加layout，然后通过设定layout的上下的padding 和 margin 来调整间距。要调整控件的左右间距，可以通过添加 horizontal spacer （弹簧）进行控制，也可以通过layout的左右margin。 调整控件次序有的时候 我们需要调整一个layout里面，控件的上下显示次序，或者左右显示次序，该怎么做呢？如果是简单的两个控件在 layout里面，通常直接拖动就行了。 界面布局步骤建议 先不使用任何 Layout，把所有控件按位置摆放在界面上 然后先从 最内层开始 进行控件的 Layout 设定 逐步拓展到外层 进行控件的 Layout设定 最后调整 layout中控件的大小比例， 优先使用 Layout的 layoutStrentch 属性来控制 从一个窗口跳转到另外一个窗口 程序开始的时候显示一个窗口（比如登录窗口），操作后进入到另外一个窗口，怎么做。 方法很简单，主要就是 实例化另外一个窗口，显示新窗口，关闭老窗口。 如下代码所示 from PySide2 import QtWidgets import sys class Window2(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('窗口2') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('按钮2') grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) class MainWindow(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('窗口1') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('打开新窗口') button.clicked.connect(self.open_new_window) grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) def open_new_window(self): # 实例化另外一个窗口 self.window2 = Window2() # 显示新窗口 self.window2.show() # 关闭自己 self.close() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) 如果经常要在两个窗口来回跳转，可以使用 hide() 方法 隐藏窗口， 而不是 closes() 方法关闭窗口。 这样还有一个好处：被隐藏的窗口再次显示时，原来的操作内容还保存着，不会消失。 弹出模式对话框 有的时候，我们需要弹出一个模式对话框输入一些数据，然后回到 原窗口。 所谓模式对话框，就是弹出此对话框后， 原窗口就处于不可操作的状态，只有当模式对话框关闭才能继续。 参考如下代码 from PySide2 import QtWidgets import sys class MyDialog(QtWidgets.QDialog): def __init__(self): super().__init__() self.setWindowTitle('模式对话框') self.resize(500, 400) self.textEdit = QtWidgets.QPlainTextEdit(self) self.textEdit.setPlaceholderText(\"请输入薪资表\") self.textEdit.move(10, 25) self.textEdit.resize(300, 350) self.button = QtWidgets.QPushButton('统计', self) self.button.move(380, 80) class MainWindow(QtWidgets.QMainWindow): def __init__(self): super().__init__() self.setWindowTitle('主窗口') centralWidget = QtWidgets.QWidget() self.setCentralWidget(centralWidget) button = QtWidgets.QPushButton('打开模式对话框') button.clicked.connect(self.open_new_window) grid = QtWidgets.QGridLayout(centralWidget) grid.addWidget(button) def open_new_window(self): # 实例化一个对话框类 self.dlg = MyDialog() # 显示对话框，代码阻塞在这里， # 等待对话框关闭后，才能继续往后执行 self.dlg.exec_() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) "},"Python/第三方库/PySide/03-发布程序.html":{"url":"Python/第三方库/PySide/03-发布程序.html","title":"发布程序","keywords":"","body":"正式发布程序 前面，我们开发好了一个HTTP协议测试程序，但是这个程序是Python程序，运行它需要Python解释器。 如果我们要发布程序给客户使用，当然不能要求别人去安装Python解释器，并且敲命令 python httpclient.py。 我们应该做成 可执行程序 发布别人使用。详情 我们前面开发的QT界面程序，在Windows 上只需要执行下面的命令，即可制作独立exe程序 pyinstaller httpclient.py --noconsole --hidden-import PySide2.QtXml这样就会在当前目录下产生一个名为 dist 的目录。里面就有一个名为 httpclient 的目录，我们的可执行程序 httpclient.exe 就在里面。 其中 --noconsole 指定不要命令行窗口，否则我们的程序运行的时候，还会多一个黑窗口。 但是我建议大家可以先去掉这个参数，等确定运行成功后，再加上参数重新制作exe。因为这个黑窗口可以显示出程序的报错，这样我们容易找到问题的线索。 --hidden-import PySide2.QtXml 参数是因为这个 QtXml库是动态导入，PyInstaller没法分析出来，需要我们告诉它， 最后，别忘了，把程序所需要的ui文件拷贝到打包目录中。 因为PyInstaller只能分析出需要哪些代码文件。 而你的程序动态打开的资源文件，比如 图片、excel、ui这些，它是不会帮你打包的。 我们的 示例代码需要从 httpclient.ui 中加载界面，手动拷贝到 dist/httpclient 目录中。 然后，再双击运行 httpclient.exe ，完美！！ 程序图标 添加主窗口图标我们程序运行的窗口，需要显示自己的图标，这样才更像一个正式的产品。 通过如下代码，我们可以把一个png图片文件作为 程序窗口图标。 from PySide2.QtGui import QIcon app = QApplication([]) # 加载 icon app.setWindowIcon(QIcon('logo.png')) 注意：这些图标png文件，在使用PyInstaller创建可执行程序时，也要拷贝到程序所在目录。否则可执行程序运行后不会显示图标。 应用程序图标 应用程序图标是放在可执行程序里面的资源。 可以在PyInstaller创建可执行程序时，通过参数 --icon=\"logo.ico\" 指定。 比如 pyinstaller httpclient.py --noconsole --hidden-import PySide2.QtXml --icon=\"logo.ico\" 注意参数一定是存在的ico文件，不能是png等图片文件。 如果你只有png文件，可以通过在线的png转ico文件网站，生成ico，比如下面两个网站 网站1 网站2 注意：这些应用程序图标ico文件，在使用PyInstaller创建可执行程序时，不需要要拷贝到程序所在目录。因为它已经被嵌入可执行程序了。 "},"Python/第三方库/PySide/04-常用控件1.html":{"url":"Python/第三方库/PySide/04-常用控件1.html","title":"常用控件1","keywords":"","body":"常用控件 1 按钮 QPushButton 就是常见的按钮 信号：被点击 当按钮被点击就会发出 clicked 信号，可以这样指定处理该信号的函数 button.clicked.connect(handleCalc) 方法：改变文本 代码中可以使用 setText 方法来改变按钮文本，比如 button.setText(text) 方法：禁用、启用所有控件（继承自QWidget类）都支持 禁用和启用方法。 禁用后，该控件不再处理用户操作 禁用 button.setEnabled(False) 启用 button.setEnabled(True) 单行文本框 QLineEdit 是只能单行编辑的文本框。 信号：文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数edit.textChanged.connect(handleTextChange)Qt在调用这个信号处理函数时，传入的参数就是 文本框目前的内容字符串。 信号：按下回车键当用户在文本框中任何时候按下回车键，就会发出 returnPressed 信号。有时我们需要处理这种情况，比如登录界面，用户输完密码直接按回车键就进行登录处理，比再用鼠标点击登录按钮快捷的多。 可以指定处理 returnPressed 信号，如下所示passwordEdit.returnPressed.connect(onLogin) 方法：获取文本通过 text 方法获取编辑框内的文本内容，比如text = edit.text() 方法：设置提示通过 setPlaceholderText 方法可以设置提示文本内容，比如edit.setPlaceholderText('请在这里输入URL') 方法：设置文本通过 setText 方法设置编辑框内的文本内容为参数里面的文本字符串，比如edit.setText('你好，白月黑羽')原来的所有内容会被清除 方法：清除所有文本clear 方法可以清除编辑框内所有的文本内容，比如edit.clear() 方法：拷贝文本到剪贴板 copy 方法可以拷贝当前选中文本到剪贴板，比如edit.copy() 方法：粘贴剪贴板文本 paste 方法可以把剪贴板内容，拷贝到编辑框当前光标所在处，比如 edit.paste() 多行纯文本框 QPlainTextEdit 是可以多行的纯文本编辑框。 注意：在苹果MacOS上，有 更新文本框内容后，需要鼠标滑过才能更新显示的bug，参考这里 信号：文本被修改当文本框中的内容被键盘编辑，被点击就会发出 textChanged 信号，可以这样指定处理该信号的函数edit.textChanged.connect(handleTextChange) 注意： Qt在调用这个信号处理函数时，不会传入文本框目前的内容字符串，作为参数。这个行为 和 单行文本框不同。 信号：光标位置改变当文本框中的光标位置变动，就会发出 cursorPositionChanged 信号，可以这样指定处理该信号的函数 edit.cursorPositionChanged.connect(handleChanged) 方法：获取文本通过 toPlainText 方法获取编辑框内的文本内容，比如text = edit.toPlainText() 方法：获取选中文本 # 获取 QTextCursor 对象 textCursor = edit.textCursor() selection = textCursor.selectedText() 方法：设置提示通过 setPlaceholderText 方法可以设置提示文本内容，比如edit.setPlaceholderText('请在这里输入薪资表') 方法：设置文本通过 setPlainText 方法设置编辑框内的文本内容 为参数里面的文本字符串，比如edit.setPlainText('''你好，白月黑羽 hello byhy''')原来的所有内容会被清除 方法：在末尾添加文本通过 appendPlainText 方法在编辑框末尾添加文本内容，比如 edit.appendPlainText('你好，白月黑羽')注意：这种方法会在添加文本后 自动换行 方法：在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如edit.insertPlainText('你好，白月黑羽')注意：这种方法 不会 在添加文本后自动换行 方法：清除所有文本 clear 方法可以清除编辑框内所有的文本内容，比如edit.clear() 方法：拷贝文本到剪贴板 copy 方法可以拷贝当前选中文本到剪贴板，比如edit.copy() 方法：粘贴剪贴板文本 paste 方法可以把剪贴板内容，拷贝到编辑框当前光标所在处，比如edit.paste() 文本浏览框 QTextBrowser 是只能查看文本控件。通常用来显示一些操作日志信息、或者不需要用户编辑的大段文本内容。该控件 获取文本、设置文本、清除文本、剪贴板复制粘贴 等等， 都和上面介绍的 多行纯文本框是一样的。 方法：在末尾添加文本通过 append 方法在编辑框末尾添加文本内容，比如textBrowser.append('你好，白月黑羽')有时，浏览框里面的内容长度超出了可见范围，我们在末尾添加了内容，往往希望控件自动翻滚到当前添加的这行， 可以通过 ensureCursorVisible 方法来实现 textBrowser.append('你好，白月黑羽') textBrowser.ensureCursorVisible() 注意：这种方法会在添加文本后 自动换行 方法：在光标处插入文本通过 insertPlainText 方法在编辑框末尾添加文本内容，比如edit.insertPlainText('你好，白月黑羽') 注意：这种方法不会在添加文本后自动换行 标签 QLabel 就是常见的标签，可以用来显示文字（包括纯文本和富文本）、图片 甚至动画。 方法：改变文本代码中可以使用 setText 方法来改变标签文本内容，比如 button.setText(text) 显示图片QLabel 可以用来显示图片，有时一个图片可以让界面好看很多，如下图所示 怎么用 QLabel 显示图片呢？可以在 Qt Designer 上 属性编辑器 QLabel 栏 的 pixmap 属性设置中选择图片文件指定。 "},"Python/第三方库/PySide/05-常用控件2.html":{"url":"Python/第三方库/PySide/05-常用控件2.html","title":"常用控件2","keywords":"","body":"常用控件2 组合选择框 QComboBox 是组合选择框，如下图所示 信号：选项改变如果用户操作修改了QComboBox中的选项就会发出 currentIndexChanged 信号，可以这样指定处理该信号的函数cbox.currentIndexChanged.connect(handleSelectionChange) 方法：添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本cbox.addItem('byhy') 方法：添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表cbox.addItems(['byhy','白月黑羽','python教程']) 方法：清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项cbox.clear() 方法：获取当前选项文本代码中可以使用 currentText 方法来获取当前 选中的选项 的文本，比如method = cbox.currentText() 列表 QListWidget 是列表控件，如下图所示Qt Designer如下图 选择： 方法：添加一个选项代码中可以使用 addItem 方法来添加一个选项到 末尾 ，参数就是选项文本listWidget.addItem('byhy') 方法：添加多个选项代码中可以使用 addItems 方法来添加多个选项到 末尾，参数是包含了多个选项文本的列表listWidget.addItems(['byhy','白月黑羽','python教程']) 方法：删除一个选项代码中可以使用 takeItem 方法来删除1个选项，参数是该选项所在行listWidget.takeItem(1)就会删除第二行选项 方法：清空选项代码中可以使用 clear 方法来清空选项，也就是删除选择框内所有的选项listWidget.clear() 方法：获取当前选项文本currentItem 方法可以得到列表当前选中项对象（QListWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如listWidget.currentItem().text()就获取了 第1行，第1列 的单元格里面的文本。listWidget.currentItem().text() 表格 QTableWidget 是表格控件，如下图所示Qt Designer 如下图 选择： 创建列和标题栏 我们可以通过 Qt designer 为一个表格创建列和对应的标题栏。只需要双击 Qt designer 设计的窗体中的 表格控件， 就会出现这样的对话框。 在列标签栏中，点击左下角的加号，就可以为 添加一个列，并且设置标题栏名称。 方法：插入一行、删除一行 insertRow 方法可以在指定位置插入一行，比如table.insertRow(0)就插入一行到第 1 行这个位置， 表格原来第1行（包括原来的第1行）以后的内容，全部往下移动一行。table.insertRow(2)就插入一行到第 3 行这个位置， 表格原来第3行（包括原来的第3行）以后的内容，全部往下移动一行。removeRow 方法可以删除指定位置的一行，比如table.removeRow(0) 就删除第 1 行， 表格原来第1行以后的内容，全部往上移动一行。table.removeRow(2)就删除第 3 行， 表格原来第3行以后的内容，全部往上移动一行。 方法：设置单元格文本内容qt表格的单元格内的内容对象 是一个 单元格对象 QTableWidgetItem 实例 如果单元格 没有被设置过 内容，可以这样 from PySide2.QtWidgets import QTableWidgetItem item = QTableWidgetItem() item.setText('白月黑羽') table.setItem(row, 0, item) 也可以简写为 from PySide2.QtWidgets import QTableWidgetItem table.setItem(row, 0, QTableWidgetItem('白月黑羽')) 如果单元格 已经被设置过 文本内容，item 方法可以获取指定位置的 QTableWidgetItem ，再调用这个对象的 setText 方法，就可以设置单元格文本内容，比如table.item(0,0).setText('白月黑羽-江老师')就设置了 第1行，第1列 的单元格里面的文本。table.item(2,4).setText('白月黑羽-江老师')就设置了 第3行，第5列 的单元格里面的文本。如果希望某个单元格为 只读，不允许修改，可以使用QTableWidgetItem对象的 setFlags 方法，像这样 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem('白月黑羽') item.setFlags(Qt.ItemIsEnabled) # 参数名字段不允许修改 table.setItem(row, 0, item) 如果想文本内容 居中对齐，每个当对应的QTableWidgetItem 调用 setTextAlignment，如下 from PySide2.QtWidgets import QTableWidgetItem from PySide2.QtCore import Qt item = QTableWidgetItem() item.setText('白月黑羽') # 文本居中 item.setTextAlignment(Qt.AlignHCenter) table.setItem(row, 0, item) 方法：获取单元格文本的内容item 方法可以指定位置的单元格对象（QTableWidgetItem） ，再调用这个对象的 text 方法，就可以获取文本内容，比如table.item(0,0).text()就获取了 第1行，第1列 的单元格里面的文本。table.item(2,4).text() 就获取了 第3行，第5列 的单元格里面的文本。 方法：获取所有行数、列数代码中可以使用 rowCount 方法来获取表格所有的 行数 ，比如rowcount = table.rowCount()可以使用 columnCount 方法来获取表格所有的 列数 ，比如rowcount = table.columnCount() 方法：获取当前选中是第几行代码中可以使用 currentRow 方法来获取当前选中是第几行，比如currentrow = table.currentRow()注意：行数是从0开始的， 第一行的行数是 0 方法：设置表格行数、列数代码中可以使用 setRowCount 方法来设置表格 行数 ，比如table.setRowCount(10)代码中可以使用 setColumnCount 方法来设置表格 列数 ，比如table.setColumnCount(10) 方法：清除/删除所有内容clearContents 方法可以清除表格所有的内容，比如table.clearContents()清除后，仍然会留下表格栏如果连表格栏都要删除，可以使用 setRowCount(0)，像这样table.setRowCount(0) 方法：设定列宽、宽度自动缩放Qt Designer 上目前没法拖拽设定 每个列的宽度，只能在代码中指定。如下所示 # 设定第1列的宽度为 180像素 table.setColumnWidth(0, 180) # 设定第2列的宽度为 100像素 table.setColumnWidth(1, 100) 如想让 表格控件宽度 随着父窗口的缩放自动缩放，可以 在 属性编辑器 中 勾选 HorizontalHeaderStretchLastSection或者使用下面代码table.horizontalHeader().setStretchLastSection(True) 信号：单元格内容改动当用户修改了一个单元格的内容，会发出 cellChanged 信号，并且携带参数指明该单元格的行号和列号。 我们的代码可以对该信号进行相应的处理。示例代码如下 def __init__(self): # 指定单元格改动信号处理函数 self.ui.table.cellChanged.connect(self.cfgItemChanged) def cfgItemChanged(self, row, column): # 获取更改内容 cfgName = self.ui.table.item(row, 0).text() # 首列为配置名称 cfgValue = self.ui.table.item(row, column).text() "},"Python/第三方库/PySide/06-常用控件3.html":{"url":"Python/第三方库/PySide/06-常用控件3.html","title":"常用控件3","keywords":"","body":"常用控件3 单选按钮和按钮组 QRadioButton 是单选按钮，如下图所示 说明同一个父窗口 里面的多个单选按钮，只能选中一项。如果你有多组单选按钮， 每组都应该有不同的父控件，或者不同的Layout。通常建议：多组单选按钮，放到不同的 按钮组 QButtonGroup 中 信号：选中状态改变如果用户操作点击了按钮组 QButtonGroup 中的一个按钮， QButtonGroup 就会发出 buttonClicked 信号，可以这样指定处理该信号的函数buttongroup.buttonClicked.connect(handleButtonClicked)然后，在处理函数中调用QButtonGroup对象的 checkedButton() 函数，返回值就是被选中的按钮对象。再调用这个返回的按钮对象的 text() 方法得到界面文本，就可以知道是哪个选项被选中了。 勾选按钮和按钮组 QCheckBox 是勾选按钮，如下图所示 说明通常建议：多组勾选按钮，放到不同的 按钮组 QButtonGroup 中，按钮组就是父控件。可以在 Qt设计师中设置 QButtonGroup 的 exclusive 属性， 来控制 是否 只能单选一个选项。 信号：选中状态改变如果用户操作点击了按钮组 QButtonGroup 中的一个按钮， QButtonGroup 就会发出 buttonClicked 信号，可以这样指定处理该信号的函数buttongroup.buttonClicked.connect(handleButtonClicked)QButtonGroup 设置为 单选 情况下： 在处理函数中调用QButtonGroup对象的 checkedButton() 函数，返回值就是被选中的按钮对象。 再调用这个返回的按钮对象的 text() 方法得到界面文本，就可以知道是哪个选项被选中了。 QButtonGroup 设置为 多选 情况下：要得知哪些按钮被选中， 可以 对所有该组中的 按钮调用 isChecked 方法 ，来判断。 tab页控件 我们可以通过tab页控件把界面分为好几个页面，如下所示通过Qt designer 只需要拖拽控件到各个页面即可。要修改 tab 页的标题，可以先点击该 tab 页，然后在下图所示处修改 tab页中布局Layout 如果要在tab页上布局， 你可能会在对象查看器总直接右键点击该tab，可以你会发现 右键菜单里面没有布局项。 这是 Qt designer 非常坑爹的地方。 首先需要你在tab页上添加一个控件 然后点击 在对象查看器 右键点击上层 TabWidget ，这时，你就会发现有布局菜单了 进度条 QProgressBar 是进度条，如下图所示 说明进度条也是一个常用的控件，当程序需要做一件比较耗费时间的任务（比如统计数据，下载文件等）时，可以用来向用户指示操作的进度。而且有了进度显示，用户就知道应用程序仍在运行，并没有出问题。QProgressBar进度条把每个进度称之为一个step（步骤）。我们可以通过它的 setRange 方法设定步骤个数，比如progressBar.setRange(0,5)就设定了，进度分为5步。然后，通过 setValue 方法，指定当前完成到了哪一步，比如progressBar.setValue(3) 就表示完成了 3/5， 也就是 60%， 进度条就会显示60%的进度。可以使用reset()将进度条倒退到开头。有时候我们的任务没法知道完成了多少，比如下载一个未知大小的文件。这时，可以把 range 范围都设置为0，这样，进度条会显示忙碌指示符，而不是显示进度百分比。下面是一个进度条程序的示例代码 from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QProgressBar,QMessageBox from time import sleep from threading import Thread class Stats(): def __init__(self): self.window = QMainWindow() self.window.resize(500, 400) self.window.move(300, 300) self.progressBar = QProgressBar(self.window) self.progressBar.resize(300, 20) self.progressBar.move(80, 30) # 进度是 0 - 5， self.progressBar.setRange(0,5) self.button = QPushButton('统计', self.window) self.button.move(80, 80) self.button.clicked.connect(self.handleCalc) # 统计进行中标记，不能同时做两个统计 self.ongoing = False def handleCalc(self): def workerThreadFunc(): self.ongoing = True for i in range(1,6): sleep(1) # 设置进度值 self.progressBar.setValue(i) self.ongoing = False if self.ongoing: QMessageBox.warning( self.window, '警告','任务进行中，请等待完成') return # 通常任务执行比较耗时，应该在新的线程中进行 # 否则会阻塞主线程显示界面 worker = Thread(target=workerThreadFunc) worker.start() app = QApplication([]) stats = Stats() stats.window.show() app.exec_() 上面的代码，运行时，会有很多告警，因为我们在新线程中操作界面对象，容易出问题。更合理的方法是通过信号，在线程之间传递信息，对界面的操作都在主线程中完成。如下 ```python from PySide2.QtWidgets import QApplication, QMainWindow, QPushButton, QProgressBar, QMessageBox from time import sleep from threading import Thread from PySide2.QtCore import Signal, QObject 信号库 class SignalStore(QObject): # 定义一种信号 progress_update = Signal(int) # 还可以定义其他作用的信号 实例化 so = SignalStore() class Stats(): def init(self): # 连接信号到处理的slot函数 so.progress_update.connect(self.setProgress) self.window = QMainWindow() self.window.resize(500, 400) self.window.move(300, 300) self.progressBar = QProgressBar(self.window) self.progressBar.resize(300, 20) self.progressBar.move(80, 30) # 进度是 0 - 5， self.progressBar.setRange(0, 5) self.button = QPushButton('统计', self.window) self.button.move(80, 80) self.button.clicked.connect(self.handleCalc) # 统计进行中标记，不能同时做两个统计 self.ongoing = False def handleCalc(self): def workerThreadFunc(): self.ongoing = True for i in range(1, 6): sleep(1) # 发出信息，通知主线程进行进度处理 so.progress_update.emit(i) self.ongoing = False if self.ongoing: QMessageBox.warning( self.window, '警告', '任务进行中，请等待完成') return worker = Thread(target=workerThreadFunc) worker.start() # 处理进度的slot函数 def setProgress(self, value): self.progressBar.setValue(value) app = QApplication([]) stats = Stats() stats.window.show() app.exec_() ### 数字输入框 `QSpinBox` 是数字输入框，可以输入或使用上下箭头选择数字，如下图所示 ![](./imgs/qspinbox.png) - 获取数字 通过 `value` 方法获取编辑框内的文本内容，比如 `number = box.value()` 注意：返回的是整数对象，不是字符串 - 方法：设置数字 通过 `setValue` 方法可以设置提示文本内容，比如 `box.setValue(100)` ### 日期控件 `QDateEdit` 类可以用来选择日期时间，如下图所示 ![](./imgs/windows-dateedit.png) 获取日期 当用户点击日期时间控件并且选取了 日期和时间，后来程序要获取这个控件里面选定的日期时间，可以使用date方法获取日期对象。 如下所示 ```python # 返回 PySide2.QtCore.QDate 对象 qdate = dateEdit.date() # 可以转化为 指定格式的字符串 dateStr = qdate.toString('yyyy-MM-dd') # 也可以获取年月日 对应的数字 ，比如日期是2020年5月2号 year = qdate.year() # 返回 2020 month = qdate.month() # 返回 5 day = qdate.day() # 返回 2 选择文件框 QFileDialog 类可以用来选择文件或者目录，如下图所示 选择目录通过 getExistingDirectory 静态方法 选择目录。该方法，第一个参数是父窗口对象，第二个参数是选择框显示的标题。比如 from PySide2.QtWidgets import QFileDialog filePath = QFileDialog.getExistingDirectory(self.ui, \"选择存储路径\") 返回值即为选择的路径字符串。如果用户点击了 选择框的 取消选择按钮，返回 空字符串。 选择单个文件 如果你想弹出文件选择框，选择一个 已经存在 的文件，可以使用 QFileDialog 静态方法 getOpenFileName ，比如 from PySide2.QtWidgets import QFileDialog filePath, _ = QFileDialog.getOpenFileName( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 该方法返回值 是一个元组，第一个元素是选择的文件路径，第二个元素是文件类型，如果你只想获取文件路径即可，可以采用上面的代码写法。如果用户点击了 选择框的 取消选择按钮，返回 空字符串。如果你想弹出文件选择框，选择路径和文件名，来 保存一个文件 ，可以使用 QFileDialog 静态方法 getSaveFileName ，比如 from PySide2.QtWidgets import QFileDialog filePath, _ = QFileDialog.getSaveFileName( self.ui, # 父窗口对象 \"保存文件\", # 标题 r\"d:\\\\data\", # 起始目录 \"json类型 (*.json)\" # 选择类型过滤项，过滤内容在括号中 ) 选择多个文件如果要选择多个文件，使用 getOpenFileNames 静态方法 from PySide2.QtWidgets import QFileDialog filePaths, _ = QFileDialog.getOpenFileNames( self.ui, # 父窗口对象 \"选择你要上传的图片\", # 标题 r\"d:\\\\data\", # 起始目录 \"图片类型 (*.png *.jpg *.bmp)\" # 选择类型过滤项，过滤内容在括号中 ) 上例中 filePaths 对应的返回值是一个列表，里面包含了选择的文件。如果用户点击了 选择框的 取消选择按钮，返回 空列表。 "},"Python/第三方库/PySide/07-常用控件4.html":{"url":"Python/第三方库/PySide/07-常用控件4.html","title":"常用控件4","keywords":"","body":"常用控件4 树控件 QTreeWidget 树控件树控件， 是和 QTreeWidgetItem 树节点控件 结合使用的。如下图所示 提示框 QMessageBox 类可以用来弹出各种提示框 该类可以通过一系列静态方法，显示 如下弹出框 错误报告使用 critical 方法 QMessageBox.critical( self.ui, '错误', '请选择爬取数据存储路径！') 警告使用 warning 方法 QMessageBox.warning( self.ui, '阅读太快', '阅读客户协议必须超过1分钟') 信息提示使用 information 方法 QMessageBox.information( self.ui, '操作成功', '请继续下一步操作') 也可以使用 about 方法 QMessageBox.about( self.ui, '操作成功', '请继续下一步操作') 确认继续使用 question 方法 choice = QMessageBox.question( self.ui, '确认', '确定要删除本文件吗？') if choice == QMessageBox.Yes: print('你选择了yes') if choice == QMessageBox.No: print('你选择了no') 输入对话框 QInputDialog 输入对话框 只让用户输入一行数据信息，比如 姓名、年龄等。可以方便的用来获取简单的信息。比如 from PySide2.QtWidgets import QInputDialog, QLineEdit # 返回值分别是输入数据 和 是否点击了 OK 按钮（True/False） title, okPressed = QInputDialog.getText( self, \"输入目录名称\", \"名称:\", QLineEdit.Normal, \"\") if not okPressed: print('你取消了输入') 常用的方法有： getText弹出对话框，让用户输入 单行文本 getMultiLineText弹出对话框，让用户输入 多行文本 getInt弹出对话框，让用户输入 整数 getItem弹出对话框，让用户选择 选项 items = [\"春天\", \"夏天\", \"秋天\", \"冬天\"] item, ok = QInputDialog().getItem(self, \"请选择\", \"季节:\", items, 0, False) if ok and not item.isEmpty(): itemLabel.setText(item) 菜单 可以在 Qt Designer上很方便的添加菜单，如下所示点击菜单的信号是 triggered， 处理点击菜单的的代码如下self.ui.actionOpenFile.triggered.connect(self.openPageFile)注意：如果菜单和工具栏有 相同的 action ，通常是先在 动作编辑器 创建一个action， 然后分别拖动到 菜单和工具栏 工具栏 在 Qt 设计师上添加工具栏，可以右键点击 Main Window 类型的窗体空白处，如下所示选择添加工具栏注意，只有 Main Window 类型的窗体，才能添加工具栏，如下添加工具栏后，还要在工具栏上添加图标。 方法是点击右下角 动作编辑器，新建动作，如下图所示然后如下图所示进行设置添加动作成功后，就可以直接拖到工具栏上了。然后，在代码中定义动作触发后的处理函数，如下所示 self.ui.actionAddNote.triggered.connect(self.actionAddNode) 状态栏 要在状态栏显示文本信息，只需要调用 QStatusBar 的 showMessage 方法self.ui.statusbar.showMessage(f'打开文件{filePath}') 剪贴板 Qt程序可以获取和设置剪贴板内容 from PySide2.QtGui import QGuiApplication cb = QGuiApplication.clipboard() # 获取剪贴板内容 originalText = cb.text() # 设置剪贴板内容 clipboard.setText(newText) MDI 多个子窗口 QMdiArea 提供了一个主窗口区，里面可以存放多个 QMdiSubWindow 子窗口如图： "},"GoLang/GoLang基础/01-GoLang发展史.html":{"url":"GoLang/GoLang基础/01-GoLang发展史.html","title":"GoLang发展史","keywords":"","body":"datetime:2020/8/18 10:53 author:nzb Go语言发展简史 开发文档 https://studygolang.com/pkgdoc Go语言核心开发团队 Ken Thompson（肯·汤普森）：1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言，同时也是C语言的主要发明人。 Rob Pike（罗布-派克）：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。 他与Thompson共事多年，并共创出广泛使用的UTF-8字元编码。 Robert Griesemer：曾协助制作Java的HotSpot编译器，和Chrome浏览器的JavaScript引擎V8。 Google为什么要创建Go 计算机硬件技术更新频繁，性能提高很快。目前主流的编程语言发展明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能。 软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。 现有编程语言存在：风格不统一、计算能力不够、处理大并发不够好 企业运行维护很多c/c++的项目，c/c++程序运行速度虽然很快，但是编译速度确很慢，同时还存在内存泄漏的一系列的困扰需要解决。 Go语言发展历史 2007年，谷歌工程师Rob Pike，Ken Thompson和Robert Griesemer开始设计一门全新的语言，这是Go语言的最初原型。 2009年11月10日，Google将Go语言以开放源代码的方式向全球发布。 2015年8月19日，Go1.5版发布，本次更新中移除了”最后残余的c代码” 2017年2月17日，Go语言Go1.8版发布。 2017年8月24日，Go语言Go1.9版发布。 2018年2月16日，Go语言Go1.10版发布。 Go语言的特点 Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言：Go=C+Python，说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发。 从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针。 // go语言的指针使用特点 func testPtr(num *int) { *num = 20 } 引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。 垃圾回收机制，内存自动回收，不需开发人员管理 【稍微不注意就会出现内存泄漏】 天然并发【重要特点】 从语言层面支持并发，实现简单 goroutine，轻量级线程，可实现大并发处理，高效利用多核。 基于CPS并发模型（Communicating Sequential Processes）实现 吸收了管道通信机制，形成go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信 函数返回多个值（实例代码） 新的创新：比如切片slice，延时执行defer等 Hello Go 我们写一个最简单的入门代码，在控制台输出hello go！ package main // fmt包中提供格式化，输入和输出的函数 import \"fmt\" func main() { fmt.Println(\"hello go!\") } Golang执行流程分析 我们可以通过以下命令来进行操作 go build hello.go -> hello.exe go run hello.go 两种执行流程分析 如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到没有go开发环境的机器上，然可以运行 如果我们是直接go rungo源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。 什么是编译 有了go源文件，通过编译器将其编译成机器可以识别的二进制码文件。 在该源文件目录下，通过go build 对hello.go文件进行编译。可以指定生成的可执行文件名，在windows下必须是.exe后缀。 如果程序没有错误，没有任何提示，会在当前目录下会出现一个可执行文件（windows下是.exe Linux下是一个可执行文件），该文件是二进制码文件，也是可以执行的程序。 如果程序有错误，编译时，会在错误的那行报错。 Go语言代码风格 代码每一行结束后不用写分号（：） 运算符左右建议各加一个空格 Go语言程序员推荐使用驼峰式命名 强制的代码风格 左括号必须紧接着语句不换行，这个特性刚开始会使开发者不习惯，但随着对Go语言的不断熟悉，就会发现风格统一让大家在阅读代码时把注意力集中在解决问题上，而不是代码风格上 Go语言开发注意事项 Go源文件以“go”为扩展名 Go应用程序的执行入口是main()方法 Go语言严格区分大小写。 Go方法由一条条语句构成，每个语句后不需要分号（Go语言会在每行后自动加分号），这也体现出Golang的简洁性。 Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错 Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过 大括号都是成对出现的，缺一不可。 Go语言中的转义字符 GoLang常用的转义字符（escape char） \\t：一个制表位，实现对齐的功能 \\n：换行符 \\：一个\\ \\r：一个回车 "},"GoLang/GoLang基础/02-打印输出.html":{"url":"GoLang/GoLang基础/02-打印输出.html","title":"打印输出","keywords":"","body":"datetime:2020/8/17 15:17 author:nzb 打印输出和键盘输入 1、打印输出 1.1、fmt包 import 'fmt' 1.2、常用打印函数 打印：fmt.Print() 格式化打印：fmt.Printf 格式化打印中的常用占位符 | 占位符 | 说明 | |--------|--------| | %v | 原样输出 | | %T | 打印类型 | | %t | bool类型 | | %s | 字符串 | | %f | 浮点 | | %d | 10进制的整数 | | %b | 2进制的整数 | | %o | 8进制 | | %x,%X | 16进制%x：0-9，a-f%X：0-9，A-F | | %c | 打印字符 | | %p | 打印地址 | | ... | ... | 打印后换行：fmt.Println() 示例代码 示例 package main import \"fmt\" func main(){ a := 100 b := 3.14 c := true d := \"Hello Golang\" e := `Golang` f := 'A' fmt.Printf(\"--------------Print--------------\\n\") fmt.Print(a, b, c, d, e, f) fmt.Printf(\"\\n--------------Printf格式化输出--------------\\n\") fmt.Printf(\"%T, %b\\n\", a, a) fmt.Printf(\"%T, %f\", b, b) fmt.Printf(\"%T,%t\\n\", c, c) fmt.Printf(\"%T,%s\\n\", d, d) fmt.Printf(\"%T,%s\\n\", e, e) fmt.Printf(\"%T,%d,%c\\n\", f, f, f) fmt.Printf(\"\\n--------------Printf原样输出--------------\\n\") fmt.Printf(\"%v\\n\", a) fmt.Printf(\"%v\\n\", b) fmt.Printf(\"%v\\n\", c) fmt.Printf(\"%v\\n\", d) fmt.Printf(\"%v\\n\", e) fmt.Printf(\"%v\\n\", f) fmt.Printf(\"\\n--------------Println--------------\\n\") fmt.Println(a) fmt.Println(b) } 输出 --------------Print-------------- 100 3.14 trueHello GolangGolang65 --------------Printf格式化输出-------------- int, 1100100 float64, 3.140000bool,true string,Hello Golang string,Golang int32,65,A --------------Printf原样输出-------------- 100 3.14 true Hello Golang Golang 65 --------------Println-------------- 100 3.14 2、键盘输入 fmt.Scan() fmt.Scanf() fmt.Scanln() 示例代码 示例 package main import \"fmt\" func main(){ var x int var y float64 fmt.Println(\"请输入一个整数，一个浮点数：\") fmt.Scanln(&x, &y) //读取键盘的输入，通过操作地址，赋值给x和y 阻塞式 fmt.Printf(\"x的数值：%d, y的数值：%f\\n\", x, y) fmt.Scanf(\"%d, %f\", &x, &y) fmt.Printf(\"x:%d, y:%f\\n\", x, y) } 输出 请输入一个整数，一个浮点数： x的数值：12, y的数值：34.000000 x:21, y:34.000000 "},"GoLang/GoLang基础/03-变量和常量.html":{"url":"GoLang/GoLang基础/03-变量和常量.html","title":"变量和常量","keywords":"","body":"datetime:2020/8/18 10:57 author:nzb Go语言中的变量和常量 1、Go语言中变量的声明 Go语言变量是由字母、数字、下划线组成，其中首个字符不能为数字。Go语言中关键字和保留字都不能用作变量名 Go语言中变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后必须使用。 变量声明后，没有初始化，打印出来的是空 1.1、如何定义变量 方式1 var name = \"zhangsan\" 方式2：带类型 var name string = \"zhangsan\" 方式3：类型推导方式定义变量 在函数内部，可以使用更简略的 := 方式声明并初始化变量 注意：短变量只能用于声明局部变量，不能用于全局变量声明 变量名 := 表达式 方式4：声明多个变量 类型都是一样的变量 var 变量名称， 变量名称 类型 a, b, c := 1,2,\"3\" 类型不一样的变量 var ( 变量名称 类型 变量名称 类型 ) 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable） 匿名变量用一个下划线“_”表示 func Getuser(){ return username, age } var username, _ = Getuser() 示例代码 代码 package main import \"fmt\" func main() { var a = 10 fmt.Printf(\"%d\\n\", a) var name1 = \"zhangsan\" var name2 string = \"lishi\" name3 := \"wangwu\" fmt.Println(name1) fmt.Println(name2) fmt.Println(name3) fmt.Printf(\"name1=%v, name2=%v, name3=%v\", name1, name2, name3) var b, c string b = \"b\" c = \"c\" fmt.Printf(\"\\nb=%v, c=%v\\n\", b, c) var ( d int e string f bool ) d = 100 e = \"string\" f = true //var ( // d int = 1 // e string = 'e' // f bool = false //) fmt.Printf(\"d=%v, e=%v, f=%v\\n\", d, e, f) } 输出 10 zhangsan lishi wangwu name1=zhangsan, name2=lishi, name3=wangwu b=b, c=c d=100, e=string, f=true 2、常量 2.1、如何定义常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。 // 定义了常量，可以不用立即使用 const pi = 3.14 // 定义两个常量 const( A = \"A\" B = \"B\" ) // const同时声明多个常量时，如果省略了值表示和上面一行的值相同 const( A = \"A\" B C ) 2.2、 Const常量结合iota的使用 iota是golang 语言的常量计数器，只能在常量的表达式中使用 iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。 每次const出现，都会让iota初始化为0【自增长】 const a = iota // a = 0 const ( b = iota // b=0 c // c = 1 d // d = 2 ) const iota使用_跳过某些值 const ( b = iota // b=0 _ d // d = 2 ) 多个赋值 const ( n1, n2 = iota + 1, iota + 2 //1 2 n3, n4 // 2 3 n5, n6 //3 4 ) 3、Go语言变量、常量命名规则 变量名必须有数字、字母、下划线组成 标识符不能是数字 标识符不能是保留字和关键字 变量的名字是区分大小写的 标识符（变量名称）一定要见名思意：变量名称建议用名词，方法名称建议用动词 变量命名一般采用驼峰式。 "},"GoLang/GoLang基础/04-数据类型.html":{"url":"GoLang/GoLang基础/04-数据类型.html","title":"数据类型","keywords":"","body":"datetime:2020/8/18 15:42 author:nzb Golang的数据类型 1、概述 Go 语言中数据类型分为：基本数据类型和复合数据类型基本数据类型有： 整型、浮点型、布尔型、字符串 复合数据类型有： 数组、切片、结构体、函数、map、通道（channel）、接口等。 2、整型 整型的类型有很多中，包括 int8，int16，int32，int64。我们可以根据具体的情况来进行定义 如果我们直接写 int也是可以的，它在不同的操作系统中，int的大小是不一样的 32位操作系统：int -> int32 64位操作系统：int -> int64 默认值为：0 有符号和无符号整型 可以通过unsafe.Sizeof 查看不同长度的整型，在内存里面的存储空间 var num2 = 12 fmt.Println(unsafe.Sizeof(num2)) 2.1、类型转换 通过在变量前面添加指定类型，就可以进行强制类型转换 var a1 int16 = 10 var a2 int32 = 12 var a3 = int32(a1) + a2 fmt.Println(a3) 注意，高位转低位的时候，需要注意，会存在精度丢失，比如上述16转8位的时候，就丢失了 var n1 int16 = 130 fmt.Println(int8(n1)) // 变成 -126 2.2、数字字面量语法 Go1.13版本之后，引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如： v := 0b00101101 // 代表二进制的101101 v := Oo377 // 代表八进制的377 2.3、进制转换 var number = 17 // 原样输出 fmt.Printf(\"%v\\n\", number) // 十进制输出 fmt.Printf(\"%d\\n\", number) // 以八进制输出 fmt.Printf(\"%o\\n\", number) // 以二进制输出 fmt.Printf(\"%b\\n\", number) // 以十六进制输出 fmt.Printf(\"%x\\n\", number) 3、浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE754标准： float32的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。float64的浮点数的最大范围约为1.8e308，可以使用一个常量定义：math.MaxFloat64 默认值为：0 打印浮点数时，可以使用fmt包配合动词%f，代码如下： var pi = math.Pi // 打印浮点类型，默认小数点6位 fmt.Printf(\"%f\\n\", pi) // 打印浮点类型，打印小数点后2位 fmt.Printf(\"%.2f\\n\", pi) // 科学计数 var f2 = 3.14e2 // 3.14 * 10的2次方 fmt.Printf(\"\\n%v,%T\\n\", f2, f2) // 314,float64 3.1、Golang中精度丢失的问题 几乎所有的编程语言都有精度丢失的问题，这是典型的二进制浮点数精度损失问题，在定长条件下，二进制小数和十进制小数互转可能有精度丢失 d := 1129.6 fmt.Println(d*100) //输出112959.99999999 解决方法，使用第三方包来解决精度损失的问题 4、布尔类型 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true和false 注意 布尔类型变量的默认值为false Go语言中不允许将整型强制转换为布尔型 布尔型无法参与数值运算，也无法与其他类型进行转换 var fl = false if f1 { fmt.Println(\"true\") } else { fmt.Println(\"false\") } 5、字符串类型 Go 语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64等）一样。Go语言里的字符串的内部实现使用UTF-8编码。字符串的值为双引号（\"）中的内容，可以在Go语言的源码中直接添加非ASCll码字符，例如： s1 := \"hello\" s1 := \"你好\" 默认值为：空字符串 如果想要定义多行字符串，可以使用反引号 var str = `第一行 第二行` fmt.Println(str) 转义输出 str1 := \"this is \\nstr\" str2 := \"C:\\\\go\\\\demo\" str3 := \"this is\\\" str3\" fmt.Println(str1) fmt.Println(str2) fmt.Println(str3) this is str C:\\go\\demo this is\" str3 5.1、字符串常见操作 len(str)：求长度 \"aaa\"：3（3个字节） \"你好\"：6（一个汉字3个字节） +或fmt.Sprintf：拼接字符串 str1 := \"你好\" str2 := \"golang\" str3 := fmt.Sprintf(\"%v%v, str1, str2) fmt.Println(str3) fmt.Sprintf(\"%v%v, str1, str2) // 可以任意拼接（加空格加符号） strings.Split：分割 strings.contains：判断是否包含 strings.HasPrefix，strings.HasSuffix：前缀/后缀判断 strings.Index()，strings.LastIndex()：子串出现的位置，不存在返回：-1 strings.Join()：join操作 strings.Index()：判断在字符串中的位置 6、byte 和 rune类型 组成每个字符串的元素叫做 “字符”，可以通过遍历字符串元素获得字符。字符用单引号 '' 包裹起来 Go语言中的字符有以下两种类型 uint8类型：或者叫byte型，代表了ACII码的一个字符 rune类型：代表一个UTF-8字符 当需要处理中文，日文或者其他复合字符时，则需要用到rune类型，rune类型实际上是一个int32 Go使用了特殊的rune类型来处理Unicode，让基于Unicode的文本处理更为方便，也可以使用byte型进行默认字符串处理，性能和扩展性都有照顾。 需要注意的是，在go语言中，一个汉字占用3个字节（utf-8），一个字母占用1个字节 ```go package main import \"fmt\" func main() { var a byte = 'a' // 输出的是ASCII码值，也就是说当我们直接输出byte（字符）的时候，输出的是这个字符对应的码值 fmt.Println(a) // 输出的是字符 fmt.Printf(\"%c\", a) fmt.Printf(\"\\n--------------通过len来循环的，相当于打印的是ASCII码，汉字出现乱码--------------\\n\") // for循环打印字符串里面的字符 // 通过len来循环的，相当于打印的是ASCII码 s := \"你好 golang\" for i := 0; i 结果 97 a --------------通过len来循环的，相当于打印的是ASCII码，汉字出现乱码-------------- 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 32( ) 103(g) 111(o) 108(l) 97(a) 110(n) 103(g) ------通过rune打印的是 utf-8字符，汉字就不能乱码，rune类型兼容byte类型------- 0 20320 3 22909 6 32 7 103 8 111 9 108 10 97 11 110 12 103 6.1、修改字符串 要修改字符串，需要先将其转换成[]rune 或 []byte类型，完成后在转换成string，无论哪种转换都会重新分配内存，并复制字节数组 转换为 []byte 类型 // 字符串转换 s1 := \"big\" byteS1 := []byte(s1) byteS1[0] = 'p' fmt.Println(string(byteS1)) 转换为rune类型 // rune类型 s2 := \"你好golang\" byteS2 := []rune(s2) byteS2[0] = '我' fmt.Println(string(byteS2)) 7、基本数据类型转换 7.1、数值类型转换 // 整型和浮点型之间转换 var aa int8 = 20 var bb int16 = 40 fmt.Println(int16(aa) + bb) // 建议整型转换成浮点型 var cc int8 = 20 var dd float32 = 40 fmt.Println(float32(cc) + dd) 建议从低位转换成高位，这样可以避免 7.2、转换成字符串类型 第一种方式，就是通过 fmt.Sprintf()来转换 // 字符串类型转换 var i int = 20 var f float64 = 12.456 var t bool = true var b byte = 'a' str1 := fmt.Sprintf(\"%d\", i) fmt.Printf(\"类型：%v-%T \\n\", str1, str1) str2 := fmt.Sprintf(\"%f\", f) fmt.Printf(\"类型：%v-%T \\n\", str2, str2) str3 := fmt.Sprintf(\"%t\", t) fmt.Printf(\"类型：%v-%T \\n\", str3, str3) str4 := fmt.Sprintf(\"%c\", b) fmt.Printf(\"类型：%v-%T \\n\", str4, str4) 第二种方法就是通过strconv包里面的集中转换方法进行转换 package main import ( \"fmt\" \"strconv\" ) func main() { // int类型转换str类型 var num1 int64 = 20 s1 := strconv.FormatInt(num1, 10) fmt.Printf(\"转换值：%v - 类型：%T\\n\", s1, s1) // float类型转换成string类型 var num2 float64 = 3.1415926 /* 参数1：要转换的值 参数2：格式化类型 'f'表示float，'b'表示二进制，‘e’表示 十进制 参数3：表示保留的小数点，-1表示不对小数点格式化 参数4：格式化的类型，传入64位 或者 32位 */ s2 := strconv.FormatFloat(num2, 'f', -1, 64) fmt.Printf(\"转换值：%v-类型：%T\", s2, s2) } 结果 转换值：20 - 类型：string 转换值：3.1415926-类型：string 7.3、字符串转换成int 和 float类型 str := \"10\" // 第一个参数：需要转换的数，第二个参数：进制， 参数三：32位或64位 num,_ = strconv.ParseInt(str, 10, 64) // 转换成float类型 str2 := \"3.141592654\" num,_ = strconv.ParseFloat(str2, 10) 7.4 不建议string类型转换为bool类型（无意义） "},"GoLang/GoLang基础/05-运算符.html":{"url":"GoLang/GoLang基础/05-运算符.html","title":"运算符","keywords":"","body":"datetime:2020/8/31 16:26 author:nzb Go的运算符 1、算数运算符 运算符 说明 + 相加 - 相减 * 相乘 / 相除 % 求余= 被除数 - (被除数 / 除数) * 除数 1.2、注意事项 ++ 和 --在go语言中不是运算符 除法注意，如果运算的数是整数，那么除后，去掉小数部分，保留整数部分，如果是浮点数，保留小数部分 在golang中， ++ 和 -- 只能单独使用，错误的写法如下 var i int = 8 var a int a = i++ // 错误，i++只能单独使用 a = i-- // 错误，i--只能单独使用 同时在golang中，没有 ++i这样的操作 var i int = 1 ++i // 错误 正确的写法 var i int = 1 i++ //正确 2、关系运算符 运算符 说明 == 检查两个值是否相等，如果相等返回True，否则返回False != 检查两个值是否不相等，如果不相等返回True，否则返回False > 检查左边值是否大于右边值，如果是返回True，否则返回False >= 检查左边值是否大于等于右边值，如果是返回True，否则返回False 检查左边值是否小于右边值，如果是返回True，否则返回False 检查左边值是否小于等于右边值，如果是返回True，否则返回False 3、关逻辑运算符 运算符 说明 && 逻辑 AND 运算符，如果两边的操作数都是True，则为True，否则为False || 逻辑 OR 运算符，如果两边的操作数有一个是True，则为True，否则为False ! 逻辑 NOT 运算符，如果条件为True，则为False，否则为True 4、赋值运算符 运算符 说明 && 逻辑 AND 运算符，如果两边的操作数都是True，则为True，否则为False || 逻辑 OR 运算符，如果两边的操作数有一个是True，则为True，否则为False ! 逻辑 NOT 运算符，如果条件为True，则为False，否则为True 短路用法，逻辑与前面为False后面的就不执行了，逻辑或前面的为True后面的也不执行了 5、赋值辑运算符 运算符 说明 = 简单的赋值运算符，将一个表达式的值赋给一个左值(从右往左计算赋值) += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值（跟上面算术运算符的注意事项相同） %= 求余后再赋值 "},"GoLang/GoLang基础/06-流程控制.html":{"url":"GoLang/GoLang基础/06-流程控制.html","title":"流程控制","keywords":"","body":"datetime:2020/9/16 11:41 author:nzb Go的流程控制 流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉\" Go 语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 1、条件语句 1.1、if else 推荐if后面不适用括号，当然也可以使用括号括起来 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else { /* 在布尔表达式为 false 时执行 */ } func main() { var num = 10 if num == 10 { fmt.Println(\"hello == 10\") } else if(num > 10) { fmt.Println(\"hello > 10\") } else { fmt.Println(\"hello if的另外一种写法，下面的方法的区别是 num2是局部变量 if num2:= 10; num2>=10 { fmt.Println(\"hello >=10\") } if 语句嵌套 if 布尔表达式 1 { /* 在布尔表达式 1 为 true 时执行 */ if 布尔表达式 2 { /* 在布尔表达式 2 为 true 时执行 */ } } 你可以以同样的方式在 if 语句中嵌套 else if...else 语句 1.2、switch case 使用switch语句可方便的对大量的值进行条件判断 switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。 switch var1 { case val1: ... case val2: ... default: ... } extname := \".a\" switch extname { case \".html\": { fmt.Println(\".html\") break } case \".doc\": { fmt.Println(\".doc\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } switch的另外一种写法 switch extname := \".a\"; extname { case \".html\": { fmt.Println(\".html\") break } case \".doc\": { fmt.Println(\".doc\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } 同时一个分支可以有多个值 extname := \".txt\" switch extname { case \".html\": { fmt.Println(\".html\") break } case \".txt\",\".doc\": { fmt.Println(\"传递来的是文档\") break } case \".js\": { fmt.Println(\".js\") } default: { fmt.Println(\"其它后缀\") } } tip：在golang中，break可以不写，也能够跳出case，而不会执行其它的。 如果我们需要使用switch的穿透 fallthrought，fallthrough语法可以执行满足条件的 case 的下一个case，为了兼容c语言中的case设计 extname := \".txt\" switch extname { case \".html\": { fmt.Println(\".html\") fallthrought } case \".txt\",\".doc\": { fmt.Println(\"传递来的是文档\") fallthrought } case \".js\": { fmt.Println(\".js\") fallthrought } default: { fmt.Println(\"其它后缀\") } } fallthrought 只能穿透紧挨着的一层，不会一直穿透，但是如果每一层都写的话，就会导致每一层都进行穿透 2、循环语句 2.1、for 循环结构 Go语言中的所有循环类型均可使用for关键字来完成 for循环的基本格式如下： for 初始语句; 条件表达式; 结束语句 { 循环体 } 和 C 的 while 一样： for condition { } 和 C 的 for(;;) 一样： for { } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环 实例：打印1 ~ 10 for i := 0; i 2.2、for range（键值循环） Go 语言中可以使用for range遍历数组、切片、字符串、map及通道（channel）。通过for range遍历的返回值有以下规律： for key, value := range oldMap { newMap[key] = value } 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 实例：遍历字符串 var str = \"你好golang\" for key, value := range str { fmt.Printf(\"%v - %c \", key, value) } 遍历切片（数组） var array = []string{\"php\", \"java\", \"node\", \"golang\"} for index, value := range array { fmt.Printf(\"%v %s \", index, value) } for循环可以通过break、goto、return、panic语句退出循环 2.3、循环嵌套 for [condition | ( init; condition; increment ) | Range] { for [condition | ( init; condition; increment ) | Range] { statement(s); } statement(s); } 2.4、循环控制语句 2.4.1、break：跳出循环 Go语言中break 语句用于以下几个方面： 用于循环语句中跳出循环，并开始执行循环之后的语句。 break在switch（开关语句）中在执行一条case后跳出语句的作用。 在多重循环中，可以用标号label标出想break的循环。 var i = 0 for { if i == 10{ fmt.Println(\"跳出循环\") break } i++ fmt.Println(i) } 使用label package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- break ----\") for i := 1; i ---- break ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 ---- break label ---- i: 1 i2: 11 2.4.2、 continue：跳过当前循环的剩余语句，然后继续进行下一轮循环 Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。 for 循环中，执行 continue 语句会触发 for 增量语句的执行。 在多重循环中，可以用标号 label 标出想 continue 的循环。 package main import \"fmt\" func main() { // 不使用标记 fmt.Println(\"---- continue ---- \") for i := 1; i ---- continue ---- i: 1 i2: 11 i2: 12 i2: 13 i: 2 i2: 11 i2: 12 i2: 13 i: 3 i2: 11 i2: 12 i2: 13 ---- continue label ---- i: 1 i2: 11 i: 2 i2: 11 i: 3 i2: 11 2.4.3、 goto：跳转到指定标签 Go 语言的 goto 语句可以无条件地转移到过程中指定的行。 goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。 但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 goto label; .. . label: statement; var n = 20 if n > 24 { fmt.Println(\"成年人\") } else { goto lable3 } fmt.Println(\"aaa\") fmt.Println(\"bbb\") lable3: fmt.Println(\"ccc\") fmt.Println(\"ddd\") "},"GoLang/GoLang基础/07-数组.html":{"url":"GoLang/GoLang基础/07-数组.html","title":"数组","keywords":"","body":"datetime:2020/9/16 14:56 author:nzb Go的数组 1、Array数组介绍 数组是指一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素（element），这种类型可以是意的原始类型，比如int、string等，也可以是用户自定义的类型。一个数组包含的元素个数被称为数组的长度。在Golang中数组是一个长度固定的数据类型，数组的长度是类型的一部分，也就是说[5]int和[10]int是两个不同的类型。Golang中数组的另一个特点是占用内存的连续性，也就是说数组中的元素是被分配到连续的内存地址中的，因而索引数组元素的速度非常快。 和数组对应的类型是Slice（切片），Slice是可以增长和收缩的动态序列，功能也更灵活，但是想要理解slice工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用。 2、数组定义 var variable_name [SIZE] variable_type 示例 // 数组的长度是类型的一部分 var arr1 [3]int var arr2 [4]string fmt.Printf(\"%T, %T \\n\", arr1, arr2) // 数组的初始化 第一种方法 var arr3 [3]int arr3[0] = 1 arr3[1] = 2 arr3[2] = 3 fmt.Println(arr3) // 第二种初始化数组的方法 var arr4 = [4]int {10, 20, 30, 40} fmt.Println(arr4) // 第三种数组初始化方法，自动推断数组长度 var arr5 = [...]int{1, 2} fmt.Println(arr5) // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} fmt.Println(a) 3、遍历数组 方法1 // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} for i := 0; i 方法2 // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} for _, value := range a { fmt.Print(value, \" \") } 4、数组的值类型 数组是值类型，赋值和传参会赋值整个数组，因此改变副本的值，不会改变本身的值 // 数组 var array1 = [...]int {1, 2, 3} array2 := array1 array2[0] = 3 fmt.Println(array1, array2) 例如上述的代码，我们将数组进行赋值后，该改变数组中的值时，发现结果如下 [1 2 3] [3 2 3] 这就说明了，golang中的数组是值类型，而不是和java一样属于引用数据类型 5、切片定义(引用类型) 在golang中，切片的定义和数组定义是相似的，但是需要注意的是，切片是引用数据类型，如下 // 切片定义 var array3 = []int{1,2,3} array4 := array3 array4[0] = 3 fmt.Println(array3, array4) 我们通过改变第一个切片元素，然后查看最后的效果 [3 2 3] [3 2 3] 6、二维数组 Go语言支持多维数组，我们这里以二维数组为例（数组中又嵌套数组）： 二维 var arrayName [ x ][ y ] variable_type 示例 // 二维数组 var array5 = [2][2]int{ {1,2},{2,3} } fmt.Println(array5) 多维 var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 7、数组遍历 二维数据组的遍历 // 二维数组 var array5 = [2][2]int{ {1,2},{2,3} } for i := 0; i 遍历方式2 for _, item := range array5 { for _, item2 := range item { fmt.Println(item2) } } 8、类型推导 另外我们在进行数组的创建的时候，还可以使用类型推导，但是只能使用一个 ... // 二维数组（正确写法） var array5 = [...][2]int{ {1,2},{2,3} } 错误写法 // 二维数组 var array5 = [2][...]int{ {1,2},{2,3} } 9、完整代码 package main import \"fmt\" func main() { // 数组的长度是类型的一部分 var arr1 [3]int var arr2 [4]string fmt.Printf(\"%T, %T \\n\", arr1, arr2) // 数组的初始化 第一种方法 var arr3 [3]int arr3[0] = 1 arr3[1] = 2 arr3[2] = 3 fmt.Println(arr3) // 第二种初始化数组的犯法 var arr4 = [4]int {10, 20, 30, 40} fmt.Println(arr4) // 第三种数组初始化方法，自动推断数组长度 var arr5 = [...]int{1, 2} fmt.Println(arr5) // 第四种初始化数组的方法，指定下标 a := [...]int{1:1, 3:5} fmt.Println(a) for i := 0; i 10、向函数传递数组 方式一：形参设定数组大小： void myFunction(param [10]int) { . . . } 方式二：形参未设定数组大小： void myFunction(param []int) { . . . } "},"GoLang/GoLang基础/08-切片.html":{"url":"GoLang/GoLang基础/08-切片.html","title":"切片","keywords":"","body":"datetime:2020/10/23 10:48 author:nzb Go的切片 1、为什么要使用切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。 它非常灵活，支持自动扩容。 切片是一个引用类型，它的内部结构包含地址、长度和容量。 声明切片类型的基本语法如下： var name [] T 其中： name：表示变量名 T：表示切片中的元素类型 举例 // 声明切片，把长度去除就是切片 var slice = []int{1,2,3} fmt.Println(slice) 2、关于nil的认识 当你声明了一个变量，但却还并没有赋值时，golang中会自动给你的变量赋值一个默认的零值。这是每种类型对应的零值。 bool：false numbers：0 string：\"\" pointers：nil slices：nil maps：nil channels：nil functions：nil nil表示空，也就是数组初始化的默认值就是nil var slice2 [] int fmt.Println(slice2 == nil) 运行结果 true 3、切片的遍历 切片的遍历和数组是一样的 var slice = []int{1,2,3} for i := 0; i 4、基于数组定义切片 由于切片的底层就是一个数组，所以我们可以基于数组来定义切片 // 基于数组定义切片 a := [5]int {55,56,57,58,59} // 获取数组所有值，返回的是一个切片 b := a[:] // 从数组获取指定的切片 c := a[1:4] // 获取 下标3之前的数据（不包括3） d := a[:3] // 获取下标3以后的数据（包括3） e := a[3:] 运行结果 [55 56 57 58 59] [55 56 57 58 59] [56 57 58] [55 56 57] [58 59] 同理，我们不仅可以对数组进行切片，还可以切片在切片 5、切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len）函数求长度，使用内置的cap（） 函数求切片的容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。切片s的长度和容量可通过表达式len（s）和cap（s）来获取。 举例 // 长度和容量 s := []int {2,3,5,7,11,13} fmt.Printf(\"长度%d 容量%d\\n\", len(s), cap(s)) ss := s[2:] fmt.Printf(\"长度%d 容量%d\\n\", len(ss), cap(ss)) sss := s[2:4] fmt.Printf(\"长度%d 容量%d\\n\", len(sss), cap(sss)) 运行结果 长度6 容量6 长度4 容量4 长度2 容量4 为什么最后一个容量不一样呢，因为我们知道，经过切片后sss = [5, 7] 所以切片的长度为2，但是一因为容量是从2的位置一直到末尾，所以为4 6、切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息 底层数组的指针 切片的长度(len) 切片的容量(cap) 举个例子，现在有一个数组 a := [8]int {0,1,2,3,4,5,6,7}，切片 s1 := a[:5]，相应示意图如下 切片 s2 := a[3:6]，相应示意图如下： 7、使用make函数构造切片 我们上面都是基于数组来创建切片的，如果需要动态的创建一个切片，我们就需要使用内置的make函数，格式如下： make ([]T, size, cap) 其中： T：切片的元素类型 size：切片中元素的数量 cap：切片的容量 举例： // make()函数创建切片 fmt.Println() var slices = make([]int, 4, 8) //[0 0 0 0] fmt.Println(slices) // 长度：4, 容量8 fmt.Printf(\"长度：%d, 容量%d\", len(slices), cap(slices)) 需要注意的是，golang中没办法通过下标来给切片扩容，如果需要扩容，需要用到append slices2 := []int{1,2,3,4} slices2 = append(slices2, 5) fmt.Println(slices2) // 输出结果 [1 2 3 4 5] 同时切片还可以将两个切片进行合并 // 合并切片 slices3 := []int{6,7,8} slices2 = append(slices2, slices3...) fmt.Println(slices2) // 输出结果 [1 2 3 4 5 6 7 8] 需要注意的是，切片会有一个扩容操作，当元素存放不下的时候，会将原来的容量扩大两倍，详情 8、使用copy()函数复制切片 前面我们知道，切片就是引用数据类型 值类型：改变变量副本的时候，不会改变变量本身 引用类型：改变变量副本值的时候，会改变变量本身的值 如果我们需要改变切片的值，同时又不想影响到原来的切片，那么就需要用到copy函数 // 需要复制的切片 var slices4 = []int{1,2,3,4} // 使用make函数创建一个切片 var slices5 = make([]int, len(slices4), len(slices4)) // 拷贝切片的值 copy(slices5, slices4) // 修改切片 slices5[0] = 4 fmt.Println(slices4) fmt.Println(slices5) 运行结果为 [1 2 3 4] [4 2 3 4] 9、删除切片中的值 Go语言中并没有删除切片元素的专用方法，我们可以利用切片本身的特性来删除元素。代码如下 // 删除切片中的值 var slices6 = []int {0,1,2,3,4,5,6,7,8,9} // 删除下标为1的值 slices6 = append(slices6[:1], slices6[2:]...) fmt.Println(slices6) 运行结果 [0 2 3 4 5 6 7 8 9] 10、切片的排序算法以及sort包 编写一个简单的冒泡排序算法 func main() { var numSlice = []int{9,8,7,6,5,4} for i := 0; i numSlice[j+1] { var temp = numSlice[j+1] numSlice[j+1] = numSlice[j] numSlice[j] = temp flag = true } } if !flag { break } } fmt.Println(numSlice) } 在来一个选择排序 // 编写选择排序 var numSlice2 = []int{9,8,7,6,5,4} for i := 0; i numSlice2[j] { var temp = numSlice2[i] numSlice2[i] = numSlice2[j] numSlice2[j] = temp } } } fmt.Println(numSlice2) 对于int、float64 和 string数组或是切片的排序，go分别提供了sort.Ints()、sort.Float64s() 和 sort.Strings()函数，默认都是从小到大进行排序 var numSlice2 = []int{9,8,7,6,5,4} sort.Ints(numSlice2) fmt.Println(numSlice2) 降序排列 Golang的sort包可以使用 sort.Reverse(slic e) 来调换slice.Interface.Less，也就是比较函数，所以int、float64 和 string的逆序排序函数可以这样写 // 逆序排列 var numSlice4 = []int{9,8,4,5,1,7} sort.Sort(sort.Reverse(sort.IntSlice(numSlice4))) fmt.Println(numSlice4) "},"GoLang/GoLang基础/09-map.html":{"url":"GoLang/GoLang基础/09-map.html","title":"map","keywords":"","body":"datetime:2020/10/23 15:57 author:nzb Go的map 1、map的介绍 map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 Go语言中map的定义语法如下： map[KeyType]ValueType 其中： KeyType：表示键的类型 ValueType：表示键对应的值的类型 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为： make：用于slice、map和channel的初始化 示例如下所示： // 方式1初始化 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" userInfo[\"age\"] = \"20\" userInfo[\"sex\"] = \"男\" fmt.Println(userInfo) fmt.Println(userInfo[\"userName\"]) // 创建方式2，map也支持声明的时候填充元素 var userInfo2 = map[string]string { \"username\":\"张三\", \"age\":\"21\", \"sex\":\"女\", } fmt.Println(userInfo2) 2、遍历map 使用for range遍历 // 遍历map for key, value := range userInfo2 { fmt.Println(\"key:\", key, \" value:\", value) } 3、判断map中某个键值是否存在 我们在获取map的时候，会返回两个值，也可以是返回的结果，一个是是否有该元素 // 判断是否存在,如果存在 ok = true，否则 ok = false value, ok := userInfo2[\"username2\"] fmt.Println(value, ok) 4、使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete函数的格式如下所示 delete(map 对象, key) 其中： map对象：表示要删除键值对的map对象 key：表示要删除的键值对的键 示例代码如下 // 删除map数据里面的key，以及对应的值 delete(userInfo2, \"sex\") fmt.Println(userInfo2) 5、元素为map类型的切片 我们想要在切片里面存放一系列用户的信息，这时候我们就可以定义一个元素为map类型的切片 // 切片在中存放map var userInfoList = make([]map[string]string, 3, 3) var user = map[string]string{ \"userName\": \"张安\", \"age\": \"15\", } var user2 = map[string]string{ \"userName\": \"张2\", \"age\": \"15\", } var user3 = map[string]string{ \"userName\": \"张3\", \"age\": \"15\", } userInfoList[0] = user userInfoList[1] = user2 userInfoList[2] = user3 fmt.Println(userInfoList) for _, item := range userInfoList { fmt.Println(item) } 6、值为切片类型的map 我们可以在map中存储切片 // 将map类型的值 var userinfo = make(map[string][]string) userinfo[\"hobby\"] = []string {\"吃饭\", \"睡觉\", \"敲代码\"} fmt.Println(userinfo) 7、示例 统计字符串中单词出现的次数 // 写一个程序，统计一个字符串中每个单词出现的次数。比如 \"how do you do\" var str = \"how do you do\" array := strings.Split(str, \" \") fmt.Println(array) countMap := make(map[string]int) for _, item := range array { countMap[item]++ } fmt.Println(countMap) "},"GoLang/GoLang基础/10-函数.html":{"url":"GoLang/GoLang基础/10-函数.html","title":"函数","keywords":"","body":"datetime:2020/10/26 15:40 author:nzb Go的函数 1、函数定义 函数是组织好的、可重复使用的、用于执行指定任务的代码块 Go语言支持：函数、匿名函数和闭包 Go语言中定义函数使用func关键字，具体格式如下： func 函数名(参数)(返回值) { 函数体 } 其中： 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也不能重名 示例 // 求两个数的和 func sumFn(x int, y int) int{ return x + y } // 调用方式 sunFn(1, 2) // 类型可以简写（多个返回值时也是） func sumFn(x, y int) int{ return x + y } // 调用方式 sunFn(1, 2) 获取可变的参数，可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后面加... 来标识。 注意：可变参数通常要作为函数的最后一个参数 func sunFn2(x ...int) int { sum := 0 for _, num := range x { sum = sum + num } return sum } // 调用方法 sunFn2(1, 2, 3, 4, 5, 7) 方法多返回值，Go语言中函数支持多返回值，同时还支持返回值命名，函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回 // 方法多返回值 func sunFn4(x int, y int)(sum int, sub int) { sum = x + y sub = x -y return } 2、函数类型和变量 2.1、定义函数类型 我们可以使用type关键字来定义一个函数类型，具体格式如下 type calculation func(int, int) int 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。 简单来说，凡是满足这两个条件的函数都是calculation类型的函数，例如下面的add 和 sub 是calculation类型 type calc func(int, int) int // 求两个数的和 func sumFn(x int, y int) int{ return x + y } func main() { var c calc c = add // 打印：c的类型是：main.cal d := add // 打印：d的类型是：func(int, int) int } 2.2、方法作为参数 类型Python的filter、sorted等方法 /** 传递两个参数和一个方法 */ func sunFn (a int, b int, sum func(int, int)int) int { return sum(a, b) } 返回值是函数：使用switch定义方法，这里用到了匿名函数 // 返回一个方法 type calcType func(int, int)int func do(o string) calcType { switch o { case \"+\": return func(i int, i2 int) int { return i + i2 } case \"-\": return func(i int, i2 int) int { return i - i2 } case \"*\": return func(i int, i2 int) int { return i * i2 } case \"/\": return func(i int, i2 int) int { return i / i2 } default: return nil } } func main() { add := do(\"+\") fmt.Println(add(1,5)) } 3、匿名函数 函数当然还可以作为返回值，但是在Go语言中，函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下 func (参数)(返回值) { 函数体 } 匿名函数因为没有函数名，所以没有办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数： func main() { // 第一种 func () { fmt.Println(\"匿名自执行函数\") }() //第二种 a := func () { fmt.Println(\"匿名自执行函数\") } a() } 4、闭包 4.1、全局变量和局部变量 全局变量的特点： 常驻内存 污染全局 局部变量的特点（注意if语句中的局部变量） 不常驻内存 不污染全局 4.2、闭包 可以让一个变量常驻内存 可以让一个变量不污染全局 闭包可以理解成 “定义在一个函数内部的函数”。在本质上，闭包就是将函数内部 和 函数外部连接起来的桥梁。或者说是函数和其引用环境的组合体。 闭包是指有权访问另一个函数作用域中的变量的函数 创建闭包的常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数的局部变量 注意：由于闭包里作用域返回的局部变量资源不会被立刻销毁，所以可能会占用更多的内存，过度使用闭包会导致性能下降，建议在非常有必要的时候才使用闭包。 // 闭包的写法：函数里面嵌套一个函数，最后返回里面的函数就形成了闭包 func adder() func() int { var i = 10 return func() int { return i + 1 } } func main() { var fn = adder() fmt.Println(fn()) fmt.Println(fn()) fmt.Println(fn()) } 最后输出的结果 11 11 11 另一个闭包的写法，让一个变量常驻内存，不污染全局 func adder2() func(y int) int { var i = 10 return func(y int) int { i = i + y return i } } func main() { var fn2 = adder2() fmt.Println(fn2(10)) fmt.Println(fn2(10)) fmt.Println(fn2(10)) } 5、defer语句 Go 语言中的defer 语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。 // defer函数 fmt.Println(\"1\") defer fmt.Println(\"2\") fmt.Println(\"3\") fmt.Println(\"4\") defer将会延迟执行 1 3 4 2 如果有多个defer修饰的语句，将会逆序进行执行 // defer函数 fmt.Println(\"1\") defer fmt.Println(\"2\") defer fmt.Println(\"3\") fmt.Println(\"4\") 运行结果 1 4 3 2 如果需要用defer运行一系列的语句，那么就可以使用匿名函数 func main() { fmt.Println(\"开始\") defer func() { fmt.Println(\"1\") fmt.Println(\"2\") }() fmt.Println(\"结束\") } 运行结果 开始 结束 1 2 5.1、defer执行时机 在Go语言的函数中return语句在底层并不是原子操作，它分为返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前，具体如下图所示 6、panic/revocer处理异常 Go语言中是没有异常机制，但是使用panic / recover模式来处理错误 panic：可以在任何地方引发 recover：只有在defer调用函数内有效 func fn1() { fmt.Println(\"fn1\") } func fn2() { panic(\"抛出一个异常\") } func main() { fn1() fn2() fmt.Println(\"结束\") } 上述程序会直接抛出异常，无法正常运行 fn1 panic: 抛出一个异常 解决方法就是使用 recover进行异常的监听 func fn1() { fmt.Println(\"fn1\") } func fn2() { // 使用recover监听异常 defer func() { err := recover() if err != nil { fmt.Println(err) } }() panic(\"抛出一个异常\") } func main() { fn1() fn2() fmt.Println(\"结束\") } 7、异常运用场景 模拟一个读取文件的方法，这里可以主动发送使用panic 和 recover func readFile(fileName string) error { if fileName == \"main.go\" { return nil } else { return errors.New(\"读取文件失败\") } } func myFn () { defer func() { e := recover() if e != nil { fmt.Println(\"给管理员发送邮件\") } }() err := readFile(\"XXX.go\") if err != nil { panic(err) } } func main() { myFn() } 8、内置函数 内置函数 介绍 close 主要用来关闭channel len 用来求长度，比如string、array、slice、map、channel new 用来分配内存、主要用来分配值类型，比如 int、struct ，返回的是指针 make 用来分配内存，主要用来分配引用类型，比如chan、map、slice append 用来追加元素到数组、slice中 panic\\recover 用来处理错误 "},"GoLang/GoLang基础/11-time包日期函数.html":{"url":"GoLang/GoLang基础/11-time包日期函数.html","title":"time包日期函数","keywords":"","body":"datetime:2020/10/26 16:57 author:nzb Go中的日期函数 time包 时间和日期是我们编程中经常会用到的，在golang中time包提供了时间的显示和测量用的函数。 1、time.Now获取当前时间 timeObj := time.Now() year := timeObj.Year() month := timeObj.Month() day := timeObj.Day() fmt.Printf(\"%d-%02d-%02d \\n\", year, month, day) %02d 2 表示宽度，如果整数不够 2 列就补上 0 2、格式化日期 时间类型有一个自带的方法 Format进行格式化 需要注意的是Go语言中格式化时间模板不是长久的 Y-m-d H:M:S 而是使用Go的诞生时间 2006年1月2日 15点04分 （记忆口诀：2006 1 2 3 4 5） /** 时间类型有一个自带的方法 Format进行格式化 需要注意的是Go语言中格式化时间模板不是长久的 Y-m-d H:M:S 而是使用Go的诞生时间 2006年1月2日 15点04分 （记忆口诀：2006 1 2 3 4 5） */ timeObj2 := time.Now() // 24小时值 （15表示二十四小时） fmt.Println(timeObj2.Format(\"2006-01-02 15:04:05\")) // 12小时制 fmt.Println(timeObj2.Format(\"2006-01-02 03:04:05\")) 3、获取当前时间戳 时间戳是自1070年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳 10位数的时间戳是以 秒 为单位； 13位数的时间戳是以 毫秒 为单位； 19位数的时间戳是以 纳秒 为单位； /** 获取当前时间戳 */ timeObj3 := time.Now() // 获取秒时间戳 unixTime := timeObj3.Unix() // 获取纳秒时间戳 unixNaTime := timeObj3.UnixNano() package main import ( \"time\" \"fmt\" ) func main() { fmt.Printf(\"时间戳（秒）：%v;\\n\", time.Now().Unix()) fmt.Printf(\"时间戳（纳秒）：%v;\\n\",time.Now().UnixNano()) fmt.Printf(\"时间戳（毫秒）：%v;\\n\",time.Now().UnixNano() / 1e6) fmt.Printf(\"时间戳（纳秒转换为秒）：%v;\\n\",time.Now().UnixNano() / 1e9) } //输出 时间戳（秒）：1530027865; 时间戳（纳秒）：1530027865231834600; 时间戳（毫秒）：1530027865231; 时间戳（纳秒转换为秒）：1530027865; 4、时间戳转日期字符串 通过将时间戳我们可以转换成日期字符串 // 时间戳转换年月日时分秒（一个参数是秒，另一个参数是毫秒） var timeObj4 = time.Unix(1595289901, 0) var timeStr = timeObj4.Format(\"2006-01-02 15:04:05\") fmt.Println(timeStr) 5、日期字符串转换成时间戳 // 日期字符串转换成时间戳 var timeStr2 = \"2020-07-21 08:10:05\"; var tmp = \"2006-01-02 15:04:05\" timeObj5, _ := time.ParseInLocation(tmp, timeStr2, time.Local) fmt.Println(timeObj5.Unix()) 6、时间间隔 time.Duration是time包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration表示一段时间间隔，可表示的最大长度段大约290年。 time包中定义的时间间隔类型的常量如下： 7、时间操作函数 我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下 func (t Time) Add(d Duration)Time 例如 // 时间相加 now := time.Now() // 当前时间加1个小时后 later := now.Add(time.Hour) fmt.Println(later) 同理的方法还有：时间差、判断相等 8、定时器 方式1：使用time.NewTicker（时间间隔）来设置定时器 // 定时器, 定义一个1秒间隔的定时器 ticker := time.NewTicker(time.Second) n := 0 for i := range ticker.C { fmt.Println(i) n++ if n>5 { // 终止定时器 ticker.Stop() return } } 方式2：time.Sleep(time.Second)来实现定时器 for { time.Sleep(time.Second) fmt.Println(\"一秒后\") } "},"GoLang/GoLang基础/12-指针.html":{"url":"GoLang/GoLang基础/12-指针.html","title":"指针","keywords":"","body":"datetime:2020/10/26 17:42 author:nzb Go中的指针 要搞明白Go语言中的指针需要先知道三个概念 指针地址 指针类型 指针取值 Go语言中的指针操作非常简单，我们只需要记住两个符号：&：取地址，*：根据地址取值 1、关于指针 我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量a:=10，这个时候可以直接通过a这个变量来读取内存中保存的10这个值。在计算机底层a这个变量其实对应了一个内存地址。 指针也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是另一个变量的内存地址。 2、指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go 语言中使用&字符放在变量前面对变量进行取地址操作。Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如： *int、，*int64、*string等 取变量指针的语法如下： ptr := &v 其中： v：代表被取地址的变量，类型为T ptr：用于接收地址的变量，ptr的类型就为T，被称做T的指针类型。\\ 代表指针 举个例子： 3、指针取值 在对普通变量进行&操作符取地址后，会获得这个变量指针，然后可以对指针使用*操作，也就是指针取值 // 指针取值 var c = 20 // 得到c的地址，赋值给d var d = &c // 打印d的值，也就是c的地址 fmt.Println(d) // 取出d指针所对应的值 fmt.Println(*d) // c对应地址的值，改成30 *d = 30 // c已经变成30了 fmt.Println(c) 改变内存中的值，会直接改变原来的变量值 // 这个类似于值传递 func fn4(x int) { x = 10 } // 这个类似于引用数据类型 func fn5(x *int) { *x = 20 } func main() { x := 5 fn4(x) fmt.Println(x) fn5(&x) fmt.Println(x) } 我们创建了两个方法，一个是传入局部变量，一个是传入指针类型，最后运行得到的结果 5 20 4、new和make函数 需要注意的是，指针必须在创建内存后才可以使用，这个和 slice 和 map是一样的 // 引用数据类型map、slice等，必须使用make分配空间，才能够使用 var userInfo = make(map[string]string) userInfo[\"userName\"] = \"zhangsan\" fmt.Println(userInfo) var array = make([]int, 4, 4) array[0] = 1 fmt.Println(array) 对于指针变量来说 // 指针变量初始化 var a *int *a = 100 fmt.Println(a) 执行上面的代码会引发panic，为什么呢？在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。Go 语言中new和make是内建的两个函数，主要用来分配内存。 这个时候，我们就需要使用new关键字来分配内存，new是一个内置的函数，它的函数签名如下： func new(Type) *Type 其中 Type表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针 实际开发中new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子： // 使用new关键字创建指针 aPoint := new(int) bPoint := new(bool) fmt.Printf(\"%T \\n\", aPoint) fmt.Printf(\"%T \\n\", bPoint) fmt.Println(*aPoint) fmt.Println(*bPoint) 本节开始的示例代码中 var a *int 只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的 5、make和new的区别 两者都是用来做内存分配的 make只能用于slice、map以及channel的初始化，返回的还是这三个引用类型的本身 而new用于类型的内存分配，并且内存对应的值为类型的零值，返回的是指向类型的指针（不常用） "},"GoLang/GoLang基础/13-结构体.html":{"url":"GoLang/GoLang基础/13-结构体.html","title":"结构体","keywords":"","body":"datetime:2020/10/26 18:03 author:nzb Go中的结构体 1、关于结构体 Golang中没有“类”的概念，Golang中的结构体和其他语言中的类有点相似。和其他面向对象语言中的类相比，Golang中的结构体具有更高的扩展性和灵活性。 Golang中的基础数据类型可以装示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型就无法满足需求了，Golang提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。也就是我们可以通过struct来定义自己的类型了。 2、Type关键字 Golang中通过type关键词定义一个结构体，需要注意的是，数组和结构体都是值类型，在这个和Java是有区别的 2.1、、自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。 type myInt int 上面代码表示：将mylnt定义为int类型，通过type关键字的定义，mylnt就是一种新的类型，它具有int的特性。 示例：如下所示，我们定义了一个myInt类型 type myInt int func main() { var a myInt = 10 fmt.Printf(\"%v %T\", a, a) } 输出查看它的值以及类型，能够发现该类型就是myInt类型 10 main.myInt 除此之外，我们还可以定义一个方法类型 func fun(x int, y int)int { return x + y } func main() { var fn myFn = fun fmt.Println(fn(1, 2)) } 然后调用并输出 3 2.2、类型别名 Golang1.9版本以后添加的新功能 类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有大名、小名、英文名，但这些名字都指的是他本人 type TypeAlias = Type 我们之前见过的rune 和 byte 就是类型别名，他们的底层代码如下 type byte = uint8 type rune = int32 3、结构体定义和初始化 3.1、结构体的定义 使用type 和 struct关键字来定义结构体，具体代码格式如下所示： /** 定义一个人结构体 */ type Person struct { name string age int sex string } func main() { // 实例化结构体 var person Person person.name = \"张三\" person.age = 20 person.sex = \"男\" fmt.Printf(\"%#v\", person) } 注意：结构体首字母可以大写也可以小写，大写表示这个结构体是公有的，在其它的包里面也可以使用，小写表示结构体属于私有的，在其它地方不能使用 例如： type Person struct { Name string Age int Sex string } 3.2、实例化结构体1 刚刚实例化结构体用到了：var person Person // 实例化结构体 var person Person person.name = \"张三\" person.age = 20 person.sex = \"男\" 3.3、实例化结构体2 我们下面使用另外一个方式来实例化结构体，通过new关键字来实例化结构体，得到的是结构体的地址，格式如下 var person2 = new(Person) person2.name = \"李四\" person2.age = 30 person2.sex = \"女\" fmt.Printf(\"%#v\", person2) 输出如下所示，从打印结果可以看出person2是一个结构体指针 &main.Person{name:\"李四\", age:30, sex:\"女\"} 需要注意：在Golang中支持对结构体指针直接使用，来访问结构体的成员 person2.name = \"李四\" // 等价于 (*person2).name = \"李四\" 3.4、实例化结构体3 使用&对结构体进行取地址操作，相当于对该结构体类型进行了一次new实例化操作 // 第三种方式实例化 var person3 = &Person{} person3.name = \"赵四\" person3.age = 28 person3.sex = \"男\" fmt.Printf(\"%#v\", person3) 3.5、实例化结构体4 使用键值对的方式来实例化结构体，实例化的时候，可以直接指定对应的值 // 第四种方式初始化 var person4 = Person{ name: \"张三\", age: 10, sex: \"女\", } fmt.Printf(\"%#v\", person4) 3.6、实例化结构体5 第五种和第四种差不多，不过是用了取地址，然后返回的也是一个地址 // 第五种方式初始化 var person5 = &Person{ name: \"孙五\", age: 10, sex: \"女\", } fmt.Printf(\"%#v\", person5) 3.7、实例化结构体6 第六种方式是可以简写结构体里面的key var person6 = Person{ \"张三\", 5, \"女\", } fmt.Println(person6) 4、结构体方法和接收者 在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接收者的函数。接收者的概念就类似于其他语言中的this 或者self。 方法的定义格式如下： func (接收者变量 接收者类型) 方法名(参数列表)(返回参数) { 函数体 } 其中 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为p，Connector类型的接收者变量应该命名为c等。、 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 非指针类型：表示不修改结构体的内容 指针类型：表示修改结构体中的内容 方法名、参数列表、返回参数：具体格式与函数定义相同 如果示例所示： /** 定义一个人结构体 */ type Person struct { name string age int sex string } // 定义一个结构体方法 func (p Person) PrintInfo() { fmt.Print(\" 姓名: \", p.name) fmt.Print(\" 年龄: \", p.age) fmt.Print(\" 性别: \", p.sex) fmt.Println() } func (p *Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } func main() { var person = Person{ \"张三\", 18, \"女\", } person.PrintInfo() person.SetInfo(\"李四\", 18, \"男\") person.PrintInfo() } 运行结果为： 姓名: 张三 年龄: 18 性别: 女 姓名: 李四 年龄: 18 性别: 男 注意，因为结构体是值类型，所以我们修改的时候，因为是传入的指针(修改的是实例里面的属性) func (p *Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } 不传指针(修改是结构体的属性，所以都一样)func (p Person) SetInfo(name string, age int, sex string) { p.name = name p.age = age p.sex = sex } 姓名: 张三 年龄: 18 性别: 女 姓名: 张三 年龄: 18 性别: 女 5、给任意类型添加方法 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。 type myInt int func fun(x int, y int)int { return x + y } func (m myInt) PrintInfo() { fmt.Println(\"我是自定义类型里面的自定义方法\") } func main() { var a myInt = 10 fmt.Printf(\"%v %T \\n\", a, a) a.PrintInfo() } 6、结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就被称为匿名字段 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能一个 /** 定义一个人结构体 */ type Person struct { string int } func main() { // 结构体的匿名字段 var person = Person{ \"张三\", 18 } } 结构体的字段类型可以是：基本数据类型，也可以是切片、Map 以及结构体 如果结构体的字段类似是：指针、slice、和 map 的零值都是nil，即还没有分配空间 如果需要使用这样的字段，需要先make，才能使用 /** 定义一个人结构体 */ type Person struct { name string age int hobby []string mapValue map[string]string } func main() { // 结构体的匿名字段 var person = Person{} person.name = \"张三\" person.age = 10 // 给切片申请内存空间 person.hobby = make([]string, 4, 4) person.hobby[0] = \"睡觉\" person.hobby[1] = \"吃饭\" person.hobby[2] = \"打豆豆\" // 给map申请存储空间 person.mapValue = make(map[string]string) person.mapValue[\"address\"] = \"北京\" person.mapValue[\"phone\"] = \"123456789\" // 加入#打印完整信息 fmt.Printf(\"%#v\", person) } 同时我们还支持结构体的嵌套，如下所示 // 用户结构体 type User struct { userName string password string sex string age int address Address // User结构体嵌套Address结构体 } // 收货地址结构体 type Address struct { name string phone string city string } func main() { var u User u.userName = \"moguBlog\" u.password = \"123456\" u.sex = \"男\" u.age = 18 var address Address address.name = \"张三\" address.phone = \"110\" address.city = \"北京\" u.address = address fmt.Printf(\"%#v\", u) } 7、嵌套结构体的字段名冲突 嵌套结构体内部可能存在相同的字段名，这个时候为了避免歧义，需要指定具体的内嵌结构体的字段。（例如，父结构体中的字段 和 子结构体中的字段相似） 默认会从父结构体中寻找，如果找不到的话，再去子结构体中在找 如果子类的结构体中，同时存在着两个相同的字段，那么这个时候就会报错了，因为程序不知道修改那个字段的为准。 8、结构体的继承 结构体的继承，其实就类似于结构体的嵌套，如下所示，我们定义了两个结构体，分别是Animal 和 Dog，其中每个结构体都有各自的方法，然后通过Dog结构体 继承于 Animal结构体 // 用户结构体 type Animal struct { name string } func (a Animal) run() { fmt.Printf(\"%v 在运动 \\n\", a.name) } // 子结构体 type Dog struct { age int // 通过结构体嵌套，完成继承 Animal } func (dog Dog) wang() { fmt.Printf(\"%v 在汪汪汪 \\n\", dog.name) } func main() { var dog = Dog{ age: 10, Animal: Animal{ name: \"阿帕奇\", }, } dog.run(); dog.wang(); } 运行后，发现Dog拥有了父类的方法 阿帕奇 在运动 阿帕奇 在汪汪汪 9、Go中的结构体和Json相互转换 JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。RESTfull Api接口中返回的数据都是json数据。 { \"name\": \"张三\", \"age\": 15 } 比如我们Golang要给App或者小程序提供Api接口数据，这个时候就需要涉及到结构体和Json之间的相互转换 Golang JSON序列化是指把结构体数据转化成JSON格式的字符串，Golang JSON的反序列化是指把JSON数据转化成Golang中的结构体对象 Golang中的序列化和反序列化主要通过“encoding/json”包中的 json.Marshal() 和 son.Unmarshal() // 定义一个学生结构体，注意结构体的首字母必须大写，代表公有，否则将无法转换 type Student struct { ID string Gender string Name string Sno string } func main() { var s1 = Student{ ID: \"12\", Gender: \"男\", Name: \"李四\", Sno: \"s001\", } // 结构体转换成Json（返回的是byte类型的切片） jsonByte, _ := json.Marshal(s1) jsonStr := string(jsonByte) fmt.Printf(jsonStr) } 将字符串转换成结构体类型 // 定义一个学生结构体，注意结构体的首字母必须大写，代表公有，否则将无法转换 type Student struct { ID string Gender string Name string Sno string } func main() { // Json字符串转换成结构体 var str = `{\"ID\":\"12\",\"Gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s001\"}` var s2 = Student{} // 第一个是需要传入byte类型的数据，第二参数需要传入转换的地址 err := json.Unmarshal([]byte(str), &s2) if err != nil { fmt.Printf(\"转换失败 \\n\") } else { fmt.Printf(\"%#v \\n\", s2) } } 注意 我们想要实现结构体转换成字符串，必须保证结构体中的字段是公有的，也就是首字母必须是大写的，这样才能够实现结构体 到 Json字符串的转换。 10、结构体标签Tag Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下： key1：\"value1\" key2：\"value2\" 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。 注意事项：为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。 如下所示，我们通过tag标签，来转换字符串的key // 定义一个Student体，使用结构体标签 type Student2 struct { Id string `json:\"id\"` // 通过指定tag实现json序列化该字段的key Gender string `json:\"gender\"` Name string `json:\"name\"` Sno string `json:\"sno\"` } func main() { var s1 = Student2{ Id: \"12\", Gender: \"男\", Name: \"李四\", Sno: \"s001\", } // 结构体转换成Json jsonByte, _ := json.Marshal(s1) jsonStr := string(jsonByte) fmt.Println(jsonStr) // Json字符串转换成结构体 var str = `{\"Id\":\"12\",\"Gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s001\"}` var s2 = Student2{} // 第一个是需要传入byte类型的数据，第二参数需要传入转换的地址 err := json.Unmarshal([]byte(str), &s2) if err != nil { fmt.Printf(\"转换失败 \\n\") } else { fmt.Printf(\"%#v \\n\", s2) } } 11、嵌套结构体和Json序列化反序列化 和刚刚类似，我们同样也是使用的是 json.Marshal() // 嵌套结构体 到 Json的互相转换 // 定义一个Student结构体 type Student3 struct { Id int Gender string Name string } // 定义一个班级结构体 type Class struct { Title string Students []Student3 } func main() { var class = Class{ Title: \"1班\", Students: make([]Student3, 0), } for i := 0; i "},"GoLang/GoLang基础/14-GoMod及包.html":{"url":"GoLang/GoLang基础/14-GoMod及包.html","title":"GoMod及包","keywords":"","body":"datetime:2020/10/28 15:19 author:nzb Go中的包 1、Go中的包的介绍和定义 包（package）是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、strconv、strings、sort、errors、time、encoding/json、os、io等。 Golang中的包可以分为三种：1、系统内置包 2、自定义包 3、第三方包 系统内置包：Golang 语言给我们提供的内置包，引入后可以直接使用，如fmt、strconv、strings、sort、errors、time、encoding/json、os、io等。 自定义包：开发者自己写的包 第三方包：属于自定义包的一种，需要下载安装到本地后才可以使用，如前面给大家介绍的 \"github.com/shopspring/decimal\"包解决float精度丢失问题。 2、Go包管理工具 go mod 在Golang1.11版本之前如果我们要自定义包的话必须把项目放在GOPATH目录。Go1.11版本之后无需手动配置环境变量，使用go mod 管理项目，也不需要非得把项目放到GOPATH指定目录下，你可以在你磁盘的任何位置新建一个项目，Go1.13以后可以彻底不要GOPATH了。 2.1、go mod init初始化项目 实际项目开发中我们首先要在我们项目目录中用go mod命令生成一个go.mod文件管理我们项目的依赖。 比如我们的golang项目文件要放在了itying这个文件夹，这个时候我们需要在itying文件夹里面使用go mod命令生成一个go.mod文件 go mod init goProject 然后会生成一个 go.mod 的文件，里面的内容是go版本，以及以后添加的包 module goProject go 1.14 2.2、引入其它项目的包 首先我们创建一个 calc，然后里面有一个calc的文件 package calc // 自定义包，最好和文件夹统一起来 // 私有变量 var age = 10 // 公有变量 var Name = \"张三\" // 首字母大写，表示共有方法 func Add(x, y int)int { return x + y } func Sub(x, y int)int { return x - y } 在其它地方需要引用的话，就是这样 package main import ( \"fmt\" \"goProject/calc\" ) func main() { fmt.Printf(\"%v\", calc.Add(2, 5)) } 3、Golang中自定义包 包（package）是多个Go源码的集合，一个包可以简单理解为一个存放多个.go文件的文件夹。该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。 package 包名 注意事项 一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。 包名可以不和文件夹的名字一样，包名不能包含-符号。 包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。 4、Go中init()初始化函数 4.1、init函数介绍 在Go 语言程序执行时导入包语句会自动触发包内部init（）函数的调用。需要注意的是：init（） 函数没有参数也没有返回值。init（）函数在程序运行时自动被调用执行，不能在代码中主动调用它。 包初始化执行的顺序如下图所示： 包初始化执行的顺序如下图所示： 4.2、init函数执行顺序 Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。 在运行时，被最后导入的包会最先初始化并调用其init（）函数，如下图示： 也就是父类中的init先执行 5、Go中的第三方包 我们可以在 https://pkg.go.dev/ 查找看常见的golang第三方包 例如，前面找到前面我们需要下载的第三方包的地址 https://github.com/shopspring/decimal 然后安装这个包 5.1、方法1：go get 包全名 （全局） go get github.com/shopspring/decimal 5.2、方法2：go mod download （全局） go mod download 依赖包会自动下载到 $GOPATH/pkg/mod目录，并且多个项目可以共享缓存的mod，注意使用go mod download的时候，需要首先在你的项目中引入第三方包 5.3、方法3：go mod vendor 将依赖复制到当前项目的vendor（本项目） go mod vendor 将依赖复制到当前项目的vendor下 注意：使用go mod vendor的时候，首先需要在你的项目里面引入第三方包 5.4、go mod常见命令 go download：下载依赖的module到本地cache go edit：编辑go.mod文件 go graph：打印模块依赖图 go init：在当前文件夹下初始化一个新的module，创建go.mod文件 tidy：增加丢失的module，去掉未使用的module vendor：将依赖复制到vendor下 verify：校验依赖，检查下载的第三方库有没有本地修改，如果有修改，则会返回非0，否则校验成功 6、安装依赖 首先我们先去官网找到这个包，https://github.com/shopspring/decimal 然后在我们的项目中引入 import ( \"fmt\" \"github.com/shopspring/decimal\" \"goProject/calc\" ) func main() { fmt.Printf(\"%v \\n\", calc.Add(2, 5)) // 打印公有变量 fmt.Println(calc.Name) _, err := decimal.NewFromString(\"136.02\") if err != nil { panic(err) } } 引入后，我们运行项目，就会去下载了，下载完成后，我们到 go.mod文件夹，能够看到依赖被引入了 module goProject go 1.14 require github.com/shopspring/decimal v1.2.0 // indirect 同时还生成了一个 go.sum文件 github.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ= github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o= 这样我们就可以使用第三包开始具体的使用了~，我们实现一个Float类型的加法 package main import ( \"fmt\" \"github.com/shopspring/decimal\" ) func main() { var num1 float64 = 3.1 var num2 float64 = 4.2 d1 := decimal.NewFromFloat(num1).Add(decimal.NewFromFloat(num2)) fmt.Println(d1) } 7、完整案例 寻找依赖 首先我们需要去 依赖官网，类似于我们的 maven repository 然后我们搜索gJson的包，这个包主要是用于json相关的操作 我们进去后，找到它的https://github.com/tidwall/gjson，然后提供了完整的教程 # 下载依赖 go get -u github.com/tidwall/gjson 使用 package main import \"github.com/tidwall/gjson\" const json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}` func main() { value := gjson.Get(json, \"name.last\") println(value.String()) } "},"Database/MySQL/计算机二级MySQL.html":{"url":"Database/MySQL/计算机二级MySQL.html","title":"计算机二级","keywords":"","body":"一、数据库基本概念 1、数据库设计的步骤 六个阶段：需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行与维护 二、MySQL编程语言 1、MySQL函数 1.1、聚合函数 count()：计数（对于除“*”以外的任何参数，返回所选集合中非null值的数目） sun()：求和 avg()：求平均数 max()：求最大值 min()：求最小值 1.2、数学函数 abs()：求绝对值 floor()：返回小于或等于参数的最大整数 rand()：返回0~1之间的随机数 truncate(x,y)：返回x保留到小数点后y为的值 sort(): 求参数的平方根 1.3、字符串函数 upper()和ucase()：把字符串所有字母变成大写字母 left(s,n)：返回字符串s的前n个字符 substring(s,n,len)：从字符串s的第n个位置开始获取长度为len的字符串 1.4、日期和时间函数 curdate()和current_date()：返回当前日期 curtime()和current_time()：获取当前时间 now()：获取当前日期和时间，current_timestamp()、localtime()、sysdate()、localtimestamp()同样可以获取当前日期和时间 1.5、其他函数 if(expr,v1,v2)：条件判断函数，如果表达式expr成立，则执行v1,否则执行v2 ifnull(v1,v2)：条件判断函数，如果表达式v1不为空，则显示v1的值,否则显示v2的值 version()：获取数据库的版本号 三、数据定义 1、定义数据库 1.1、创建数据库 create {database | schema} [if not exists] db_name [[default] character set [=] charset_name [[default] collate [=] collation_name]; 1.2、选择和查看数据库 use da_name; show {databases | schemas}; 1.3、修改数据库 alter {database | schema} [db_name] [[default] character set [=] charset_name [[default] collate [=] collation_name]; 数据库名可省略，表示修改当前数据库 1.4、删除数据库 drop {database | schema} [if exists] db_name; 2、定义表 2.1数据类型 2.1.1、数值类型 bit tinyint bool,boolean smallint mediumint int,integer bigint double decimal(m.d) 2.1.2、日期和时间类型 date:日期型，MySQL以“YYYY-MM-DD”格式显示date值 datetime:日期和时间类型，MySQL以“YYYY-MM-DD HH:MM:SS”格式显示datetime值 timestamp:时间戳 time:时间型,MySQL以“HH:MM:SS”格式显示time值 year两位或四位格式的年 2.1.3、字符串类型 char：定长字符串 varchar：可变长字符串 tinytext text 2.2、创建表 create table tbl_name ( 字段名1 数据类型 [列级完整性约束条件] [默认值] [,字段名2 数据类型 [列级完整性约束条件] [默认值] [,... ...] [,表级完整性约束条件] ) [engine=引擎类型]; 2.3、查看表 2.3.1、查看表名称 show tables [{from | in } db_name]; 2.3.2、查看数据表的基本结构 show columns {from | in } tb_name [from | in } db_name]; 或 desc tb_name; 2.3.3、查看数据表的详细结构 show create table tb_name; 2.4、修改表 2.4.1、添加字段 alter table tb_name add [column] 新字段名 数据类型 [约束条件] [first | after 已有字段名]; 2.4.2、修改字段 # 可改指定列的名称和数据类型，修改多个彼此用逗号分隔 alter table tb_name change [column] 原字段名 新字段名 数据类型 [约束条件]; # 修改或删除指定列的默认值 alter table tb_name alter [column] 字段名 {set | drop} default; # 修改列的数据类型，而不改名 alter table tb_name modify [column] 字段名 数据类型 [约束条件] [first | after 已有字段名]; 2.4.3、删除字段 alter table tb_name drop [column] 字段名; 2.5、重命名表 alter table 原表名 rename [to] 新表名; 或 rename table 原表名1 to 新表名1 [,原表名2 to 新表名2]......; 2.6、删除表 drop table [if exists] tb_name1 [,tb_name2]......; 3、数据的完整性约束 3.1、定义实体完整性 3.1.1、主键约束 一个表必须要有一个主键，且唯一不为空 3.2.2、完整性约束的命名 constraint {primary key(主键字段列表) | unique(候选键字段列表) |foreign key(外键字段列表) references tb_被参照的关系(表) (主键字段列表) | check(约束条件表达式)}; 3.2、定义参照完整性 外键需存在或为空 3.3、用户定义完整性 MySQL支持的几种用户定义完整性约束：非空约束，check约束和触发器 check约束： check(expr); 3.4、更新完整性约束 3.4.1、删除约束 alter table drop foreign key ; alter table drop primary key; alter table drop {约束名 | 候选键字段名}; 3.4.2、添加约束 alter table add [constraint ] primary key(主键字段); alter table add [constraint ] foreign key(外键字段名) references 被参照表(主键字段名); alter table add [constraint ] unique key(字段名); 四、数据查询 1、select语句 select [all | distinct | distinctrow] [,目标表达式2]... form [,] [group by [having ]] [order by [asc | desc]] [limit[m,]n] 2、单表查询 2.1、选择字段 select 目标表达式1, 目标表达式2,...,目标表达式n from 表名; select * form 表名; # 定义字段的别名 select 字段名 as 字段别名 from 表名; 2.2、选择指定的字段 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 查询条件; # 带between ...and... select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where expression [not] between expr1 and expr2; #带like关键字,换码字符也叫转义字符，如果字符串本身含有通配符_和%,就需要换码字符 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 字段名 [not] like ''[escape '']; #使用正则表达式查询 select 目标表达式1, 目标表达式2, ... , 目标表达式n from 表名 where 字段名 [not] [regexp | rlike] ; # 限制查询结果数目 limit 行数 offset 位置偏移数; 3、分组聚合查询 3.1、使用聚合函数 group by 字段列表 having ; 4、连接查询 4.1、交叉查询（笛卡尔积）:用得极少 select * from tb_name1 cross join tb_name2; 或 select * from tb_name1, tb_name2; 4.2、内连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 [inner] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1, table2 where 连接条件 [and 过滤条件]; 4.2.1、等值于非等值连接 [.] [.]; 4.2.2、自连接 使用自连接时，需要指定多个不同的别名，查询字段都有别名来限定 4.2.3、自然连接 两张表中的字段名都相同才可以使用，否则放回笛卡尔积结果 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 natural join table2 [as] 别名2; 4.3、外连接 # 左外连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 left [outer] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; # 右外连接 select 目标表达式1, 目标表达式2, ... , 目标表达式n from table1 [as] 别名1 right [outer] join table2 [as] 别名2 on 连接条件 [where 过滤条件]; 5、子查询 子查询关键字：in, any, all, [not]exists, 必要时为表名加上别名 6、联合查询 select -from-where union [all] select -from-where [...union [all] select -from-where] 多个表查询联合起来，不使用all关键字，执行的时候去重，返回的行都是唯一的，使用all则不去重。 五、数据更新 1、插入数据 1.1、插入一条或多条 insert into table(字段名列表) values(值列表1), [,值列表2], ... ,[值列表n]; replace into table(字段名列表) values(值列表1), [,值列表2], ... ,[值列表n]; 1.2、插入查询结果 insert into table1(字段名列表) select (字段名列表) from table2 where(conditions); 2、修改数据记录 update table set 字段名1=值1, 字段名2=值2, ... , 字段名n=值n [where ]; 3、删除数据记录 delete from table [where]; truncate [table] tb_name; 六、索引 1、什么时候需要创建索引 a.主键自动建立唯一索引 b.频繁作为查询条件的字段应该创建索引 c.查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找 d.查询中统计或者分组的字段； 2、什么时候不需要创建索引 a.频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件 b.where条件里用不到的字段，不创建索引； c.表记录太少，不需要创建索引； d.经常增删改的表； e.数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。 3、索引的分类： a.普通索引：最基本的索引，它没有任何限制 b.唯一索引：索引列的值必须唯一，且不能为空，如果是组合索引，则列值的组合必须唯一。 c.主键索引：特殊的索引，唯一的标识一条记录，不能为空，一般用primary key来约束。 d.联合索引：在多个字段上建立索引，能够加速查询到速度 1、查看数据表上的索引 show {index | indexes | keys} {fron | in } tb_name [{from | in } db_name]; 2、创建索引 2.1、建表时创建 create table(字段名, 字段类型...) [constrint index_name] [unique] [index | key] [index_name](字段列名[长度]) [asc | aesc]; 2.2、使用create index create [unique] index index_name on tb_name(字段名[(长度)] [asc | desc] , ...); 2.3、使用alter table alter table tb_name add [unique | fulltext] [index|key] index_name(字段名[(长度)][asc|desc],...) 3、删除索引 drop index index_name on tb_name; alter table tb_name drop index index_name; 七、视图 1、创建视图 create [or replace] view view_name[(column_list)] as select_statement [with [cascaded | local] check option]; 2、删除视图 drop view [if exists] view_name[,view_name]...; 3、修改视图 alter view view_name [(column_list)] as select_statement [with [cascaded | local] check option]; 4、查看视图定义 show create view view_name\\G 八、触发器 1、创建触发器 create trigger trigger_name trigger_time(before|after) trigger_event(insert|update|delete) on tb_name for each row trigger_body; # 查看已有的触发器 show triggers [{from | in} db_name]; 2、删除触发器 drop trigger [if exists] [schema_name.]trigger_name; 3、使用触发器 在insert触发器中可以引用名为new的虚拟表来访问被插入的行 在delete触发器中可以引用名为old的虚拟表来访问被删除的行 在delete触发器中可以引用名为new的虚拟表来访问更新后的值 在delete触发器中可以引用名为old的虚拟表来访问更新前的值 例子： create trigger tg1 after update on tb_name1 for each row set new.col1 = old.col2; 九、事件(临时触发器) 1、创建事件 create event [if not exists] event_name on schedule 时间调度 [enable|disable|disable on slave] do event_body; 时间调度语法格式： at timestamp [+ interval interval]... | every interval [starts timestamp [+ interval interval]...] [ends timestamp [+ interval interval]...] interval语法格式 quantity {year | quarter | month | day | hour | minute | week | second | year_month | day_hour | day_minute| day_second | hour_minute | hour_second | minute_second} 例子： 每个月向表tb_1插入一条数据，该事件开始于下个月并且结束于2019年12月31日。 首先改变结束符：delimiter $$ create event if not exists event_insert on schedule every 1 month starts curdate() + interval 1 month ends '2019-12-31' do begin if year(curdate()) 2、修改事件 alter event event_name [on schedule 时间调度] [rename to new_name] [enable | disable | disable on slave] [do event_body]; 3、删除事件 drop event [if exists] event_name; 十、存储过程和存储函数 1、存储过程 1.1、创建存储过程 create procedure sp_name ([proc_parameter[,...]]) [characteristic...]routine_body 其中proc_parameter格式为 [in | out | inout]param_name type 分别对应输入、输出和输入/输出参数 其中routine_body为存储过程主体： 也称存储过程体，其中包含了在过程调用的时候必须执行的sql语句，这个部分以关键字begin开始，以关键字end结束。如存储过程体中只有一条sql语句，可以省略begin-end标志，另外begin-end可以嵌套。 1.2、存储过程体 1.2.1、局部变量 声明： declare var_name [,...] type [defautl value] ps:局部变量不同意用户变量，区别：局部变量声明时，在其前面没有使用“@”符号，并且它只能在声明它的begin-end语句块中使用，而用户变量前面使用“@”符号，存在整个会话中。 1.2.2、赋值 set var_name = expr[, var_name = expr]... 或 select 字段名 into var_name[,...] 查询源及条件; 1.2.3、流程控制语句 条件 if search_condition then statement_list [elseif search_condition then statement_list]... [else statement_list] end if; 或 case case_vale when when_value then statement_list [when when_value then statement_list] [else statement_list] end case; 或 case when search_condition then statement_list [when search_condition then statement_list] [else statement_list] end case; 循环 [begin_label:]while search_condition do statement_list end while[end_label]; 或 [begin_label:]repeat statement_list until search_condition end repeat[end_label]; 或 [begin_label:]loop statement_list end loop[end_label]; 1.2.4、游标 # 声明游标 declare cursor_name cursor for select_statement; # select_statement为一条select语句注意不能有into子句。 # 打开游标 open cursor_name; # 读取游标 fetch cursor_name into var_name[,var_name]...; # 关闭游标 close cursor_name; # 例子:统计行数 delimiter $$ create procedure sp_sum(out rows int) begin declare sno char; declare found boolean default true; declare cur cursor for select studentNo from tb_students; declare continue handler for not found set found = false; set rows = 0; open cur; fetch cur into sno; while found do set rows = rows +1; fetch cur into sno; end while; close cur; end$$ 1.3、调用存储过程 call sp_name([parameter[,...]]); call sp_name[()]; 1.4、删除存储过程 drop procedure [if exists] sp_name; 2、存储函数 2.1、与存储过程的区别 # 存储函数不能有输出参数，因为存储函数本身就是输出参数，而存储过程可以有输出参数 # 可以直接对存储函数进行调用，不需要使用call # 存储函数必须包含一条return语句，而这条语句不允许包含于存储过程中 2.1、创建存储函数 create function sp_name ([func_parameter[,...]]) returns type routine_body # 例子：根据给定的学号返回学生性别，如果没有则返回“没有该学生” delimiter $$ create function fn_student(sno char(10)) returns char(2) begin declare ssex char(2); select sex into ssex from student where studentNo = sno; if ssex is null then return (select \"没有该学生\"); else if ssex=\"女\" then return (select \"女\"); else return (select \"男\"); end if; end$$ 2.2、调用存储函数 select sp_name([func_parameter[,...]]); 2.3、删除存储函数 drop function [if exists] sp_name; 十一、访问控制与安全管理 1、用户账号与管理 1.1、创建用户账号 create user user_specification [,user_specification]...; 其中user_specification格式： user [indentified by [password] 'password' | identified with 指定认证的插件名称 [as 'auth_string']]; # 例子： create user 'zhangsan@localhost' identified by '123','lisi@localhost' identified by password 'password(字符串)返回的散列值'; 1.2、删除用户 drop user user_name [,user_name]...; 1.3、修改用户账号 rename user old_name to new_name [,old_name to new_name]...; 1.4、修改用户密码 set password [for user] = {password('new_password') | 'encryted password(表示已被password加密的口令值)' } # 如果不加for 则表示给当前用户改密码 2、账号权限管理 2.1、权限的授予 grant priv_type [(column_list)] [,priv_type[(column_list)]]... on [object_type] priv_level to user_specification [,user_specifition]... [require {none|ssl_option[[and]ssl_option]...}] [with with_option...] # priv_type 如：select、update、delete # 其中object_type格式为： table | function | procedure # priv_level格式为： * | *.* | db_name.tb_name | tb_name | db_name.routine_name # user_specifition格式同上面 说明该语句同样可以用来创建用户 # with_option格式为： grant option | max_queries_per_hour count #每小时查询数据库的次数 | max_updates_per_hour count #每小时可以修改数据库的次数 | max_connections_per_hour count #每小时可以连接数据库的次数 | max_user_connections count #同时连接数据库的最大用户数 例子： grant select(studentNo, studentName) on db_school.tb_student to 'lisi@localhost' identifie by '123'; grant all on *.* to 'zhangsan@loclhost' identified by '123'; grant create user on *.* to 'zhangsan@loclhost' identified by '123'; 2.2、权限的转移与限制 2.2.1、转移 with 子句指定为with grant option时，表示to 子句中所指定的所以用户都具有把自己所拥有的权限授予其他用户。 例子： grant select, update on db_school.tb_student to 'lisi@localhost' identified by '123' with grant option; 2.2.2、限制 with子句后面跟关键字 例子： grant delete on db_school.* to 'zhangsan@localhost' identified by '123' with MAX_QUERIES_PER_HOUR 1; 2.3、权限的撤销 # 回收某些特定的权限 revoke priv_type [(column_list)] [,priv_type[(column_list)]]... on [object_type] priv_level form user [,user]...; 或 # 回收特定用户的所有权限 revoke all privileges, grant option form user [,user]; 十二、备份与恢复 1、使用sql语句备份和恢复表数据 1.1、select into ... outfile语句导出备份 select * into outfile 'file_name ' [character set charset_name ] export_options | into dumpfile 'file_name'; # export_options格式： [fields [terminated by 'string'] [[optionally] enclosed by 'char'] [escaped by 'char'] ] [lines terminated by 'string'] 1.2、load data ...infile语句导入恢复 load data [low_priority | concurrent] [local] infile 'file_name.txt' [replace | ignore] into table tb_name [fields [terminated by 'string'] [[optionally] enclosed by 'char'] [escaped by 'char'] ] [lines [starting by 'string'] [terminated by 'string'] ] [IGNORE number LINES] [(col_name_or_user_var,...)] [set col_name = expr, ...]] 例子： # 导出 select * from db_school.tb_student into outfile 'C:\\BACKUP\\backupfiel.txt' fields terminated by ','optionally enclosed by '\"' lines terminated by '?'; # 导出 load data infile 'C:\\BACKUP\\backupfiel.txt' into table db_school.tb_student_copy fields terminated by ',' optionally enclosed by '\"' lines terminated by '?' 2、使用MySQL客服端实用程序备份和恢复数据 2.1、备份表 # 备份数据表 mysqldump [option] database [tables] > filename; # 备份数据库 mysqldump [option] database --database [option] DB1 [DB2 DB3...] > filename; # 备份整个数据库系统 msyqldump [option] --all-database [option] > fielname; # 例子： mysqldump -hlocalhost -uroot -p123 db_school.tb_table > c:\\backup\\file.sql; msyqldump -hlocalhost -uroot -p123 --database db_school > c:\\backup\\data.sql; msyqldump -uroot -p123 --all-database > c:\\backup\\alldata.sql; 2.2、使用mysql命令恢复数据 mysql -uroot -p123 tb_student 3、二进制日志文件的使用 3.1、查看二进制日志文件 msyqlbinlog [option] log_file... [> c:\\backup\\bin_log000001.txt]; 3.2、使用二进制文件恢复数据 msyqlbinlog [option] log_file... | msyql [option] # 例子 msyqlbinlog bin_log0001 | mysql -uroot -p123; 3.3、删除二进制日志文件 # 清除所有日志文件 reset master; # 删除指定的日志文件 purge {master | binary| logs to 'log_name': #删除某个时间之前的所有日志文件 purge {master | binary| logs before 'date'; 十三、MySQL数据库的应用编程 1、使用PHP进行MySQL数据库应用编程 1.1、mysql连接 # 非持久连接 mysql_connect([servername[, username[,password]]]); # 持久连接 mysql_pconnect([servername[, username[,password]]]); ps：如果msyql函数成功执行后连接成功，函数mysql_errno()和mysql_error会分别返回数值0和空字符串。 1.2、选择数据库 msyql_select_db(database[,connection]) 1.3、执行数据库操作 msyql_query(query[,connection]) ps:sql语句是以字符串的形式提交，且不以分号作为结束符。 1.4、数据结果读取 mysql_fetch_array(data[,array_type]) # array_type有： MYSQL_NUM:表示数值数组，功能与mysql_fetch_row(data)一样 MYSQL_ASSOC:表示关联数组，功能与mysql_fetch_assoc(data)一样 MYSQL_BOTH:表示同时产生关联数组和数字数组 mysql_fetch_row(data) msyql_fetch_assoc(data) 1.5、读取结果数目 mysql_num_rows(data) 1.6、读取指定记录号的记录 # 在结果集中随意移动记录的指针，也就是将记录指针直接指向某个记录，其中0指示结果集中的第一条记录。 mysql_data_seek(data,row) 1.7、关闭数据库 msyql_close([content]) # 例子： ’); mysql_select_db('db01',$con) or die('数据库选择失败！‘); mysql_query(\"set names 'gbk'\"); $sql = \"select studentname from tb_student\"; $sql = $sql.\"where studentNo = 200120\"; $result = mysql_query($sql, $con); if ($result){ echo \"学生查询成功！\" $array = mysql_fetch_array($result,MYSQL_NUM); if ($array){ echo \"读取到学生信息！\"; echo \"所查询的学生姓名为：\".$array[0]; } else echo \"没有查询到学生信息！\"; } else echo \"学生信息查询失败！\"; ?> "},"Database/MySQL/数据库三大范式.html":{"url":"Database/MySQL/数据库三大范式.html","title":"数据库三大范式","keywords":"","body":"数据库三大范式 第一范式（1NF）（原子不可分性） 所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项， 而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。 在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。 不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。 第二范式（2NF）（消除非主键部分依赖） 在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。 例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。 在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复， 无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加） 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在， 那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列， 以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。 第三范式（3NF）（消除传递依赖） 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。 简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。 那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。 简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。 范式应用实例 第一范式（1NF） 数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。 因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。 首先我们确定一下要设计的内容包括那些。学号、学生姓名、年龄、性别、课程名称、课程学分、系别、学科成绩，系办地址、系办电话等信息。 为了简单我们暂时只考虑这些字段信息。我们对于这些信息，所关心的问题有如下几个方面。 学生有那些基本信息？ 学生选了那些课，成绩是什么？ 每个课的学分是多少？ 学生属于那个系，系的基本信息是什么？ 第二范式（2NF） 首先我们考虑，把所有这些信息放到一个表中（学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话）下面存在如下的依赖关系。 (学号, 课程名称) → (姓名, 年龄, 成绩, 学分) 问题分析 姓名和年龄不依于课程，即不完全依赖于主属性因此不满足第二范式的要求，会产生如下问题： 数据冗余：同一门课程由n个学生选修，\"学分\"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。 更新异常： 1）若调整了某门课程的学分，数据表中所有行的\"学分\"值都要更新，否则会出现同一门课程学分不同的情况。 2）假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有\"学号\"关键字，课程名称和学分也无法记录入数据库。 删除异常 ：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。 解决方案 把选课关系表SelectCourse改为如下三个表： 学生：Student（学号，姓名，年龄，性别，系别，系办地址、系办电话）； 课程：Course（课程名称,学分）； 选课关系：SelectCourse（学号，课程名称，成绩）。 第三范式（3NF） 接着看上面的学生表Student（学号，姓名，年龄，性别，系别，系办地址、系办电话），关键字为单一关键字\"学号\"，因为存在如下决定关系： （学号）→ （姓名，年龄，性别，系别，系办地址、系办电话 但是还存在下面的决定关系： （学号） → (系别）→（系办地点，系办电话） 即存在非关键字段\"系办地点\"、\"系办电话\"对关键字段\"学号\"的传递函数依赖。 它也会存在数据冗余、更新异常、插入异常和删除异常的情况。 根据第三范式把学生关系表分为如下两个表就可以满足第三范式了： 学生：（学号，姓名，年龄，性别，系别）； 系别：（系别，系办地址、系办电话）。 上面的数据库表就是符合I，Ⅱ，Ⅲ范式的，消除了数据冗余、更新异常、插入异常和删除异常。 "},"Database/MySQL/主从复制.html":{"url":"Database/MySQL/主从复制.html","title":"MySQL主从复制","keywords":"","body":"datetime:2019/9/5 10:01 author:nzb MySQL的主从复制 主从复制 两台数据库服务器(Linux服务器), IP分别为192.168.1.110和192.168.1.111,服务器上装上MySQL(版本为5.7) 打开主数据库配置文件：vim /etc/mysql/my.cnf, 加入以下内容后重启MySQL服务 [mysqld] log-bin=mysql-bin server-id=1 （默认为1，总之两台服务器要设置为不同的ID） 打开从数据库配置文件：vim /etc/mysql/my.cnf, 加入相同内容后将其中的 server-id 设为2（默认为1）然后重启MySQL服务 设192.168.1.110为主数据库, 在数据库中加入一个从服务器可以登录的用户, 语句如下： GRANT ALL PRIVILEGES ON *.* TO 'user'@'192.168.1.111' IDENTIFIED BY 'password' WITH GRANT OPTION;(或 GRANT REPLICATION SLAVE ON *.* TO 'username'@'192.168.1.111' IDENTIFIED BY 'password' WITH GRANT OPTION;) FLUSH PRIVILEGES; 完成后, 在192.168.1.111服务器上执行：mysql -h 192.168.1.110 -u用户名 -p密码, 查看连接是否成功 最后在主数据库中执行以下语句, 查询master状态：show master status; 可以看到以上结果，这儿只需要看 File 和 Position，其它的两个分别是白名单和黑名单，意思为同步哪几个数据库和不同步哪几个数据库，可自行根据需求进行设置。记录了前两个字段后，在从库上执行以下语句： CHANGE MASTER TO MASTER_HOST='192.168.1.110', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_PORT='3306', MASTER_LOG_FILE='mysql-bin.000020', MASTER_LOG_POS=1441; 执行完成后, 在从数据库上继续执行以下语句： start slava; show slave status\\G; 这样，查看从服务器的状态，如果状态中的用红线标出来两个参数的值都为YES，那证明配置已经成功，否则可以检查一下具体问题出现在什么地方。 这样，就算配置完成了。在主库中新建数据库，新建一张表，插几条数据，到从库上查询一下看是否已经同步过来。 PS:如果失败，可以从以下几个方面去排查问题：　　 1.首先试一下主从服务器相互之间是否 PING 得通 2.试一下远程连接是否正确，如果连不上，则有可能是网卡不一致、防火墙没有放行 3306 端口 3.server-id 是否配成一致 4.bin-log 的信息是否正确 主主复制 上面说了主从复制的配置方法，现在接着上面的配置继续，然后实现双主复制，让以上的两个服务器互为主从。 在主服务器上配置 /etc/mysql/my.cnf 文件，配置如下,配置之后重启MYSQL服务: auto_increment_increment=2 #步进值auto_imcrement。一般有n台主MySQL就填n auto_increment_offset=1 #起始值。一般填第n台主MySQL。此时为第一台主MySQL binlog-ignore=mysql #忽略mysql库【一般都不写】 binlog-ignore=information_schema #忽略information_schema库【一般都不写】 在从服务器上配置 /etc/mysql/my.cnf 文件，配置如下, 配置之后重启MYSQL服务: auto_increment_increment=2 #步进值auto_imcrement。一般有n台主MySQL就填n auto_increment_offset=2 #起始值。一般填第n台主MySQL。此时为第二台主MySQL binlog-ignore=mysql #忽略mysql库【一般都不写】 binlog-ignore=information_schema #忽略information_schema库【一般都不写】 在从服务器上添加一个主服务器可以访问的用户，命令如下： GRANT REPLICATION SLAVE ON *.* TO 'user'@'192.168.1.110' IDENTIFIED BY 'password' with grant option ; FLUSH PRIVILEGES 建好之后在192.168.1.110服务器上访问从数据库, 测试是否成功，如果可以连上，则进行下一步，连不上的话，参考上面进行问题排查。 因为要互为主从，所以现在从服务器也是master ，所以也要查看一下状态：show master status; 查到相应的信息后，在原来的主服务器上执行以下命令（因为现在它现在也是另一台的从服务器） CHANGE MASTER TO MASTER_HOST='192.168.1.111', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_LOG_FILE='mysql-bin.000021', MASTER_LOG_POS=1457; 执行完毕后，在原主库上继续执行如下语句： start slave; show slave status\\G; 同上，如果出现如下画面，则证明配置成功。 在两台服务器的MYSQL中分别进行一些建库、建表、插入、更新等操作，看一下另一台会不会进行同步，如果可以则证明主主配置成功，否则还是上面的排错方法，进行错误排查。 双主多从 现在已经是双主配置了，但是如果要进行读写分离，那么我们要再增加N台从库，如何做呢？非常简单，按如下操作即可： 新增加一台数据库服务器，192.168.1.112，数据库配置均与前两台相同 确定一下要将哪一台当作自己的主服务器，我们姑且设 192.168.1.110 为主服务器 在第三台服务器中编辑 /etc/mysql/my.cnf ，将其 server-id 设为 3（保证与前两个不一样即可），然后重启MYSQL服务 在主服务器中，增加一条用户记录，用于当前服务器对主库对的连接，代码如下： GRANT REPLICATION SLAVE ON *.* TO 'user'@'192.168.1.112' IDENTIFIED BY 'password'; FLUSH PRIVILEGES; 在 192.168.216.130 服务器上测试是否可以连接到主库: mysql -h 192.168.1.110 -u用户名 -p密码, 如果可以连上，则可以进行下一步，否则根据上面的提示排查问题。 在 192.168.216.130 服务器上查询 master 当前状态: show master status; 看到相关信息后，我们执行如下操作： CHANGE MASTER TO MASTER_HOST='192.168.1.110', MASTER_USER='user', MASTER_PASSWORD='password', MASTER_LOG_FILE='mysql-bin.000020', MASTER_LOG_POS=1441; 执行完毕后，在原主库上继续执行如下语句： start slave; show slave status\\G; 同上，如果出现如下画面，则证明配置成功。如果此处有问题，参考上面所提排查并解决问题。 此时我们在 192.168.1.110 上建库、建表、插入、更新、删除数据，在 另外两台上分别进行查看，发现均已经同步。 但是如果我们在 192.168.1.111 上做相应的操作，则发现只有 192.168.1.110 上进行了相应的同步，而 192.168.1.112 上的数据并未同步。 这是为什么呢？因为我们设置的主库是 192.168.1.110，所以在 192.168.1.111 进行数据操作的时候并未同步，这显然不符合我们的需求， 那么，我们要怎么修改呢？非常简单，在互为主从的两台服务器的配置文件中均加入以下语句：log-slave-updates=on 加上后将两台服务器的MYSQL重启，然后再进行测试，发现数据已经可以同步了。如果要再多加一些从服务器，和以上类似，现在我们做的是双主一从，我们可以再加N台从服务器，配置也是一样的。 至此，MYSQL主从复制、主主复制、双主多从配置我们均已经搞定！ Docker配置MySQL主从复制 下面还是基于Docker来演示如何配置MySQL主从复制。我们事先准备好MySQL的配置文件以及保存MySQL数据和运行日志的目录，然后通过Docker的数据卷映射来指定容器的配置、数据和日志文件的位置。 root └── mysql ├── master │ ├── conf | └── data └── slave-1 | ├── conf | └── data └── slave-2 | ├── conf | └── data └── slave-3 ├── conf └── data MySQL的配置文件（master和slave的配置文件需要不同的server-id）。 [mysqld] pid-file=/var/run/mysqld/mysqld.pid socket=/var/run/mysqld/mysqld.sock datadir=/var/lib/mysql log-error=/var/log/mysql/error.log server-id=1 log-bin=/var/log/mysql/mysql-bin.log expire_logs_days=30 max_binlog_size=256M symbolic-links=0 # slow_query_log=ON # slow_query_log_file=/var/log/mysql/slow.log # long_query_time=1 创建和配置master。 docker run -d -p 3306:3306 --name mysql-master \\ -v /root/mysql/master/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/master/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker exec -it mysql-master /bin/bash mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 1 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> grant replication slave on *.* to 'slave'@'%' identified by 'iamslave'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) mysql> show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000003 | 590 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) mysql> quit Bye exit 上面创建Docker容器时使用的-v参数（--volume）表示映射数据卷，冒号前是宿主机的目录，冒号后是容器中的目录，这样相当于将宿主机中的目录挂载到了容器中。 创建和配置slave。 docker run -d -p 3308:3306 --name mysql-slave-1 \\ -v /root/mysql/slave-1/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-1/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3309:3306 --name mysql-slave-2 \\ -v /root/mysql/slave-2/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-2/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker run -d -p 3310:3306 --name mysql-slave-3 \\ -v /root/mysql/slave-3/conf:/etc/mysql/mysql.conf.d \\ -v /root/mysql/slave-3/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ --link mysql-master:mysql-master mysql:5.7 docker exec -it mysql-slave-1 /bin/bash mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.23-log MySQL Community Server (GPL) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> reset slave; Query OK, 0 rows affected (0.02 sec) mysql> change master to master_host='mysql-master', master_user='slave', master_password='iamslave', master_log_file='mysql-bin.000003', master_log_pos=590; Query OK, 0 rows affected, 2 warnings (0.03 sec) mysql> start slave; Query OK, 0 rows affected (0.01 sec) mysql> show slave status\\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: mysql57 Master_User: slave Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 590 Relay_Log_File: f352f05eb9d0-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 590 Relay_Log_Space: 534 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0 Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 1 Master_UUID: 30c38043-ada1-11e8-8fa1-0242ac110002 Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) mysql> quit Bye exit 接下来可以如法炮制配置出slave2和slave3，这样就可以搭建起一个“一主带三从”的主从复制环境。上面创建创建容器时使用的--link参数用来配置容器在网络上的主机名（网络地址别名）。 配置好主从复制后，写数据的操作应该master上执行，而读数据的操作应该在slave上完成。为此，在Django项目中需要配置DATABASE_ROUTERS并通过自定义的主从复制路由类来实现读写分离操作，如下所示： DATABASE_ROUTERS = [ # 此处省略其他配置 'common.routers.MasterSlaveRouter', ] class MasterSlaveRouter(object): \"\"\"主从复制路由\"\"\" @staticmethod def db_for_read(model, **hints): \"\"\" Attempts to read auth models go to auth_db. \"\"\" return random.choice(('slave1', 'slave2', 'slave3')) @staticmethod def db_for_write(model, **hints): \"\"\" Attempts to write auth models go to auth_db. \"\"\" return 'default' @staticmethod def allow_relation(obj1, obj2, **hints): \"\"\" Allow relations if a model in the auth app is involved. \"\"\" return None @staticmethod def allow_migrate(db, app_label, model_name=None, **hints): \"\"\" Make sure the auth app only appears in the 'auth_db' database. \"\"\" return True 上面的内容参考了Django官方文档的DATABASE_ROUTERS配置，对代码进行了适当的调整。 "},"Database/NoSQL/01-NoSql入门.html":{"url":"Database/NoSQL/01-NoSql入门.html","title":"NoSql入门","keywords":"","body":"datetime:2019/10/29 16:41 author:nzb NoSQL入门 NoSQL概述 如今，大多数的计算机系统（包括服务器、PC、移动设备等）都会产生庞大的数据量。其实，早在2012年的时候，全世界每天产生的数据量就达到了2.5EB（艾字节，$$1EB\\approx10^{18}B$$）。这些数据有很大一部分是由关系型数据库来存储和管理的。 早在1970年，E.F.Codd发表了论述关系型数据库的著名论文“A relational model of data for large shared data banks”，这篇文章奠定了关系型数据库的基础并在接下来的数十年时间内产生了深远的影响。实践证明，关系型数据库是实现数据持久化最为重要的方式，它也是大多数应用在选择持久化方案时的首选技术。 NoSQL是一项全新的数据库革命性运动，虽然它的历史可以追溯到1998年，但是NoSQL真正深入人心并得到广泛的应用是在进入大数据时候以后，业界普遍认为NoSQL是更适合大数据存储的技术方案，这才使得NoSQL的发展达到了前所未有的高度。2012年《纽约时报》的一篇专栏中写到，大数据时代已经降临，在商业、经济及其他领域中，决策将不再基于经验和直觉而是基于数据和分析而作出。事实上，在天文学、气象学、基因组学、生物学、社会学、互联网搜索引擎、金融、医疗、社交网络、电子商务等诸多领域，由于数据过于密集和庞大，在数据的分析和处理上也遇到了前所未有的限制和阻碍，这一切都使得对大数据处理技术的研究被提升到了新的高度，也使得各种NoSQL的技术方案进入到了公众的视野。 NoSQL数据库按照其存储类型可以大致分为以下几类： 类型 部分代表 特点 列族数据库 HBaseCassandraHypertable 顾名思义是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的I/O优势，适合于批量数据处理和即时查询。 文档数据库 MongoDBCouchDBElasticSearch 文档数据库一般用类JSON格式存储数据，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能，但不提供对参照完整性和分布事务的支持。 KV数据库 DynamoDBRedisLevelDB 可以通过key快速查询到其value，有基于内存和基于磁盘两种实现方案。 图数据库 Neo4JFlockDBJanusGraph 使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据。图数据库从设计上，就可以简单快速的检索难以在关系系统中建模的复杂层次结构。 对象数据库 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 说明：想了解更多的NoSQL数据库，可以访问http://nosql-database.org/。 Redis概述 Redis是一种基于键值对的NoSQL数据库，它提供了对多种数据类型（字符串、哈希、列表、集合、有序集合、位图等）的支持，能够满足很多应用场景的需求。Redis将数据放在内存中，因此读写性能是非常惊人的。与此同时，Redis也提供了持久化机制，能够将内存中的数据保存到硬盘上，在发生意外状况时数据也不会丢掉。此外，Redis还支持键过期、地理信息运算、发布订阅、事务、管道、Lua脚本扩展等功能，总而言之，Redis的功能和性能都非常强大，如果项目中要实现高速缓存和消息队列这样的服务，直接交给Redis就可以了。目前，国内外很多著名的企业和商业项目都使用了Redis，包括：Twitter、Github、StackOverflow、新浪微博、百度、优酷土豆、美团、小米、唯品会等。 Redis简介 2008年，一个名为Salvatore Sanfilippo的程序员为他开发的LLOOGG项目定制了专属的数据库（因为之前他无论怎样优化MySQL，系统性能已经无法再提升了），这项工作的成果就是Redis的初始版本。后来他将Redis的代码放到了全球最大的代码托管平台Github，从那以后，Redis引发了大量开发者的好评和关注，继而有数百人参与了Redis的开发和维护，这使得Redis的功能越来越强大和性能越来越好。 Redis是REmote DIctionary Server的缩写，它是一个用ANSI C编写的高性能的key-value存储系统，与其他的key-value存储系统相比，Redis有以下一些特点（也是优点）： Redis的读写性能极高，并且有丰富的特性（发布/订阅、事务、通知等）。 Redis支持数据的持久化（RDB和AOF两种方式），可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis支持多种数据类型，包括：string、hash、list、set，zset、bitmap、hyperloglog等。 Redis支持主从复制（实现读写分析）以及哨兵模式（监控master是否宕机并自动调整配置）。 Redis支持分布式集群，可以很容易的通过水平扩展来提升系统的整体性能。 Redis基于TCP提供的可靠传输服务进行通信，很多编程语言都提供了Redis客户端支持。 Redis的应用场景 高速缓存 - 将不常变化但又经常被访问的热点数据放到Redis数据库中，可以大大降低关系型数据库的压力，从而提升系统的响应性能。 排行榜 - 很多网站都有排行榜功能，利用Redis中的列表和有序集合可以非常方便的构造各种排行榜系统。 商品秒杀/投票点赞 - Redis提供了对计数操作的支持，网站上常见的秒杀、点赞等功能都可以利用Redis的计数器通过+1或-1的操作来实现，从而避免了使用关系型数据的update操作。 分布式锁 - 利用Redis可以跨多台服务器实现分布式锁（类似于线程锁，但是能够被多台机器上的多个线程或进程共享）的功能，用于实现一个阻塞式操作。 消息队列 - 消息队列和高速缓存一样，是一个大型网站不可缺少的基础服务，可以实现业务解耦和非实时业务削峰等特性，这些我们都会在后面的项目中为大家展示。 Redis的安装和配置 可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 wget http://download.redis.io/releases/redis-5.0.4.tar.gz gunzip redis-5.0.4.tar.gz tar -xvf redis-5.0.4.tar cd redis-5.0.4 make && make install 在redis源代码目录下有一个名为redis.conf的配置文件，我们可以先查看一下该文件。 vim redis.conf 配置将Redis服务绑定到指定的IP地址和端口。 配置底层有多少个数据库。 配置Redis的持久化机制 - RDB。 配置Redis的持久化机制 - AOF。 配置访问Redis服务器的验证口令。 配置Redis的主从复制，通过主从复制可以实现读写分离。 配置慢查询。 上面这些内容就是Redis的基本配置，如果你对上面的内容感到困惑也没有关系，先把Redis用起来再回头去推敲这些内容就行了。如果想找一些参考书，《Redis开发与运维》是一本不错的入门读物，而《Redis实战》是不错的进阶读物。 Redis的服务器和客户端 接下来启动Redis服务器，下面的方式将以默认的配置启动Redis服务。 redis-server 如果希望修改Redis的配置（如端口、认证口令、持久化方式等），可以通过下面两种方式。 方式一：通过参数指定认证口令和AOF持久化方式。 redis-server --requirepass 1qaz2wsx --appendonly yes 方式二：通过指定的配置文件来修改Redis的配置。 redis-server /root/redis-5.0.4/redis.conf 下面我们使用第一种方式来启动Redis并将其置于后台运行，将Redis产生的输出重定向到名为redis.log的文件中。 redis-server --requirepass 1qaz2wsx > redis.log & 可以通过ps或者netstat来检查Redis服务器是否启动成功。 ps -ef | grep redis-server netstat -nap | grep redis-server 接下来，我们尝试用Redis客户端去连接服务器。 redis-cli 127.0.0.1:6379> auth 1qaz2wsx OK 127.0.0.1:6379> ping PONG 127.0.0.1:6379> Redis有着非常丰富的数据类型，也有很多的命令来操作这些数据，具体的内容可以查看Redis命令参考，在这个网站上，除了Redis的命令参考，还有Redis的详细文档，其中包括了通知、事务、主从复制、持久化、哨兵、集群等内容。 说明：上面的插图来自付磊和张益军先生编著的《Redis开发与运维》一书。 127.0.0.1:6379> set username admin OK 127.0.0.1:6379> get username \"admin\" 127.0.0.1:6379> set password \"123456\" ex 300 OK 127.0.0.1:6379> get password \"123456\" 127.0.0.1:6379> ttl username (integer) -1 127.0.0.1:6379> ttl password (integer) 286 127.0.0.1:6379> hset stu1 name hao (integer) 0 127.0.0.1:6379> hset stu1 age 38 (integer) 1 127.0.0.1:6379> hset stu1 gender male (integer) 1 127.0.0.1:6379> hgetall stu1 1) \"name\" 2) \"hao\" 3) \"age\" 4) \"38\" 5) \"gender\" 6) \"male\" 127.0.0.1:6379> hvals stu1 1) \"hao\" 2) \"38\" 3) \"male\" 127.0.0.1:6379> hmset stu2 name wang age 18 gender female tel 13566778899 OK 127.0.0.1:6379> hgetall stu2 1) \"name\" 2) \"wang\" 3) \"age\" 4) \"18\" 5) \"gender\" 6) \"female\" 7) \"tel\" 8) \"13566778899\" 127.0.0.1:6379> lpush nums 1 2 3 4 5 (integer) 5 127.0.0.1:6379> lrange nums 0 -1 1) \"5\" 2) \"4\" 3) \"3\" 4) \"2\" 5) \"1\" 127.0.0.1:6379> lpop nums \"5\" 127.0.0.1:6379> lpop nums \"4\" 127.0.0.1:6379> rpop nums \"1\" 127.0.0.1:6379> rpop nums \"2\" 127.0.0.1:6379> sadd fruits apple banana orange apple grape grape (integer) 4 127.0.0.1:6379> scard fruits (integer) 4 127.0.0.1:6379> smembers fruits 1) \"grape\" 2) \"orange\" 3) \"banana\" 4) \"apple\" 127.0.0.1:6379> sismember fruits apple (integer) 1 127.0.0.1:6379> sismember fruits durian (integer) 0 127.0.0.1:6379> sadd nums1 1 2 3 4 5 (integer) 5 127.0.0.1:6379> sadd nums2 2 4 6 8 (integer) 4 127.0.0.1:6379> sinter nums1 nums2 1) \"2\" 2) \"4\" 127.0.0.1:6379> sunion nums1 nums2 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" 6) \"6\" 7) \"8\" 127.0.0.1:6379> sdiff nums1 nums2 1) \"1\" 2) \"3\" 3) \"5\" 127.0.0.1:6379> zadd topsinger 5234 zhangxy 1978 chenyx 2235 zhoujl 3520 xuezq (integer) 4 127.0.0.1:6379> zrange topsinger 0 -1 withscores 1) \"chenyx\" 2) \"1978\" 3) \"zhoujl\" 4) \"2235\" 5) \"xuezq\" 6) \"3520\" 7) \"zhangxy\" 8) \"5234\" 127.0.0.1:6379> zrevrange topsinger 0 -1 1) \"zhangxy\" 2) \"xuezq\" 3) \"zhoujl\" 4) \"chenyx\" 127.0.0.1:6379> geoadd pois 116.39738549206541 39.90862689286386 tiananmen 116.27172936413572 39.99 135172904494 yiheyuan 117.27766503308104 40.65332064313784 gubeishuizhen (integer) 3 127.0.0.1:6379> geodist pois tiananmen gubeishuizhen km \"111.5333\" 127.0.0.1:6379> geodist pois tiananmen yiheyuan km \"14.1230\" 127.0.0.1:6379> georadius pois 116.86499108288572 40.40149669363615 50 km withdist 1) 1) \"gubeishuizhen\" 2) \"44.7408\" 在Python程序中使用Redis 可以使用pip安装redis模块。redis模块的核心是名为Redis的类，该类的对象代表一个Redis客户端，通过该客户端可以向Redis服务器发送命令并获取执行的结果。上面我们在Redis客户端中使用的命令基本上就是Redis对象可以接收的消息，所以如果了解了Redis的命令就可以在Python中玩转Redis。 pip3 install redis python3 >>> import redis >>> client = redis.Redis(host='1.2.3.4', port=6379, password='1qaz2wsx') >>> client.set('username', 'admin') True >>> client.hset('student', 'name', 'hao') 1 >>> client.hset('student', 'age', 38) 1 >>> client.keys('*') [b'username', b'student'] >>> client.get('username') b'admin' >>> client.hgetall('student') {b'name': b'hao', b'age': b'38'} MongoDB概述 MongoDB简介 MongoDB是2009年问世的一个面向文档的数据库管理系统，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。虽然在划分类别的时候后，MongoDB被认为是NoSQL的产品，但是它更像一个介于关系数据库和非关系数据库之间的产品，在非关系数据库中它功能最丰富，最像关系数据库。 MongoDB将数据存储为一个文档，一个文档由一系列的“键值对”组成，其文档类似于JSON对象，但是MongoDB对JSON进行了二进制处理（能够更快的定位key和value），因此其文档的存储格式称为BSON。关于JSON和BSON的差别大家可以看看MongoDB官方网站的文章《JSON and BSON》。 目前，MongoDB已经提供了对Windows、MacOS、Linux、Solaris等多个平台的支持，而且也提供了多种开发语言的驱动程序，Python当然是其中之一。 MongoDB的安装和配置 可以从MongoDB的官方下载链接下载MongoDB，官方为Windows系统提供了一个Installer程序，而Linux和MacOS则提供了压缩文件。下面简单说一下Linux系统如何安装和配置MongoDB。 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-3.6.5.tgz gunzip mongodb-linux-x86_64-amazon-3.6.5.tgz mkdir mongodb-3.6.5 tar -xvf mongodb-linux-x86_64-amazon-3.6.5.tar --strip-components 1 -C mongodb-3.6.5/ export PATH=$PATH:~/mongodb-3.6.5/bin mkdir -p /data/db mongod --bind_ip 172.18.61.250 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] MongoDB starting : pid=1163 port=27017 dbpath=/data/db 64-bit host=iZwz97tbgo9lkabnat2lo8Z 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] db version v3.6.5 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] git version: a20ecd3e3a174162052ff99913bc2ca9a839d618 2018-06-03T18:03:28.232+0800 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.0.0-fips29 Mar 2010 ... 2018-06-03T18:03:28.945+0800 I NETWORK [initandlisten] waiting for connections on port 27017 说明：上面的操作中，export命令是设置PATH环境变量，这样可以在任意路径下执行mongod来启动MongoDB服务器。MongoDB默认保存数据的路径是/data/db目录，为此要提前创建该目录。此外，在使用mongod启动MongoDB服务器时，--bind_ip参数用来将服务绑定到指定的IP地址，也可以用--port参数来指定端口，默认端口为27017。 MongoDB基本概念 我们通过与关系型数据库进行对照的方式来说明MongoDB中的一些概念。 SQL MongoDB 解释（SQL/MongoDB） database database 数据库/数据库 table collection 二维表/集合 row document 记录（行）/文档 column field 字段（列）/域 index index 索引/索引 table joins --- 表连接/嵌套文档 primary key primary key 主键/主键（_id字段） 通过Shell操作MongoDB 启动服务器后可以使用交互式环境跟服务器通信，如下所示。 mongo --host 172.18.61.250 MongoDB shell version v3.6.5 connecting to: mongodb://172.18.61.250:27017/ 查看、创建和删除数据库。 > // 显示所有数据库 > show dbs admin 0.000GB config 0.000GB local 0.000GB > // 创建并切换到school数据库 > use school switched to db school > // 删除当前数据库 > db.dropDatabase() { \"ok\" : 1 } > 创建、删除和查看集合。 > // 创建并切换到school数据库 > use school switched to db school > // 创建colleges集合 > db.createCollection('colleges') { \"ok\" : 1 } > // 创建students集合 > db.createCollection('students') { \"ok\" : 1 } > // 查看所有集合 > show collections colleges students > // 删除colleges集合 > db.colleges.drop() true > 说明：在MongoDB中插入文档时如果集合不存在会自动创建集合，所以也可以按照下面的方式通过创建文档来创建集合。 文档的CRUD操作。 > // 向students集合插入文档 > db.students.insert({stuid: 1001, name: '骆昊', age: 38}) WriteResult({ \"nInserted\" : 1 }) > // 向students集合插入文档 > db.students.save({stuid: 1002, name: '王大锤', tel: '13012345678', gender: '男'}) WriteResult({ \"nInserted\" : 1 }) > // 查看所有文档 > db.students.find() { \"_id\" : ObjectId(\"5b13c72e006ad854460ee70b\"), \"stuid\" : 1001, \"name\" : \"骆昊\", \"age\" : 38 } { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } > // 更新stuid为1001的文档 > db.students.update({stuid: 1001}, {'$set': {tel: '13566778899', gender: '男'}}) WriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) > // 插入或更新stuid为1003的文档 > db.students.update({stuid: 1003}, {'$set': {name: '白元芳', tel: '13022223333', gender: '男'}}, upsert=true) WriteResult({ \"nMatched\" : 0, \"nUpserted\" : 1, \"nModified\" : 0, \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\") }) > // 查询所有文档 > db.students.find().pretty() { \"_id\" : ObjectId(\"5b13c72e006ad854460ee70b\"), \"stuid\" : 1001, \"name\" : \"骆昊\", \"age\" : 38, \"gender\" : \"男\", \"tel\" : \"13566778899\" } { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } { \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\"), \"stuid\" : 1003, \"gender\" : \"男\", \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询stuid大于1001的文档 > db.students.find({stuid: {'$gt': 1001}}).pretty() { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } { \"_id\" : ObjectId(\"5b13c92dd185894d7283efab\"), \"stuid\" : 1003, \"gender\" : \"男\", \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询stuid大于1001的文档只显示name和tel字段 > db.students.find({stuid: {'$gt': 1001}}, {_id: 0, name: 1, tel: 1}).pretty() { \"name\" : \"王大锤\", \"tel\" : \"13012345678\" } { \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询name为“骆昊”或者tel为“13022223333”的文档 > db.students.find({'$or': [{name: '骆昊'}, {tel: '13022223333'}]}, {_id: 0, name: 1, tel: 1}).pretty() { \"name\" : \"骆昊\", \"tel\" : \"13566778899\" } { \"name\" : \"白元芳\", \"tel\" : \"13022223333\" } > // 查询学生文档跳过第1条文档只查1条文档 > db.students.find().skip(1).limit(1).pretty() { \"_id\" : ObjectId(\"5b13c790006ad854460ee70c\"), \"stuid\" : 1002, \"name\" : \"王大锤\", \"tel\" : \"13012345678\", \"gender\" : \"男\" } > // 对查询结果进行排序(1表示升序，-1表示降序) > db.students.find({}, {_id: 0, stuid: 1, name: 1}).sort({stuid: -1}) { \"stuid\" : 1003, \"name\" : \"白元芳\" } { \"stuid\" : 1002, \"name\" : \"王大锤\" } { \"stuid\" : 1001, \"name\" : \"骆昊\" } > // 在指定的一个或多个字段上创建索引 > db.students.ensureIndex({name: 1}) { \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1 } > 使用MongoDB可以非常方便的配置数据复制，通过冗余数据来实现数据的高可用以及灾难恢复，也可以通过数据分片来应对数据量迅速增长的需求。关于MongoDB更多的操作可以查阅官方文档 ，同时推荐大家阅读Kristina Chodorow写的《MongoDB权威指南》。 在Python程序中操作MongoDB 可以通过pip安装pymongo来实现对MongoDB的操作。 pip3 install pymongo python3 >>> from pymongo import MongoClient >>> client = MongoClient('mongodb://127.0.0.1:27017') >>> db = client.school >>> for student in db.students.find(): ... print('学号:', student['stuid']) ... print('姓名:', student['name']) ... print('电话:', student['tel']) ... 学号: 1001.0 姓名: 骆昊 电话: 13566778899 学号: 1002.0 姓名: 王大锤 电话: 13012345678 学号: 1003.0 姓名: 白元芳 电话: 13022223333 >>> db.students.find().count() 3 >>> db.students.remove() {'n': 3, 'ok': 1.0} >>> db.students.find().count() 0 >>> coll = db.students >>> from pymongo import ASCENDING >>> coll.create_index([('name', ASCENDING)], unique=True) 'name_1' >>> coll.insert_one({'stuid': int(1001), 'name': '骆昊', 'gender': True}) >>> coll.insert_many([{'stuid': int(1002), 'name': '王大锤', 'gender': False}, {'stuid': int(1003), 'name': '白元芳', 'gender': True}]) >>> for student in coll.find({'gender': True}): ... print('学号:', student['stuid']) ... print('姓名:', student['name']) ... print('性别:', '男' if student['gender'] else '女') ... 学号: 1001 姓名: 骆昊 性别: 男 学号: 1003 姓名: 白元芳 性别: 男 >>> 关于PyMongo更多的知识可以通过它的官方文档进行了解，也可以使用MongoEngine这样的库来简化Python程序对MongoDB的操作，除此之外，还有以异步I/O方式访问MongoDB的三方库motor都是不错的选择。 "},"Database/NoSQL/02-Redis安装与配置文件.html":{"url":"Database/NoSQL/02-Redis安装与配置文件.html","title":"Redis安装与配置文件","keywords":"","body":"datetime:2019/10/30 16:26 author:nzb Redis安装与配置文件 安装 Linux安装 可以使用Linux系统的包管理工具（如yum）来安装Redis，也可以通过在Redis的官方网站下载Redis的源代码，解压缩解归档之后通过make工具对源代码进行构建并安装，在更新这篇文档时，Redis官方提供的最新稳定版本是Redis 5.0.4。 wget http://download.redis.io/releases/redis-5.0.4.tar.gz gunzip redis-5.0.4.tar.gz tar -xvf redis-5.0.4.tar cd redis-5.0.4 make && make install Docker安装 搜索镜像 docker search redis 拉取镜像 docker pull redis 创建redis容器 docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/data:/data redis --requirepass \"123456\" --appendonly yes 创建redis容器（指定配置文件） docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/config:/usr/local/redis/conf/redis.conf -v /usr/local/redis/data:/data redis redis-server /usr/local/redis/conf/redis.conf --requirepass \"123456\" --appendonly yes docker run -d --name redis --restart always -p 6379:6379 -v /usr/local/redis/data:/data redis --requirepass \"123456\" --appendonly yes 参数说明： -p 6379:6379　　//容器redis端口6379映射宿主主机6379 --name redis　　//容器名字为redis -v /usr/local/redis/conf:/usr/local/redis/conf/redis.conf//docker镜像redis默认无配置文件，在宿主主机/usr/local/redis/conf下创建redis.conf配置文件，会将宿主机的配置文件复制到docker中(加上这参数会报错) -v /root/redis/redis01/data:/data　　//容器/data映射到宿主机 /usr/local/redis/data下 -d redis 　　//后台模式启动redis redis-server /usr/local/redis/conf/redis.conf//redis将以/usr/local/redis/conf/redis.conf为配置文件启动(加上这参数会报错) --appendonly yes　　//开启redis的AOF持久化，默认为false，不持久化 redis.conf配置文件详解 # Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no # 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid # 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口， 因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 # 绑定的主机地址 bind 127.0.0.1 # 当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 # 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning， 默认为verbose loglevel verbose # 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志 记录方式为标准输出，则日志将会发送给/dev/null logfile stdout # 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id databases 16 # 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 # 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 # 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， 可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes # 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb # 指定本地数据库存放目录 dir ./ # 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof # 当master服务设置了密码保护时，slav服务连接master的密码 masterauth # 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared # 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数， 如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端 返回max number of clients reached错误信息 maxclients 128 # 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key， 当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存， Value会存放在swap区 maxmemory # 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。 因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no # 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof # 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec # 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上， 访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no # 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap # 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys), 也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 # Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享， vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes； 如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 # 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 # 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的， 可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 # 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes # 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 # 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes # 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf ----------------------------------------------------------------------------- # daemonize no 默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes daemonize yes # 当 redis 在后台运行的时候， Redis 默认会把 pid 文件放在 /var/run/redis.pid ，你可以配置到其他地址。 # 当运行多个 redis 服务时，需要指定不同的 pid 文件和端口 pidfile /var/run/redis_6379.pid # 指定 redis 运行的端口，默认是 6379 port 6379 # 在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志 tcp-backlog 511 # 指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求 # bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 # 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接 # 0 是关闭此设置 timeout 0 # TCP keepalive # 在 Linux 上，指定值（秒）用于发送 ACKs 的时间。注意关闭连接需要双倍的时间。默认为 0 。 tcp-keepalive 0 # 指定日志记录级别，生产环境推荐 notice # Redis 总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 verbose # debug 记录很多信息，用于开发和测试 # varbose 有用的信息，不像 debug 会记录那么多 # notice 普通的 verbose ，常用于生产环境 # warning 只有非常重要或者严重的信息会记录到日志 loglevel notice # 配置 log 文件地址 # 默认值为 stdout ，标准输出，若后台模式会输出到 /dev/null 。 logfile /var/log/redis/redis.log # 可用数据库数 # 默认值为 16 ，默认数据库为 0 ，数据库范围在 0- （ database-1 ）之间 databases 16 ################################ 快照################################# # 保存数据到磁盘，格式如下 : # save # 指出在多长时间内，有多少次更新操作，就将数据同步到数据文件 rdb 。 # 相当于条件触发抓取快照，这个可以多个条件配合 # 比如默认配置文件中的设置，就设置了三个条件 # save 900 1 900 秒内至少有 1 个 key 被改变 # save 300 10 300 秒内至少有 300 个 key 被改变 # save 60 10000 60 秒内至少有 10000 个 key 被改变 save 900 1 save 300 10 save 60 10000 # 后台存储错误停止写。 stop-writes-on-bgsave-error yes # 存储至本地数据库时（持久化到 rdb 文件）是否压缩数据，默认为 yes rdbcompression yes # 对rdb数据进行校验,耗费CPU资源,默认为yes rdbchecksum yes # 本地持久化数据库文件名，默认值为 dump.rdb dbfilename dump.rdb # 工作目录 # 数据库镜像备份的文件放置的路径。 # 这里的路径跟文件名要分开配置是因为 redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成， # 再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。 # AOF文件也会存放在这个目录下面 # 注意这里必须制定一个目录而不是文件 dir /var/lib/redis-server/ ################################# 复制 ################################# # 主从复制 . 设置该数据库为其他数据库的从数据库 . # 设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 # slaveof # 当 master 服务设置了密码保护时 ( 用 requirepass 制定的密码 ) # slave 服务连接 master 的密码 # masterauth # 当从库同主机失去连接或者复制正在进行，从机库有两种运行方式： # 1) 如果 slave-serve-stale-data 设置为 yes( 默认设置 ) ，从库会继续响应客户端的请求 # 2) 如果 slave-serve-stale-data 是指为 no ，出去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个 # 错误 \"SYNC with master in progress\" slave-serve-stale-data yes # 配置 slave 实例是否接受写。写 slave 对存储短暂数据（在同 master 数据同步后可以很容易地被删除）是有用的，但未配置的情况下，客户端写可能会发送问题。 # 从 Redis2.6 后，默认 slave 为 read-only slaveread-only yes # 从库会按照一个时间间隔向主库发送 PINGs. 可以通过 repl-ping-slave-period 设置这个时间间隔，默认是 10 秒 # repl-ping-slave-period 10 # repl-timeout 设置主库批量数据传输时间或者 ping 回复时间间隔，默认值是 60 秒 # 一定要确保 repl-timeout 大于 repl-ping-slave-period # repl-timeout 60 # 在 slave socket 的 SYNC 后禁用 TCP_NODELAY # 如果选择“ yes ” ,Redis 将使用一个较小的数字 TCP 数据包和更少的带宽将数据发送到 slave ， 但是这可能导致数据发送到 slave 端会有延迟 , 如果是 Linux kernel 的默认配置，会达到 40 毫秒 # 如果选择 \"no\" ，则发送数据到 slave 端的延迟会降低，但将使用更多的带宽用于复制 . repl-disable-tcp-nodelay no # 设置复制的后台日志大小。 # 复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。 # 后台日志在至少有一个 slave 连接时，仅仅分配一次。 # repl-backlog-size 1mb # 在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。 # 0 意味着从不释放后台日志 # repl-backlog-ttl 3600 # 如果 master 不能再正常工作，那么会在多个 slave 中，选择优先值最小的一个 slave 提升为 master ，优先值为 0 表示不能提升为 master 。 slave-priority 100 # 如果少于 N 个 slave 连接，且延迟时间 利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用 Least RecentlyUsed ) # allkeys-lru -> 利用 LRU 算法移除任何 key # volatile-random -> 移除设置过过期时间的随机 key # allkeys->random -> remove a randomkey, any key # volatile-ttl -> 移除即将过期的 key(minor TTL) # noeviction -> 不移除任何可以，只是返回一个写错误 # 注意：对于上面的策略，如果没有合适的 key 可以移除，当写的时候 Redis 会返回一个错误 # 默认是 : volatile-lru # maxmemory-policy volatile-lru # LRU 和 minimal TTL 算法都不是精准的算法，但是相对精确的算法 ( 为了节省内存 ) ，随意你可以选择样本大小进行检测。 # Redis 默认的灰选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置 # maxmemory-samples 3 ############################## AOF############################### # 默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。 # 所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。 # 开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到 appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。 # 但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对 appendonly.aof 进行重新整理。 # 你可以同时开启 asynchronous dumps 和 AOF appendonly no # AOF 文件名称 ( 默认 : \"appendonly.aof\") # appendfilename appendonly.aof # Redis 支持三种同步 AOF 文件的策略 : # no: 不进行同步，系统去操作 . Faster. # always: always 表示每次有写操作都进行同步 . Slow, Safest. # everysec: 表示对写操作进行累积，每秒同步一次 . Compromise. # 默认是 \"everysec\" ，按照速度和安全折中这是最好的。 # 如果想让 Redis 能更高效的运行，你也可以设置为 \"no\" ，让操作系统决定什么时候去执行 # 或者相反想让数据更安全你也可以设置为 \"always\" # 如果不确定就用 \"everysec\". # appendfsync always appendfsync everysec # appendfsync no # AOF 策略设置为 always 或者 everysec 时，后台处理进程 ( 后台保存或者 AOF 日志重写 ) 会执行大量的 I/O 操作 # 在某些 Linux 配置中会阻止过长的 fsync() 请求。注意现在没有任何修复，即使 fsync 在另外一个线程进行处理 # 为了减缓这个问题，可以设置下面这个参数 no-appendfsync-on-rewrite no-appendfsync-on-rewrite no # AOF 自动重写 # 当 AOF 文件增长到一定大小的时候 Redis 能够调用 BGREWRITEAOF 对日志文件进行重写 # 它是这样工作的： Redis 会记住上次进行些日志后文件的大小 ( 如果从开机以来还没进行过重写，那日子大小在开机的时候确定 ) # 基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动 # 同时需要指定一个最小大小用于 AOF 重写，这个用于阻止即使文件很小但是增长幅度很大也去重写 AOF 文件的情况 # 设置percentage 为 0 就关闭这个特性 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb ################################ LUASCRIPTING ############################# # 一个 Lua 脚本最长的执行时间为 5000 毫秒（ 5 秒），如果为 0 或负数表示无限执行时间。 lua-time-limit 5000 ################################LOW LOG################################ # Redis Slow Log 记录超过特定执行时间的命令。执行时间不包括 I/O 计算比如连接客户端，返回结果等，只是命令执行时间 # 可以通过两个参数设置 slow log ：一个是告诉 Redis 执行超过多少时间被记录的参数 slowlog-log-slower-than( 微妙 ) ， # 另一个是 slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除 # 下面的时间以微妙为单位，因此 1000000 代表一秒。 # 注意指定一个负数将关闭慢日志，而设置为 0 将强制每个命令都会记录 slowlog-log-slower-than 10000 # 对日志长度没有限制，只是要注意它会消耗内存 # 可以通过 SLOWLOG RESET 回收被慢日志消耗的内存 # 推荐使用默认值 128 ，当慢日志超过 128 时，最先进入队列的记录会被踢出 slowlog-max-len 128 ################################ 事件通知 ############################# # 当事件发生时， Redis 可以通知 Pub/Sub 客户端。 # 可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识： # K Keyspace 事件，以 _keyspace@_ 的前缀方式发布 # E Keyevent 事件，以 _keysevent@_ 的前缀方式发布 # g 通用事件（不指定类型），像 DEL, EXPIRE, RENAME, … # $ String 命令 # s Set 命令 # h Hash 命令 # z 有序集合命令 # x 过期事件（每次 key 过期时生成） # e 清除事件（当 key 在内存被清除时生成） # A g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件 # notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。 # 例子：启用 list 和通用事件： # notify-keyspace-events Elg # 默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。 # 注意如果你不指定至少 K 或 E 之一，不会发送任何事件。 notify-keyspace-events “” ############################## 高级配置 ############################### # 当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时， # hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值 # Redis Hash 对应 Value 内部实际就是一个 HashMap ，实际这里会有 2 种不同实现， # 这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 valueredisObject 的 encoding 为 zipmap, # 当成员数量增大时会自动转成真正的 HashMap, 此时 encoding 为 ht 。 hash-max-zipmap-entries 512 hash-max-zipmap-value 64 # 和 Hash 一样，多个小的 list 以特定的方式编码来节省空间。 # list 数据类型节点值大小小于多少字节会采用紧凑存储格式。 list-max-ziplist-entries 512 list-max-ziplist-value 64 # set 数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。 set-max-intset-entries 512 # 和 hashe 和 list 一样 , 排序的 set 在指定的长度内以指定编码方式存储以节省空间 # zsort 数据类型节点值大小小于多少字节会采用紧凑存储格式。 zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash ，可以降低内存的使用 # 当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no 。 # 如果没有这么严格的实时性要求，可以设置为 yes ，以便能够尽可能快的释放内存 activerehashing yes # 客户端的输出缓冲区的限制，因为某种原因客户端从服务器读取数据的速度不够快， # 可用于强制断开连接（一个常见的原因是一个发布 / 订阅客户端消费消息的速度无法赶上生产它们的速度）。 # 可以三种不同客户端的方式进行设置： # normal -> 正常客户端 # slave -> slave 和 MONITOR 客户端 # pubsub -> 至少订阅了一个 pubsub channel 或 pattern 的客户端 # 每个 client-output-buffer-limit 语法 : # client-output-buffer-limit # 一旦达到硬限制客户端会立即断开，或者达到软限制并保持达成的指定秒数（连续）。 # 例如，如果硬限制为 32 兆字节和软限制为 16 兆字节 /10 秒，客户端将会立即断开 # 如果输出缓冲区的大小达到 32 兆字节，客户端达到 16 兆字节和连续超过了限制 10 秒，也将断开连接。 # 默认 normal 客户端不做限制，因为他们在一个请求后未要求时（以推的方式）不接收数据， # 只有异步客户端可能会出现请求数据的速度比它可以读取的速度快的场景。 # 把硬限制和软限制都设置为 0 来禁用该特性 client-output-buffer-limit normal 0 0 0 client-output-buffer-limit slave 256mb 64mb60 client-output-buffer-limit pubsub 32mb 8mb60 # Redis 调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除过期的 Key ，等等。 # 不是所有的任务都以相同的频率执行，但 Redis 依照指定的“ Hz ”值来执行检查任务。 # 默认情况下，“ Hz ”的被设定为 10 。 # 提高该值将在 Redis 空闲时使用更多的 CPU 时，但同时当有多个 key 同时到期会使 Redis 的反应更灵敏，以及超时可以更精确地处理。 # 范围是 1 到 500 之间，但是值超过 100 通常不是一个好主意。 # 大多数用户应该使用 10 这个预设值，只有在非常低的延迟的情况下有必要提高最大到 100 。 hz 10 # 当一个子节点重写 AOF 文件时，如果启用下面的选项，则文件每生成 32M 数据进行同步。 aof-rewrite-incremental-fsync yes "},"Database/NoSQL/03-Redis基础.html":{"url":"Database/NoSQL/03-Redis基础.html","title":"Redis基础","keywords":"","body":"datetime:2019/10/31 16:02 author:nzb Redis基础 应用场景 EXPIRE key seconds 限时的优惠活动信息 网站数据缓存(对于一些需要定时更新的数据,例如:积分排行榜) 手机验证码 限制网站访客访问频率(例如：1分钟最多访问10次) Redis键(key) DEL key 该命令用于在 key 存在时删除 key(所有类型都可以使用)。 DUMP key 序列化给定 key ，并返回被序列化的值。 EXISTS key 检查给定 key 是否存在。 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。 EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 KEYS pattern 查找所有符合给定模式( pattern)的 key 。 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。 示例： ```text # key 存在于当前数据库 redis> SELECT 0 # redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。 OK redis> SET song \"secret base - Zone\" OK redis> MOVE song 1 # 将 song 移动到数据库 1 (integer) 1 redis> EXISTS song # song 已经被移走 (integer) 0 redis> SELECT 1 # 使用数据库 1 OK redis:1> EXISTS song # 证实 song 被移到了数据库 1 (注意命令提示符变成了\"redis:1\"，表明正在使用数据库 1) (integer) 1 # 当 key 不存在的时候 redis:1> EXISTS fake_key (integer) 0 redis:1> MOVE fake_key 0 # 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败 (integer) 0 redis:1> select 0 # 使用数据库0 OK redis> EXISTS fake_key # 证实 fake_key 不存在 (integer) 0 # 当源数据库和目标数据库有相同的 key 时 redis> SELECT 0 # 使用数据库0 OK redis> SET favorite_fruit \"banana\" OK redis> SELECT 1 # 使用数据库1 OK redis:1> SET favorite_fruit \"apple\" OK redis:1> SELECT 0 # 使用数据库0，并试图将 favorite_fruit 移动到数据库 1 OK redis> MOVE favorite_fruit 1 # 因为两个数据库有相同的 key，MOVE 失败 (integer) 0 redis> GET favorite_fruit # 数据库 0 的 favorite_fruit 没变 \"banana\" redis> SELECT 1 OK redis:1> GET favorite_fruit # 数据库 1 的 favorite_fruit 也是 \"apple\" ``` PERSIST key 移除 key 的过期时间，key 将持久保持。 示例 redis> SET mykey \"Hello\" OK redis> EXPIRE mykey 10 # 为 key 设置生存时间 (integer) 1 redis> TTL mykey (integer) 10 redis> PERSIST mykey # 移除 key 的生存时间 (integer) 1 redis> TTL mykey (integer) -1 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 示例 ```text # 不存在的 key redis> FLUSHDB OK redis> TTL key (integer) -2 # key 存在，但没有设置剩余生存时间 redis> SET key value OK redis> TTL key (integer) -1 # 有剩余生存时间的 key redis> EXPIRE key 10086 (integer) 1 redis> TTL key (integer) 10084 ``` RANDOMKEY 从当前数据库中随机返回一个 key 。 RENAME key newkey 修改 key 的名称 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。 TYPE key 返回 key 所储存的值的类型。 key的命名规范 redis 单个key存入512M大小 key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且降低查找的效率 key也不要太短，太短的话，key的可读性会降低 在一个项目中，key最好使用统一的命名模式，例如：user:123:password(推荐\":\"，不建议\"_\"，因为程序里面有的变量是以下划线连接的) Redis 字符串(String) SET key value SET 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。 GET key Get 命令用于获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误。 SETNX key value只有在 key 不存在时设置 key 的值。应用于解决分布式锁方案之一 INCR key 将 key 中储存的数字值增一。 INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 DECR key 将 key 中储存的数字值减一。 DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 GETRANGE key start end 返回 key 中字符串值的子字符 GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 STRLEN key 返回 key 所储存的字符串值的长度。 MSET key value [key value ...] 同时设置一个或多个 key-value 对。 MSETNX key value [key value ...] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 应用场景 String通常应用于保存单个字符串或json字符串数据 因String是二进制安全的，所有完全可以把一个图片文件的内容作为字符串来存储 计算器(通常key-value缓存一样，常规计数：微博数，粉丝数) INCR等指令就具有原子操作的特性，所有完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。 Redis 哈希(Hash) Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 HDEL key field1 [field2] 删除一个或多个哈希表字段 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field 获取存储在哈希表中指定字段的值。 HGETALL key 获取在哈希表中指定 key 的所有字段和值 HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 HKEYS key 获取所有哈希表中的字段 HLEN key 获取哈希表中字段的数量 HMGET key field1 [field2] 获取所有给定字段的值 HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HVALS key 获取哈希表中所有值 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 应用场景 常用与存储一个对象 为什么不用String存储一个对象？ 因为hash是最接近关系数据库结果的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中 Redis 列表(List) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 LINDEX key index 通过索引获取列表中的元素 LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素 LLEN key 获取列表长度 LPOP key 移出并获取列表的第一个元素 LPUSH key value1 [value2] 将一个或多个值插入到列表头部 LPUSHX key value 将一个值插入到已存在的列表头部 LRANGE key start stop 获取列表指定范围内的元素 LREM key count value 移除列表元素 LSET key index value 通过索引设置列表元素的值 LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 RPOP key 移除列表的最后一个元素，返回值为移除的元素。 RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 RPUSH key value1 [value2] 在列表中添加一个或多个值 RPUSHX key value 为已存在的列表添加值 应用场景(1、对数据量大的集合数据删减 2、任务队列 ) 对数据量大的集合数据删减：列表数据显示、关注列表、粉丝列表、留言评价等...分页、热点新闻(top)等。利用LANGE还可以很方便的实现分页的功能，在博客系统中，每片博文的评论也可以存入一个单独的list中。 任务队列(list通常用来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样需要通过ORDER BY 来进行排序) 任务队列介绍(生产者和消费者模式) 在处理Web客服端发送的命令请求时，某些操作的执行时间可能会比我们预期的更长一些，通过将待执行任务的相关信息放入队列里面，并在之后对队列进行处理，用户可以推迟执行那些需要一段时间才能完成的操作，这种将工作交给任务处理器来执行的做法被称为任务队列(task queue) 常用案例：订单系统的下单流程、用户系统登录注册短信等。 Redis 集合(Set) Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 SADD key member1 [member2] 向集合添加一个或多个成员 SCARD key 获取集合的成员数 SDIFF key1 [key2] 返回给定所有集合的差集 SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中 SINTER key1 [key2] 返回给定所有集合的交集 SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中 SISMEMBER key member 判断 member 元素是否是集合 key 的成员 SMEMBERS key 返回集合中的所有成员 SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合 SPOP key 移除并返回集合中的一个随机元素 SRANDMEMBER key [count] 返回集合中一个或多个随机数 SREM key member1 [member2] 移除集合中一个或多个成员 SUNION key1 [key2] 返回所有给定集合的并集 SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中 SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素 应用场景 常应用于：对两个集合间的数据[计算]进行交集、并集、差集运算 1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。 2、利用唯一性，可以统计访问网站的所有独立 IP Redis 有序集合(sorted set) Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间分数的成员数 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment ZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员 ZRANK key member 返回有序集合中指定成员的索引 ZREM key member [member ...] 移除有序集合中的一个或多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZSCORE key member 返回有序集中，成员的分数值 ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） 应用场景 常应用于：排行榜 比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。 还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 Redis 发布订阅 PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。 SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。 PUBLISH channel message 将信息发送到指定的频道。 PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。 UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。 应用场景 这一功能最明显的用法就是构建实时消息系统，比如普通的即时聊天，群聊等功能 在一个博客网站中，有100个粉丝订阅了你，当你发布新文章，就可以推送消息给粉丝们。 微信公众号模式 Redis多数据库 Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。默认情况下，一个客户端连接到数据库0。 redis配置文件中下面的参数来控制数据库总数： database 16 //(从0开始 1 2 3 …15) select 数据库//数据库的切换 移动数据（将当前key移动另个库) move key名称 数据库 数据库清空： flushdb //清除当前数据库的所有key flushall //清除整个Redis的数据库所有key Redis 事务 Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 一个事务从开始到执行会经历以下三个阶段： 开始事务。 命令入队。 执行事务。 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。 DISCARD 取消事务，放弃执行事务块内的所有命令。 EXEC 执行所有事务块内的命令。 MULTI 标记一个事务块的开始。 UNWATCH 取消 WATCH 命令对所有 key 的监视。 WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 Redis数据淘汰策略redis.conf Redis官方给的警告，当内存不足时，Redis会根据配置的缓存策略淘汰部分Keys，以保证写入成功。当无淘汰策略时或没有找到适合淘汰的Key时，Redis直接返回out of memory错误。 最大缓存配置 在 redis 中，允许用户设置最大使用内存大小 maxmemory 512G redis 提供6种数据淘汰策略： volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-lfu：从已设置过期的Keys中，删除一段时间内使用次数最少使用的 volatile-ttl：从已设置过期时间的数据集中挑选最近将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集中随机选择数据淘汰 allkeys-lru：从数据集中挑选最近最少使用的数据淘汰 allkeys-lfu：从所有Keys中，删除一段时间内使用次数最少使用的 allkeys-random：从数据集中随机选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据(不采用任何淘汰策略。默认即为此配置),针对写操作，返回错误信息 建议：了解了Redis的淘汰策略之后，在平时使用时应尽量主动设置/更新key的expire时间，主动剔除不活跃的旧数据，有助于提升查询性能 Redis持久化 数据存放于： 内存：高效、断电（关机）内存数据会丢失 硬盘：读写速度慢于内存，断电数据不会丢失 RDB RDB：是redis的默认持久化机制。 RDB相当于照快照，保存的是一种状态。 几十G数据 --> 几KB快照 快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。 优点： 快照保存数据极快、还原数据极快 适用于灾难备份 缺点：小内存机器不适合使用,RDB机制符合要求就会照快照 快照条件： 1、服务器正常关闭时 ./bin/redis-cli shutdown 2、key满足一定条件，会进行快照 save 900 1 //每900秒（15分钟）至少1个key发生变化，产生快照 save 300 10 //每300秒（5分钟）至少10个key发生变化，产生快照 save 60 10000 //每60秒（1分钟）至少10000个key发生变化，产生快照 AOF 由于快照方式是在一定间隔时间做一次的，所以如果redis 意外down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof 持久化方式。 Append-only file:aof 比快照方式有更好的持久化性，是由于在使用aof 持久化方式时,redis 会将每一个收到的写命令都通过write 函数追加到文件中(默认是appendonly.aof)。当redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 有三种方式如下（默认是：每秒 fsync 一次） appendonly yes //启用 aof 持久化方式 appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化 appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中 appendfsync no //完全依赖 os，性能最好,持久化没保证 产生的问题： aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。 redis缓存与数据库(MySQL)一致性方案 一、实时同步 对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。 @Cacheable：查询时使用，注意Long类型需转换为Sting类型，否则会抛异常 @CachePut：更新时使用，使用此注解，一定会从DB上查询数据 @CacheEvict：删除时使用； @Caching：组合用法 二、异步队列 对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。 三、使用阿里的同步工具canal canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。 master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件，将改变反映它自己的数据。 canal模拟mysql slave的交互协议，伪装自己为mysql slave，向mysql master发送dump协议 mysql master收到dump请求，开始推送binary log给slave(也就是canal) canal解析binary log对象(原始为byte流) 四、采用UDF自定义函数的方式 面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。 总结： 穿透 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决办法： 持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回， 注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间） 雪崩 雪崩：缓存大量失效的时候，引发大量查询数据库。 解决办法： 用锁/分布式锁或者队列串行访问 缓存失效时间均匀分布 热点key 热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。 解决办法： 使用锁，单机用synchronized,lock等，分布式用分布式锁。 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。 在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。 设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存 "},"MachineLearning/MatplotlibNumpyPandas/numpy基础.html":{"url":"MachineLearning/MatplotlibNumpyPandas/numpy基础.html","title":"numpy基础","keywords":"","body":"datetime:2020/8/1 13:28 author:nzb numpy基础 幕布numpy基础 幕布numpy方法 numpy用于数组计算 中文文档 import numpy as np import random 创建数组 a1 = np.array([1,2,3]) a2 = np.array(range(5)) a3 = np.arange(8) a4 = np.array(range(4), dtype='f4') a5 = np.array([1,0,1,0,1,0], dtype=bool) print(a1, a2, a3, sep='\\n') print(type(a1), type(a2), type(a3)) print(\"a3:dtype:\", a3.dtype) print(\"a4:dtype:\", a4.dtype) print(\"a5:dtype:\", a5.dtype) print(\"a1调整dtype前\",a1.dtype ) # a1.dtype = 'f2' a1 = a1.astype('float32') print(\"a1调整dtype后\",a1.dtype ) print(\"\\n\") # 保留小数点 a6 = np.array([random.random() for _ in range(10)]) print(a6) print(np.round(a6, 3)) [1 2 3] [0 1 2 3 4] [0 1 2 3 4 5 6 7] a3:dtype: int32 a4:dtype: float32 a5:dtype: bool a1调整dtype前 int32 a1调整dtype后 float32 [0.67067085 0.2306847 0.25868171 0.71041073 0.53141459 0.40654488 0.62679249 0.51855766 0.30907571 0.63072732] [0.671 0.231 0.259 0.71 0.531 0.407 0.627 0.519 0.309 0.631] 数据类型 形状 a7 = np.array([[1,2,3],[4,5,6]]) a8 = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[4,5,6]] ]) print(a3, a7, a8, sep='\\n') print(a3.shape, a7.shape, a8.shape) [0 1 2 3 4 5 6 7] [[1 2 3] [4 5 6]] [[[1 2 3] [4 5 6]] [[7 8 9] [4 5 6]]] (8,) (2, 3) (2, 2, 3) a9 = np.arange(12) # 转换为2维， print(a9.reshape((3,4)), a9.reshape((2,6)), a9.reshape((2,2,3)), a9.reshape((2,3,2)), sep='\\n\\n\\n') [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11]] [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[[ 0 1] [ 2 3] [ 4 5]] [[ 6 7] [ 8 9] [10 11]]] print(a9.reshape((12,)),a9.reshape((1,12)), a9.reshape((12,1)), sep='\\n\\n\\n') [ 0 1 2 3 4 5 6 7 8 9 10 11] [[ 0 1 2 3 4 5 6 7 8 9 10 11]] [[ 0] [ 1] [ 2] [ 3] [ 4] [ 5] [ 6] [ 7] [ 8] [ 9] [10] [11]] a10 = np.arange(12).reshape((2,2,3)) print(a10, a10.flatten(), sep='\\n\\n\\n') [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [ 0 1 2 3 4 5 6 7 8 9 10 11] 计算 a11 = np.arange(12).reshape((3,-1)) # nan：没有的意思 # infinity：无限，无穷的意思，所以这里是无限大的意思 print(a11, a11/2, a11/0, sep='\\n\\n\\n') [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[0. 0.5 1. 1.5] [2. 2.5 3. 3.5] [4. 4.5 5. 5.5]] [[nan inf inf inf] [inf inf inf inf] [inf inf inf inf]] C:\\Users\\Admin\\Anaconda3\\lib\\site-packages\\ipykernel_launcher.py:4: RuntimeWarning: divide by zero encountered in true_divide after removing the cwd from sys.path. C:\\Users\\Admin\\Anaconda3\\lib\\site-packages\\ipykernel_launcher.py:4: RuntimeWarning: invalid value encountered in true_divide after removing the cwd from sys.path. 维度相同 a12 = np.arange(1,13).reshape((3,4)) a13 = np.arange(11, 23).reshape((3,4)) print(a12, a13, sep='\\n'*3) [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] [[11 12 13 14] [15 16 17 18] [19 20 21 22]] print(\"加：\", a12 + a13, end=\"\\n\"*3) print(\"减：\", a12 - a13, end=\"\\n\"*3) print(\"乘：\", a12 * a13, end=\"\\n\"*3) print(\"除：\", a12 / a13, end=\"\\n\"*3) 加： [[12 14 16 18] [20 22 24 26] [28 30 32 34]] 减： [[-10 -10 -10 -10] [-10 -10 -10 -10] [-10 -10 -10 -10]] 乘： [[ 11 24 39 56] [ 75 96 119 144] [171 200 231 264]] 除： [[0.09090909 0.16666667 0.23076923 0.28571429] [0.33333333 0.375 0.41176471 0.44444444] [0.47368421 0.5 0.52380952 0.54545455]] 维度不相同 需要有一个维度的相同 广播原则 如果两个数组的后缘维度（即从末尾开始算起的维度）的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的，广播会在缺失和（或）长度为1的维度上进行 a14 = np.arange(6) a15 = np.arange(24).reshape((4,6)) a16 = np.arange(4).reshape((4,1)) a17 = np.arange(10) print(a14, a15, a16, a17, sep=\"\\n\"*3) [0 1 2 3 4 5] [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[0] [1] [2] [3]] [0 1 2 3 4 5 6 7 8 9] # 维度不一样时会计算对应位置 print(a15-a14, a15-a16, sep='\\n'*3) [[ 0 0 0 0 0 0] [ 6 6 6 6 6 6] [12 12 12 12 12 12] [18 18 18 18 18 18]] [[ 0 1 2 3 4 5] [ 5 6 7 8 9 10] [10 11 12 13 14 15] [15 16 17 18 19 20]] # 维度不一样时会计算对应位置不一样也不一定可以计算 print(a15-a14, a15-a16, a15-a17, sep='\\n'*3) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) in 1 # 维度不一样时会计算对应位置不一样也不一定可以计算 ----> 2 print(a15-a14, a15-a16, a15-a17, sep='\\n'*3) ValueError: operands could not be broadcast together with shapes (4,6) (10,) 轴 二维 axis=0：行 axis=1：列 三维 axis=0：行 aixs=1：列（每一行的每一列） aixs=2：块（每一行的每一列的每个元素） print(a10, np.sum(a10, axis=0), np.sum(a10, axis=1), np.sum(a10, axis=2), sep='\\n'*3) [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[ 6 8 10] [12 14 16]] [[ 3 5 7] [15 17 19]] [[ 3 12] [21 30]] 转置 a18 = np.arange(24).reshape((4,6)) print(a18, a18.transpose(), a18.T, a18.swapaxes(1,0), sep='\\n'*3) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] [[ 0 6 12 18] [ 1 7 13 19] [ 2 8 14 20] [ 3 9 15 21] [ 4 10 16 22] [ 5 11 17 23]] 索引与切片 中文文档 # 一维（前闭后开） print(a2, a2[0], a2[2:5],a2[::-1], sep='\\n'*2) [0 1 2 3 4] 0 [2 3 4] [4 3 2 1 0] 三个点（ ... ）表示产生完整索引元组所需的冒号。例如，如果 x 是rank为5的数组（即，它具有5个轴），则： x[1,2,...] 相当于 x[1,2,:,:,:] x[...,3] 等效于 x[:,:,:,:,3] x[4,...,5,:] 等效于 x[4,:,:,5,:] # 多维 print(\"二维\",a12,a12[:2,:2], a12[:, 1:3],a12[[0, 1,2],[1,2,0]], sep='\\n'*2) print(\"三维\",a10, a10[:,:2,:2], a10[1,...],sep='\\n'*3) 二维 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] [[1 2] [5 6]] [[ 2 3] [ 6 7] [10 11]] [2 7 9] 三维 [[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]]] [[[ 0 1] [ 3 4]] [[ 6 7] [ 9 10]]] [[ 6 7 8] [ 9 10 11]] index = np.where(a12 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10 11 12]] (array([0, 0, 0, 0], dtype=int64), array([0, 1, 2, 3], dtype=int64)) [1 2 3 4] # 小于5的赋值为1，,大于等于5的赋值为0 # 三目运算符 print(np.where(a12 [[1 1 1 1] [0 0 0 0] [0 0 0 0]] 数据拼接 a1 = np.arange(12).reshape((2,6)) a2 = np.arange(12, 24).reshape((2,6)) # 竖直拼接 a3 = np.vstack((a1, a2)) # 水平拼接 a4 = np.hstack((a1, a2)) print(a3, a4, sep=\"\\n\"*3) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] [[ 0 1 2 3 4 5 12 13 14 15 16 17] [ 6 7 8 9 10 11 18 19 20 21 22 23]] 行列交换 a3 array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) # 行交换 a3[[1,2], :] = a3[[2,1], :] print(\"行交换\",a3, sep='\\n') # 列交换 a3[:, [0,2]] = a3[:,[2,0]] print(\"行交换\",a3, sep='\\n') 行交换 [[ 0 1 2 3 4 5] [12 13 14 15 16 17] [ 6 7 8 9 10 11] [18 19 20 21 22 23]] 行交换 [[ 2 1 0 3 4 5] [14 13 12 15 16 17] [ 8 7 6 9 10 11] [20 19 18 21 22 23]] import matplotlib.pyplot as plt %matplotlib inline a1 = np.random.rand(100) plt.scatter(range(100), a1) plt.show() nan和inf print(type(np.nan),np.nan == np.nan, np.nan is np.nan, sep=\"\\n\"*2) False True a1 = np.array([1,2,np.nan]) print(a1 != a1, np.count_nonzero(a1 != a1), sep=\"\\n\") print(np.isnan(a1)) print(\"求和：\", np.sum(a1)) a1[np.isnan(a1)]=0 print(a1) [False False True] 1 [False False True] 求和： nan [1. 2. 0.] np.isnan(a1) array([False, False, False]) a1 = np.array([1,2,np.nan]) a2 = np.arange(12).reshape((3,4)).astype(\"float\") a2[[1], 2:] = np.nan # 使用了 ~（取补运算符）来过滤 NaN。 a = np.array([np.nan, 1,2,np.nan,3,4,5]) print (a[~np.isnan(a)]) [1. 2. 3. 4. 5.] "},"MachineLearning/MatplotlibNumpyPandas/Pandas快速入门.html":{"url":"MachineLearning/MatplotlibNumpyPandas/Pandas快速入门.html","title":"pandas基础","keywords":"","body":"Pandas 中文文档 英文文档 Pandas概览 Pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为最强大、最灵活、可以支持任何语言的开源数据分析工具。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。 Pandas 适用于处理以下类型的数据： 与 SQL 或 Excel 表类似的，含异构列的表格数据; 有序和无序（非固定频率）的时间序列数据; 带行列标签的矩阵数据，包括同构或异构型数据; 任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。 Pandas 的主要数据结构是 Series（一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、- 社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。 Pandas 就像一把万能瑞士军刀，下面仅列出了它的部分优势 ： 处理浮点与非浮点数据里的缺失数据，表示为 NaN； 大小可变：插入或删除 DataFrame 等多维对象的列； 自动、显式数据对齐：显式地将对象与一组标签对齐，也可以忽略标签，在 Series、DataFrame 计算时自动与数据对齐； 强大、灵活的分组（group by）功能：拆分-应用-组合数据集，聚合、转换数据； 把 Python 和 NumPy 数据结构里不规则、不同索引的数据轻松地转换为 DataFrame 对象； 基于智能标签，对大型数据集进行切片、花式索引、子集分解等操作； 直观地合并（merge）、连接（join）数据集； 灵活地重塑（reshape）、透视（pivot）数据集； 轴支持结构化标签：一个刻度支持多个标签； 成熟的 IO 工具：读取文本文件（CSV 等支持分隔符的文件）、Excel 文件、数据库等来源的数据，利用超快的 HDF5 格式保存 / 加载数据； 时间序列：支持日期范围生成、频率转换、移动窗口统计、移动窗口线性回归、日期位移等时间序列功能。 这些功能主要是为了解决其它编程语言、科研环境的痛点。处理数据一般分为几个阶段：数据整理与清洗、数据分析与建模、数据可视化与制表，Pandas 是处理数据的理想工具。 其它说明： Pandas 速度很快。Pandas 的很多底层算法都用 Cython 优化过。然而，为了保持通用性，必然要牺牲一些性能，如果专注某一功能，完全可以开发出比 Pandas 更快的专用工具。 Pandas 是 statsmodels 的依赖项，因此，Pandas 也是 Python 中统计计算生态系统的重要组成部分。 Pandas 已广泛应用于金融领域。 数据结构 维数 名称 描述 1 Series 带标签的一维同构数组 2 DataFrame 带标签的，大小可变的，二维异构表格 为什么有多个数据结构？ Pandas 数据结构就像是低维数据的容器。比如，DataFrame 是 Series 的容器，Series 则是标量的容器。使用这种方式，可以在容器中以字典的形式插入或删除对象。 此外，通用 API 函数的默认操作要顾及时间序列与截面数据集的方向。多维数组存储二维或三维数据时，编写函数要注意数据集的方向，这对用户来说是一种负担；如果不考虑 C 或 Fortran 中连续性对性能的影响，一般情况下，不同的轴在程序里其实没有什么区别。Pandas 里，轴的概念主要是为了给数据赋予更直观的语义，即用“更恰当”的方式表示数据集的方向。这样做可以让用户编写数据转换函数时，少费点脑子。 处理 DataFrame 等表格数据时，index（行）或 columns（列）比 axis 0 和 axis 1 更直观。用这种方式迭代 DataFrame 的列，代码更易读易懂： for col in df.columns: series = df[col] # do something with series 大小可变与数据复制 Pandas 所有数据结构的值都是可变的，但数据结构的大小并非都是可变的，比如，Series 的长度不可改变，但 DataFrame 里就可以插入列。 Pandas 里，绝大多数方法都不改变原始的输入数据，而是复制数据，生成新的对象。 一般来说，原始输入数据不变更稳妥。 十分钟入门Pandas 本节是帮助 Pandas 新手快速上手的简介。烹饪指南里介绍了更多实用案例。 本节以下列方式导入 Pandas 与 NumPy： import numpy as np import pandas as pd 生成对象 详见数据结构简介文档。 用值列表生成 Series 时，Pandas 默认自动生成整数索引： s = pd.Series([1,2,3,4,5,np.nan, 6,8]) s 0 1.0 1 2.0 2 3.0 3 4.0 4 5.0 5 NaN 6 6.0 7 8.0 dtype: float64 用含日期时间索引与标签的Numpy数组生成DataFrame df1 = pd.date_range(start='20150101', periods=6) df1 DatetimeIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04', '2015-01-05', '2015-01-06'], dtype='datetime64[ns]', freq='D') df2 = pd.DataFrame(np.random.randn(6,4), index=df1, columns=list('ABCD')) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 用Series字典对象生成DataFrame df3 = pd.DataFrame({ 'A': 1., 'B': pd.Timestamp('20150101'), 'C': pd.Series(1, index=list(range(4)), dtype='float32'), 'D': np.array([3]* 4, dtype='int32'), 'E': pd.Categorical(['test', 'train','test', 'train']), 'F':'foo' }) df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E F 0 1.0 2015-01-01 1.0 3 test foo 1 1.0 2015-01-01 1.0 3 train foo 2 1.0 2015-01-01 1.0 3 test foo 3 1.0 2015-01-01 1.0 3 train foo DataFrame 的列有不同数据类型。 df3.dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object IPython支持 tab 键自动补全列名与公共属性。下面是部分可自动补全的属性： df3. # df2.A df2.bool # df2.abs df2.boxplot # df2.add df2.C # df2.add_prefix df2.clip # df2.add_suffix df2.clip_lower # df2.align df2.clip_upper # df2.all df2.columns # df2.any df2.combine # df2.append df2.combine_first # df2.apply df2.compound # df2.applymap df2.consolidate # df2.D # 列 A、B、C、D 和 E 都可以自动补全；为简洁起见，此处只显示了部分属性。 File \"\", line 1 df3. ^ SyntaxError: invalid syntax 查看数据 详见基础用法文档。 下列代码说明如何查看 DataFrame 头部和尾部数据： df2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 df2.tail(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 显示索引与列名 df2.index DatetimeIndex(['2015-01-01', '2015-01-02', '2015-01-03', '2015-01-04', '2015-01-05', '2015-01-06'], dtype='datetime64[ns]', freq='D') df2.columns Index(['A', 'B', 'C', 'D'], dtype='object') DataFrame.to_numpy() 输出底层数据的 NumPy 对象。注意，DataFrame 的列由多种数据类型组成时，该操作耗费系统资源较大，这也是 Pandas 和 NumPy 的本质区别：NumPy 数组只有一种数据类型，DataFrame 每列的数据类型各不相同。调用 DataFrame.to_numpy() 时，Pandas 查找支持 DataFrame 里所有数据类型的 NumPy 数据类型。还有一种数据类型是 object，可以把 DataFrame 列里的值强制转换为 Python 对象。 下面的 df2 这个 DataFrame 里的值都是浮点数，DataFrame.to_numpy() 的操作会很快，而且不复制数据。 df2.to_numpy() array([[ 0.49577653, -0.5242963 , -0.08997072, 1.64004361], [ 2.01445165, -0.42293604, 0.99104484, -0.28133103], [ 0.88359618, -1.79480302, 0.57597891, -1.85652831], [ 0.56512531, 0.85877834, 0.13837606, 0.20131605], [-1.85407664, 0.36895609, -1.26782639, -2.46488774], [-0.22499319, -1.25311828, -0.19571662, -0.62379678]]) df3 这个 DataFrame 包含了多种类型，DataFrame.to_numpy() 操作就会耗费较多资源。 df3.to_numpy() array([[1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'train', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'test', 'foo'], [1.0, Timestamp('2015-01-01 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object) 提醒： DataFrame.to_numpy() 的输出不包含行索引和列标签。 describe() 可以快速查看数据的统计摘要： df2.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D count 6.000000 6.000000 6.000000 6.000000 mean 0.313313 -0.461237 0.025314 -0.564197 std 1.288654 0.984132 0.772400 1.470442 min -1.854077 -1.794803 -1.267826 -2.464888 25% -0.044801 -1.070913 -0.169280 -1.548345 50% 0.530451 -0.473616 0.024203 -0.452564 75% 0.803978 0.170983 0.466578 0.080654 max 2.014452 0.858778 0.991045 1.640044 转置数据： print(df2) print(\"\\n-------------------转置后-------------------------\") df2.T A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 -------------------转置后------------------------- .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2015-01-01 2015-01-02 2015-01-03 2015-01-04 2015-01-05 2015-01-06 A 0.495777 2.014452 0.883596 0.565125 -1.854077 -0.224993 B -0.524296 -0.422936 -1.794803 0.858778 0.368956 -1.253118 C -0.089971 0.991045 0.575979 0.138376 -1.267826 -0.195717 D 1.640044 -0.281331 -1.856528 0.201316 -2.464888 -0.623797 按轴排序： df2.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } D C B A 2015-01-01 1.640044 -0.089971 -0.524296 0.495777 2015-01-02 -0.281331 0.991045 -0.422936 2.014452 2015-01-03 -1.856528 0.575979 -1.794803 0.883596 2015-01-04 0.201316 0.138376 0.858778 0.565125 2015-01-05 -2.464888 -1.267826 0.368956 -1.854077 2015-01-06 -0.623797 -0.195717 -1.253118 -0.224993 按值排序： df2.sort_values(by='B') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 2015-01-04 0.565125 0.858778 0.138376 0.201316 选择 提醒： 选择、设置标准 Python / Numpy 的表达式已经非常直观，交互也很方便，但对于生产代码，我们还是推荐优化过的 Pandas 数据访问方法：.at、.iat、.loc 和 .iloc。 详见索引与选择数据、多层索引与高级索引文档。 获取数据 选择单列，产生Series，与df2.A等效： df2['A'] 2015-01-01 0.495777 2015-01-02 2.014452 2015-01-03 0.883596 2015-01-04 0.565125 2015-01-05 -1.854077 2015-01-06 -0.224993 Freq: D, Name: A, dtype: float64 用[]切片行： df2[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 df2['20150102': '20150103'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 按标签选择 详见按标签选择 用标签提取一行数据： df2.loc[df1[0]] A 0.495777 B -0.524296 C -0.089971 D 1.640044 Name: 2015-01-01 00:00:00, dtype: float64 用标签选择多列数据： df2.loc[:,['A', 'B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-01 0.495777 -0.524296 2015-01-02 2.014452 -0.422936 2015-01-03 0.883596 -1.794803 2015-01-04 0.565125 0.858778 2015-01-05 -1.854077 0.368956 2015-01-06 -0.224993 -1.253118 用标签切片，包含行与列结束点： df2.loc['20150102': '20150104', ['A','B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-02 2.014452 -0.422936 2015-01-03 0.883596 -1.794803 2015-01-04 0.565125 0.858778 返回对象降维： df2.loc['20150102', ['A','B']] A 2.014452 B -0.422936 Name: 2015-01-02 00:00:00, dtype: float64 提取标量值： df2.loc[df1[0],'A'] 0.4957765303321702 快速访问标量，与上述方法等效 df2.at[df1[0], 'A'] 0.4957765303321702 按位置选择 详见按位置选择 用整数位置选择： df2.iloc[3] A 0.565125 B 0.858778 C 0.138376 D 0.201316 Name: 2015-01-04 00:00:00, dtype: float64 类似Numpy/Python，用整数切片 df2.iloc[3:5,0:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2015-01-04 0.565125 0.858778 2015-01-05 -1.854077 0.368956 类型Numpy/Python，用整数列表按位置切片： df2.iloc[[1,2,4], [0,2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A C 2015-01-02 2.014452 0.991045 2015-01-03 0.883596 0.575979 2015-01-05 -1.854077 -1.267826 显式整行切片 df2.iloc[1:3, :] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 显式整列切片： df2.iloc[:,1:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } B C 2015-01-01 -0.524296 -0.089971 2015-01-02 -0.422936 0.991045 2015-01-03 -1.794803 0.575979 2015-01-04 0.858778 0.138376 2015-01-05 0.368956 -1.267826 2015-01-06 -1.253118 -0.195717 显式提取值： df2.iloc[1,1] -0.4229360414145462 快速访问标量，与上述方法等效： df2.iat[1,1] -0.4229360414145462 布尔索引 用单列的值选择数据： df2[df2.A > 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 2015-01-04 0.565125 0.858778 0.138376 0.201316 选择DataFrame里满足条件的值： df2[df2 > 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2015-01-01 0.495777 NaN NaN 1.640044 2015-01-02 2.014452 NaN 0.991045 NaN 2015-01-03 0.883596 NaN 0.575979 NaN 2015-01-04 0.565125 0.858778 0.138376 0.201316 2015-01-05 NaN 0.368956 NaN NaN 2015-01-06 NaN NaN NaN NaN 用isin()筛选： df4 = df2.copy() df4['E'] = ['one', 'two', 'three', 'four', 'three', 'one'] df4 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 one 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 two 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 three 2015-01-04 0.565125 0.858778 0.138376 0.201316 four 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 three 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 one df4[df4['E'].isin(['two', 'four'])] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 two 2015-01-04 0.565125 0.858778 0.138376 0.201316 four 赋值 用索引自动对齐新增列的数据： s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20150101', periods=6)) df2['F'] = s1 print(df2) A B C D F 2015-01-01 0.495777 -0.524296 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按标签赋值： df2.at[df1[0], 'A'] = 0 df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 -0.524296 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按位置赋值： df2.iat[0,1] = 0 df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 1.640044 1 2015-01-02 2.014452 -0.422936 0.991045 -0.281331 2 2015-01-03 0.883596 -1.794803 0.575979 -1.856528 3 2015-01-04 0.565125 0.858778 0.138376 0.201316 4 2015-01-05 -1.854077 0.368956 -1.267826 -2.464888 5 2015-01-06 -0.224993 -1.253118 -0.195717 -0.623797 6 按Numpy数组赋值： df2.loc[:,\"D\"] = np.array([5]* len(df2)) df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 5 1 2015-01-02 2.014452 -0.422936 0.991045 5 2 2015-01-03 0.883596 -1.794803 0.575979 5 3 2015-01-04 0.565125 0.858778 0.138376 5 4 2015-01-05 -1.854077 0.368956 -1.267826 5 5 2015-01-06 -0.224993 -1.253118 -0.195717 5 6 用where条件赋值： 签名DataFrame.where()不同于numpy.where()。大致相当于。df1.where(m, df2)``````np.where(m, df1, df2) df5 = df2.copy() df5[df5 > 0] = -df5 df5 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 -5 -1 2015-01-02 -2.014452 -0.422936 -0.991045 -5 -2 2015-01-03 -0.883596 -1.794803 -0.575979 -5 -3 2015-01-04 -0.565125 -0.858778 -0.138376 -5 -4 2015-01-05 -1.854077 -0.368956 -1.267826 -5 -5 2015-01-06 -0.224993 -1.253118 -0.195717 -5 -6 缺失值 Pandas 主要用 np.nan 表示缺失数据。 计算时，默认不包含空值。详见缺失数据。 重建索引（reindex）可以更改、添加、删除指定轴的索引，并返回数据副本，即不更改原数据。 df6 = df2.reindex(index=df1[0:4], columns=list(df2.columns) + ['E']) df6.loc[df1[0]:df1[1], 'E'] = 1 df6 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 2015-01-03 0.883596 -1.794803 0.575979 5 3 NaN 2015-01-04 0.565125 0.858778 0.138376 5 4 NaN 删除所有含缺失值得行： df6.dropna(how='any') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 填充缺失值： df6.fillna(value=4) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 0.000000 0.000000 -0.089971 5 1 1.0 2015-01-02 2.014452 -0.422936 0.991045 5 2 1.0 2015-01-03 0.883596 -1.794803 0.575979 5 3 4.0 2015-01-04 0.565125 0.858778 0.138376 5 4 4.0 提取nan值得布尔掩码： pd.isna(df6) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2015-01-01 False False False False False False 2015-01-02 False False False False False False 2015-01-03 False False False False False True 2015-01-04 False False False False False True 运算 详见二进制操作 统计 一般情况下，运算时排除缺失值。 描述性统计： df2.mean() A 0.230684 B -0.373854 C 0.025314 D 5.000000 F 3.500000 dtype: float64 在另一个轴(即,行)上执行同样的操作： df2.mean(1) 2015-01-01 1.182006 2015-01-02 1.916512 2015-01-03 1.532954 2015-01-04 2.112456 2015-01-05 1.449411 2015-01-06 1.865234 Freq: D, dtype: float64 不同维度对象运算时，要先对齐。此外，Pandas自动沿指定维度广播。 s2 = pd.Series([1,3,5, np.nan, 6, 8], index=df1).shift(2) s2 2015-01-01 NaN 2015-01-02 NaN 2015-01-03 1.0 2015-01-04 3.0 2015-01-05 5.0 2015-01-06 NaN Freq: D, dtype: float64 df2.sub(s2, axis='index') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 NaN NaN NaN NaN NaN 2015-01-02 NaN NaN NaN NaN NaN 2015-01-03 -0.116404 -2.794803 -0.424021 4.0 2.0 2015-01-04 -2.434875 -2.141222 -2.861624 2.0 1.0 2015-01-05 -6.854077 -4.631044 -6.267826 0.0 0.0 2015-01-06 NaN NaN NaN NaN NaN Apply函数 Apply函数处理数据 df2.apply(np.cumsum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2015-01-01 0.000000 0.000000 -0.089971 5 1 2015-01-02 2.014452 -0.422936 0.901074 10 3 2015-01-03 2.898048 -2.217739 1.477053 15 6 2015-01-04 3.463173 -1.358961 1.615429 20 10 2015-01-05 1.609096 -0.990005 0.347603 25 15 2015-01-06 1.384103 -2.243123 0.151886 30 21 df2.apply(lambda x: x.max() - x.min()) A 3.868528 B 2.653581 C 2.258871 D 0.000000 F 5.000000 dtype: float64 直方图 详见直方图与离散化。 s3 = pd.Series(np.random.randint(0, 7, size=10)) s3 0 6 1 3 2 4 3 0 4 2 5 3 6 1 7 6 8 4 9 3 dtype: int32 s3.value_counts() 3 3 6 2 4 2 2 1 1 1 0 1 dtype: int64 字符串方法 Series 的 str 属性包含一组字符串处理功能，如下列代码所示。注意，str 的模式匹配默认使用正则表达式。详见矢量字符串方法。 s4 = pd.Series(['A','B', 'C', 'Aaba','Baca', np.nan, 'CABA', 'dog', 'cat']) s4.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object 合并（Merge） 结合（Concat） Pandas 提供了多种将 Series、DataFrame 对象组合在一起的功能，用索引与关联代数功能的多种设置逻辑可执行连接（join）与合并（merge）操作。 详见合并。 concat() 用于连接 Pandas 对象： df7 = pd.DataFrame(np.random.randn(10, 4)) df7 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.510118 1.297539 -0.226940 -1.298777 1 -0.156357 -0.501054 -0.884452 -0.642022 2 -0.084234 0.522088 0.559494 0.614627 3 -1.877422 1.173498 -0.590322 1.283285 4 0.599235 -0.459644 -0.991115 0.602145 5 -0.918474 1.273175 0.391105 1.760057 6 1.454607 0.301366 0.569512 -0.853014 7 0.533967 2.432820 -0.116690 -1.042676 8 0.788732 0.988278 -0.317310 -0.555627 9 0.717240 -0.003718 2.191069 1.661000 # 分解为多组 pieces = [df7[:3], df7[3:7],df7[7:]] pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 0.510118 1.297539 -0.226940 -1.298777 1 -0.156357 -0.501054 -0.884452 -0.642022 2 -0.084234 0.522088 0.559494 0.614627 3 -1.877422 1.173498 -0.590322 1.283285 4 0.599235 -0.459644 -0.991115 0.602145 5 -0.918474 1.273175 0.391105 1.760057 6 1.454607 0.301366 0.569512 -0.853014 7 0.533967 2.432820 -0.116690 -1.042676 8 0.788732 0.988278 -0.317310 -0.555627 9 0.717240 -0.003718 2.191069 1.661000 连接（join） SQL 风格的合并。 详见数据库风格连接。 left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1,2]}) right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4,5]}) print(left) print('-------------------') print(right) key lval 0 foo 1 1 foo 2 ------------------- key rval 0 foo 4 1 foo 5 pd.merge(left, right, on='key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 还有一个例子： left = pd.DataFrame({'key': ['foo', 'bar'], 'lval': [1,2]}) right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4,5]}) print(left) print('-------------------') print(right) key lval 0 foo 1 1 bar 2 ------------------- key rval 0 foo 4 1 bar 5 pd.merge(left, right, on='key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 bar 2 5 追加（Append） 为 DataFrame 追加行。详见追加文档。 df = pd.DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D']) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.288486 0.071832 -0.573014 -0.740909 1 -0.437346 -0.341157 0.652473 1.647469 2 -0.041598 1.400381 0.034764 0.030222 3 0.269048 0.363632 1.939811 0.371858 4 1.135352 -1.729701 1.319469 0.695883 5 0.024442 0.259727 -0.255833 -1.128733 6 1.310012 1.068041 -0.961124 0.513195 7 -0.811828 2.385519 -0.211693 -1.799050 s = df.iloc[3] df.append(s, ignore_index=True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0.288486 0.071832 -0.573014 -0.740909 1 -0.437346 -0.341157 0.652473 1.647469 2 -0.041598 1.400381 0.034764 0.030222 3 0.269048 0.363632 1.939811 0.371858 4 1.135352 -1.729701 1.319469 0.695883 5 0.024442 0.259727 -0.255833 -1.128733 6 1.310012 1.068041 -0.961124 0.513195 7 -0.811828 2.385519 -0.211693 -1.799050 8 0.269048 0.363632 1.939811 0.371858 分组（Grouping） “group by” 指的是涵盖下列一项或多项步骤的处理流程： 分割：按条件把数据分割成多组； 应用：为每组单独应用函数； 组合：将处理结果组合成一个数据结构。 详见中文文档 官方 df = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'], 'B': ['one', 'one', 'two', 'three','two', 'two', 'one', 'three'], 'C': np.random.randn(8), 'D': np.random.randn(8)}) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 1.039872 0.388262 1 bar one -0.512593 1.288747 2 foo two 2.751863 -0.549265 3 bar three 1.826074 -0.152341 4 foo two 0.565190 1.234779 5 bar two -0.544772 -1.006594 6 foo one -0.232166 0.317457 7 foo three 1.150941 0.672226 先分组，再用sum函数计算每组的汇总数据 df.groupby('A').sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A bar 0.768709 0.129812 foo 5.275699 2.063459 多列分组后，生成多层索引，也可以应用 sum 函数： df.groupby(['A', 'B']).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A B bar one -0.512593 1.288747 three 1.826074 -0.152341 two -0.544772 -1.006594 foo one 0.807705 0.705719 three 1.150941 0.672226 two 3.317053 0.685514 重塑（Reshaping） 详见多层索引与重塑。 堆叠（Stack） tuples = list(zip(*[['bar', 'bar', 'baz', 'baz','foo', 'foo', 'qux', 'qux'], ....: ['one', 'two', 'one', 'two','one', 'two', 'one', 'two']])) index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second']) df = pd.DataFrame(np.random.randn(8,2), index=index, columns=['A', 'B']) df2 = df[:4] print(df, df2, sep='\\n'*3) A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 foo one 0.495192 -1.072288 two 0.447279 -1.292418 qux one -0.317342 -0.857073 two 0.452839 0.217488 A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 # stack()方法把 DataFrame 列压缩至一层 stacked = df2.stack() stacked first second bar one A 1.192086 B -1.617945 two A -0.541903 B -0.763716 baz one A 0.002802 B -0.073066 two A 1.086178 B 0.505617 dtype: float64 # 压缩后的 DataFrame 或 Series 具有多层索引， stack() 的逆操作是 unstack()，默认为拆叠最后一层： stacked.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B first second bar one 1.192086 -1.617945 two -0.541903 -0.763716 baz one 0.002802 -0.073066 two 1.086178 0.505617 stacked.unstack(1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } second one two first bar A 1.192086 -0.541903 B -1.617945 -0.763716 baz A 0.002802 1.086178 B -0.073066 0.505617 stacked.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } first bar baz second one A 1.192086 0.002802 B -1.617945 -0.073066 two A -0.541903 1.086178 B -0.763716 0.505617 数据透视表（Pivot Tables） 详见数据透视表。 df = pd.DataFrame({'A': ['one', 'one', 'two', 'three'] * 3, .....: 'B': ['A', 'B', 'C'] * 4, .....: 'C': ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, .....: 'D': np.random.randn(12), .....: 'E': np.random.randn(12)}) df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 0 one A foo 0.310437 0.596380 1 one B foo 1.015415 -0.658475 2 two C foo 0.526326 1.851567 3 three A bar 1.502380 -1.316516 4 one B bar -1.752622 0.461646 5 one C bar 0.888497 0.703693 6 two A foo -0.629228 0.718748 7 three B foo 2.389784 0.049419 8 one C foo -0.890217 0.858487 9 one A bar -0.261845 -1.190759 10 two B bar -0.040979 -0.877174 11 three C bar -0.216170 -0.865147 pd.pivot_table(df, values='D', index=['A','B'], columns=['C']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C bar foo A B one A -0.261845 0.310437 B -1.752622 1.015415 C 0.888497 -0.890217 three A 1.502380 NaN B NaN 2.389784 C -0.216170 NaN two A NaN -0.629228 B -0.040979 NaN C NaN 0.526326 时间序列(TimeSeries) Pandas 为频率转换时重采样提供了虽然简单易用，但强大高效的功能， 如，将秒级的数据转换为 5 分钟为频率的数据。这种操作常见于财务应用程序，但又不仅限于此。详见时间序列。 rng = pd.date_range('1/1/2020', periods=10, freq='S') ts = pd.Series(np.random.randint(0, 20, len(rng)), index=rng) print(rng, ts, sep='\\n'*2) DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 00:00:01', '2020-01-01 00:00:02', '2020-01-01 00:00:03', '2020-01-01 00:00:04', '2020-01-01 00:00:05', '2020-01-01 00:00:06', '2020-01-01 00:00:07', '2020-01-01 00:00:08', '2020-01-01 00:00:09'], dtype='datetime64[ns]', freq='S') 2020-01-01 00:00:00 17 2020-01-01 00:00:01 0 2020-01-01 00:00:02 7 2020-01-01 00:00:03 12 2020-01-01 00:00:04 1 2020-01-01 00:00:05 15 2020-01-01 00:00:06 0 2020-01-01 00:00:07 10 2020-01-01 00:00:08 14 2020-01-01 00:00:09 8 Freq: S, dtype: int32 ts.resample('5Min').sum() 2020-01-01 84 Freq: 5T, dtype: int32 # 时区表示 rng = pd.date_range('2020/8/1', periods=5, freq='D') ts = pd.Series(np.random.randn(len(rng)), rng) ts_UTC = ts.tz_localize('UTC') print(ts, ts_UTC, sep='\\n'*3) 2020-08-01 -0.938967 2020-08-02 0.056395 2020-08-03 -1.249805 2020-08-04 -0.300962 2020-08-05 -1.635329 Freq: D, dtype: float64 2020-08-01 00:00:00+00:00 -0.938967 2020-08-02 00:00:00+00:00 0.056395 2020-08-03 00:00:00+00:00 -1.249805 2020-08-04 00:00:00+00:00 -0.300962 2020-08-05 00:00:00+00:00 -1.635329 Freq: D, dtype: float64 # 转换成其他时区 ts_UTC.tz_convert('US/Eastern') 2020-07-31 20:00:00-04:00 -0.938967 2020-08-01 20:00:00-04:00 0.056395 2020-08-02 20:00:00-04:00 -1.249805 2020-08-03 20:00:00-04:00 -0.300962 2020-08-04 20:00:00-04:00 -1.635329 Freq: D, dtype: float64 # 转换时间段 rng = pd.date_range('2020/8/1', periods=5, freq='M') ts = pd.Series(np.random.randn(len(rng)), rng) ps = ts.to_period() pts = ps.to_timestamp() print(ts, ps, pts, sep='\\n'*3) 2020-08-31 2.606606 2020-09-30 1.631934 2020-10-31 1.167378 2020-11-30 -0.376675 2020-12-31 -0.196782 Freq: M, dtype: float64 2020-08 2.606606 2020-09 1.631934 2020-10 1.167378 2020-11 -0.376675 2020-12 -0.196782 Freq: M, dtype: float64 2020-08-01 2.606606 2020-09-01 1.631934 2020-10-01 1.167378 2020-11-01 -0.376675 2020-12-01 -0.196782 Freq: MS, dtype: float64 可视化 详见可视化文档。 ts = pd.Series(np.random.randn(1000), index=pd.date_range('2020/1/1', periods=1000)) ts = ts.cumsum() ts.plot() DataFrame 的 plot() 方法可以快速绘制所有带标签的列： import matplotlib.pyplot as plt df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=['A', 'B', 'C', 'D']) df = df.cumsum() plt.figure(figsize=(30,10),dpi=80) df.plot() plt.legend(loc='best') "},"MachineLearning/MatplotlibNumpyPandas/Pandas_merge_concat_append.html":{"url":"MachineLearning/MatplotlibNumpyPandas/Pandas_merge_concat_append.html","title":"pandas连接合并追加","keywords":"","body":"Pandas 连接合并追加操作 concat concat(objs, axis=0, join='outer', ignore_index: bool = False, keys = None, levels = None, names = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) 连接 2 个Series s1 = pd.DataFrame([1,2,3]) s2 = pd.DataFrame([4,6,5]) s1 0 0 1 1 2 2 3 s2 0 0 4 1 6 2 5 pd.concat([s1, s2]) 0 0 1 1 2 2 3 0 4 1 6 2 5 # 忽略索引 pd.concat([s1, s2], ignore_index=True) 0 0 1 1 2 2 3 3 4 4 6 5 5 连接 2个 DataFrame # 普通连接(行) df1 = pd.DataFrame([['a', 1], ['b', 2]], columns=['letter', 'number']) df2 = pd.DataFrame([['c', 3], ['d', 4]], columns=['letter', 'number']) df1 letter number 0 a 1 1 b 2 df2 letter number 0 c 3 1 d 4 pd.concat([df1, df2]) letter number 0 a 1 1 b 2 0 c 3 1 d 4 # 普通连接(列) pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 c 3 1 b 2 d 4 # 如果字段不相同，填充 `Nan` df3 = pd.DataFrame([['c', 3, 'cat'], ['d', 4, 'dog']], columns=['letter', 'number', 'animal']) df3 letter number animal 0 c 3 cat 1 d 4 dog pd.concat([df1, df3], sort=False) letter number animal 0 a 1 NaN 1 b 2 NaN 0 c 3 cat 1 d 4 dog # 内连接(只连接相同字段) pd.concat([df1, df3], join='inner') letter number 0 a 1 1 b 2 0 c 3 1 d 4 # 排序后，列拼接 pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 c 3 1 b 2 d 4 df2.sort_values('number', ascending=False, inplace=True) # 这一步至关重要 df2.reset_index(drop=True, inplace=True) pd.concat([df1, df2], axis=1) letter number letter number 0 a 1 d 4 1 b 2 c 3 merge merge(left, right, how: str = 'inner', on = None, left_on = None, right_on = None, left_index: bool = False, right_index: bool = False, sort: bool = False, suffixes = ('_x', '_y'), copy: bool = True, indicator: bool = False, validate = None) 普通合并 df1 = pd.DataFrame({'lkey': ['foo', 'bar', 'baz', 'foo'], 'value': [1, 2, 3, 5]}) df2 = pd.DataFrame({'rkey': ['foo', 'bar', 'baz', 'foo'], 'value': [5, 6, 7, 8]}) df1 lkey value 0 foo 1 1 bar 2 2 baz 3 3 foo 5 df2 rkey value 0 foo 5 1 bar 6 2 baz 7 3 foo 8 df1.merge(df2, left_on='lkey', right_on='rkey') lkey value_x rkey value_y 0 foo 1 foo 5 1 foo 1 foo 8 2 foo 5 foo 5 3 foo 5 foo 8 4 bar 2 bar 6 5 baz 3 baz 7 df1.merge(df2, left_on='lkey', right_on='rkey',suffixes=('_left', '_right')) lkey value_left rkey value_right 0 foo 1 foo 5 1 foo 1 foo 8 2 foo 5 foo 5 3 foo 5 foo 8 4 bar 2 bar 6 5 baz 3 baz 7 内、左、右连接 df1 = pd.DataFrame({'a': ['foo', 'bar'], 'b': [1, 2]}) df2 = pd.DataFrame({'a': ['foo', 'baz'], 'c': [3, 4]}) df1 a b 0 foo 1 1 bar 2 df2 a c 0 foo 3 1 baz 4 df1.merge(df2, how='inner', on='a') a b c 0 foo 1 3 df1.merge(df2, how='left', on='a') a b c 0 foo 1 3.0 1 bar 2 NaN df1.merge(df2, how='right', on='a') a b c 0 foo 1.0 3 1 baz NaN 4 # 相同值，但是不同的字段名，左连接 df3 = pd.DataFrame({'d': ['foo', 'baz'], 'c': [3, 4]}) df3 d c 0 foo 3 1 baz 4 df1.merge(df3, how='left', left_on='a', right_on='d') a b d c 0 foo 1 foo 3.0 1 bar 2 NaN NaN 笛卡尔积 df1 = pd.DataFrame({'left': ['foo', 'bar']}) df2 = pd.DataFrame({'right': [7, 8]}) df1 left 0 foo 1 bar df2 right 0 7 1 8 df1.merge(df2, how='cross') left right 0 foo 7 1 foo 8 2 bar 7 3 bar 8 append append(other, ignore_index=False, verify_integrity=False, sort=False) 普通追加 df = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB')) df A B 0 1 2 1 3 4 df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB')) df2 A B 0 5 6 1 7 8 df.append(df2) A B 0 1 2 1 3 4 0 5 6 1 7 8 df.append(df2, ignore_index=True) A B 0 1 2 1 3 4 2 5 6 3 7 8 # 通过 for 循环追加 df = pd.DataFrame(columns=['A']) for i in range(5): df = df.append({'A': i}, ignore_index=True) df A 0 0 1 1 2 2 3 3 4 4 # 等价于 concat 连接，如下 pd.concat([pd.DataFrame([i], columns=['A']) for i in range(5)],ignore_index=True) A 0 0 1 1 2 2 3 3 4 4 "},"MachineLearning/MatplotlibNumpyPandas/matplotlib基础.html":{"url":"MachineLearning/MatplotlibNumpyPandas/matplotlib基础.html","title":"matplotlib基础","keywords":"","body":"matplotlib基础 中文文档 import matplotlib.pyplot as plt import random import pandas as pd from matplotlib import font_manager as fm %matplotlib inline matplotlib设置中文字体 # 配置中文字体： my_font = fm.FontProperties(fname=r\"C:\\Users\\Admin\\AppData\\Local\\Microsoft\\FontCache\\CloudFonts\\TTC\\107373335009.ttc\") x = range(2, 26, 2) # x轴数据 y = list(range(22, 46, 2)) # y轴数据 random.shuffle(y) 基本用法 双击可查看大图 # 基本用法 plt.plot(x, y) # 绘制 plt.grid(alpha=0.5) # 绘制网格（会根据x和y轴的刻度间隔绘制） alpha:透明度：0-1 plt.show() # 展示 设置图标大小和分辨率 # 设置图标大小 # figure图形图标的意思，在这里指的是我们画的图 # 通过实例化一个figure并且传递参数，能够在后台自动使用该figure实例 # 在图形模糊的时候可以传入dpi参数，让图形更清晰（每一英寸上的像素点） fig = plt.figure(figsize=(20, 8), dpi=100) plt.plot(x, y) # 图片保存(还可以保存为svg这种矢量图格式，放大不会有锯齿) # plt.savefig(\"./t1.png\") plt.show() 设置x轴和y轴刻度间隔 # 设置x轴和y轴刻度间隔 # 当刻度太密集时候使用列表的步长（间隔取值）来取值，matplotlib会自动帮我们对应 plt.figure(figsize=(25, 15)) plt.subplot(3,3,1) plt.plot(x, y) plt.xticks(x) plt.grid() # 设置y的刻度 plt.yticks(range(min(y),max(y)+1)[::2]) plt.subplot(3,3,2) plt.plot(x, y) plt.xticks(range(2, 26)) plt.subplot(3,3,3) plt.plot(x, y) plt.xticks(range(2, 26, 3)) plt.subplot(3,3,4) plt.plot(x, y) _xtick_labels = [i+0.5 for i in range(2,26)] plt.xticks(_xtick_labels) plt.subplot(3,3,5) plt.plot(x, y) _xtick_labels = [i+0.5 for i in range(2,26)] plt.xticks(_xtick_labels[::3]) plt.subplot(3,3,6) plt.plot(x, y) # 需注意x绘制的是2到26的值，超过了就没有可以绘制了 plt.xticks(range(26, 50, 2)) plt.show() # 绘制11点到1点每一分钟的气温变化 tmp = [random.randint(20, 45) for _ in range(120)] minus = pd.date_range('2020-07-28 11:00:00', '2020-07-28 13:00:00', freq='T') minus DatetimeIndex(['2020-07-28 11:00:00', '2020-07-28 11:01:00', '2020-07-28 11:02:00', '2020-07-28 11:03:00', '2020-07-28 11:04:00', '2020-07-28 11:05:00', '2020-07-28 11:06:00', '2020-07-28 11:07:00', '2020-07-28 11:08:00', '2020-07-28 11:09:00', ... '2020-07-28 12:51:00', '2020-07-28 12:52:00', '2020-07-28 12:53:00', '2020-07-28 12:54:00', '2020-07-28 12:55:00', '2020-07-28 12:56:00', '2020-07-28 12:57:00', '2020-07-28 12:58:00', '2020-07-28 12:59:00', '2020-07-28 13:00:00'], dtype='datetime64[ns]', length=121, freq='T') x轴和y轴添加描述信息 plt.figure(figsize=(30, 10)) plt.plot(tmp) # x = range(120)[::2] # _xtick_labels = [\"a{0}\".format(i) for i in x] # plt.xticks(x ,_xtick_labels) # 刻度字符串映射 # 刻度数据长度和x轴数据长度需对应 # rotation=90旋转90度 plt.xticks(range(120)[::2], minus[::2], rotation=45, fontsize=15) plt.yticks(fontsize=20) plt.xlabel(\"时间\", fontproperties=my_font, fontsize=50) plt.ylabel(\"温度\", fontproperties=my_font, fontsize=50) plt.title(\"11点到1点每一分钟的气温变化\",fontproperties=my_font, fontsize=50) plt.show() 绘制多次图像很不同图像的差异 绘制的时候指定 color：颜色 linestyle：线条风格 linewidth：线条粗细 alpha：透明度 颜色字符 风格字符 r红色 -实线 g绿色 --虚线，破折线 b蓝色 -.点划线 w白色 :点虚线，虚线 ''留空或空格，无线条 c青色 m洋红 y黄色 k黑色 #00ff0016进制 0.8灰度值字符串 y_1 = [random.randint(1,50) for _ in range(25)] y_2 = [random.randint(1,50) for _ in range(25)] plt.figure(figsize=(20,10)) plt.plot(y_1, label=\"y1的线\", linestyle='-.') plt.plot(y_2, label=\"y2的线\", color='r') plt.grid(linestyle=\"--\") # 添加图例(展示上面的label) # prop：字体 # loc：位置 plt.legend(prop=my_font, loc=\"best\") plt.show() 散点图 y1 = [random.randint(20, 45) for _ in range(30)] y2 = [random.randint(20, 45) for _ in range(30)] x1 = range(1, 31) x2 = range(51, 81) plt.figure(figsize=(20,10),dpi=80) #散点图 plt.scatter(x1, y1, label=\"3月份\") plt.scatter(x2, y2, label=\"10月份\") # 修改x轴刻度 _x = list(x1) + list(x2) _xtick_label = [\"3月{0}日\".format(i) for i in x1] _xtick_label += [\"10月{0}日\".format(i-50) for i in x2] plt.xticks(_x[::2], _xtick_label[::2], fontproperties=my_font, rotation=45, fontsize=10) # 添加描述信息 plt.xlabel(\"时间\", fontproperties=my_font, fontsize=20) plt.ylabel(\"温度\", fontproperties=my_font, fontsize=20) # t添加图例 plt.legend(prop=my_font, handlelength=5, handleheight=5, fontsize=50) plt.show() 条形图 a = [\"战狼2\",\"速度与激情8\",\"功夫瑜伽\",\"西游伏妖篇\",\"变形金刚5：最后的骑士\",\"摔跤吧！爸爸\",\"加勒比海盗5：死无对证\",\"金刚：骷髅岛\",\"极限特工：终极回归\",\"生化危机6：终章\",\"乘风破浪\",\"神偷奶爸3\",\"智取威虎山\",\"大闹天竺\",\"金刚狼3：殊死一战\",\"蜘蛛侠：英雄归来\",\"悟空传\",\"银河护卫队2\",\"情圣\",\"新木乃伊\",] b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] x = range(len(a)) plt.figure(figsize=(20,10)) # width：宽度 plt.bar(x, b, width=0.5) # 修改x轴信息 plt.xticks(x, a, fontproperties=my_font, fontsize=15, rotation=90) plt.show() 横条形图 a = [\"战狼2\",\"速度与激情8\",\"功夫瑜伽\",\"西游伏妖篇\",\"变形金刚5：最后的骑士\",\"摔跤吧！爸爸\",\"加勒比海盗5：死无对证\",\"金刚：骷髅岛\",\"极限特工：终极回归\",\"生化危机6：终章\",\"乘风破浪\",\"神偷奶爸3\",\"智取威虎山\",\"大闹天竺\",\"金刚狼3：殊死一战\",\"蜘蛛侠：英雄归来\",\"悟空传\",\"银河护卫队2\",\"情圣\",\"新木乃伊\",] b=[56.01,26.94,17.53,16.49,15.45,12.96,11.8,11.61,11.28,11.12,10.49,10.3,8.75,7.55,7.32,6.99,6.88,6.86,6.58,6.23] x = range(len(a)) plt.figure(figsize=(20,10)) # height：宽度(因为是横条形图，所以是高度) plt.barh(x, b, height=0.5, color='orange') # 修改y轴信息(横条形图) plt.yticks(x, a, fontproperties=my_font, fontsize=20) # 网格 plt.grid() plt.show() 绘制多次条形图 a = [\"猩球崛起3：终极之战\",\"敦刻尔克\",\"蜘蛛侠：英雄归来\",\"战狼2\"] b_16 = [15746,312,4497,319] b_15 = [12357,156,2045,168] b_14 = [2358,399,2358,362] bar_width = 0.2 plt.figure(figsize=(20,10)) x16 = list(range(len(a))) x15 = [i+bar_width for i in x16] # 移动2个宽度 x14 = [i+bar_width*2 for i in x16] plt.bar(x16, b_16, width=bar_width, label=\"16日票房\") plt.bar(x15, b_15, width=bar_width, label=\"15日票房\") plt.bar(x14, b_14, width=bar_width, label=\"14日票房\") # 设置x刻度(因为刻度是在黄色上，即x15对应一下即可，x16和x14对应也可以就是标注会左右移动一点) plt.xticks(x15, a,fontproperties=my_font, fontsize=25) plt.grid() plt.legend(prop=my_font) plt.show() 直方图 组数：将数据分组，如果数据在100个以内，按数据多少分为5-12组 组距：指每个小组的两个端点的距离 组数 = 极值 / 组距 = (max(a) - min(a)) / bin_width 原始数据 如果是统计之后的数据，需要用条形图绘制 a=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150] plt.figure(figsize=(20, 15)) # 计算组数 bin_width = 3 num_bins = (max(a) - min(a)) // bin_width # 频数分布直方图 plt.subplot(2,1,1) # 也可以传一个列表，长度为组数，值为分组依据，当组距不均匀的时候使用 plt.hist(a, num_bins) # 设置x刻度 plt.xticks(range(min(a), max(a) + bin_width, bin_width)) plt.xlabel(\"电影时长(分钟)\", fontproperties=my_font, fontsize=20) plt.ylabel(\"频数\", fontproperties=my_font, fontsize=30) plt.title(\"频数分布直方图\", fontproperties=my_font, fontsize=30) plt.grid() # 频率分布直方图（density=1） plt.subplot(2,1,2) plt.hist(a, num_bins, density=1) plt.xticks(range(min(a), max(a) + bin_width, bin_width)) plt.xlabel(\"电影时长(分钟)\", fontproperties=my_font, fontsize=20) plt.ylabel(\"频率\", fontproperties=my_font, fontsize=30) plt.title(\"频率分布直方图\", fontproperties=my_font, fontsize=30) plt.grid() plt.show() 统计后数据 在美国2004年人口普查发现有124 million的人在离家相对较远的地方工作。根据他们从家到上班地点所需要的时间,通过抽样统计(最后一列)出了下表的数据,这些数据能够绘制成直方图么? # 还有些疑问 interval = [0,5,10,15,20,25,30,35,40,45,60,90] width = [5,5,5,5,5,5,5,5,5,15,30,60] quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47] plt.figure(figsize=(20,10), dpi=80) plt.bar(interval, quantity, width=width) x = interval _xtick_label = interval.append(150) plt.xticks(x, _xtick_label) # plt.grid() plt.show() "},"Web/Web前端概述.html":{"url":"Web/Web前端概述.html","title":"Web前端入门","keywords":"","body":"datetime:2019/5/17 17:12 author:nzb Web前端概述 说明：本文使用的部分插图来自Jon Duckett先生的HTML and CSS: Design and Build Websites一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。 HTML简史 1991年10月：一个非正式CERN（欧洲核子研究中心）文件首次公开18个HTML标签，这个文件的作者是物理学家蒂姆·伯纳斯-李，因此他是万维网的发明者，也是万维网联盟的主席。 1995年11月：HTML 2.0标准发布（RFC 1866）。 1997年1月：HTML 3.2作为W3C推荐标准发布。 1997年12月：HTML 4.0作为W3C推荐标准发布。 1999年12月：HTML4.01作为W3C推荐标准发布。 2008年1月：HTML5由W3C作为工作草案发布。 2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。 2012年12月：W3C指定HTML5作为“候选推荐”阶段。 2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。 HTML5新特性 引入原生多媒体支持（audio和video标签） 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持 使用标签承载内容 结构 head title meta body 文本 标题和段落 h1 ~ h6 p 上标和下标 sup sub 空白（白色空间折叠） 折行和水平标尺 br hr 语义化标签 加粗和强调 - strong 引用 - blockquote 缩写词和首字母缩写词 - abbr / acronym 引文 - cite 所有者联系信息 - address 内容的修改 - ins / del 列表（list） 有序列表（ordered list）- ol / li 无序列表（unordered list）- ul / li 定义列表（definition list）- dl / dt / dd 链接（anchor） 页面链接 锚链接 功能链接 图像（image） 图像存储位置 图像及其宽高 选择正确的图像格式 JPEG GIF PNG 矢量图 语义化标签 - figure / figcaption 表格（table） 基本的表格结构 - table / tr / td 表格的标题 - caption 跨行和跨列 - rowspan属性 / colspan属性 长表格 - thead / tbody / tfoot 表单（form） 重要属性 - action / method 表单控件（input）- type属性 文本框 - text / 密码框 - password / 数字框 - number 邮箱 - email / 电话 - tel / 日期 - date / 滑条 - range / URL - url / 搜索 - search 单选按钮 - radio / 复选按钮 - checkbox 文件上传 - file / 隐藏域（埋点）- hidden 提交按钮 - submit / 图像按钮 - image / 重置按钮 - reset 下拉列表 - select / option 文本域（多行文本）- textarea 组合表单元素 - fieldset / legend 音视频（audio / video） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster 其他 文档类型 注释 属性 id class 块级元素 / 行级元素 内联框架（internal frame） 字符实体（实体替换符） 使用CSS渲染页面 简介 CSS的作用 CSS的工作原理 规则、属性和值 常用选择器 颜色（color） 如何指定颜色 颜色术语和颜色对比 背景色 文本（text / font） 文本的大小和字型(font-size / font-family) 粗细、样式、拉伸和装饰(font-weight / font-style / font-stretch / text-decoration) 行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing) 对齐(text-align)方式和缩进(text-ident) 链接样式（:link / :visited / :active / :hover） CSS3新属性 阴影效果 - text-shadow 首字母和首行文本(:first-letter / :first-line) 响应用户 盒子（box model） 盒子大小的控制（width / height） 盒子的边框、外边距和内边距（border / margin / padding） 盒子的显示和隐藏（display / visibility） CSS3新属性 边框图像（border-image） 投影（border-shadow） 圆角（border-radius） 列表、表格和表单 列表的项目符号（list-style） 表格的边框和背景（border-collapse） 表单控件的外观 表单控件的对齐 浏览器的开发者工具 图像 控制图像的大小（display: inline-block） 对齐图像 背景图像（background / background-image / background-repeat / background-position） 布局 控制元素的位置（position / z-index） 普通流 相对定位 绝对定位 固定定位 浮动元素（float / clear） 网站布局 HTML5布局 适配屏幕尺寸 固定宽度布局 流体布局 布局网格 使用JavaScript控制行为 JavaScript基本语法 语句和注释 变量和数据类型 声明和赋值 简单数据类型和复杂数据类型 变量的命名规则 表达式和运算符 赋值运算符 算术运算符 比较运算符 逻辑运算符 分支结构 if...else... switch...cas...default... 循环结构 for循环 while循环 do...while循环 数组 创建数组 操作数组中的元素 函数 声明函数 调用函数 参数和返回值 匿名函数 立即调用函数 面向对象 对象的概念 创建对象的字面量语法 访问成员运算符 创建对象的构造函数语法 this关键字 添加和删除属性 delete关键字 标准对象 Number / String / Boolean / Symbol / Array / Function Date / Error / Math / RegEx / Object / Map / Set JSON / Promise / Generator / Reflect / Proxy BOM window对象的属性和方法 history对象 forward() / back() / go() location对象 navigator对象 screen对象 DOM DOM树 访问元素 getElementById() / querySelector() getElementsByClassName() / getElementsByTagName() / querySelectorAll() parentNode / previousSibling / nextSibling / children / firstChild / lastChild 操作元素 nodeValue innerHTML / textContent / createElement() / createTextNode() / appendChild() / insertBefore() / removeChild() className / id / hasAttribute() / getAttribute() / setAttribute() / removeAttribute() 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement） type cancelable preventDefault() stopPropagation()（低版本IE中的cancelBubble） 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload JavaScript API 客户端存储 - localStorage和sessionStorage localStorage.colorSetting = '#a4509b'; localStorage['colorSetting'] = '#a4509b'; localStorage.setItem('colorSetting', '#a4509b'); 获取位置信息 - geolocation navigator.geolocation.getCurrentPosition(function(pos) { console.log(pos.coords.latitude) console.log(pos.coords.longitude) }) 从服务器获取数据 - Fetch API 绘制图形 - 的API 音视频 - 和的API 使用jQuery jQuery概述 Write Less Do More（用更少的代码来完成更多的工作） 使用CSS选择器来查找元素（更简单更方便） 使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法） 引入jQuery 下载jQuery的开发版和压缩版 从CDN加载jQuery window.jQuery || document.write('') 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent>child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains('…') / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute='value'] / [attribute!='value'] / [attribute^='value'] / [attribute$='value'] / [attribute|='value'] / [attribute~='value'] 表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 链式操作 检测页面是否可用 $(document).ready(function() { }); $(function() { }); jQuery插件 jQuery Validation jQuery Treeview jQuery Autocomplete jQuery UI 避免和其他库的冲突 先引入其他库再引入jQuery的情况。 jQuery.noConflict(); jQuery(function() { jQuery('div').hide(); }); 先引入jQuery再引入其他库的情况。 jQuery(function() { jQuery('div').hide(); }); 使用Ajax Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 原生的Ajax 基于jQuery的Ajax 加载内容 提交表单 前端框架 渐进式框架 - Vue.js 前后端分离开发（前端渲染）必选框架。 快速上手 引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。 数据绑定（声明式渲染 ）。 库存信息 const app = new Vue({ el: '#app', data: { product: 'iPhone X' } }); 条件与循环。 库存信息 - 已经售罄 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] } }); 计算属性。 库存信息 - 已经售罄 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 处理事件。 库存信息 - 已经售罄 增加库存 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 用户输入。 库存信息 - 已经售罄 增加库存 库存总量：台 const app = new Vue({ el: '#app', data: { products: [ {\"id\": 1, \"name\": \"iPhone X\", \"quantity\": 20}, {\"id\": 2, \"name\": \"华为 Mate20\", \"quantity\": 0}, {\"id\": 3, \"name\": \"小米 Mix3\", \"quantity\": 50} ] }, computed: { totalQuantity() { return this.products.reduce((sum, product) => { return sum + product.quantity }, 0); } } }); 通过网络加载JSON数据。 库存信息 - 已经售罄 const app = new Vue({ el: '#app', data: { products: [] }， created() { fetch('https://jackfrued.top/api/products') .then(response => response.json()) .then(json => { this.products = json }); } }); 使用脚手架 - vue-cli Vue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。 安装脚手架。 创建项目。 安装依赖包。 运行项目。 UI框架 - Element 基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。 引入Element的CSS和JavaScript文件。 一个简单的例子。 点我 开始使用Element吧 new Vue({ el: '#app', data: { visible: false, } }) 使用组件。 new Vue({ el: '#app', data: { tableData: [ { date: '2016-05-02', name: '王一霸', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '刘二狗', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '杨三萌', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '陈四吹', address: '上海市普陀区金沙江路 1516 弄' } ] } }) 报表框架 - ECharts 百度出品的开源可视化库，常用于生成各种类型的报表。 基于弹性盒子的CSS框架 - Bulma Bulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。 Bulma div { margin-top: 10px; } .column { color: #fff; background-color: #063; margin: 10px 10px; text-align: center; } 1 2 3 4 Primary Link Info Success Warning Danger 60% One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve 响应式布局框架 - Bootstrap 用于快速开发Web应用程序的前端框架，支持响应式布局。 特点 支持主流的浏览器和移动设备 容易上手 响应式设计 内容 网格系统 封装的CSS 现成的组件 JavaScript插件 可视化 "},"Web/HTML5/HTML5.html":{"url":"Web/HTML5/HTML5.html","title":"HTML5","keywords":"","body":"datetime:2019/7/1 9:43 author:nzb HTML5元素 元素指的是从开始标签到结束标签的所有代码 开始标签 元素内容 结束标签 this is my web page HTML元素语法： 元素的内容是开始标签与结束标签之间的内容 空元素在开始标签进行关闭 大多数HTML元素拥有属性 嵌套HTML元素 HTML5属性使用方法 标签可以拥有属性为元素提供更多的信息 属性以键值对的形式出现。 如：href=\"www.baidu.com\" 常用标签属性： :align对齐方式 :bgcolor背景颜色 :target规定在何处打开链接 通用属性 class：规定元素的类名 id：规定元素唯一id style：规定元素的样式 title：规定元素的额外信息 HTML5格式化 标签 描述 定义粗体文本 定义大号字,在HTML5取消采用CSS代替 定义着重文字 定义斜体字 定义小号字 定义加重语气 定义下标字 定义上标字 定义插入字 定义删除字 HTML5样式 标签： ：样式定义 ：资源引用 属性： rel=\"stylesheet\"：外部样式表 type=\"text/css\"：引入文档的类型 margin-left：边距 三种样式表插入方法： 外部样式表： 内部样式表： body{background-color: red} p{margin-left: 20px;} 内联样式表： HTML5链接 链接数据： 文本链接 图片链接 属性： href属性：指向另一个文档的链接 name属性：创建文档内的链接 img标签属性： alt：替换文本属性 width：宽 height：高 HTML5表格 标签 描述 定义表格 定义表格标题 定义表格的表头 定义表格的行 定义表格的单元 定义表格的页眉 定义表格的主体 定义表格的页脚 定义表格的列属性 没有边框的表格：不加border属性 表格中的表头：表头 空单元格：不书写内容即可 带有标题的表格：标题 表格内的标签： 单元4 单元5 苹果 香蕉 桃子 单元格边距：cellpadding=\"20\" 单元格间距：cellspacing=\"10\" 表格内背景颜色和图像：bgcolor=\"red\" HTML5列表 标签 描述 有序列表 无序列表 列表项 列表 列表项 描述 无序列表 使用标签：、 属性：disc、circle、square 有序列表 使用标签：、 属性：A、a、I、i、start 嵌套列表 使用标签：、、 自定义列表 使用标签：、、 HTML5块 HTML块元素 块元素在显示时，通常会以新行开始。 如：、、 HTML内联元素 内联元素通常不会以新行开始。 如：、、 HTML元素 元素也被称为块元素，其主要是组合HTML元素的容器 HTML元素 元素是内联元素，可作为文本的容器 HTML5布局 使用元素布局 div布局 body{ margin: 0px; } #container{ width: 100%; height: 950px; background-color: gray; } #heading{ width: 100%; height: 10%; background-color: #1b6d85; } #content_menu{ width: 30%; height: 80%; background-color: #5cb85c; /*从左到右浮动*/ float: left; } #content_body{ width: 70%; height: 80%; background-color: #8a6d3b; float: left; } #footing{ width: 100%; height: 10%; background-color: #985f0d; /*清除浮动*/ clear: both; } 头部 内容菜单 内容主体 底部 使用元素布局 table布局 这是头部 view code other 主体 右菜单 底部 HTML5表单 表单用于获取不同类型的用户输入 常用表单标签 表单 输入域 文本域 控制标签 定义域 域的标题 选择列表 选项组 下拉列表中的选项 按钮 HTML5框架 框架标签(frame):(HTML5已过时) 框架对于页面的设计有着很大的作用 框架集标签():(HTML5中已过时) 框架集标签定义如何将窗口分隔为框架 每一个frameset定义一系列行或列 rows/cols的值规定了每行或每列占据屏幕的面积 常用标签： noresize：固定框架大小 cols：列 rows：行 内联框架(HTML5主要使用的) iframe target属性： _self：当前frame打开 _blank：新窗口打开 _parent：父级frame打开 _top：当前窗口打开 frame.html frame 百度--> framea.html Title framea 百度一下 --> frameb.html Title frameb framec.html Title framec HTML5背景 背景标签： Background 背景颜色 Bgcolor 颜色： 颜色是由一个十六进制符号来定义，这个符号由红色、蓝色和绿色的值组成(RGB) 颜色值最小值：0(#00) 颜色值最大值：255(#FF) 红色：#FF0000 绿色：#00FF00 蓝色：#0000FF HTML5实体 实体 HTML中预留字符串必须被替换成字符实体。如：、& XHTML的规范化 什么是XHTML? XHTML指的是可扩展超文本标记语言 XHTML与HTML4.01几乎是相同的 XHTML是更严格更纯净的HTML版本 XHTML是以XML应用的方式定义的HTML XHTML得到所有主流浏览器的支持 为什么使用XHTML? 为了代码的完整性和良好性 文档声明： DTD：规定了使用通用标记语言的网页语法 三种XHTML文档类型 STRICT(严格类型) TRANSITIONAL(过度类型) FRAMESET(框架类型) XHTML元素语法： XHTML元素必须嵌套 XHTML元素必须始终关闭 XHTML元素必须小写 XHTML文档必须有一个根元素 XHTML属性语法规则： XHTML属性必须使用小写 XHTML属性值必须用引号包围 XHTML属性最小化也是禁止的 HTML5新特性 引入原生多媒体支持（audio和video标签） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持 HTML5新增的主体结构元素 article元素 article元素代表文档、页面或应用程序中独立的、完整的、可以独立被外部引用的内容。它可以是一篇博客或者报刊中的一篇文章，一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。 article元素可以嵌套使用，也可以用来表示插件。 article元素 英雄联盟 欢迎来到英雄联盟 作者 评论 time 这是底部 这是一个内嵌页面 section元素 section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由其内容及标题组成。但section元素并非一个普通的容器元素；当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section元素。 section元素 苹果 这是一个苹果 苹果 这是一个苹果 红富士 这是苹果的一种 国光 这是苹果的一种 水果 苹果 内容 苹果 内容 苹果 内容 section与article的区别 section的作用强调对文章或页面进行分段、分块，而article元素强调独立性 section使用总结：1、不要将section元素作为设置样式的页面容器，那是div的工作。2、如果使用article、aside、nav元素更符合使用条件，那就不要使用section元素。3、没有标题内容，不要使用section元素。 nav元素 nav元素是一个可以用作页面导航的连接组，其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的连接组都要被放进nav元素，只需要将主要的、基本的连接组放进nav元素即可。nav的应用场景：传统导航栏、侧边导航栏、页内导航、翻页操作。 nav元素 主页 开发文档 html5与css3的历史 html5历史 css3历史 css3的历史 ... 删除 修改 版权声明 HTML5中不能使用menu元素代替nav元素 aside元素 -aside元素用来表示当前页面或文章的附属信息部分，它可以包含于当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有区别于主要内容的部分。 aside元素 js入门 语法 文章的正文。。。 名词解释 语法：。。。。。。。 评论 2019-7-1 好好学习 time元素和微格式 time元素 2019-7-1 2019-7-1 2019-7-1 2019-7-1 苹果 发布时间 2019-7-1 舞会事件 2019-7-2 HTML5新增的非主体结构元素 header元素 Header元素是一种具有引导和导航作用的结构元素，通常放置整个页面或页面内的一个内容区域的标题，但是也可以包含其他内容列如数据表格，搜索表单或相关Logo图片！ header元素 it最新技术 信息 信息1 信息2 footer元素 footer元素可作为上层父级内容区块或是一个根区块的脚注。footer通常包括相关区块的脚注信息，如作者，相关阅读连接及其版权信息等。 footer元素 --> 版权信息 版权信息 版权信息 版权信息 --> 这是文章的底部 这是块底部 hgroup元素(已废除) hgroup元素是将标题及其子标题进行分组的元素。 hgroup元素通常被分为H1~H6元素进行分组，如一个内容区块的标题及其子元素算一组。 hgroup元素 这是文章标题 这是一个子标题 2019-7-1 这是内容 这是底部 address元素 address元素用来存放文档中呈现的联系信息，文档作者，等等的名字 网站链接 电子邮箱 真实地址 电话号码 等 address元素 a b c 百度一下 2019-7-1 网页编排规则 网页标题 文章主标题 文章子标题 文章正文 评论标题 评论正文 版权所有：hawen 表单新增元素与属性 表单内元素的form属性 在Html4中，表单内的从属元素必须写在表单内部，而在HTML5中，可以把它们书写在页面的任何地方，然后为该元素指定一个form属性，属性值为该表单的id。 这样九可以声明该元素从属于指定表单了。 表单内元素的formaction属性 在HTML4中，一个表单内的所有元素只能通过表单的action属性统一提交到另一个页面，而在HTML5中可以为所有的提交按钮。 表单内元素的formmethod属性 在HTML4中，一个表单内只有一个action属性用来对表单内所有元素统一指定提交页面，所以每个表单内也只有一个method属性来统一指定提交方法。 在HTML5中，可以使用formmethod属性来对每个表单元素分别指定不同的提交方法。 表单内元素的formenctype属性 在HTML4中，表单元素具有一个enctype属性，该属性用于指定在表单发送到服务器之前应该如何对表单内的数据进行编码。 application/x-www-from-urlencoded：编码方式把表单数据转换成一个字符串形式?a=value1&b=value2&c=value3,然后把这个字符串价到提交的目标URL地址后面。 该属性为表单enctype属性的默认属性值。 multipart/form-data:不对字符编码,在使用包含文件上传控件的表单时，必须使用该值。 text/plain:对表单数据中的空格被转换为\"+\",但不对表单数据中的特殊字符进行编码。 在HTML5中，可以使用formenctype属性对表单元素分别指定不同的编码方式。 文件: 表单内元素的formtarget属性 在HTML4中，表单元素具有一个target属性，该属性用于指定在何处打开表单提交后，所需要加载的页面。 _blank:在新的浏览器窗口中打开。 _self:默认值，在相同的框架中打开。 _parent:在当前框架的父框架中打开。 _top:在当前浏览器窗口中打开。 framename:在指定的框架中打开。 在HTML5中，可以对多个提交按钮分别使用formtarget属性来指定提交后在何处打开所需要加载的页面。 表单内元素的autofocus属性 文本框、选择框或按钮加上autofocus属性，当页面打开时，该控件自动获取光标焦点。一个页面上只能有一个控件具有autofocus属性。 表单内元素的required属性 HTML5中新增的required属性可以应用在大多数输入元素上，在提交时，将验证输入内容是否合法，如果不合法则不允许提交，同时在浏览器显示相应的提示信息。 表单内元素的labels属性 在HTML5中，为所有可使用label的表单元素，定义一个labels属性，属性值为一个NodeList对象，代表该元素所绑定的标签元素构成的集合。 var TxtName=document.getElementById(\"txt_name\"); alert(TxtName.labels.length); 名字: 标签的control属性 在HTML5中，可以在标签内部放置一个表单元素，并且通过该标签的control属性来访问该表单元素。 邮编: 请输入六位数字 function setValue(){ var label = document.getElementById('label'); var textbox = label.control; textbox.value='10010'; } 文本框的placeholder属性 placeholder是指当文本框处于微输入状态时显示的输入提示。 文本框的list属性 HTML5中,为增加了一个list属性，该属性的值为某个datalist的id。 datalist元素也是HTML5中新增的元素，该元素类似于选择框(Select元素),但是当用户想要设定的值不在选择列表之内时，允许自行输入。 datalist元素本身并不显示，而是当文本框获取焦点时以提示输入的方式显示。 你好 早上 文本框的AutoComplete属性 辅助输入所用的自动完成功能，时一个即节省输入时间又十分方便的功能。在HTML5之前，因为谁都可以看见输入的值，所以在安全方面存在缺陷。 对于autocomplete属性，可以指定\"on\"、\"off\"与\"\"(不指定)这三种值。在不进行指定时，使用浏览器的默认值。把该属性设为on时， 可以显示指定候补输入的数据列表。使用datalist元素与list属性提供候补输入的数据列表，在执行自动完成时， 可以将该datalist元素中的数据作为候补输入的数据在文本框中自动显示。 文本框的pattern属性 在HTML5中，对input元素使用pattern属性，并且将属性值设置某个格式的正则表达式时，在提交时会对这些进行检查，检查其内容是否符合给定格式。 文本框的SelectDirection属性 对input 元素和textarea 元素，HTML5增加了SelectionDirection属性。当用户在这两个元素中用户鼠标选取部分文字时， 可以使用属性来获取选取方向。正向选取:forward,反向选取为:backward。 复选框的indeterminate属性 对复选框checkbox元素来说，过去只有选取与非选取两种状态。在HTML5中，可以在Javascript脚本代码中对该元素使用indeterminate属性， 以说明复选框处于\"尚未明确是否选取的状态\"。indeterminate属性为boolean 类型 当为true 时，浏览器中的复选框将显示为不明状态。 需要注意的时，indeterminate属性与checked属性时两种不同的属性。因此，在判断复选框时，应该现判断indeterminate属性值，然后在判断checked属性值。 var cb = document.getElementById('cb'); cb.indeterminate = true; image提交按钮的height属性与width属性 针对类型为image的input元素，HTML5新增了两个属性，height、width分别用来指定图片的高、宽。 "},"Web/CSS/CSS.html":{"url":"Web/CSS/CSS.html","title":"CSS","keywords":"","body":"datetime:2019/7/2 9:40 author:nzb CSS基础语法 `selector { property:value }` 例：h1{color:red;font-size:14px;} 属性大于1个之后，属性之间用分号隔开，如果值大于一个单词，则需要加上引号：p{font-family:\"sans serif\"} 浏览器读取 CSS 的顺序是从上到下，这意味着，在发生冲突时，浏览器会使用最后的 CSS 声明。后面的会覆盖前面的。 id 声明都会覆盖 class 声明。行内样式会覆盖其他声明。 多情况下，你会使用 CSS 库，这些库可能会意外覆盖掉你自己的 CSS。所以当你需要确保某元素具有指定的 CSS 时，你可以使用 !important。 CSS高级语法 选择器分组： h1,h2,h3,h4,h5{color:red;} 继承：body{color:green} 派生选择器 通过依据元素在其位置的上下文关系来定义样式 address元素 li strong{ color: red; } strong{ color: gray; } 文章1 文章2 id选择器 id选择器可以为标有id的HTML元素指定特定的样式 id选择器以\"#\"来定义 目前比较常用的方式是id选择器常常用于建立派生选择器 address元素 #div1{ color: red; } #div1 a{ color: blue; } 这是一个div 这是超链接 类选择器 类选择器以一个点显示 class也可以作为派生选择器 address元素 .dclass p{ color: red; } 这是一个p标签 属性选择器 属性选择器：对带有指定属性的HTML元素设置样式 属性和值选择器 address元素 [title]{ color:red; } [title=te]{ color: blue; } 这是一个p标签 这是一个p标签 CSS背景 CSS允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果 属性 描述 backgroud-attachment 背景图是否或者随着页面的其余部分滚动 backgroud-color 设置元素的背景颜色 backgroud-image 把图片设置为背景 backgroud-position 设置背景图片的起始位置 backgroud-repeat 设置背景图片是否及如何重复 backgroud-size 规定背景图片的尺寸 backgroud-origin 规定背景图片的定位区域 backgroud-clip 规定背景的绘制区域 CSS文本 属性 描述 color 文本颜色 direction 文本方向 line-height 行高 letter-spacing 字符间距 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-transform 元素中的字母 unicode-bidi 设置文本方向 white-space 元素中空白的处理方式 word-spacing 字间距 CSS3文本效果 属性 描述 text-shadow 向文本添加阴影 word-wrap 规定文本的换行规则 CSS 字体 CSS字体属性定义文本的字体系列、大小、加粗、风格和变形 属性 描述 font-family 设置字体系列 font-size 设置字体的尺寸 font-style 设置字体风格 font-variant 以小型大写字体或正常字体显示文本 font-weight 设置字体的粗细 CSS链接 CSS链接的四种状态 a:link 普通的、未被访问的链接 a:visited 用户已访问的链接 a:hover 鼠标指针位于链接的上方 a:active 链接被点击的时刻 常见的链接方式 text-decoration 属性大多用于去掉链接中的下划线 设置背景颜色 -backgroud-color CSS列表 CSS列表属性允许你放置、改变列表标志，或者将图像作为列表项标志 属性 描述 list-style 简写列表项 list-style-image 列表项图像 list-style-position 列表标志位置 list-style-type 列表类型 CSS表格 指定CSS表格边框，使用border属性。 border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开： Width和height属性定义表格的宽度和高度。 表格中的文本对齐和垂直对齐属性。text-align属性设置水平对齐方式，向左，右，或中心： 表格填充：padding 表格颜色：color CSS轮廓 属性 描述 outline 设置轮廓属性 outline-color 设置轮廓的颜色 outline-style 设置轮廓的样式 outline-width 设置轮廓的宽度 CSS定位 CSS定位 改变元素在页面上的位置 CSS定位机制 普通流：元素按照其在HTML中的位置顺序决定排布的过程 浮动 绝对布局 CSS定位属性 属性 描述 position 把元素放在一个静态的、相对的、绝对的、或固定的位置中 top 元素向上的偏移量 left 元素向左的偏移量 right 元素向右的偏移量 bottom 元素向下的偏移量 overflow 设置元素溢出其区域发生的事情 clip 设置元素显示的形状 vertical-align 设置元素垂直对齐方式 z-index 设置元素的堆叠顺序 position 属性的五个值： static：HTML 元素的默认值，即没有定位，遵循正常的文档流对象。静态定位的元素不会受到 top, bottom, left, right影响。 relative：元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动： fixed：相对定位元素的定位是相对其正常位置。移动相对定位元素，但它原本所占的空间不会改变。相对定位元素经常被用来作为绝对定位元素的容器块。 absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。absolute 定位的元素和其他元素重叠。 sticky：sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。position: sticky; 基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 重叠的元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） 一个元素可以有正数或负数的堆叠顺序： 具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。 注意： 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。 CSS浮动 浮动： float属性可用的值： left：元素向左浮动 right：元素向右浮动 none：元素不浮动 inherit：从父级继承浮动属性 clear属性： 去掉浮动属性(包括继承来的属性) clear属性值： left、right：去掉元素向左、向右浮动 both：左右两侧去掉浮动 inherit：从父级继承来clear的值 盒子模型 概述 margin、border、padding、content部分组成 内边距 padding padding-top padding-bottom padding-right padding-left 边框 CSS边框 我们可以创建出效果出色的边框，并且可以应用于任何元素 边框的样式： boder-style：定义了10个不同的非继承样式，包括none none: 默认无边框 dotted: 定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 单边框样式 border-top-style border-right-style border-bottom-style border-left-style 边框宽度 border-width：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。 单边框宽度 border-top-width border-right-width border-bottom-width border-left-width 边框颜色 border-color 单边框颜色 border-top-color border-right-color border-bottom-color border-left-color CSS3边框 border-image：设置所有边框图像的速记属性。 border-radius ：一个用于设置所有四个边框-*-半径属性的速记属性 box-shadow：附加一个或多个下拉框的阴影 外边距 属性 描述 margin 简写属性。在一个声明中设置所有外边距属性, 如margin：上下，左右。也可以auto自适应会居中 margin-bottom 设置元素的下外边距 margin-left 设置元素的左外边距 margin-right 设置元素的右外边距 margin-top 设置元素的上外边距 外边距合并 外边距合并就是第一个叠加的概念 盒子模型应用 盒子模型 *{ margin: 0px; padding: 0px; } .top{ width: 100%; height: 50px; background-color: black; } .top_content{ width: 75%; height: 50px; background-color: #8a6d3b; margin: 0px auto; } .body{ margin: 20px auto; width: 75%; height: 1500px; background-color: #9d9d9d; } .body_img{ width: 100%; height: 500px; background-color: #5bc0de; } .body_content{ width: 100%; height: 1000px; background-color: #985f0d; } .body_no{ width: 100%; height: 40px; background-color: #23527c; } .footing{ width: 75%; height: 400px; background-color: #a6e1ec; margin: 0 auto; } .footing_content{ width: 100%; height: 300px; background-color: #245269; } .footing_subnav{ width: 100%; height: 100px; background-color: #555555; } CSS对齐-水平&垂直对齐 元素居中对齐 要水平居中对齐一个元素(如 ), 可以使用 margin: auto;。 设置到元素的宽度将防止它溢出到容器的边缘。 元素通过指定宽度，并将两边的空外边距平均分配： 注意: 如果没有设置 width 属性(或者设置 100%)，居中对齐将不起作用。 文本居中对齐 如果仅仅是为了文本在元素内居中对齐，可以使用 text-align: center; 图片居中对齐 要让图片居中对齐, 可以使用 margin: auto; 并将它放到 块 元素中: 左右对齐 - 使用定位方式 我们可以使用 position: absolute; 属性来对齐元素: .right { position: absolute; right: 0px; width: 300px; border: 3px solid #73AD21; padding: 10px; } 注释：绝对定位元素会被从正常流中删除，并且能够交叠元素。 提示: 当使用 position 来对齐元素时, 通常 元素会设置 margin 和 padding 。 这样可以避免在不同的浏览器中出现可见的差异。 body { margin: 0; padding: 0; } .container { position: relative; width: 100%; } .right { position: absolute; right: 0px; width: 300px; background-color: #b0e0e6; } 左右对齐 - 使用 float 方式 我们也可以使用 float 属性来对齐元素 垂直居中对齐 - 使用 padding CSS 中有很多方式可以实现垂直居中对齐。 一个简单的方式就是头部顶部使用 padding 如果要水平和垂直都居中，可以使用 padding 和 text-align: center: 垂直居中 - 使用 line-height 垂直居中 - 使用 position 和 transform CSS尺寸 属性 描述 height 设置元素的高度 line-height 设置行高 max-height 设置元素的最大高度 max-width 设置元素的最大宽度 min-height 设置元素的最小高度 min-width 设置元素的最小宽度 width 设置元素的宽度 CSS分类 属性 描述 clear 设置一个元素的侧面是否允许其他的浮动元素 cursor 规定当指向某元素之上时显示的指针类型 display 设置是否及如何显示元素 float 定义元素在那个方向浮动 position 把元素放置到一个静态的、相对的、绝对的、固定的位置 visibility 设置元素是否看见或不可见 CSS中块级、内联元素的应用： 利用CSS我们可以摆脱上面表格里HTML标签归类的限制，自由地在不同标签/元素上应用我们需要的属性。 主要用的CSS样式有以下三个： display:block -- 显示为块级元素 display:inline -- 显示为内联元素 display:inline-block -- 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性 我们常将元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。 导航栏 导航栏=链接列表 作为标准的HTML基础一个导航栏是必须的。在我们的例子中我们将建立一个标准的HTML列表导航栏。 导航条基本上是一个链接列表，所以使用 和 元素非常有意义 ul { list-style-type: none; margin: 0; padding: 0; width: 200px; background-color: #f1f1f1; } /*垂直导航栏*/ li a { display: block; color: #000; padding: 8px 16px; text-decoration: none; } /* 鼠标移动到选项上修改背景颜色 */ li a:hover { background-color: #555; color: white; } /*激活/当前导航条实例*/ .active { background-color: #4CAF50; color: white; } 主页 新闻 联系 关于 示例说明： display:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度 width:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度 水平导航栏 有两种方法创建横向导航栏。使用内联(inline)或浮动(float)的列表项。 这两种方法都很好，但如果你想链接到具有相同的大小，你必须使用浮动的方法。 CSS图片 圆角图片：border-radius: 8px; 椭圆形图片：border-radius: 50%; 缩略图：我们使用 border 属性来创建缩略图。 透明度：opacity。 Opacity属性值从0.0 - 1.0。值越小，使得元素更加透明。 选择器详解 元素选择器 选择器分组(以逗号分隔) 通配符：* 一般这样设置： `*{ margin:0px padding:0px }` 类选择器 class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点\".\"号显示： ID选择器 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 \"#\" 来定义 ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。 属性选择器 属性选择器： `[title] { color:blue; }` 属性和值选择器： `[title=runoob] { border:5px solid green; }` 属性和值的选择器 - 多值： [title~=hello] { color:blue; } 后代选择器(以空格分隔) 选取所有 元素插入到 元素中： `div p { background-color:yellow; }` 子元素选择器(以大于号分隔) 选择了元素中所有直接子元素 ： `div>p { background-color:yellow; }` 相邻兄弟选择器(以加号分隔) 选取了所有位于 元素后的第一个 元素： `div+p { background-color:yellow; }` 后续兄弟选择器 选取了所有 元素之后的所有相邻兄弟元素 ： `div~p { background-color:yellow; }` 2D、3D转换(transform) 2D 转换： 移动：translate()：根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。 旋转：rotate()：在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。 div { transform: rotate(30deg); /*浏览器支持*/ -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ } 缩放：scale()：该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数。 倾斜：skew()： 包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。 skewX();表示只在X轴(水平方向)倾斜。 skewY();表示只在Y轴(垂直方向)倾斜。 matrix()： matrix()方法和2D变换方法合并成一个。 matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 3D转换： rotateX()：围绕其在一个给定度数X轴旋转的元素。 rotateY()：围绕其在一个给定度数Y轴旋转的元素 过渡 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性 transition-property 规定应用过渡的 CSS 属性的名称 transition-duration 定义过渡效果花费的时间。默认是 0 transition-timing-function 规定过渡效果的时间曲线。默认是 \"ease\" transition-delay 规定过渡效果何时开始。默认是 0 /*在一个例子中使用所有过渡属性：*/ div { transition-property: width; transition-duration: 1s; transition-timing-function: linear; transition-delay: 2s; /* Safari */ -webkit-transition-property:width; -webkit-transition-duration:1s; -webkit-transition-timing-function:linear; -webkit-transition-delay:2s; } /*与上面的例子相同的过渡效果，但是使用了简写的 transition 属性：*/ div { transition: width 1s linear 2s; /* Safari */ -webkit-transition:width 1s linear 2s; } 动画 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了 animation-play-state 属性 animation-name 规定 @keyframes 动画的名称 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0 animation-timing-function 规定动画的速度曲线。默认是 \"ease\" animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式 animation-delay 规定过渡效果何时开始。默认是 0 animation-iteration-count 规定动画被播放的次数。默认是 1 animation-direction 规定动画是否在下一周期逆向地播放。默认是 \"normal\" animation-play-state 规定动画是否正在运行或暂停。默认是 \"running\" 菜鸟教程(runoob.com) div { width:100px; height:100px; background:red; position:relative; animation-name:myfirst; animation-duration:5s; animation-timing-function:linear; animation-delay:2s; animation-iteration-count:infinite; animation-direction:alternate; animation-play-state:running; /* Safari and Chrome: */ -webkit-animation-name:myfirst; -webkit-animation-duration:5s; -webkit-animation-timing-function:linear; -webkit-animation-delay:2s; -webkit-animation-iteration-count:infinite; -webkit-animation-direction:alternate; -webkit-animation-play-state:running; } /*与上面的动画相同，但是使用了简写的动画 animation 属性：*/ div { width:100px; height:100px; background:red; position:relative; animation:myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation:myfirst 5s linear 2s infinite alternate; /* Safari and Chrome: */ -webkit-animation:myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation:myfirst 5s linear 2s infinite alternate; } @keyframes myfirst { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } @-webkit-keyframes myfirst /* Safari and Chrome */ { 0% {background:red; left:0px; top:0px;} 25% {background:yellow; left:200px; top:0px;} 50% {background:blue; left:200px; top:200px;} 75% {background:green; left:0px; top:200px;} 100% {background:red; left:0px; top:0px;} } 注意: 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。 多列 column-count：指定了需要分割的列数。 column-fill： 指定如何填充列。 column-gap：指定了列与列间的间隙。 column-rule-style：指定了列与列间的边框样式。 column-rule-width：指定了两列的边框厚度 column-rule-color：指定了两列的边框颜色 column-rule：是 column-rule-* 所有属性的简写 column-span：指定元素要跨越多少列。 column-width：指定了列的宽度。 columns：设置 column-width 和 column-count 的简写 瀑布流 waterfall .container{ column-width: 200px; -webkit-column-width: 200px; -webkit-column-gap: 5px; } .container div{ width: 200px; margin: 5px; } .container p{ text-align: center; } 标签 标签 标签 标签 标签 标签 "},"Web/JavaScript/JavaScript基础.html":{"url":"Web/JavaScript/JavaScript基础.html","title":"JavaScript基础","keywords":"","body":"datetime:2019/7/3 15:48 author:nzb 语法与注释 JavaScript语句 JavaScript语句向浏览器发出的命令。语句的作用是告诉浏览器该做什么。 分号： 语句之间的分割是分号(;) 注意：分号是可选项，有时候看到不以分号隔开的。 JavaScript代码： 按照编写顺序依次执行 标识符： JavaScript标识符必须以字母、下划线或美元符号开始 JavaScript关键字 JavaScript对大小写敏感 空格 JavaScript会忽略多余的空格 代码换行 保留字 单行注释 // 多行注释 /**/ 变量和数据类型 变量是用来存储信息的“容器”，使用var来声明 例: var x=10; var y=10.1; var z=\"hello\"; 数据类型 字符串(String) 数字(Number) 布尔(Boolean) 数组(Array) var arr=['hello',1,2]; var arr=new Array('world',2,3); var arr=new Array(); arr[0]=4; arr[1]=5; arr[2]=6; 对象(Object) 空(null) 未定义 可以通过赋值为null的方式清除变量 运算符 赋值运算符 =、+=、-=、*=、/=、%= 算术运算符 +、-、*、/、++、-- 比较运算符 ==、===、!=、!==、>、=、 逻辑运算符 &&、||、！ 条件(三目)运算符 例：x 字符串操作 相加就是拼接，任何类型相加字符串都会转化为字符串然后拼接 分支结构 if...else... var i = 10; if(i>=10){ document.write(\"i大于等于10\"); }else{ document.write(\"i小于10\"); } // 可以无限嵌套 if(i>10){ document.write(\"i大于10\"); }else if(i switch...cas...default... var i = 5; switch (i){ case 1: document.write(\"i为1\"); break; case 2: document.write(\"i为2\"); break; default: document.write(\"条件不满足\"); }; 循环结构 for循环 var i=[1,2,3,4,5,6]; for(var j=0;j while循环 var i = 1; while (i do...while循环 var i = 1; do{ document.write(\"i\"); i++; }while (i 跳转语句 break continue return 函数 定义函数 定义函数： function 函数名(){ 函数体; (代码块) } 注意： JavaScript对大小写十分敏感，所以这里的function必须小写。在函数调用时，也必须按照函数的相同名称来调用函数。 调用函数 function demo() { var a = 10; var b = 20; var sum = a+b; alert(sum); } // 第一种调用方式 demo(); // 第二种调用方式 按钮 带参数的函数 参数的个数可以为任意多，每个参数通过\",\"隔开 function demo(a,b) { var sum = a+b; alert(sum); } demo(10,20); 带返回值的函数 function demo(a,b) { var sum = a+b; return sum; } var sum = demo(10,20); alert(sum) 局部变量和全局变量 局部变量：函数内部声明 全局变量：函数外部声明 var n = 10; m = 10; //全局变量 任何地方都可以使用 function demo() { var i = 10; //局部变量 只能在当前函数中使用 x = 10; // 全局变量 只要调用了该函数任何地方都可以使用 } demo(); alert(x); 异常捕获 异常 当JavaScript引擎执行JavaScript代码时，发生了错误，导致程序停止运行 异常抛出 当异常产生，并且将这个异常生成一个错误信息 异常捕获 try{ 发生异常的代码块; }catch(err){ 错误信息处理; } Throw语句： 通过throw语句创建一个自定义错误 提交 function demo() { try{ var e = document.getElementById(\"txt\").value; if(e==\"\"){ throw \"请输入\"; } }catch (e) { alert(e) } } 事件 什么是事件 事件是可以被JavaScript侦测到的行为 | 事件 | 描述 | |------|-----| | onClick | 单击事件 | | onMouseOver | 鼠标经过事件 | | onMouseOut | 鼠标移出事件 | | onChange | 文本内容改变事件 | | onSelect | 文本框选中事件 | | onFocus | 光标聚集事件 | | onBlur | 移开光标事件 | | onLoad | 网页加载事件 | | onUnload | 关闭网页事件 | 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement）获取事件目标 type：获取事件类型 cancelable： preventDefault()：阻止事件默认行为 stopPropagation()（低版本IE中的cancelBubble）：阻止时间冒泡 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload DOM HTML DOM 当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model) DOM操作HTML JavaScript能够改变页面中的所有HTML元素 JavaScript能够改变页面中的所有HTML属性 JavaScript能够改变页面中的所有CSS样式 JavaScript能够改变页面中的所有事件作出反应 DOM操作HTML 改变 HTML 输出流 注意：绝对不要在文档加载完成之后使用document.write()。这会覆盖该文档 寻找元素： 通过id找到HTML元素 通过标签名找到HTML元素 改变 HTML 内容 使用属性：innerHTML document.getElementById(id).innerHTML=新的 HTML 改变 HTML 属性 使用属性：attribute document.getElementById(id).attribute=新属性值 document.getElementById(id).href=\"https://www.baidu.com\" document.getElementById(id).src=\"https://www.baidu.com\" DOM操作CSS 改变 HTML 样式 如需改变 HTML 元素的样式，请使用这个语法： document.getElementById(id).style.property=新样式 菜鸟教程(runoob.com) Hello World! Hello World! document.getElementById(\"p2\").style.color=\"blue\"; document.getElementById(\"p2\").style.fontFamily=\"Arial\"; document.getElementById(\"p2\").style.fontSize=\"larger\"; 以上段落通过脚本修改。 DOM EventListener addEventListener() addEventListener() 方法用于向指定元素添加事件句柄。 addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。 你可以向一个元素添加多个事件句柄。 你可以向同个元素添加多个同类型的事件句柄，如：两个 \"click\" 事件。 你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。 当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 你可以使用 removeEventListener() 方法来移除事件的监听。 语法：element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 \"click\" 或 \"mousedown\"). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 注意：不要使用 \"on\" 前缀。 例如，使用 \"click\" ,而不是使用 \"onclick\"。 例：在用户点击按钮时触发监听事件： document.getElementById(\"myBtn\").addEventListener(\"click\", displayDate); removeEventListener() removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄: element.removeEventListener(\"mousemove\", myFunction); 事件冒泡或事件捕获？ 事件传递有两种方式：冒泡与捕获。 事件传递定义了元素事件触发的顺序。 如果你将 元素插入到 元素中，用户点击 元素, 哪个元素的 \"click\" 事件先被触发呢？ 在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。 在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： 元素的点击事件先触发 ，然后再触发 元素的点击事件。 addEventListener() 方法可以指定 \"useCapture\" 参数来设置传递类型： addEventListener(event, function, useCapture); 默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。 浏览器支持 IE 8 及更早 IE 版本，Opera 7.0及其更早版本不支持 addEventListener() 和 removeEventListener() 方法。但是，对于这类浏览器版本可以使用 detachEvent() 方法来移除事件句柄: element.attachEvent(event, function); element.detachEvent(event, function); 例： var x = document.getElementById(\"myBtn\"); if (x.addEventListener) { // 所有主流浏览器，除了 IE 8 及更早版本 x.addEventListener(\"click\", myFunction); } else if (x.attachEvent) { // IE 8 及更早版本 x.attachEvent(\"onclick\", myFunction); } "},"Web/JavaScript/JavaScript对象.html":{"url":"Web/JavaScript/JavaScript对象.html","title":"JavaScript对象","keywords":"","body":"datetime:2019/7/4 15:38 author:nzb 对象 JavaScript 中的所有事物都是对象：字符串、数值、数组、函数... 对象只是一种特殊的数据。对象拥有属性和方法。 此外，JavaScript 允许自定义对象。 访问对象的属性 属性是与对象相关的值。 访问对象属性的语法是： objectName.propertyName 下面这个例子使用了 String 对象的 length 属性来获得字符串的长度： var message=\"Hello World!\"; var x=message.length; 在以上代码执行后，x 的值将是：12 访问对象的方法 方法是能够在对象上执行的动作。 您可以通过以下语法来调用方法： objectName.methodName() 下面这个例子使用了 String 对象的 toUpperCase() 方法来将文本转换为大写： var message=\"Hello world!\"; var x=message.toUpperCase(); 在以上代码执行后，x 的值将是：HELLO WORLD! 创建 JavaScript 对象 通过 JavaScript，您能够定义并创建自己的对象。 创建新对象有两种不同的方法： 定义并创建对象的实例 person=new Object(); person.firstname=\"John\"; person.lastname=\"Doe\"; person.age=50; person.eyecolor=\"blue\"; // 或 person={firstname:\"John\",lastname:\"Doe\",age:50,eyecolor:\"blue\"}; 使用函数来定义对象，然后创建新的对象实例 function person(firstname,lastname,age,eyecolor) { this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; } 在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时） 创建 JavaScript 对象实例 一旦您有了对象构造器，就可以创建新的对象实例，就像这样： var myFather=new person(\"John\",\"Doe\",50,\"blue\"); var myMother=new person(\"Sally\",\"Rally\",48,\"green\"); 把属性添加到 JavaScript 对象 person.firstname=\"John\"; person.lastname=\"Doe\"; person.age=30; person.eyecolor=\"blue\"; x=person.firstname; 在以上代码执行后，x 的值将是：John 把方法添加到 JavaScript 对象 function person(firstname,lastname,age,eyecolor) { this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; this.changeName=changeName; function changeName(name) { this.lastname=name; } } String对象 String 对象用于处理已有的字符块。 一个字符串可以使用单引号或双引号。 字符串（String）使用长度属性length来计算字符串的长度。 字符串使用 indexOf() 来定位字符串中某一个指定的字符首次出现的位置。 var str=\"Hello world, welcome to the universe.\"; var n=str.indexOf(\"welcome\"); 如果没找到对应的字符函数返回-1 lastIndexOf() 方法在字符串末尾开始查找字符串出现的位置。 内容匹配：match()函数用来查找字符串中特定的字符，并且如果找到的话，则返回这个字符。 替换内容：replace() 方法在字符串中用某些字符替换另一些字符。 字符串大小写转换：字符串大小写转换使用函数 toUpperCase() / toLowerCase() 字符串转为数组：字符串使用split()函数转为数组。 特殊字符：Javascript 中可以使用反斜线（\\）插入特殊符号，如：撇号,引号等其他特殊符号。 | 代码 | 输出 | |------|-----| | \\' | 单引号 | | \\\" | 双引号 | | \\ | 斜杆 | | \\n | 换行 | | \\r | 回车 | | \\t | tab | | \\b | 空格 | | \\f | 换页 | 字符串属性和方法 属性: | 属性 | 描述 | |------|-----| | constructor | 对创建该对象的函数的引用 | | length | 字符串的长度 | | prototype | 允许您向对象添加属性和方法 | 方法: | 方法 | 描述 | |-----|------| | charAt() | 返回在指定位置的字符 | | charCodeAt() | 返回在指定的位置的字符的 Unicode 编码 | | concat() | 连接两个或更多字符串，并返回新的字符串 | | fromCharCode() | 将 Unicode 编码转为字符 | | indexOf() | 返回某个指定的字符串值在字符串中首次出现的位置 | | includes() | 查找字符串中是否包含指定的子字符串 | | lastIndexOf() | 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置 | | match() | 查找找到一个或多个正则表达式的匹配 | | repeat() | 复制字符串指定次数，并将它们连接在一起返回 | | replace() | 在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串 | | search() | 查找与正则表达式相匹配的值 | | slice() | 提取字符串的片断，并在新的字符串中返回被提取的部分 | | split() | 把字符串分割为字符串数组 | | startsWith() | 查看字符串是否以指定的子字符串开头 | | substr() | 从起始索引号提取字符串中指定数目的字符 | | substring() | 提取字符串中两个指定的索引号之间的字符 | | toLowerCase() | 把字符串转换为小写 | | toUpperCase() | 把字符串转换为大写 | | trim() | 去除字符串两边的空白 | | toLocaleLowerCase() | 根据本地主机的语言环境把字符串转换为小写 | | toLocaleUpperCase() | 根据本地主机的语言环境把字符串转换为大写 | | valueOf() | 返回某个字符串对象的原始值 | | toString() | 返回一个字符串 | Date日期对象 Date() 方法获得当日的日期。 getFullYear() 获取年份。 getTime() 返回从 1970 年 1 月 1 日至今的毫秒数。 setFullYear() 设置具体的日期。 toUTCString() 将当日的日期（根据 UTC）转换为字符串。 getDay() 和数组来显示星期，而不仅仅是数字。 创建日期 Date 对象用于处理日期和时间。 可以通过 new 关键词来定义 Date 对象。以下代码定义了名为 myDate 的 Date 对象： 有四种方式初始化日期: new Date() // 当前日期和时间 new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数 new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) 上面的参数大多数都是可选的，在不指定的情况下，默认参数是0。 实例化一个日期的一些例子： var today = new Date() var d1 = new Date(\"October 13, 1975 11:13:00\") var d2 = new Date(79,5,24) var d3 = new Date(79,5,24,11,33,0) 设置日期 通过使用针对日期对象的方法，我们可以很容易地对日期进行操作。 在下面的例子中，我们为日期对象设置了一个特定的日期 (2010 年 1 月 14 日)： var myDate=new Date(); myDate.setFullYear(2010,0,14); 在下面的例子中，我们将日期对象设置为 5 天后的日期： var myDate=new Date(); myDate.setDate(myDate.getDate()+5); 注意: 如果增加天数会改变月份或者年份，那么日期对象会自动完成这种转换。 两个日期比较 日期对象也可用于比较两个日期。 下面的代码将当前日期与 2100 年 1 月 14 日做了比较： var x=new Date(); x.setFullYear(2100,0,14); var today = new Date(); if (x>today) { alert(\"今天是2100年1月14日之前\"); } else { alert(\"今天是2100年1月14日之后\"); } 字符串属性和方法 属性: | 属性 | 描述 | |------|-----| | constructor | 返回对创建此对象的 Date 函数的引用 | | prototype | 使您有能力向对象添加属性和方法 | 方法: | 方法 | 描述 | |-----|------| | getDate() | 从 Date 对象返回一个月中的某一天 (1 ~ 31) | | getDay() | 从 Date 对象返回一周中的某一天 (0 ~ 6) | | getFullYear() | 从 Date 对象以四位数字返回年份 | | getHours() | 返回 Date 对象的小时 (0 ~ 23) | | getMilliseconds() | 返回 Date 对象的毫秒(0 ~ 999) | | getMinutes() | 返回 Date 对象的分钟 (0 ~ 59) | | getMonth() | 从 Date 对象返回月份 (0 ~ 11) | | getSeconds() | 返回 Date 对象的秒数 (0 ~ 59) | | getTime() | 返回 1970 年 1 月 1 日至今的毫秒数 | | getTimezoneOffset() | 返回本地时间与格林威治标准时间 (GMT) 的分钟差 | | getUTCDate() | 根据世界时从 Date 对象返回月中的一天 (1 ~ 31) | | getUTCDay() | 根据世界时从 Date 对象返回周中的一天 (0 ~ 6) | | getUTCFullYear() | 根据世界时从 Date 对象返回四位数的年份 | | getUTCHours() | 根据世界时返回 Date 对象的小时 (0 ~ 23) | | getUTCMilliseconds() | 根据世界时返回 Date 对象的毫秒(0 ~ 999) | | getUTCMinutes() | 根据世界时返回 Date 对象的分钟 (0 ~ 59) | | getUTCMonth() | 根据世界时从 Date 对象返回月份 (0 ~ 11) | | getUTCSeconds() | 根据世界时返回 Date 对象的秒钟 (0 ~ 59) | | getYear() | 已废弃。 请使用 getFullYear() 方法代替 | | parse() | 返回1970年1月1日午夜到指定日期（字符串）的毫秒数 | | setDate() | 设置 Date 对象中月的某一天 (1 ~ 31) | | setFullYear() | 设置 Date 对象中的年份（四位数字） | | setHours() | 设置 Date 对象中的小时 (0 ~ 23) | | setMilliseconds() | 设置 Date 对象中的毫秒 (0 ~ 999) | | setMinutes() | 设置 Date 对象中的分钟 (0 ~ 59) | | setMonth() | 设置 Date 对象中月份 (0 ~ 11) | | setSeconds() | 设置 Date 对象中的秒钟 (0 ~ 59) | | setTime() setTime() | 方法以毫秒设置 Date 对象 | | setUTCDate() | 根据世界时设置 Date 对象中月份的一天 (1 ~ 31) | | setUTCFullYear() | 根据世界时设置 Date 对象中的年份（四位数字） | | setUTCHours() | 根据世界时设置 Date 对象中的小时 (0 ~ 23) | | setUTCMilliseconds() | 根据世界时设置 Date 对象中的毫秒 (0 ~ 999) | | setUTCMinutes() | 根据世界时设置 Date 对象中的分钟 (0 ~ 59) | | setUTCMonth() | 根据世界时设置 Date 对象中的月份 (0 ~ 11) | | setUTCSeconds() | setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段 | | setYear() | 已废弃。请使用 setFullYear() 方法代替。 | toDateString() | 把 Date 对象的日期部分转换为字符串 | | toGMTString() | 已废弃。请使用 toUTCString() 方法代替 | | toISOString() | 使用 ISO 标准返回字符串的日期格式 | | toJSON() | 以 JSON 数据格式返回日期字符串 | | toLocaleDateString() | 根据本地时间格式，把 Date 对象的日期部分转换为字符串 | | toLocaleTimeString() | 根据本地时间格式，把 Date 对象的时间部分转换为字符串 | | toLocaleString() | 据本地时间格式，把 Date 对象转换为字符串 | | toString() | 把 Date 对象转换为字符串 | | toTimeString() | 把 Date 对象的时间部分转换为字符串 | | toUTCString() | 根据世界时，把 Date 对象转换为字符串 | | UTC() | 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数 | | valueOf() | 返回 Date 对象的原始值 | Array对象 数组对象是使用单独的变量名来存储一系列的值。 数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。 数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到。 创建一个数组 常规方式: var myCars=new Array(); myCars[0]=\"Saab\"; myCars[1]=\"Volvo\"; myCars[2]=\"BMW\"; 简洁方式: var myCars=new Array(\"Saab\",\"Volvo\",\"BMW\"); 字面: var myCars=[\"Saab\",\"Volvo\",\"BMW\"]; 访问数组 通过指定数组名以及索引号码，你可以访问某个特定的元素。 在一个数组中你可以有不同的对象 所有的JavaScript变量都是对象。数组元素是对象。函数是对象。 因此，你可以在数组中有不同的变量类型。 你可以在一个数组中包含对象元素、函数、数组 数组方法和属性 属性: | 属性 | 描述 | |------|-----| | constructor | 返回创建数组对象的原型函数 | | length | 设置或返回数组元素的个数 | | prototype | 允许你向数组对象添加属性或方法 | 方法: | 方法 | 描述 | |-----|------| | concat() | 连接两个或更多的数组，并返回结果 | | copyWithin() | 从数组的指定位置拷贝元素到数组的另一个指定位置中 | | entries() | 返回数组的可迭代对象 | | every() | 检测数值元素的每个元素是否都符合条件 | | fill() | 使用一个固定值来填充数组 | | filter() | 检测数值元素，并返回符合条件所有元素的数组 | | find() | 返回符合传入测试（函数）条件的数组元素 | | findIndex() | 返回符合传入测试（函数）条件的数组元素索引 | | forEach() | 数组每个元素都执行一次回调函数 | | from() | 通过给定的对象中创建一个数组 | | includes() | 判断一个数组是否包含一个指定的值 | | indexOf() | 搜索数组中的元素，并返回它所在的位置 | | isArray() | 判断对象是否为数组 | | join() | 把数组的所有元素放入一个字符串 | | keys() | 返回数组的可迭代对象，包含原始数组的键(key) | | lastIndexOf() | 搜索数组中的元素，并返回它最后出现的位置 | | map() | 通过指定函数处理数组的每个元素，并返回处理后的数组 | | pop() | 删除数组的最后一个元素并返回删除的元素 | | push() | 向数组的末尾添加一个或更多元素，并返回新的长度 | | reduce() | 将数组元素计算为一个值（从左到右） | | reduceRight() | 将数组元素计算为一个值（从右到左） | | reverse() | 反转数组的元素顺序 | | shift() | 删除并返回数组的第一个元素 | | slice() | 选取数组的的一部分，并返回一个新数组 | | some() | 检测数组元素中是否有元素符合指定条件 | | sort() | 对数组的元素进行排序 | | splice() | 从数组中添加或删除元素 | | toString() | 把数组转换为字符串，并返回结果 | | unshift() | 向数组的开头添加一个或更多元素，并返回新的长度 | | valueOf() | 返回数组对象的原始值 | Math对象 Math方法和属性 属性: | 属性 | 描述 | |------|-----| | E | 返回算术常量 e，即自然对数的底数（约等于2.718） | | LN2 | 返回 2 的自然对数（约等于0.693） | | LN10 | 返回 10 的自然对数（约等于2.302） | | LOG2E | 返回以 2 为底的 e 的对数（约等于 1.4426950408889634） | | LOG10E | 返回以 10 为底的 e 的对数（约等于0.434） | | PI | 返回圆周率（约等于3.14159） | | SQRT1_2 | 返回 2 的平方根的倒数（约等于 0.707） | | SQRT2 | 返回 2 的平方根（约等于 1.414） | 方法: | 方法 | 描述 | |-----|------| | abs(x) | 返回 x 的绝对值 | | acos(x) | 返回 x 的反余弦值 | | asin(x) | 返回 x 的反正弦值 | | atan(x) | 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 | | atan2(y,x) | 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） | | ceil(x) | 对数进行上舍入 | | cos(x) | 返回数的余弦 | | exp(x) | 返回 Ex 的指数 | | floor(x) | 对 x 进行下舍入 | | log(x) | 返回数的自然对数（底为e） | | max(x,y,z,...,n) | 返回 x,y,z,...,n 中的最高值 | | min(x,y,z,...,n) | 返回 x,y,z,...,n中的最低值 | | pow(x,y) | 返回 x 的 y 次幂 | | random() | 返回 0 ~ 1 之间的随机数 | | round(x) | 四舍五入 | | sin(x) | 返回数的正弦 | | sqrt(x) | 返回数的平方根 | | tan(x) | 返回角的正切 | DOM对象 HTML DOM 节点 在 HTML DOM (Document Object Model) 中 , 每一个元素都是 节点: 文档是一个文档节点。 所有的HTML元素都是元素节点。 所有 HTML 属性都是属性节点。 文本插入到 HTML 元素是文本节点。are text nodes。 注释是注释节点。 Document 对象 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 Document 对象属性和方法 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | document.activeElement | 返回当前获取焦点元素 | | document.addEventListener() | 向文档添加句柄 | | document.adoptNode(node) | 从另外一个文档返回 adapded 节点到当前文档 | | document.anchors | 返回对文档中所有 Anchor 对象的引用 | | document.applets | 返回对文档中所有 Applet 对象的引用。注意: HTML5 已不支持 元素 | | document.baseURI | 返回文档的绝对基础 URI | | document.body | 返回文档的body元素 | | document.close() | 关闭用 document.open() 方法打开的输出流，并显示选定的数据 | | document.cookie | 设置或返回与当前文档有关的所有 cookie | | document.createAttribute() | 创建一个属性节点 | | document.createComment() | createComment() 方法可创建注释节点 | | document.createDocumentFragment() | 创建空的 DocumentFragment 对象，并返回此对象 | | document.createElement() | 创建元素节点 | | document.createTextNode() | 创建文本节点 | | document.doctype | 返回与文档相关的文档类型声明 (DTD) | | document.documentElement | 返回文档的根节点 | | document.documentMode | 返回用于通过浏览器渲染文档的模式 | | document.documentURI | 设置或返回文档的位置 | | document.domain | 返回当前文档的域名 | | document.domConfig | 已废弃。返回 normalizeDocument() 被调用时所使用的配置 | | document.embeds | 返回文档中所有嵌入的内容（embed）集合 | | document.forms | 返回对文档中所有 Form 对象引用 | | document.getElementsByClassName() | 返回文档中所有指定类名的元素集合，作为 NodeList 对象 | | document.getElementById() | 返回对拥有指定 id 的第一个对象的引用 | | document.getElementsByName() | 返回带有指定名称的对象集合 | | document.getElementsByTagName() | 返回带有指定标签名的对象集合 | | document.images | 返回对文档中所有 Image 对象引用 | | document.implementation | 返回处理该文档的 DOMImplementation 对象 | | document.importNode() | 把一个节点从另一个文档复制到该文档以便应用 | | document.inputEncoding | 返回用于文档的编码方式（在解析时） | | document.lastModified | 返回文档被最后修改的日期和时间 | | document.links | 返回对文档中所有 Area 和 Link 对象引用 | | document.normalize() | 删除空文本节点，并连接相邻节点 | | document.normalizeDocument() | 删除空文本节点，并连接相邻节点的 | | document.open() | 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出 | | document.querySelector() | 返回文档中匹配指定的CSS选择器的第一元素 | | document.querySelectorAll() | document.querySelectorAll() 是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 | | document.readyState | 返回文档状态 (载入中……) | | document.referrer | 返回载入当前文档的文档的 URL | | document.removeEventListener() | 移除文档中的事件句柄(由 addEventListener() 方法添加) | | document.renameNode() | 重命名元素或者属性节点 | | document.scripts | 返回页面中所有脚本的集合 | | document.strictErrorChecking | 设置或返回是否强制进行错误检查 | | document.title | 返回当前文档的标题 | | document.URL | 返回文档完整的URL | | document.write() | 向文档写 HTML 表达式 或 JavaScript 代码 | | document.writeln() | 等同于 write() 方法，不同的是在每个表达式之后写一个换行符 | 警告 !!! 在 W3C DOM核心，文档对象 继承节点对象的所有属性和方法。 很多属性和方法在文档中是没有意义的。 HTML 文档对象可以避免使用这些节点对象和属性： | 属性 / 方法 | 避免的原因 | |-------|----------------| | document.attributes | 文档没有该属性 | | document.hasAttributes() | 文档没有该属性 | | document.nextSibling | 文档没有下一节点 | | document.nodeName | 这个通常是 #document | | document.nodeType | 这个通常是 9(DOCUMENT_NODE) | | document.nodeValue | 文档没有一个节点值 | | document.ownerDocument | 文档没有主文档 | | document.ownerElement | 文档没有自己的节点 | | document.parentNode | 文档没有父节点 | | document.previousSibling | 文档没有兄弟节点 | | document.textContent | 文档没有文本节点 | 元素对象 在 HTML DOM 中, 元素对象代表着一个 HTML 元素。 元素对象 的 子节点可以是, 可以是元素节点，文本节点，注释节点。 NodeList 对象 代表了节点列表，类似于 HTML元素的子节点集合。 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | element.accessKey | 设置或返回accesskey一个元素 | | element.addEventListener() | 向指定元素添加事件句柄 | | element.appendChild() | 为元素添加一个新的子元素 | | element.attributes | 返回一个元素的属性数组 | | element.childNodes | 返回元素的一个子节点的数组 | | element.children | 返回元素的子元素的集合 | | element.classList | 返回元素的类名，作为 DOMTokenList 对象。 | | element.className | 设置或返回元素的class属性 | | element.clientHeight | 在页面上返回内容的可视高度（不包括边框，边距或滚动条） | | element.clientWidth | 在页面上返回内容的可视宽度（不包括边框，边距或滚动条） | | element.cloneNode() | 克隆某个元素 | | element.compareDocumentPosition() | 比较两个元素的文档位置。 | | element.contentEditable | 设置或返回元素的内容是否可编辑 | | element.dir | 设置或返回一个元素中的文本方向 | | element.firstChild | 返回元素的第一个子节点 | | element.focus() | 设置文档或元素获取焦点 | | element.getAttribute() | 返回指定元素的属性值 | | element.getAttributeNode() | 返回指定属性节点 | | element.getElementsByTagName() | 返回指定标签名的所有子元素集合。 | | element. getElementsByClassName() | 返回文档中所有指定类名的元素集合，作为 NodeList 对象。 | | element.getFeature() | 返回指定特征的执行APIs对象。 | | element.getUserData() | 返回一个元素中关联键值的对象。 | | element.hasAttribute() | 如果元素中存在指定的属性返回 true，否则返回false。 | | element.hasAttributes() | 如果元素有任何属性返回true，否则返回false。 | | element.hasChildNodes() | 返回一个元素是否具有任何子元素 | | element.hasFocus() | 返回布尔值，检测文档或元素是否获取焦点 | | element.id | 设置或者返回元素的 id。 | | element.innerHTML | 设置或者返回元素的内容。 | | element.insertBefore() | 现有的子元素之前插入一个新的子元素 | | element.isContentEditable | 如果元素内容可编辑返回 true，否则返回false | | element.isDefaultNamespace() | 如果指定了namespaceURI 返回 true，否则返回 false。 | | element.isEqualNode() | 检查两个元素是否相等 | | element.isSameNode() | 检查两个元素所有有相同节点。 | | element.isSupported() | 如果在元素中支持指定特征返回 true。 | | element.lang | 设置或者返回一个元素的语言。 | | element.lastChild | 返回的最后一个子元素 | | element.namespaceURI | 返回命名空间的 URI。 | | element.nextSibling | 返回该元素紧跟的一个节点 | | element.nextElementSibling | 返回指定元素之后的下一个兄弟元素（相同节点树层中的下一个元素节点）。 | | element.nodeName | 返回元素的标记名（大写） | | element.nodeType | 返回元素的节点类型 | | element.nodeValue | 返回元素的节点值 | | element.normalize() | 使得此成为一个\"normal\"的形式，其中只有结构（如元素，注释，处理指令，CDATA节和实体引用）隔开Text节点，即元素（包括属性）下面的所有文本节点，既没有相邻的文本节点也没有空的文本节点 | | element.offsetHeight | 返回任何一个元素的高度包括边框和填充，但不是边距 | | element.offsetWidth | 返回元素的宽度，包括边框和填充，但不是边距 | | element.offsetLeft | 返回当前元素的相对水平偏移位置的偏移容器 | | element.offsetParent | 返回元素的偏移容器 | | element.offsetTop | 返回当前元素的相对垂直偏移位置的偏移容器 | | element.ownerDocument | 返回元素的根元素（文档对象） | | element.parentNode | 返回元素的父节点 | | element.previousSibling | 返回某个元素紧接之前元素 | | element.previousElementSibling | 返回指定元素的前一个兄弟元素（相同节点树层中的前一个元素节点）。 | | element.querySelector() | 返回匹配指定 CSS 选择器元素的第一个子元素 | | document.querySelectorAll() | 返回匹配指定 CSS 选择器元素的所有子元素节点列表 | | element.removeAttribute() | 从元素中删除指定的属性 | | element.removeAttributeNode() | 删除指定属性节点并返回移除后的节点。 | | element.removeChild() | 删除一个子元素 | | element.removeEventListener() | 移除由 addEventListener() 方法添加的事件句柄 | | element.replaceChild() | 替换一个子元素 | | element.scrollHeight | 返回整个元素的高度（包括带滚动条的隐蔽的地方） | | element.scrollLeft | 返回当前视图中的实际元素的左边缘和左边缘之间的距离 | | element.scrollTop | 返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离 | | element.scrollWidth | 返回元素的整个宽度（包括带滚动条的隐蔽的地方） | | element.setAttribute() | 设置或者改变指定属性并指定值。 | | element.setAttributeNode() | 设置或者改变指定属性节点。 | | element.setIdAttribute() | | | element.setIdAttributeNode() | | | element.setUserData() | 在元素中为指定键值关联对象。 | | element.style | 设置或返回元素的样式属性 | | element.tabIndex | 设置或返回元素的标签顺序。 | | element.tagName | 作为一个字符串返回某个元素的标记名（大写） | | element.textContent | 设置或返回一个节点和它的文本内容 | | element.title | 设置或返回元素的title属性 | | element.toString() | 一个元素转换成字符串 | | nodelist.item() | 返回某个元素基于文档树的索引 | | nodelist.length | 返回节点列表的节点数目。 | Attr(属性) 对象 在 HTML DOM 中, Attr 对象 代表一个 HTML 属性。 HTML属性总是属于HTML元素。 NamedNodeMap 对象 在 HTML DOM 中, the NamedNodeMap 对象 表示一个无顺序的节点列表。 我们可通过节点名称来访问 NamedNodeMap 中的节点。 属性和方法 | 属性 / 方法 | 描述 | |------|------------| | attr.isId | 如果属性是 ID 类型，则 isId 属性返回 true，否则返回 false。 | | attr.name | 返回属性名称 | | attr.value | 设置或者返回属性值 | | attr.specified | 如果属性被指定返回 true ，否则返回 false | | nodemap.getNamedItem() | 从节点列表中返回的指定属性节点。 | | nodemap.item() | 返回节点列表中处于指定索引号的节点。 | | nodemap.length | 返回节点列表的节点数目。 | | nodemap.removeNamedItem() | 删除指定属性节点 | | nodemap.setNamedItem() | 设置指定属性节点(通过名称) | DOM 4 警告 !!! 在 W3C DOM 内核中, Attr (属性) 对象继承节点对象的所有属性和方法 。 在 DOM 4 中, Attr (属性) 对象不再从节点对象中继承。 从长远的代码质量来考虑，在属性对象中你需要避免使用节点对象属性和方法: | 属性 / 方法 | 避免原因 | |------|------------| | attr.appendChild() | 属性没有子节点 | | attr.attributes | 属性没有属性 | | attr.baseURI | 使用 document.baseURI 替代 | | attr.childNodes | 属性没有子节点 | | attr.cloneNode() | 使用 attr.value 替代 | | attr.firstChild | 属性没有子节点 | | attr.hasAttributes() | 属性没有属性 | | attr.hasChildNodes | 属性没有子节点 | | attr.insertBefore() | 属性没有子节点 | | attr.isEqualNode() | 没有意义 | | attr.isSameNode() | 没有意义 | | attr.isSupported() | 通常为 true | | attr.lastChild | 属性没有子节点 | | attr.nextSibling | 属性没有兄弟节点 | | attr.nodeName | 使用 attr.name 替代 | | attr.nodeType | 通常为 2 (ATTRIBUTE-NODE) | | attr.nodeValue | 使用 attr.value 替代 | | attr.normalize() | 属性没有规范 | | attr.ownerDocument | 通常为你的 HTML 文档 | | attr.ownerElement | 你用来访问属性的 HTML 元素 | | attr.parentNode | 你用来访问属性的 HTML 元素 | | attr.previousSibling | 属性没有兄弟节点 | | attr.removeChild | 属性没有子节点 | | attr.replaceChild | 属性没有子节点 | | attr.textContent | 使用 attr.value 替代 | Console 对象 Console 对象提供了访问浏览器调试模式的信息到控制台。 方法 描述 assert() 如果断言为 false，则在信息到控制台输出错误信息。 clear() 清除控制台上的信息。 count() 记录 count() 调用次数，一般用于计数。 error() 输出错误信息到控制台 group() 在控制台创建一个信息分组。 一个完整的信息分组以 console.group() 开始，console.groupEnd() 结束 groupCollapsed() 在控制台创建一个信息分组。 类似 console.group() ，但它默认是折叠的。 groupEnd() 设置当前信息分组结束 info() 控制台输出一条信息 log() 控制台输出一条信息 table() 以表格形式显示数据 time() 计时器，开始计时间，与 timeEnd() 联合使用，用于算出一个操作所花费的准确时间。 timeEnd() 计时结束 trace() 显示当前执行的代码在堆栈中的调用路径。 warn() 输出警告信息，信息最前面加一个黄色三角，表示警告 CSS 样式声明对象(CSSStyleDeclaration) CSSStyleDeclaration 对象 CSSStyleDeclaration 对象表示一个 CSS 属性-值（property-value）对的集合。 CSSStyleDeclaration 对象属性 | 属性 | 描述 | |------|------------| | cssText | 设置或返回样式声明文本，cssText 对应的是 HTML 元素的 style 属性。 | | length | 返回样式中包含多少条声明。 | | parentRule | 返回包含当前规则的规则。 | CSSStyleDeclaration 对象方法 | 属性 | 描述 | |------|------------| | getPropertyPriority() | 返回指定的 CSS 属性是否设置了 \"important!\" 属性。 | | getPropertyValue() | 返回指定的 CSS 属性值。 | | item() | 通过索引方式返回 CSS 声明中的 CSS 属性名。 | | removeProperty() | 移除 CSS 声明中的 CSS 属性。 | | setProperty() | 在 CSS 声明块中新建或者修改 CSS 属性。 | DOM 事件 DOM： 指明使用的 DOM 属性级别。 鼠标事件 属性 描述 DOM onclick 当用户点击某个对象时调用的事件句柄。 2 oncontextmenu 在用户点击鼠标右键打开上下文菜单时触发 ondblclick 当用户双击某个对象时调用的事件句柄。 2 onmousedown 鼠标按钮被按下。 2 onmouseenter 当鼠标指针移动到元素上时触发。 2 onmouseleave 当鼠标指针移出元素时触发 2 onmousemove 鼠标被移动。 2 onmouseover 鼠标移到某元素之上。 2 onmouseout 鼠标从某元素移开。 2 onmouseup 鼠标按键被松开。 2 键盘事件 属性 描述 DOM onkeydown 某个键盘按键被按下。 2 onkeypress 某个键盘按键被按下并松开。 2 onkeyup 某个键盘按键被松开。 2 框架/对象（Frame/Object）事件 属性 描述 DOM onabort 图像的加载被中断。 ( ) 2 onbeforeunload 该事件在即将离开页面（刷新或关闭）时触发 2 onerror 在加载文档或图像时发生错误。 ( , 和 ) onhashchange 该事件在当前 URL 的锚部分发生修改时触发。 onload 一张页面或一幅图像完成加载。 2 onpageshow 该事件在用户访问页面时触发 onpagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 onresize 窗口或框架被重新调整大小。 2 onscroll 当文档被滚动时发生的事件。 2 onunload 用户退出页面。 ( 和 ) 2 表单事件 属性 描述 DOM onblur 元素失去焦点时触发 2 onchange 该事件在表单元素的内容改变时触发( , , , 和 ) 2 onfocus 元素获取焦点时触发 2 onfocusin 元素即将获取焦点时触发 2 onfocusout 元素即将失去焦点时触发 2 oninput 元素获取用户输入时触发 3 onreset 表单重置时触发 2 onsearch 用户向搜索域输入文本时触发 ( ) onselect 用户选取文本时触发 ( 和 ) 2 onsubmit 表单提交时触发 2 剪贴板事件 属性 描述 DOM oncopy 该事件在用户拷贝元素内容时触发 oncut 该事件在用户剪切元素内容时触发 onpaste 该事件在用户粘贴元素内容时触发 打印事件 属性 描述 DOM onafterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 onbeforeprint 该事件在页面即将开始打印时触发 拖动事件 事件 描述 DOM ondrag 该事件在元素正在拖动时触发 ondragend 该事件在用户完成元素的拖动时触发 ondragenter 该事件在拖动的元素进入放置目标时触发 ondragleave 该事件在拖动元素离开放置目标时触发 ondragover 该事件在拖动元素在放置目标上时触发 ondragstart 该事件在用户开始拖动元素时触发 ondrop 该事件在拖动元素放置在目标区域时触发 多媒体（Media）事件 事件 描述 DOM onabort 事件在视频/音频（audio/video）终止加载时触发。 oncanplay 事件在用户可以开始播放视频/音频（audio/video）时触发。 oncanplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。 ondurationchange 事件在视频/音频（audio/video）的时长发生变化时触发。 onemptied 当期播放列表为空时触发 onended 事件在视频/音频（audio/video）播放结束时触发。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 onloadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。 onloadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。 onloadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。 onpause 事件在视频/音频（audio/video）暂停时触发。 onplay 事件在视频/音频（audio/video）开始播放时触发。 onplaying 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。 onprogress 事件在浏览器下载指定的视频/音频（audio/video）时触发。 onratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。 onseeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。 onseeking 事件在用户开始重新定位视频/音频（audio/video）时触发。 onstalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 onsuspend 事件在浏览器读取媒体数据中止时触发。 ontimeupdate 事件在当前的播放位置发送改变时触发。 onvolumechange 事件在音量发生改变时触发。 onwaiting 事件在视频由于要播放下一帧而需要缓冲时触发。 动画事件 事件 描述 DOM animationend 该事件在 CSS 动画结束播放时触发 animationiteration 该事件在 CSS 动画重复播放时触发 animationstart 该事件在 CSS 动画开始播放时触发 过渡事件 事件 描述 DOM transitionend 该事件在 CSS 完成过渡后触发。 其他事件 事件 描述 DOM onmessage 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 onmousewheel 已废弃。 使用 onwheel 事件替代 ononline 该事件在浏览器开始在线工作时触发。 onoffline 该事件在浏览器开始离线工作时触发。 onpopstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 onshow 该事件当 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 ontoggle 该事件在用户打开或关闭 元素时触发 onwheel 该事件在鼠标滚轮在元素上下滚动时触发 事件对象 常量 | 静态变量 | 描述 | DOM | |------|------|------| | CAPTURING-PHASE | 当前事件阶段为捕获阶段(1) | 1 | | AT-TARGET | 当前事件是目标阶段,在评估目标事件(1) | 2 | | BUBBLING-PHASE | 当前的事件为冒泡阶段 (3) | 3 | 属性 | 属性 | 描述 | DOM | |------|------|------| | bubbles | 返回布尔值，指示事件是否是起泡事件类型。 | 2 | | cancelable | 返回布尔值，指示事件是否可拥可取消的默认动作。 | 2 | | currentTarget | 返回其事件监听器触发该事件的元素。 | 2 | | eventPhase | 返回事件传播的当前阶段。 | 2 | | target | 返回触发此事件的元素（事件的目标节点）。 | 2 | | timeStamp | 返回事件生成的日期和时间。 | 2 | | type | 返回当前 Event 对象表示的事件的名称。 | 2 | 方法 | 方法 | 描述 | DOM | |------|------|------| | initEvent() | 初始化新创建的 Event 对象的属性。 | 2 | | preventDefault() | 通知浏览器不要执行与事件关联的默认动作。 | 2 | | stopPropagation() | 不再派发事件。 | 2 | 目标事件对象 方法 | 方法 | 描述 | DOM | |------|------|------| | addEventListener() | 允许在目标事件中注册监听事件(IE8 = attachEvent()) | 2 | | dispatchEvent() | 允许发送事件到监听器上 (IE8 = fireEvent()) | 2 | | removeEventListener() | 运行一次注册在事件目标上的监听事件(IE8 = detachEvent()) | 2 | 事件监听对象 方法 | 方法 | 描述 | DOM | |------|------|------| | handleEvent() | 把任意对象注册为事件处理程序 | 2 | 文档事件对象 方法 | 方法 | 描述 | DOM | |------|------|------| | createEvent() | | 2 | 鼠标/键盘事件对象 属性 | 属性 | 描述 | DOM | |------|------|------| | altKey | 返回当事件被触发时，\"ALT\" 是否被按下。 | 2 | | button | 返回当事件被触发时，哪个鼠标按钮被点击。 | 2 | | clientX | 返回当事件被触发时，鼠标指针的水平坐标。 | 2 | | clientY | 返回当事件被触发时，鼠标指针的垂直坐标。 | 2 | | ctrlKey | 返回当事件被触发时，\"CTRL\" 键是否被按下。 | 2 | | Location | 返回按键在设备上的位置 | 3 | | charCode | 返回onkeypress事件触发键值的字母代码。 | 2 | | key | 在按下按键时返回按键的标识符。 | 3 | | keyCode | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 | 2 | | which | 返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码。 | 2 | | metaKey | 返回当事件被触发时，\"meta\" 键是否被按下。 | 2 | | relatedTarget | 返回与事件的目标节点相关的节点。 | 2 | | screenX | 返回当某个事件被触发时，鼠标指针的水平坐标。 | 2 | | screenY | 返回当某个事件被触发时，鼠标指针的垂直坐标。 | 2 | | shiftKey | 返回当事件被触发时，\"SHIFT\" 键是否被按下。 | 2 | 方法 | 方法 | 描述 | DOM | |------|------|------| | initMouseEvent() | 初始化鼠标事件对象的值 | 2 | | initKeyboardEvent() | 初始化键盘事件对象的值 | 3 | 浏览器对象 Window对象 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（ 或 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 注意： 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。 Window 对象属性 | 属性 | 描述 | |------|------------| | closed | 返回窗口是否已被关闭。 | | defaultStatus | 设置或返回窗口状态栏中的默认文本。 | | document | 对 Document 对象的只读引用。(请参阅对象) | | frames | 返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。 | | history | 对 History 对象的只读引用。请参数 History 对象。 | | innerHeight | 返回窗口的文档显示区的高度。 | | innerWidth | 返回窗口的文档显示区的宽度。 | | localStorage | 在浏览器中存储 key/value 对。没有过期时间。 | | length | 设置或返回窗口中的框架数量。 | | location | 用于窗口或框架的 Location 对象。请参阅 Location 对象。 | | name | 设置或返回窗口的名称。 | | navigator | 对 Navigator 对象的只读引用。请参数 Navigator 对象。 | | opener | 返回对创建此窗口的窗口的引用。 | | outerHeight | 返回窗口的外部高度，包含工具条与滚动条。 | | outerWidth | 返回窗口的外部宽度，包含工具条与滚动条。 | | pageXOffset | 设置或返回当前页面相对于窗口显示区左上角的 X 位置。 | | pageYOffset | 设置或返回当前页面相对于窗口显示区左上角的 Y 位置。 | | parent | 返回父窗口。 | | screen | 对 Screen 对象的只读引用。请参数 Screen 对象。 | | screenLeft | 返回相对于屏幕窗口的x坐标 | | screenTop | 返回相对于屏幕窗口的y坐标 | | screenX | 返回相对于屏幕窗口的x坐标 | | sessionStorage | 在浏览器中存储 key/value 对。 在关闭窗口或标签页之后将会删除这些数据。 | | screenY | 返回相对于屏幕窗口的y坐标 | | self | 返回对当前窗口的引用。等价于 Window 属性。 | | status | 设置窗口状态栏的文本。 | | top | 返回最顶层的父窗口。 | Window 对象方法 | 方法 | 描述 | |------|------------| | alert() | 显示带有一段消息和一个确认按钮的警告框。 | | atob() | 解码一个 base-64 编码的字符串。 | | btoa() | 创建一个 base-64 编码的字符串。 | | blur() | 把键盘焦点从顶层窗口移开。 | | clearInterval() | 取消由 setInterval() 设置的 timeout。 | | clearTimeout() | 取消由 setTimeout() 方法设置的 timeout。 | | close() | 关闭浏览器窗口。 | | confirm() | 显示带有一段消息以及确认按钮和取消按钮的对话框。 | | createPopup() | 创建一个 pop-up 窗口。 | | focus() | 把键盘焦点给予一个窗口。 | | getSelection() | 返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。 | | getComputedStyle() | 获取指定元素的 CSS 样式。 | | matchMedia() | 该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。 | | moveBy() | 可相对窗口的当前坐标把它移动指定的像素。 | | moveTo() | 把窗口的左上角移动到一个指定的坐标。 | | open() | 打开一个新的浏览器窗口或查找一个已命名的窗口。 | | print() | 打印当前窗口的内容。 | | prompt() | 显示可提示用户输入的对话框。 | | resizeBy() | 按照指定的像素调整窗口的大小。 | | resizeTo() | 把窗口的大小调整到指定的宽度和高度。 | | scroll() | 已废弃。 该方法已经使用了 scrollTo() 方法来替代。 | | scrollBy() | 按照指定的像素值来滚动内容。 | | scrollTo() | 把内容滚动到指定的坐标。 | | setInterval() | 按照指定的周期（以毫秒计）来调用函数或计算表达式。 | | setTimeout() | 在指定的毫秒数后调用函数或计算表达式。 | | stop() | 停止页面载入。 | 计时器 计时事件 通过使用JavaScript，我们有能力做到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行，我们称之为计时事件 计时方法： setInterval()：间隔指定的毫秒数不停地执行指定的代码 clearInterval()：用于停止setInterval()方法执行的函数代码 setTimeout()：暂停指定的毫秒数后执行指定的代码 clearTimeout()：用于停止执行setTimeout()方法的函数代码 History 对象 Histor对象包含用户（在浏览器窗口中）访问过的 URL。 History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。 注意： 没有应用于History对象的公开标准，不过所有浏览器都支持该对象。 History 对象属性 | 属性 | 描述 | |------|------------| | length | 返回历史列表中的网址数 | History 对象方法 | 方法 | 描述 | |------|------------| | back() | 加载 history 列表中的前一个 URL | | forward() | 加载 history 列表中的下一个 URL | | go() | 加载 history 列表中的某个具体页面 | Location 对象 Location 对象包含有关当前 URL 的信息。 Location 对象是 window 对象的一部分，可通过 window.Location 属性对其进行访问。 注意： 没有应用于Location对象的公开标准，不过所有浏览器都支持该对象。 Location 对象属性 | 属性 | 描述 | |------|------------| | hash | 返回一个URL的锚部分 | | host | 返回一个URL的主机名和端口 | | hostname | 返回URL的主机名 | | href | 返回完整的URL | | pathname | 返回的URL路径名。 | | port | 返回一个URL服务器使用的端口号 | | protocol | 返回一个URL协议 | | search | 返回一个URL的查询部分 | Location 对象方法 | 方法 | 描述 | |------|------------| | assign() | 载入一个新的文档 | | reload() | 重新载入当前文档 | | replace() | 用新的文档替换当前文档 | Screen 对象 Screen 对象包含有关客户端显示屏幕的信息。 注意： 没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。 Screen 对象属性 | 属性 | 描述 | |------|------------| | availHeight | 返回屏幕的高度（不包括Windows任务栏） | | availWidth | 返回屏幕的宽度（不包括Windows任务栏） | | colorDepth | 返回目标设备或缓冲器上的调色板的比特深度 | | height | 返回屏幕的总高度 | | pixelDepth | 返回屏幕的颜色分辨率（每象素的位数） | | width | 返回屏幕的总宽度 | "},"Web/JavaScript/JavaScript瀑布流.html":{"url":"Web/JavaScript/JavaScript瀑布流.html","title":"JavaScript瀑布流","keywords":"","body":"datetime:2019/7/5 11:40 author:nzb JavaScript实现瀑布流效果 滚动条到底可以一直加载 warterfall.html js瀑布流效果 myjs.js window.onload = function () { // window.onload() 方法用于在网页加载完毕后立刻执行的操作 imgLocation(\"container\", 'box'); var imgData = {\"data\":[{\"src\":\"../../res/waterfall1.jpg\"},{\"src\":\"../../res/waterfall2.jpg\"},{\"src\":\"../../res/waterfall3.jpg\"}, {\"src\":\"../../res/waterfall4.jpg\"},{\"src\":\"../../res/waterfall5.jpg\"}]}; // 模拟数据 window.onscroll = function () { if(checkFlag()){ //是否到底部 var cparent = document.getElementById(\"container\"); // 获取父级 (优化：因为很多地方用到可以分装成一个函数) for(var i=0;i mystyle.css *{ margin: 0px; padding: 0px; } #container{ position: relative; } .box{ padding: 5px; float: left; } .box_img{ padding: 5px; border: 1px solid #cccccc; box-shadow: 0 0 5px #cccccc; } .box_img img{ width: 150px; height: auto; } "},"Web/JavaScript/JavaScript面向对象.html":{"url":"Web/JavaScript/JavaScript面向对象.html","title":"JavaScript面向对象","keywords":"","body":"datetime:2019/7/5 16:23 author:nzb 面向对象编程 面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式。它使用先前建立的范例，包括模块化，多态和封装几种技术。今天，许多流行的编程语言（如Java，JavaScript，C＃，C+ +，Python，PHP，Ruby和Objective-C）都支持面向对象编程（OOP）。 相对于「一个程序只是一些函数的集合，或简单的计算机指令列表。」的传统软件设计观念而言，面向对象编程可以看作是使用一系列对象相互协作的软件设计。 在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器。 面向对象程序设计的目的是在编程中促进更好的灵活性和可维护性，在大型软件工程中广为流行。凭借其对模块化的重视，面向对象的代码开发更简单，更容易理解，相比非模块化编程方法 1, 它能更直接地分析, 编码和理解复杂的情况和过程。 术语 Namespace 命名空间 允许开发人员在一个独特，应用相关的名字的名称下捆绑所有功能的容器。 Class 类 定义对象的特征。它是对象的属性和方法的模板定义。 Object 对象 类的一个实例。 Property 属性 对象的特征，比如颜色。 Method 方法 对象的能力，比如行走。 Constructor 构造函数 对象初始化的瞬间，被调用的方法。通常它的名字与包含它的类一致。 Inheritance 继承 一个类可以继承另一个类的特征。 Encapsulation 封装 一种把数据和相关的方法绑定在一起使用的方法。 Abstraction 抽象 结合复杂的继承，方法，属性的对象能够模拟现实的模型。 Polymorphism 多态 多意为「许多」，态意为「形态」。不同类可以定义相同的方法或属性。 更多关于面向对象编程的描述，请参照维基百科的 面向对象编程 。 JavaScript面向对象编程 命名空间 命名空间是一个容器，它允许开发人员在一个独特的，特定于应用程序的名称下捆绑所有的功能。 在JavaScript中，命名空间只是另一个包含方法，属性，对象的对象。 注意：需要认识到重要的一点是：与其他面向对象编程语言不同的是，Javascript中的普通对象和命名空间在语言层面上没有区别。这点可能会让JavaScript初学者感到迷惑。 创造的JavaScript命名空间背后的想法很简单：一个全局对象被创建，所有的变量，方法和功能成为该对象的属性。使用命名空间也最大程度地减少应用程序的名称冲突的可能性。 我们来创建一个全局变量叫做 MYAPP // 全局命名空间 var MYAPP = MYAPP || {}; 在上面的代码示例中，我们首先检查MYAPP是否已经被定义（是否在同一文件中或在另一文件）。如果是的话，那么使用现有的MYAPP全局对象，否则，创建一个名为MYAPP的空对象用来封装方法，函数，变量和对象。 我们也可以创建子命名空间： // 子命名空间 MYAPP.event = {}; 下面是用于创建命名空间和添加变量，函数和方法的代码写法： // 给普通方法和属性创建一个叫做MYAPP.commonMethod的容器 MYAPP.commonMethod = { regExForName: \"\", // 定义名字的正则验证 regExForPhone: \"\", // 定义电话的正则验证 validateName: function(name){ // 对名字name做些操作，你可以通过使用“this.regExForname” // 访问regExForName变量 }, validatePhoneNo: function(phoneNo){ // 对电话号码做操作 } } // 对象和方法一起申明 MYAPP.event = { addListener: function(el, type, fn) { // 代码 }, removeListener: function(el, type, fn) { // 代码 }, getEvent: function(e) { // 代码 } // 还可以添加其他的属性和方法 } //使用addListener方法的写法: MYAPP.event.addListener(\"yourel\", \"type\", callback); 标准内置对象 JavaScript有包括在其核心的几个对象，例如，Math，Object，Array和String对象。下面的例子演示了如何使用Math对象的random()方法来获得一个随机数。 console.log(Math.random()); 注意：这里和接下来的例子都假设名为 console.log 的方法全局有定义。console.log 实际上不是 JavaScript 自带的。 查看 JavaScript 参考：全局对象 了解 JavaScript 内置对象的列表。 JavaScript 中的每个对象都是 Object 对象的实例且继承它所有的属性和方法。 自定义对象 类 JavaScript是一种基于原型的语言，它没类的声明语句，比如C+ +或Java中用的。这有时会对习惯使用有类申明语句语言的程序员产生困扰。相反，JavaScript可用方法作类。定义一个类跟定义一个函数一样简单。在下面的例子中，我们定义了一个新类Person。 function Person() { } // 或 var Person = function(){ } 对象（类的实例） 我们使用 new obj 创建对象 obj 的新实例, 将结果（obj 类型）赋值给一个变量方便稍后调用。 在下面的示例中，我们定义了一个名为Person的类，然后我们创建了两个Person的实例(person1 and person2). function Person() { } var person1 = new Person(); var person2 = new Person(); 注意：有一种新增的创建未初始化实例的实例化方法，请参考 Object.create 。 构造器 在实例化时构造器被调用 (也就是对象实例被创建时)。构造器是对象中的一个方法。 在JavaScript中函数就可以作为构造器使用，因此不需要特别地定义一个构造器方法，每个声明的函数都可以在实例化后被调用执行。 构造器常用于给对象的属性赋值或者为调用函数做准备。 在本文的后面描述了类中方法既可以在定义时添加，也可以在使用前添加。 在下面的示例中, Person类实例化时构造器调用一个 alert函数。 function Person() { alert('Person instantiated'); } var person1 = new Person(); var person2 = new Person(); 属性 (对象属性) 属性就是 类中包含的变量;每一个对象实例有若干个属性. 为了正确的继承，属性应该被定义在类的原型属性 (函数)中。 可以使用 关键字 this调用类中的属性, this是对当前对象的引用。 从外部存取(读/写)其属性的语法是: InstanceName.Property; 这与C++，Java或者许多其他语言中的语法是一样的 (在类中语法 this.Property 常用于set和get属性值) 在下面的示例中，我们为定义Person类定义了一个属性 firstName 并在实例化时赋初值。 function Person(firstName) { this.firstName = firstName; alert('Person instantiated'); } var person1 = new Person('Alice'); var person2 = new Person('Bob'); // Show the firstName properties of the objects alert('person1 is ' + person1.firstName); // alerts \"person1 is Alice\" alert('person2 is ' + person2.firstName); // alerts \"person2 is Bob\" 方法（对象属性） 方法与属性很相似， 不同的是：一个是函数，另一个可以被定义为函数。 调用方法很像存取一个属性, 不同的是add () 在方法名后面很可能带着参数. 为定义一个方法, 需要将一个函数赋值给类的 prototype 属性; 这个赋值给函数的名称就是用来给对象在外部调用它使用的。 在下面的示例中，我们给Person类定义了方法 sayHello()，并调用了它. function Person(firstName) { this.firstName = firstName; } Person.prototype.sayHello = function() { alert(\"Hello, I'm \" + this.firstName); }; var person1 = new Person(\"Alice\"); var person2 = new Person(\"Bob\"); // call the Person sayHello method. person1.sayHello(); // alerts \"Hello, I'm Alice\" person2.sayHello(); // alerts \"Hello, I'm Bob\" 在JavaScript中方法通常是一个绑定到对象中的普通函数, 这意味着方法可以在其所在context之外被调用。 思考下面示例中的代码: function Person(firstName) { this.firstName = firstName; } Person.prototype.sayHello = function() { alert(\"Hello, I'm \" + this.firstName); }; var person1 = new Person(\"Alice\"); var person2 = new Person(\"Bob\"); var helloFunction = person1.sayHello; person1.sayHello(); // alerts \"Hello, I'm Alice\" person2.sayHello(); // alerts \"Hello, I'm Bob\" helloFunction(); // alerts \"Hello, I'm undefined\" (or fails // with a TypeError in strict mode) console.log(helloFunction === person1.sayHello); // logs true console.log(helloFunction === Person.prototype.sayHello); // logs true helloFunction.call(person1); // logs \"Hello, I'm Alice\" 如上例所示, 所有指向sayHello函数的引用 ，包括 person1, Person.prototype, 和 helloFunction 等， 均引用了相同的函数. 在调用函数的过程中，this的值取决于我们怎么样调用函数. 在通常情况下，我们通过一个表达式person1.sayHello()来调用函数：即从一个对象的属性中得到所调用的函数。此时this被设置为我们取得函数的对象（即person1）。这就是为什么person1.sayHello() 使用了姓名“Alice”而person2.sayHello()使用了姓名“bob”的原因。 然而我们使用不同的调用方法时, this的值也就不同了。当从变量 helloFunction()中调用的时候， this就被设置成了全局对象 (在浏览器中即window)。由于该对象 (非常可能地) 没有firstName 属性, 我们得到的结果便是\"Hello, I'm undefined\". (这是松散模式下的结果， 在 严格模式中，结果将不同（此时会产生一个error）。 但是为了避免混淆，我们在这里不涉及细节) 。另外，我们可以像上例末尾那样，使用Function#call (或者Function#apply)显式的设置this的值。 更多有关信息请参考 Function#call and Function#apply 继承 创建一个或多个类的专门版本类方式称为继承（Javascript只支持单继承）。 创建的专门版本的类通常叫做子类，另外的类通常叫做父类。 在Javascript中，继承通过赋予子类一个父类的实例并专门化子类来实现。在现代浏览器中你可以使用 Object.create 实现继承. JavaScript 并不检测子类的 prototype.constructor (见 Object.prototype), 所以我们必须手动申明它. 在下面的例子中, 我们定义了 Student类作为 Person类的子类. 之后我们重定义了sayHello() 方法并添加了 sayGoodBye() 方法. // 定义Person构造器 function Person(firstName) { this.firstName = firstName; } // 在Person.prototype中加入方法 Person.prototype.walk = function(){ alert(\"I am walking!\"); }; Person.prototype.sayHello = function(){ alert(\"Hello, I'm \" + this.firstName); }; // 定义Student构造器 function Student(firstName, subject) { // 调用父类构造器, 确保(使用Function#call)\"this\" 在调用过程中设置正确 Person.call(this, firstName); // 初始化Student类特有属性 this.subject = subject; }; // 建立一个由Person.prototype继承而来的Student.prototype对象. // 注意: 常见的错误是使用 \"new Person()\"来建立Student.prototype. // 这样做的错误之处有很多, 最重要的一点是我们在实例化时 // 不能赋予Person类任何的FirstName参数 // 调用Person的正确位置如下，我们从Student中来调用它 Student.prototype = Object.create(Person.prototype); // See note below // 设置\"constructor\" 属性指向Student Student.prototype.constructor = Student; // 更换\"sayHello\" 方法 Student.prototype.sayHello = function(){ console.log(\"Hello, I'm \" + this.firstName + \". I'm studying \" + this.subject + \".\"); }; // 加入\"sayGoodBye\" 方法 Student.prototype.sayGoodBye = function(){ console.log(\"Goodbye!\"); }; // 测试实例: var student1 = new Student(\"Janet\", \"Applied Physics\"); student1.sayHello(); // \"Hello, I'm Janet. I'm studying Applied Physics.\" student1.walk(); // \"I am walking!\" student1.sayGoodBye(); // \"Goodbye!\" // Check that instanceof works correctly console.log(student1 instanceof Person); // true console.log(student1 instanceof Student); // true 对于“Student.prototype = Object.create(Person.prototype);”这一行，在不支持 Object.create方法的老JavaScript引擎中，可以使用一个\"polyfill\"（又名\"shim\"，查看文章链接），或者使用一个function来获得相同的返回值，就像下面： function createObject(proto) { function ctor() { } ctor.prototype = proto; return new ctor(); } // Usage: Student.prototype = createObject(Person.prototype); 封装 在上一个例子中，Student类虽然不需要知道Person类的walk()方法是如何实现的，但是仍然可以使用这个方法；Student类不需要明确地定义这个方法，除非我们想改变它。 这就叫做封装，对于所有继承自父类的方法，只需要在子类中定义那些你想改变的即可。 抽象 抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。 JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。 JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。 var foo = function(){}; console.log( 'foo is a Function: ' + (foo instanceof Function) ); // logs \"foo is a Function: true\" console.log( 'foo.prototype is an Object: ' + (foo.prototype instanceof Object) ); // logs \"foo.prototype is an Object: true\" 多态 就像所有定义在原型属性内部的方法和属性一样，不同的类可以定义具有相同名称的方法;方法是作用于所在的类中。并且这仅在两个类不是父子关系时成立（继承链中，一个类不是继承自其他类）。 注意 本文中所展示的面向对象编程技术不是唯一的实现方式，在JavaScript中面向对象的实现是非常灵活的。 同样的，文中展示的技术没有使用任何语言hacks，它们也没有模仿其他语言的对象理论实现。 JavaScript中还有其他一些更加先进的面向对象技术，但这些都超出了本文的介绍范围。 "},"Web/JavaScript/框架/Promise.html":{"url":"Web/JavaScript/框架/Promise.html","title":"Promise","keywords":"","body":"datetime:2019/12/5 15:03 author:nzb 接口调用方式 原生ajax 基于jQuery的ajax fetch axios 异步 JavaScript的执行环境是「单线程」 所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程 异步模式可以一起执行多个任务 JS中常见的异步调用 定时任何 ajax 事件函数 promise 主要解决异步深层嵌套的问题 promise 提供了简洁的API 使得异步操作更加容易 /* 1. Promise基本使用 我们使用new来构建一个Promise Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数 */ var p = new Promise(function(resolve, reject){ //2. 这里用于实现异步任务 setTimeout setTimeout(function(){ var flag = false; if(flag) { //3. 正常情况 resolve('hello'); }else{ //4. 异常情况 reject('出错了'); } }, 100); }); // 5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 // 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 p.then(function(data){ console.log(data) },function(info){ console.log(info) }); 基于Promise发送Ajax请求 JavaScript /* 基于Promise发送Ajax请求 */ function queryData(url) { # 1.1 创建一个Promise实例 var p = new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 && xhr.status == 200) { # 1.2 处理正常的情况 resolve(xhr.responseText); }else{ # 1.3 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); return p; } # 注意： 这里需要开启一个服务 # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 queryData('http://localhost:3000/data') .then(function(data){ console.log(data) # 1.4 想要继续链式编程下去 需要 return return queryData('http://localhost:3000/data1'); }) .then(function(data){ console.log(data); return queryData('http://localhost:3000/data2'); }) .then(function(data){ console.log(data) }); Jquery jquery中的promise $(function () { $(\"#btn\").on(\"click\", function () { $.ajax({ url: './data.json', type: 'get', dataType: 'json', //常见用法 // success: function (data) { // console.log(data) // } }) //promise用法 .then(function (data) { console.log(\"promise后数据\", data) }) }) }) Promise 基本API 实例方法 .then() 得到异步任务正确的结果 .catch() 获取异常信息 .finally() 成功与否都会执行（不是正式标准） /* Promise常用API-实例方法 */ // console.dir(Promise); function foo() { return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject('error'); }, 100); }) } // foo() // .then(function(data){ // console.log(data) // }) // .catch(function(data){ // console.log(data) // }) // .finally(function(){ // console.log('finished') // }); // -------------------------- // 两种写法是等效的 foo() .then(function(data){ # 得到异步任务正确的结果 console.log(data) },function(data){ # 获取异常信息 console.log(data) }) # 成功与否都会执行（不是正式标准） .finally(function(){ console.log('finished') }); 静态方法 .all() Promise.all方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定 .race() Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数 ​ /* Promise常用API-对象方法 */ // console.dir(Promise) function queryData(url) { return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 && xhr.status == 200) { // 处理正常的情况 resolve(xhr.responseText); }else{ // 处理异常情况 reject('服务器错误'); } }; xhr.open('get', url); xhr.send(null); }); } var p1 = queryData('http://localhost:3000/a1'); var p2 = queryData('http://localhost:3000/a2'); var p3 = queryData('http://localhost:3000/a3'); Promise.all([p1,p2,p3]).then(function(result){ // all 中的参数 [p1,p2,p3] 和 返回的结果一 一对应[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] console.log(result) //[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"] }) Promise.race([p1,p2,p3]).then(function(result){ // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。 console.log(result) // \"HELLO TOM\" }) fetch Fetch API是新的ajax解决方案 Fetch会返回Promise fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch(url, options).then(） /* Fetch API 基本用法 fetch(url).then() 第一个参数请求的路径 Fetch会返回Promise 所以我们可以使用then 拿到请求成功的结果 */ fetch('http://localhost:3000/fdata').then(function(data){ // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data){ // 在这个then里面我们能拿到最终的数据 console.log(data); }) fetch API 中的 HTTP 请求 fetch(url, options).then(） HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT 默认的是 GET 请求 需要在 options 对象中 指定对应的 method method:请求使用的方法 post 和 普通 请求的时候 需要在options 中 设置 请求头 headers 和 body /* Fetch API 调用接口传递参数 */ #1.1 GET参数传递 - 传统URL 通过url ？ 的形式传参 fetch('http://localhost:3000/books?id=123', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { # 它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data) { # 在这个then里面我们能拿到最终的数据 console.log(data) }); #1.2 GET参数传递 restful形式的URL 通过/ 的形式传递参数 即 id = 456 和id后台的配置有关 fetch('http://localhost:3000/books/456', { # get 请求可以省略不写 默认的是GET method: 'get' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #2.1 DELETE请求方式参数传递 删除id 是 id=789 fetch('http://localhost:3000/books/789', { method: 'delete' }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #3 POST请求传参 fetch('http://localhost:3000/books', { method: 'post', # 3.1 传递数据 body: 'uname=lisi&pwd=123', # 3.2 设置请求头 headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # POST请求传参 fetch('http://localhost:3000/books', { method: 'post', body: JSON.stringify({ uname: '张三', pwd: '456' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # PUT请求传参 修改id 是 123 的 fetch('http://localhost:3000/books/123', { method: 'put', body: JSON.stringify({ uname: '张三', pwd: '789' }), headers: { 'Content-Type': 'application/json' } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); fetchAPI 中 响应格式 用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如JSON，BLOB或者TEXT等等 /* Fetch响应结果的数据格式 */ fetch('http://localhost:3000/json').then(function(data){ // return data.json(); // 将获取到的数据使用 json 转换对象 return data.text(); // // 将获取到的数据 转换成字符串 }).then(function(data){ // console.log(data.uname) // console.log(typeof data) var obj = JSON.parse(data); console.log(obj.uname,obj.age,obj.gender) }) axios 基于promise用于浏览器和node.js的http客户端 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 能转换请求和响应数据 axios基础用法 get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params 形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 # 1. 发送get 请求 axios.get('http://localhost:3000/adata').then(function(ret){ # 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret) }) # 2. get 请求传递参数 # 2.1 通过传统的url 以 ? 的形式传递参数 axios.get('http://localhost:3000/axios?id=123').then(function(ret){ console.log(ret.data) }) # 2.2 restful 形式传递参数 axios.get('http://localhost:3000/axios/123').then(function(ret){ console.log(ret.data) }) # 2.3 通过params 形式传递参数 axios.get('http://localhost:3000/axios', { params: { id: 789 } }).then(function(ret){ console.log(ret.data) }) #3 axios delete 请求传参 传参的形式和 get 请求一样 axios.delete('http://localhost:3000/axios', { params: { id: 111 } }).then(function(ret){ console.log(ret.data) }) # 4 axios 的 post 请求 # 4.1 通过选项传递参数 axios.post('http://localhost:3000/axios', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) }) # 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams(); params.append('uname', 'zhangsan'); params.append('pwd', '111'); axios.post('http://localhost:3000/axios', params).then(function(ret){ console.log(ret.data) }) #5 axios put 请求传参 和 post 请求一样 axios.put('http://localhost:3000/axios/123', { uname: 'lisi', pwd: 123 }).then(function(ret){ console.log(ret.data) }) axios 全局配置 # 配置公共的请求头 axios.defaults.baseURL = 'https://api.example.com'; # 配置 超时时间 axios.defaults.timeout = 2500; # 配置公共的请求头 axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; # 配置公共的 post 的 Content-Type axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; axios 拦截器 请求拦截器 请求拦截器的作用是在请求发送前进行一些操作 例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易 响应拦截器 响应拦截器的作用是在接收到响应后进行一些操作 例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页 # 1. 请求拦截器 axios.interceptors.request.use(function(config) { console.log(config.url) # 1.1 任何请求都会经过这一步 在发送请求之前做些什么 config.headers.mytoken = 'nihao'; # 1.2 这里一定要return 否则配置不成功 return config; }, function(err){ #1.3 对请求错误做点什么 console.log(err) }) #2. 响应拦截器 axios.interceptors.response.use(function(res) { #2.1 在接收响应做些什么 var data = res.data; return data; }, function(err){ #2.2 对响应错误做点什么 console.log(err) }) async 和 await async作为一个关键字放到函数前面 任何一个async函数都会隐式返回一个promise await关键字只能在使用async定义的函数中使用 ​ await后面可以直接跟一个 Promise实例对象 ​ await函数不能单独使用 async/await 让异步代码看起来、表现起来更像同步代码 # 1. async 基础用法 # 1.1 async作为一个关键字放到函数前面 async function queryData() { # 1.2 await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 var ret = await new Promise(function(resolve, reject){ setTimeout(function(){ resolve('nihao') },1000); }) // console.log(ret.data) return ret; } # 1.3 任何一个async函数都会隐式返回一个promise 我们可以使用then 进行链式编程 queryData().then(function(data){ console.log(data) }) #2. async 函数处理多个异步函数 axios.defaults.baseURL = 'http://localhost:3000'; async function queryData() { # 2.1 添加await之后 当前的await 返回结果之后才会执行后面的代码 var info = await axios.get('async1'); #2.2 让异步代码看起来、表现起来更像同步代码 var ret = await axios.get('async2?info=' + info.data); return ret.data; } queryData().then(function(data){ console.log(data) }) 图书列表案例 1. 基于接口案例-获取图书列表 导入axios 用来发送ajax 把获取到的数据渲染到页面上 编号 名称 时间 操作 { {item.id} } { {item.name} } { {item.date } } 修改 | 删除 1. 导入axios /* 图书管理-添加图书 */ # 2 配置公共的url地址 简化后面的调用方式 axios.defaults.baseURL = 'http://localhost:3000/'; axios.interceptors.response.use(function(res) { return res.data; }, function(error) { console.log(error) }); var vm = new Vue({ el: '#app', data: { flag: false, submitFlag: false, id: '', name: '', books: [] }, methods: { # 3 定义一个方法 用来发送 ajax # 3.1 使用 async 来 让异步的代码 以同步的形式书写 queryData: async function() { // 调用后台接口获取图书列表数据 // var ret = await axios.get('books'); // this.books = ret.data; # 3.2 发送ajax请求 把拿到的数据放在books 里面 this.books = await axios.get('books'); } }, mounted: function() { # 4 mounted 里面 DOM已经加载完毕 在这里调用函数 this.queryData(); } }); 2 添加图书 获取用户输入的数据 发送到后台 渲染最新的数据到页面上 methods: { handle: async function(){ if(this.flag) { // 编辑图书 // 就是根据当前的ID去更新数组中对应的数据 this.books.some((item) => { if(item.id == this.id) { item.name = this.name; // 完成更新操作之后，需要终止循环 return true; } }); this.flag = false; }else{ # 1.1 在前面封装好的 handle 方法中 发送ajax请求 # 1.2 使用async 和 await 简化操作 需要在 function 前面添加 async var ret = await axios.post('books', { name: this.name }) # 1.3 根据后台返回的状态码判断是否加载数据 if(ret.status == 200) { # 1.4 调用 queryData 这个方法 渲染最新的数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, } 3 验证图书名称是否存在 添加图书之前发送请求验证图示是否已经存在 如果不存在 往后台里面添加图书名称 图书存在与否只需要修改submitFlag的值即可 watch: { name: async function(val) { // 验证图书名称是否已经存在 // var flag = this.books.some(function(item){ // return item.name == val; // }); var ret = await axios.get('/books/book/' + this.name); if(ret.status == 1) { // 图书名称存在 this.submitFlag = true; }else{ // 图书名称不存在 this.submitFlag = false; } } }, 4. 编辑图书 根据当前书的id 查询需要编辑的书籍 需要根据状态位判断是添加还是编辑 methods: { handle: async function(){ if(this.flag) { #4.3 编辑图书 把用户输入的信息提交到后台 var ret = await axios.put('books/' + this.id, { name: this.name }); if(ret.status == 200){ #4.4 完成添加后 重新加载列表数据 this.queryData(); } this.flag = false; }else{ // 添加图书 var ret = await axios.post('books', { name: this.name }) if(ret.status == 200) { // 重新加载列表数据 this.queryData(); } } // 清空表单 this.id = ''; this.name = ''; }, toEdit: async function(id){ #4.1 flag状态位用于区分编辑和添加操作 this.flag = true; #4.2 根据id查询出对应的图书信息 页面中可以加载出来最新的信息 # 调用接口发送ajax 请求 var ret = await axios.get('books/' + id); this.id = ret.id; this.name = ret.name; }, 5 删除图书 把需要删除的id书籍 通过参数的形式传递到后台 deleteBook: async function(id){ // 删除图书 var ret = await axios.delete('books/' + id); if(ret.status == 200) { // 重新加载列表数据 this.queryData(); } } "},"Web/JavaScript/框架/Vue.js基础.html":{"url":"Web/JavaScript/框架/Vue.js基础.html","title":"Vue.Js基础","keywords":"","body":"datetime:2019/7/15 10:09 author:nzb Vue.js Vue.js 是什么 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时， Vue 也完全能够为复杂的单页应用提供驱动。 简单示例 Vue基础 { { msg } } // 2.创建一个Vue示例 // 当我们导入包后，浏览器的内存中就多了一个Vue的构造函数 // 这个new出来的vm对象就是MVVM中的VM调度者 var vm = new Vue({ el: '#app', // 表示element, 网页上需要控制的区域 // 这里的data就是MVVM中的M，用于保存页面的数据 data: { // 存储需要的数据。 msg: \"Hello world, I'm Vue.js!!!\" // 通过Vue指令，把数据渲染到页面，不需要再操作DOM元素。 // (前端Vue之类的框架，不提倡我们去手动操作DOM元素了) } }) 模板语法 Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。 插值 文本 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： Message: { { msg } } Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 这个将不会改变: { { msg } } 原始HTML 双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令： Using mustaches: { { rawHtml } } Using v-html directive: 这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板， 因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 特性 Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令： 对于布尔特性 (它们只要存在就意味着值为 true)，v-bind 工作起来略有不同，在这个例子中： Button 如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 元素中。 使用 JavaScript 表达式 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 { { number + 1 } } { { ok ? 'YES' : 'NO' } } { { message.split('').reverse().join('') } } 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 { { var a = 1 } } { { if (ok) { return message } } } 注意：模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 指令 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子： 现在你看到我了 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 元素。 参数 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性： ... 在这里 href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件： ... 在这里参数是监听的事件名。我们也会更详细地讨论事件处理。 动态参数 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： ... 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 \"href\"，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： ... 同样地，当 eventName 的值为 \"focus\" 时，v-on:[eventName] 将等价于 v-on:focus。 对动态参数的值的约束 注意：动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在 HTML 特性名里是无效的。同样，在 DOM 中使用模板时你需要回避大写键名。 例如，下面的代码是无效的： ... 变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。 另外，如果你在 DOM 中使用模板 (直接在一个 HTML 文件里撰写模板)，需要留意浏览器会把特性名全部强制转为小写： ... 修饰符 修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： ... 事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 例子 百度一下 var vm = new Vue({ el: '#app', data: {}, methods: { divclick(){ console.log('div'); }, btnclick(){ console.log('btn') }, noredirect(){ console.log('a') } }, }); 归纳常见指令 v-cloak：解决闪烁问题 当网速较慢时，vue加载较慢，插值表达式渲染的数据就会产生闪烁，使用v-cloak指令加上如上样式可以解决该问题 v-text：插入文本字符串 v-text默认就没有闪烁，但是会以文本字符串的方式覆盖所在元素的文本 v-html：插入html v-html与v-text的不同在于插入的是html。 v-bind：绑定属性 在vue中想要让属性如title等于data对象中的一个变量（键），会被直接当作字符串显示出来，这时就要用到v-bind，v-bind可以将绑定的属性值当作变量对待，在data对象中去找。 v-bind的三种用法： 直接使用指令v-bind 使用简化指令\":\" 在绑定的时候，拼接绑定内容：:title=\"btnTitle + ', 这是追加的内容'\" v-on：绑定方法,缩写：\"@\" 示例 +++++{ { msg } }----- ====== 123123 var vm = new Vue({ el: '#app', data: { msg: 'hello', msg2: '我是h1', mytitle: '这是一个自定义title', }, methods: { // 这个methods属性中定义了当前vue实例所有可用的方法 show: function () { alert(\"Hello!!!\") } } }) v-model：、实现双向数据绑定： { { message } } new Vue({ el: '#app', data: { message: 'Runoob!' } }) 注意：v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 缩写 v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的特性。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时， v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。 同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。 因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写 ... ... v-on 缩写 ... ... 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于特性名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。 在Vue中使用样式 使用class样式 数组 这是一个邪恶的H1 数组中使用三元表达式 这是一个邪恶的H1 数组中嵌套对象(对象就是键值对) 这是一个邪恶的H1 直接使用对象 这是一个邪恶的H1 var vm = new Vue({ el: '#app', data: { flag: true, classObj: {red:true, thin:true, italic:true, active:false}, }, methods: {}, }); 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 这是一个善良的H1 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 这是一个善良的H1 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： data: { h1StyleObj: { color: 'red', 'font-size': '40px', 'font-weight': '200' }, h1StyleObj2: { fontStyle: 'italic' } } 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 这是一个善良的H1 条件渲染 v-if 条件判断使用 v-if 指令： 现在你看到我了 菜鸟教程 学的不仅是技术，更是梦想！ 哈哈哈，打字辛苦啊！！！ new Vue({ el: '#app', data: { seen: true, ok: true } }) 你可以使用 v-else 指令来表示 v-if 的“else 块”： 0.5\"> Now you see me Now you don't v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： A B C Not A/B/C 注意：v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 v-show Hello! 注意，v-show 不支持 元素，也不支持 v-else。 v-if vs v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换， 则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-if 与 v-for 一起使用 不推荐同时使用 v-if 和 v-for。请查阅风格指南以获取更多信息。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。请查阅列表渲染指南 以获取详细信息。 列表渲染-循环 v-for迭代数组 { { parentMessage } } - { { index } } - { { item.message } } var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [ { message: 'Foo' }, { message: 'Bar' } ] } }) 第二个参数为当前项的索引。 v-for迭代对象中的属性 { { value } } new Vue({ el: '#v-for-object', data: { object: { title: 'How to do lists in Vue', author: 'Jane Doe', publishedAt: '2016-04-10' } } }) 你也可以提供第二个的参数为 property 名称 (也就是键名)： { { name } }: { { value } } 还可以用第三个参数作为索引： { { index } }. { { name } }: { { value } } v-for迭代数字 { { n } } 注意事项 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=\"$index\"。 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： 建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。 注意：不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。 过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： { { message | capitalize } } 你可以在一个组件的选项中定义本地的过滤器： filters: { capitalize: function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) } } 或者在创建 Vue 实例之前全局定义过滤器： Vue.filter('capitalize', function (value) { if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) }) new Vue({ // ... }) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 过滤器可以串联： { { message | filterA | filterB } } 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript 函数，因此可以接收参数： { { message | filterA('arg1', arg2) } } 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 事件处理 监听事件 可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 示例： Add 1 The button above has been clicked { { counter } } times. var example1 = new Vue({ el: '#example-1', data: { counter: 0 } }) 事件处理方法 然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。 示例： Greet var example2 = new Vue({ el: '#example-2', data: { name: 'Vue.js' }, // 在 `methods` 对象中定义方法 methods: { greet: function (event) { // `this` 在方法里指向当前 Vue 实例 alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 if (event) { alert(event.target.tagName) } } } }) // 也可以用 JavaScript 直接调用方法 example2.greet() // => 'Hello Vue.js!' 内联处理器中的方法 除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： Say hi Say what new Vue({ el: '#example-3', methods: { say: function (message) { alert(message) } } }) 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： Submit // ... methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) } } 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive ... ... 注意：使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 2.3.0 新增 Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。 ... 这个 .passive 修饰符尤其能够提升移动端的性能。 注意：不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 按键修饰符 在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 按键码 keyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持。 使用 keyCode 特性也是允许的： 为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。 你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名： // 可以使用 v-on:keyup.f1 Vue.config.keyCodes.f1 = 112 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 例如： Do something 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 A A A 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 为什么在 HTML 中监听事件? 你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 自定义指令 简介 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。 然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子。 当页面加载时，该元素将获得焦点 (注意：autofocus 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容， 这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能： // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 如果想注册局部指令，组件中也接受一个 directives 的选项： directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 然后你可以在模板中任何元素上使用新的 v-focus 属性，如下： 钩子函数 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。 但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 钩子函数参数 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 注意：除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 这是一个使用了这些属性的自定义钩子样例： Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' } }) 结果： name: \"demo\" value: \"hello!\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 动态指令参数 指令的参数可以是动态的。例如，在 v-mydirective:[argument]=\"value\"中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。 例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令： Scroll down the page Stick me 200px from the top of the page Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' el.style.top = binding.value + 'px' } }) new Vue({ el: '#baseexample' }) 这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。 Scroll down inside this section ↓ I am pinned onto the page at 200px to the left. Vue.directive('pin', { bind: function (el, binding, vnode) { el.style.position = 'fixed' var s = (binding.arg == 'left' ? 'left' : 'top') el.style[s] = binding.value + 'px' } }) new Vue({ el: '#dynamicexample', data: function () { return { direction: 'left' } } }) 这样这个自定义指令现在的灵活性就足以支持一些不同的用例了。 函数简写 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: Vue.directive('color-swatch', function (el, binding) { el.style.backgroundColor = binding.value }) 对象字面量 如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。 Vue.directive('demo', function (el, binding) { console.log(binding.value.color) // => \"white\" console.log(binding.value.text) // => \"hello!\" }) vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器 vue-resource 实现 get, post, jsonp请求 除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； const http = require('http'); // 导入解析 URL 地址的核心模块 const urlModule = require('url'); const server = http.createServer(); // 监听 服务器的 request 请求事件，处理每个请求 server.on('request', (req, res) => { const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') { // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = { name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] }; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `${cbName}(${JSON.stringify(data)})`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); } else { res.end('404'); } }); server.listen(3000, () => { console.log('server running at http://127.0.0.1:3000'); Vue.js Ajax(axios) Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。 Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Github开源地址： https://github.com/axios/axios 安装方法 使用 cdn: 或 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 yarn: $ yarn add axios GET方法 我们可以简单的读取 JSON 数据： new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .get('https://www.runoob.com/try/ajax/json_demo.json') .then(response => (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) 使用 response.data 读取 JSON 数据： 网站列表 { { site.name } } new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .get('https://www.runoob.com/try/ajax/json_demo.json') .then(response => (this.info = response.data.sites)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) GET 方法传递参数格式如下： // 直接在 URL 上添加参数 ID=12345 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 也可以通过 params 设置参数： axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); POST方法 示例 new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .post('https://www.runoob.com/try/ajax/demo_axios_post.php') .then(response => (this.info = response)) .catch(function (error) { // 请求失败处理 console.log(error); }); } }) POST 方法传递参数格式如下： axios.post('/user', { firstName: 'Fred', // 参数 firstName lastName: 'Flintstone' // 参数 lastName }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 示例 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); axios API 可以通过向axios传递相关配置来创建请求 axios(config) // 发送 POST 请求 axios({ method: 'post', url: '/user/12345', data: { firstName: 'Fred', lastName: 'Flintstone' } }); // GET 请求远程图片 axios({ method:'get', url:'http://bit.ly/2mTM3nY', responseType:'stream' }) .then(function(response) { response.data.pipe(fs.createWriteStream('ada_lovelace.jpg')) }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); 请求方法的别名 为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 可以使用自定义配置创建一个axios实例： axios.create([config]) const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: {'X-Custom-Header': 'foobar'} }); 实例方法 以下是可以的实例方法，指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置项 下面是创建请求时可用的配置选项，注意只有url是必需的。如果没有指定method，请求将默认使用get方法。 { // `url` 是用于请求的服务器 URL url: \"/user\", // `method` 是创建请求时使用的方法 method: \"get\", // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: \"https://some-domain.com/api/\", // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {\"X-Requested-With\": \"XMLHttpRequest\"}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: \"brackets\"}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\" // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: \"Fred\" }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求花费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: \"janedoe\", password: \"s00pers3cret\" }, // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\" responseType: \"json\", // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: \"XSRF-TOKEN\", // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // \"proxy\" 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: \"127.0.0.1\", port: 9000, auth: : { username: \"mikeymike\", password: \"rapunz3l\" } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 axios请求的响应包含以下信息 { // `data` 由服务器提供的响应 data: {}, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: \"OK\", // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用then时，会接收下面这样的响应： axios.get(\"/user/12345\") .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。 配置的默认值 你可以指定将被用在各个请求的配置默认值。 全局的axios默认值 axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: 'https://api.example.com' }); // 在实例已创建后修改默认值 instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 `0` var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get('/longRequest', { timeout: 5000 }); 拦截器 在请求或响应被 then 或 catch 处理前拦截它们。 // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器。 var instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理： axios.get('/user/12345') .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log('Error', error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get('/user/12345', { validateStatus: function (status) { return status 取消 使用 cancel token 取消请求。 Axios 的 cancel token API 基于cancelable promises proposal 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： var CancelToken = axios.CancelToken; var source = CancelToken.source(); axios.get('/user/12345', { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log('Request canceled', thrown.message); } else { // 处理错误 } }); // 取消请求（message 参数是可选的） source.cancel('Operation canceled by the user.'); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get('/user/12345', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); 注意：可以使用同一个 cancel token 取消多个请求。 请求时使用 application/x-www-form-urlencoded axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。 浏览器 在浏览器环境，你可以使用 URLSearchParams API： const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); URLSearchParams 不是所有的浏览器均支持。 除此之外，你可以使用 qs 库来编码数据: const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); // Or in another way (ES6), import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); Node.js 环境 在 node.js里, 可以使用 querystring 模块: const querystring = require('querystring'); axios.post('http://something.com/', querystring.stringify({ foo: 'bar' })); 当然，同浏览器一样，你还可以使用 qs 库。 Promises axios 依赖原生的 ES6 Promise 实现而被支持。 如果你的环境不支持 ES6 Promise，你可以使用 polyfill。 TypeScript支持 axios 包含 TypeScript 的定义。 import axios from \"axios\"; axios.get(\"/user?ID=12345\"); 案例 跑马灯 简易计算器 品牌管理案例 "},"Web/JavaScript/框架/Vue.js组件.html":{"url":"Web/JavaScript/框架/Vue.js组件.html","title":"Vue.Js组件","keywords":"","body":"datetime:2019/11/27 16:40 author:nzb Vue.js组件 基础 基本示例 简单示例 // 定义一个名为 button-counter 的新组件 Vue.component('button-counter', { data: function () { return { count: 0 } }, template: 'You clicked me { { count } } times.' }) new Vue({ el: '#components-demo' }) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 组件的复用 你可以将组件进行任意次数的复用： 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 data必须是一个函数 当我们定义这个 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象： data: { count: 0 } 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： data: function f() { return { count: 0 } } 组件的注册 通常一个应用会以一颗嵌套的组件树的形式来组织 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。 组件名 在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了： Vue.component('my-component-name', { /* ... */ }) 该组件名就是 Vue.component 的第一个参数。 你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 你可以在风格指南中查阅到关于组件名的其它建议。 组件名大小写 使用kebab-case Vue.component('my-component-name', { /* ... */ }) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 。 使用 PascalCase Vue.component('MyComponentName', { /* ... */ }) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 和 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册 到目前为止，我们只用过 Vue.component 来创建组件： Vue.component('my-component-name', { // ... 选项 ... }) 这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中。比如： Vue.component('component-a', { /* ... */ }) Vue.component('component-b', { /* ... */ }) Vue.component('component-c', { /* ... */ }) new Vue({ el: '#app' }) 在所有子组件中也是如此，也就是说这三个组件在各自内部也都可以相互使用。 局部注册 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件： var ComponentA = { /* ... */ } var ComponentB = { /* ... */ } var ComponentC = { /* ... */ } 然后在 components 选项中定义你想要使用的组件： new Vue({ el: '#app', components: { 'component-a': ComponentA, 'component-b': ComponentB } }) 对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 注意局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写： var ComponentA = { /* ... */ } var ComponentB = { components: { 'component-a': ComponentA }, // ... } 或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像： import ComponentA from './ComponentA.vue' export default { components: { ComponentA }, // ... } 注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是： 用在模板中的自定义元素的名称 包含了这个组件选项的变量名 通过 Prop 向子组件传递数据 早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 prop 的由来。 Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中： Vue.component('blog-post', { props: ['title'], template: '{ { title } }' }) 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 一个 prop 被注册之后，你就可以像这样把数据作为一个自定义特性传递进来： 然而在一个典型的应用中，你可能在 data 里有一个博文的数组： new Vue({ el: '#blog-post-demo', data: { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] } }) 并想要为每篇博文渲染一个组件： 如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。 到目前为止，关于 prop 你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把 prop 读完。 单个根元素 当构建一个 组件时，你的模板最终会包含的东西远不止一个标题： { { title } } 最最起码，你会包含这篇博文的正文： { { title } } 然而如果你在模板中尝试这样写，Vue 会显示一个错误，并解释道 every component must have a single root element (每个组件必须只有一个根元素)。你可以将模板的内容包裹在一个父元素内，来修复这个问题，例如： { { title } } 看起来当组件变得越来越复杂的时候，我们的博文不只需要标题和内容，还需要发布日期、评论等等。为每个相关的信息定义一个 prop 会变得很麻烦： 所以是时候重构一下这个 组件了，让它变成接受一个单独的 post prop： Vue.component('blog-post', { props: ['post'], template: ` { { post.title } } ` }) 注意：上述的这个和一些接下来的示例使用了 JavaScript 的模板字符串来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之。 现在，不论何时为 post 对象添加一个新的属性，它都会自动地在 内可用。 动态组件(组件切换) 有点时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 元素加一个特殊的 is 特性来实现： 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 你可以在这里查阅并体验完整的代码，或在这个版本了解绑定组件选项对象，而不是已注册组件名的示例。 到目前为止，关于动态组件你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把动态和异步组件读完。 多个组件的过渡动画 多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件。 其中mode=\"out-in\"属性是先出后进 new Vue({ el: '#transition-components-demo', data: { view: 'v-a' }, components: { 'v-a': { template: 'Component A' }, 'v-b': { template: 'Component B' } } }) .component-fade-enter-active, .component-fade-leave-active { transition: opacity .3s ease; } .component-fade-enter, .component-fade-leave-to /* .component-fade-leave-active for below version 2.1.8 */ { opacity: 0; } 父组件向子组件传值 Document var vm = new Vue({ el: '#app', data:{ msg: '123父组件中的数据' }, methods: { }, components:{ 'com1':{ //子组件中，默认无法访问到父组件中的data和methods template: ' 这是子组件 { {parentmsg} }', //注意，组件中的所有props中的数据都是通过父组件传递给子组件的 //propes中的数据是只可读 props: ['parentmsg'] ,// 把父组件传递过来的parentmsg属性， 数组中，定义一下，这样才能用这个数据, //注意子组件中的data数据，并不是通过父组件传递过来的，而是子组件字有的，比如：子组件通过Ajax请求回来的值，可以放到data中 //dat a中的数据可读可写 data(){ return { title: '123', content: 'qqq' } }, methods: { change(){ this.parentmsg='被修改' } }, } } }) 父组件把方法传递给子组件 Document 子组件 //定义了一个字面类型的组件模板对象 var com2 = { template: '#temp1' , methods: { myclick(){ //当点击子组件方法的时候，如何拿到父组件传递过来的func方法 //emit是触发的意思 this.$emit('func', this.sonmsg) } }, data() { return { sonmsg: { name: 'aaa', age: 6 } } } } var vm = new Vue({ el: '#app', data: { datamsgFromSon: null }, methods: { show(data){ // console.log('调用了父组件身上的show方法'+data) console.log(data) this.datamsgFromSon = data }, }, components:{ com2 }, }) ref获取DOM元素和组件 Document 哈哈哈 拉拉 var login = { template: ' 登陆组件 ', data(){ return { msg: 'template msg' } }, methods: { show(){ console.log('调用了子组件的方法') } }, } var vm = new Vue({ el: '#app', data: { }, methods: { getElement(){ console.log(this.$refs.myh3.innerText) console.log(this.$refs.myLogin.msg) this.$refs.myLogin.show() } }, components:{ login } }) "},"Web/JavaScript/框架/Vue.js路由.html":{"url":"Web/JavaScript/框架/Vue.js路由.html","title":"Vue.Js路由","keywords":"","body":"datetime:2019/12/3 14:13 author:nzb Vue.js路由 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 基本示例 Document .router-link-active, .myactive{ color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; } .v-enter, .v-leave-to{ opacity: 0; transform: translateX(140px); } .v-enter-active, .v-leave-active{ transition: all 0.5s ease; } 登陆 注册 登陆 注册 var login = { template: 'login' } var register = { template: '注册' } /* 1 创建一个路由对象， 当导入vue-router之后，在windows 全局对象中，就有了一个路由的构造函数叫做VueRouter 在new路由对象的时候，可以为构造函数传递一个配置对象 */ var routerObj = new VueRouter({ routes:[ //路由匹配规则 /* 每个路由规则都是一个对象，这个规则的对象必须有两个必须的属性 属性1：path 表示监听哪个路由链接地址 属性2：component，表示如果路由是前面匹配到的path，则展示component属性对应的组件 */ //注意：component的属性值必须是一个组件的模板对象 不能是组件的引用名称 //{ path: '/', component: login}, { path:'/', redirect: '/login'}, { path: '/login', component: login}, { path: '/register', component: register} ], linkActiveClass: 'myactive' }) var vm = new Vue({ el: '#app', data: { }, methods: { }, //将路由规则对象， 注册到vm实例上，用来舰艇URL地址的变化，然后展示对应的组件 router: routerObj }) 重定向和别名 重定向// 重定向也是通过 `routes` 配置来完成，下面例子是从 `/a` 重定向到 `/b`： const router = new VueRouter({ routes: [ { path: '/a', redirect: '/b' } ] }) //重定向的目标也可以是一个命名的路由： const router = new VueRouter({ routes: [ { path: '/a', redirect: { name: 'foo' } } ] }) // 甚至是一个方法，动态返回重定向目标： const router = new VueRouter({ routes: [ { path: '/a', redirect: to => { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 } } ] }) 注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。 其它高级用法，请参考例子。 别名 “重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，那么“别名”又是什么呢？ /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。 上面对应的路由配置为： const router = new VueRouter({ routes: [ { path: '/a', component: A, alias: '/b' } ] }) “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。更多高级用法，请查看例子。 高亮，过渡动画，重定向示例 在路由规则中定义参数 在规则中定义参数：{ path: '/register/:id', component: register } 通过 this.$route.params来获取路由中的参数： ```javascript var register = Vue.extend({template: '注册组件 --- { {this.$route.params.id} }' }); ### [路由嵌套](https://router.vuejs.org/zh/guide/essentials/nested-routes.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1) 实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： ![](../../res/vue-路由嵌套.png) 借助 `vue-router`，使用嵌套路由配置，就可以很简单地表达这种关系。 接着上节创建的 app： ```html 这里的 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 。例如，在 User 组件的模板添加一个 ： const User = { template: ` User { { $route.params.id } } ` } 要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置： const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, children: [ { // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 中 path: 'profile', component: UserProfile }, { // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 中 path: 'posts', component: UserPosts } ] } ] }) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。 你会发现，children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。 此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 中 { path: '', component: UserHome }, // ...其他子路由 ] } ] }) 命名视图 示例实现经典布局 名称拼接案例 案例1：使用keyup 案例2：使用watch监听 使用watch监听路由变化 案例3：computed计算属性 watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； "},"Web/JavaScript/框架/Vue.js过渡和动画.html":{"url":"Web/JavaScript/框架/Vue.js过渡和动画.html","title":"Vue.Js过渡和动画","keywords":"","body":"datetime:2019/11/26 9:19 author:nzb Vue.js过渡和动画 Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。 包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡 简单例子 Toggle hello new Vue({ el: '#demo', data: { show: true } }) .fade-enter-active, .fade-leave-active { transition: opacity .5s; } .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } 过渡的类名 过渡其实就是一个淡入淡出的效果。Vue在元素显示与隐藏的过渡中，提供了 6 个 class 来切换： v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 ，则 v- 是这些类名的默认前缀。如果你使用了 ，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明。 自定义过渡的类名-使用第三方类库animate.css 我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 示例： Toggle render hello new Vue({ el: '#example-3', data: { show: true } }) JavaScript钩子 // ... methods: { // -------- // 进入中 // -------- beforeEnter: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) { // ... done() }, afterEnter: function (el) { // ... }, enterCancelled: function (el) { // ... }, // -------- // 离开时 // -------- beforeLeave: function (el) { // ... }, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) { // ... done() }, afterLeave: function (el) { // ... }, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) { // ... } } 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 注意： 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 一个使用 Velocity.js 的简单例子： Toggle Demo new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } } }) 初始渲染的过渡 可以通过 appear 特性设置节点在初始渲染的过渡 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。 自定义 JavaScript 钩子： 在上面的例子中，无论是 appear 特性还是 v-on:appear 钩子都会生成初始渲染过渡。 多个元素/组件过渡 列表过渡 目前为止，关于过渡我们已经讲到： 单个节点 同一时间渲染多个节点中的一个 那么怎么同时渲染整个列表，比如使用 v-for ？在这种场景中，使用 组件。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 ，它会以一个真实元素呈现：默认为一个 。你也可以通过 tag 特性更换为其他元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素 总是需要 提供唯一的 key 属性值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。 列表的进入/离开过渡 Add Remove { { item } } new Vue({ el: '#list-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } }) .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s; } .list-enter, .list-leave-to /* .list-leave-active for below version 2.1.8 */ { opacity: 0; transform: translateY(30px); } 这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。 列表的排序过渡 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。 v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： Shuffle { { item } } new Vue({ el: '#flip-list-demo', data: { items: [1,2,3,4,5,6,7,8,9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } }) .flip-list-move { transition: transform 1s; } 列表的交错过渡 "},"Web/JavaScript/框架/jQuery-UI.html":{"url":"Web/JavaScript/框架/jQuery-UI.html","title":"JQuery UI","keywords":"","body":"datetime:2019/7/12 9:47 author:nzb 特效（Effects） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 百叶窗特效（Blind Effect） 百叶窗特效（Blind Effect）通过将元素包裹在一个容器内，采用\"拉百叶窗\"效果来隐藏或显示元素。 反弹特效（Bounce Effect） 反弹特效（Bounce Effect）反弹一个元素。当与隐藏或显示一起使用时，最后一次或第一次反弹会呈现淡入/淡出效果。 剪辑特效（Clip Effect） 剪辑特效（Clip Effect）通过垂直或水平方向夹剪元素来隐藏或显示一个元素。 颜色动画（Color Animation） 使用 .animate() 实现颜色动画效果。 降落特效（Drop Effect） 降落特效（Drop Effect）通过单个方向滑动的淡入淡出来隐藏或显示一个元素。 Easing Easing函数指定动画在不同点上的行进速度。 .effect() 对一个元素应用动画特效。 特效核心（Effects Core） | 方法（Method） 爆炸特效（Explode Effect） 爆炸特效（Explode Effect）通过把元素裂成碎片来隐藏或显示一个元素。 淡入淡出特效（Fade Effect） 淡入淡出特效（Fade Effect）通过淡入淡出元素来隐藏或显示一个元素。 折叠特效（Fold Effect） 折叠特效（Fold Effect）通过折叠元素来隐藏或显示一个元素。 .hide() 使用自定义效果来隐藏匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） 突出特效（Highlight Effect） 突出特效（Highlight Effect）通过首先改变背景颜色来隐藏或显示一个元素。 膨胀特效（Puff Effect） 通过在缩放元素的同时隐藏元素来创建膨胀特效（Puff Effect）。 跳动特效（Pulsate Effect） 跳动特效（Pulsate Effect）通过跳动来隐藏或显示一个元素。 .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 缩放特效（Scale Effect） 按照某个百分比缩放元素。 震动特效（Shake Effect） 垂直或水平方向多次震动元素。 .show() 使用自定义效果来显示匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） 尺寸特效（Size Effect） 调整元素尺寸到指定宽度和高度。 滑动特效（Slide Effect） 把元素滑动出视区。 .switchClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加和移除指定的 Class。 特效核心（Effects Core） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效核心（Effects Core） | 方法重载（Method Overrides） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效核心（Effects Core） | 方法重载（Method Overrides） 转移特效（Transfer Effect） 把一个元素的轮廓转移到另一个元素。 特效核心（Effects Core） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效（Effects） | 方法重载（Method Overrides） 颜色动画（Color Animation） 使用 .animate() 实现颜色动画效果。 .effect() 对一个元素应用动画特效。 特效（Effects） | 方法（Method） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效（Effects） | 方法重载（Method Overrides） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .switchClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加和移除指定的 Class。 特效（Effects） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 方法重载（Method Overrides） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效（Effects） | 方法重载（Method Overrides） 交互（Interactions） API 描述 也属于类别 可拖拽小部件（Draggable Widget） 允许使用鼠标移动元素。 可放置小部件（Droppable Widget） 为可拖拽小部件创建目标。 鼠标交互（Mouse Interaction） 基本交互层。 实用工具（Utilities） 可调整尺寸小部件（Resizable Widget） 使用鼠标改变元素的尺寸。 可选择小部件（Selectable Widget） 使用鼠标选择单个元素或一组元素。 可排序小部件（Sortable Widget） 使用鼠标调整列表中或者网格中元素的排序。 方法重载（Method Overrides） API 描述 也属于类别 .addClass() 当动画样式改变时，为匹配的元素集合内的每个元素添加指定的 Class。 特效（Effects） | 特效核心（Effects Core） .focus() 异步聚焦到一个元素。 方法（Method） | UI 核心（UI Core） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .position() 相对另一个元素定位一个元素。 方法（Method） | 实用工具（Utilities） .removeClass() 当动画样式改变时，为匹配的元素集合内的每个元素移除指定的 Class。 特效（Effects） | 特效核心（Effects Core） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法（Method） .toggleClass() 当动画样式改变时，根据 Class 是否存在以及 switch 参数的值，为匹配的元素集合内的每个元素添加或移除一个或多个 Class。 特效（Effects） | 特效核心（Effects Core） 方法（Methods） API 描述 也属于类别 .disableSelection() 禁用选择匹配的元素集合内的文本内容。 UI 核心（UI Core） .effect() 对一个元素应用动画特效。 特效（Effects） | 特效核心（Effects Core） .enableSelection() 启用选择匹配的元素集合内的文本内容。 UI 核心（UI Core） .focus() 异步聚焦到一个元素。 方法重载（Method Overrides） | UI 核心（UI Core） .hide() 使用自定义效果来隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .position() 相对另一个元素定位一个元素。 方法重载（Method Overrides） | 实用工具（Utilities） .removeUniqueId() 为匹配的元素集合移除由 .uniqueId() 设置的 Id。 UI 核心（UI Core） .scrollParent() 获取最近的可滚动的祖先。 UI 核心（UI Core） .show() 使用自定义效果来显示匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .toggle() 使用自定义效果来显示或隐藏匹配的元素。 特效（Effects） | 特效核心（Effects Core） | 方法重载（Method Overrides） .uniqueId() 为匹配的元素集合生成并申请一个唯一的 Id。 UI 核心（UI Core） .zIndex() 为元素获取 z-index。 UI 核心（UI Core） 选择器（Selectors） API 描述 也属于类别 :data() Selector 选择数据已存储在指定的键下的元素。 UI 核心（UI Core） :focusable Selector 选择可被聚焦的元素。 UI 核心（UI Core） :tabbable Selector 选择用户可通过 tab 键聚焦的元素。 UI 核心（UI Core） 主题（Theming） API 描述 CSS 框架（CSS Framework） jQuery UI 使用的允许组件主题化的 Class 名称列表。 图标（Icons） jQuery UI 提供的图标列表。 堆叠元素（Stacking Elements） 一种处理 z-index 和堆叠元素的模式。 UI 核心（UI Core） API 描述 也属于类别 :data() Selector 选择数据已存储在指定的键下的元素。 选择器（Selectors） .disableSelection() 禁用选择匹配的元素集合内的文本内容。 方法（Methods） .enableSelection() 启用选择匹配的元素集合内的文本内容。 方法（Methods） .focus() 异步聚焦到一个元素。 方法重载（Method Overrides） 方法（Methods） :focusable Selector 选择可被聚焦的元素。 选择器（Selectors） jQuery.ui.keyCode 一个相对于数字值的关键代码描述的映射。 .removeUniqueId() 为匹配的元素集合移除由 .uniqueId() 设置的 Id。 方法（Methods） .scrollParent() 获取最近的可滚动的祖先。 方法（Methods） :tabbable Selector 选择用户可通过 tab 键聚焦的元素。 选择器（Selectors） .uniqueId() 为匹配的元素集合生成并申请一个唯一的 Id。 方法（Methods） .zIndex() 为元素获取 z-index。 方法（Methods） 实用工具（Utilities） API 描述 也属于类别 Easings Easing 函数指定动画在不同点上的行进速度。 部件库（Widget Factory） 使用与所有 jQuery UI 小部件相同的抽象化来创建有状态的 jQuery 插件。 小部件（Widgets） 插件桥（Widget Plugin Bridge） jQuery.widget.bridge() 方法是 jQuery 部件库（Widget Factory）的一部分。它扮演着由 $.widget() 创建的对象和 jQuery API 之间的中介。 小部件（Widgets） 鼠标交互（Mouse Interaction） 基本交互层。 交互（Interactions） .position() 相对另一个元素定位一个元素。 方法重载（Method Overrides） | 方法（Method） 小部件（Widgets） API 描述 也属于类别 折叠面板部件（Accordion Widget） 把一对标题和内容面板转换成折叠面板。 自动完成部件（Autocomplete Widget） 自动完成功能根据用户输入值进行搜索和过滤，让用户快速找到并从预设值列表中选择。 按钮部件（Button Widget） 可主题化的按钮和按钮集合。 日期选择器部件（Datepicker Widget） 从弹出框或在线日历选择一个日期。 对话框部件（Dialog Widget） 在一个交互覆盖层中打开内容。 部件库（Widget Factory） 使用与所有 jQuery UI 小部件相同的抽象化来创建有状态的 jQuery 插件。 实用工具（Utilities） 插件桥（Widget Plugin Bridge） jQuery.widget.bridge() 方法是 jQuery 部件库（Widget Factory）的一部分。它扮演着由 $.widget() 创建的对象和 jQuery API 之间的中介。 实用工具（Utilities） 菜单部件（Menu Widget） 带有鼠标和键盘交互的用于导航的可主题化菜单。 进度条部件（Progressbar Widget） 显示一个确定的或不确定的进程状态。 滑块部件（Slider Widget） 拖动手柄可以选择一个数值。 旋转器部件（Spinner Widget） 通过向上/向下按钮和箭头键处理，为输入数值增强文本输入功能。 标签页部件（Tabs Widget） 一种多面板的单内容区，每个面板与列表中的标题相关。 工具提示框部件（Tooltip Widget） 可自定义的、可主题化的工具提示框，替代原生的工具提示框。 "},"Web/JavaScript/框架/jQuery基础.html":{"url":"Web/JavaScript/框架/jQuery基础.html","title":"JQuery基础","keywords":"","body":"datetime:2019/7/10 13:43 author:nzb jQuery简介 jQuery 库可以通过一行简单的标记被添加到网页中。 什么是 jQuery ？ jQuery是一个JavaScript函数库。 jQuery是一个轻量级的\"写的少，做的多\"的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 提示： 除此之外，Jquery还提供了大量的插件。 语法 jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。 基础语法： $(selector).action() 美元符号定义 jQuery 选择符（selector）\"查询\"和\"查找\" HTML 元素 jQuery 的 action() 执行对元素的操作 实例: $(this).hide() - 隐藏当前元素 $(\"p\").hide() - 隐藏所有 元素 $(\"p.test\").hide() - 隐藏所有 class=\"test\" 的 元素 $(\"#test\").hide() - 隐藏所有 id=\"test\" 的元素 文档就绪事件 您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中： $(document).ready(function(){ // 开始写 jQuery 代码... }); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。下面是两个具体的例子： 试图隐藏一个不存在的元素 获得未完全加载的图像的大小 提示：简洁写法（与以上写法效果相同）: $(function(){ // 开始写 jQuery 代码... }); 以上两种方式你可以选择你喜欢的方式实现文档就绪后执行 jQuery 方法。 JavaScript 入口函数: window.onload = function () { // 执行代码 } jQuery 入口函数与 JavaScript 入口函数的区别： jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 中所有选择器都以美元符号开头：$()。 元素选择器 用户点击按钮后，所有 元素都隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(); }); }); #id 选择器 当用户点击按钮后，有 id=\"test\" 属性的元素将被隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\"#test\").hide(); }); }); .class 选择器 用户点击按钮后所有带有 class=\"test\" 属性的元素都隐藏： $(document).ready(function(){ $(\"button\").click(function(){ $(\".test\").hide(); }); }); 更多实例 语法 描述 $(\"*\") 选取所有元素 $(this) 选取当前 HTML 元素 $(\"p.intro\") 选取 class 为 intro 的 元素 $(\"p:first\") 选取第一个 元素 $(\"ul li:first\") 选取第一个 元素的第一个 元素 $(\"ul li:first-child\") 选取每个 元素的第一个 元素 $(\"[href]\") 选取带有 href 属性的元素 $(\"a[target='_blank']\") 选取所有 target 属性值等于 \"_blank\" 的 元素 $(\"a[target!='_blank']\") 选取所有 target 属性值不等于 \"_blank\" 的 元素 $(\":button\") 选取所有 type=\"button\" 的 元素 和 元素 $(\"tr:even\") 选取偶数位置的 元素 $(\"tr:odd\") 选取奇数位置的 元素 $(\"#id\", \".class\") 复合选择器 $(div p span) 层级选择器 //div下的p元素中的span元素 $(div>p) 父子选择器 //div下的所有p元素 $(div+p) 相邻元素选择器 //div后面的p元素(仅一个p) $(div~p) 兄弟选择器 //div后面的所有p元素(同级别) $(.p:last) 类选择器 加 过滤选择器 第一个和最后一个（first 或者 last） $(\"#mytable td:odd\") 层级选择 加 过滤选择器 奇偶（odd 或者 even） $(\"div p:eq(2)\") 索引选择器 div下的第三个p元素（索引是从0开始） $(\"a[href='www.baidu.com']\") 属性选择器 $(\"p:contains(test)\") // 内容过滤选择器，包含text内容的p元素 $(\":emtyp\") //内容过滤选择器，所有空标签（不包含子标签和内容的标签）parent 相反 $(\":hidden\") //所有隐藏元素 visible $(\"input:enabled\") //选取所有启用的表单元素 $(\":disabled\") //所有不可用的元素 $(\"input:checked\") //获取所有选中的复选框单选按钮等 $(\"select option:selected\") //获取选中的选项元素 关于 : 和 [] 这两个符号的理解 “：”：可以理解为种类的意思，如：p:first，p 的种类为第一个。 “[]” ：很自然的可以理解为属性的意思，如：[href] 选取带有 href 属性的元素。 $(\":button\") 为 jQuery 中表单选择器（貌似与过滤选择器同级），旨在选择所有的按钮，所以会找到 、 元素；而 $(\"button\") 则为基本选择器，旨在选择为 的标签。 : 即为 jQuery 的过滤选择器，语法类似于 css 中的伪类选择器；其过滤选择器大概可以分为基本过滤（p:first 之类）、内容过滤（:empty）、子元素过滤(:first-child)和属性过滤 [href] 选择器。 事件 页面对不同访问者的响应叫做事件。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。 实例： 在元素上移动鼠标。 选取单选按钮 点击元素 在事件中经常使用术语\"触发\"（或\"激发\"）例如： \"当您按下按键时触发 keypress 事件\"。 常用的 jQuery 事件方法 $(document).ready() $(document).ready() 方法允许我们在文档完全加载完后执行函数。该事件方法在 jQuery 语法 章节中已经提到过。 click() click() 方法是当按钮点击事件被触发时会调用一个函数。 dblclick() 当双击元素时，会发生 dblclick 事件。 mouseenter() 当鼠标指针穿过元素时，会发生 mouseenter 事件。 mouseleave() 当鼠标指针离开元素时，会发生 mouseleave 事件。 mousedown() 当鼠标指针移动到元素上方，并按下鼠标按键时，会发生 mousedown 事件。 mouseup() 当在元素上松开鼠标按钮时，会发生 mouseup 事件。 hover() hover()方法用于模拟光标悬停事件。 当鼠标移动到元素上时，会触发指定的第一个函数(mouseenter);当鼠标移出这个元素时，会触发指定的第二个函数(mouseleave)。 focus() 当元素获得焦点时，发生 focus 事件。 当通过鼠标点击选中元素或通过 tab 键定位到元素时，该元素就会获得焦点。 blur() 当元素失去焦点时，发生 blur 事件。 on() 和 off() 绑定事件和解除绑定事件 笔记 一.keypress,keydown,keyup的区别: 1.keydown：在键盘上按下某键时发生,一直按着则会不断触发（opera浏览器除外）, 它返回的是键盘代码; 2.keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效 ,换句话说, 只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。 3.keyup：用户松开某一个按键时触发, 与keydown相对, 返回键盘代码. 二.两种常用用法举例 案例1:获取按键代码或字符的ASCII码 $(window).keydown( function(event){ // 通过event.which可以拿到按键代码. 如果是keypress事件中,则拿到ASCII码. } ); 案例2:传递数据给事件处理函数 语法: jQueryObject.keypress( [[ data ,] handler ] ); data: 通过event.data传递给事件处理函数的任意数据; handler: 指定的事件处理函数; 举例: // 只允许按下的字母键生效, 65~90是所有大写字母的键盘代码范围. var validKeys = { start: 65, end: 90 }; $(\"#keys\").keypress( validKeys, function(event){ var keys = event.data; //拿到validKeys对象. return event.which >= keys.start && event.which 三.关于获取触发事件的说明： 1.获取事件对象 $(document).ready(function(){ $(window).keypress(function(event){ //获取事件对象，里面包含各种有用的信息。 console.log(event); //console.log(event.which); }); }); 2.keypress事件获取键入字符 $(window).keypress(function(event){ //event.which是获取ASCII码，前面的函数是将ASCII码转换成字符，空格键和Enter键输出均为空白。 console.log(String.fromCharCode(event.which)); //从event对象中key属性获取字符，但是Enter键的key值为\"Enter\"，空白键还是空白\" \"。 console.log(event.key); }); jQuery - noConflict() 方法 正如您已经了解到的，jQuery 使用 $ 符号作为 jQuery 的简写。 如果其他 JavaScript 框架也使用 $ 符号作为简写怎么办？ 其他一些 JavaScript 框架包括：MooTools、Backbone、Sammy、Cappuccino、Knockout、JavaScript MVC、Google Web Toolkit、Google Closure、Ember、Batman 以及 Ext JS。 其中某些框架也使用 $ 符号作为简写（就像 jQuery），如果您在用的两种不同的框架正在使用相同的简写符号，有可能导致脚本停止运行。 jQuery 的团队考虑到了这个问题，并实现了 noConflict() 方法。 noConflict() 方法会释放对 $ 标识符的控制，这样其他脚本就可以使用它了。 当然，您仍然可以通过全名替代简写的方式来使用 jQuery： $.noConflict(); jQuery(document).ready(function(){ jQuery(\"button\").click(function(){ jQuery(\"p\").text(\"jQuery 仍然在工作!\"); }); }); 您也可以创建自己的简写。noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用。请看这个例子： var jq = $.noConflict(); jq(document).ready(function(){ jq(\"button\").click(function(){ jq(\"p\").text(\"jQuery 仍然在工作!\"); }); }); 如果你的 jQuery 代码块使用 $ 简写，并且您不愿意改变这个快捷方式，那么您可以把 $ 符号作为变量传递给 ready 方法。这样就可以在函数内使用 $ 符号了 - 而在函数外，依旧不得不使用 \"jQuery\"： $.noConflict(); jQuery(document).ready(function($){ $(\"button\").click(function(){ $(\"p\").text(\"jQuery 仍然在工作!\"); }); }); HTML 获取内容和属性 获得内容： text()、html() 以及 val() 三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 $(\"#btn1\").click(function(){ alert(\"Text: \" + $(\"#test\").text()); }); $(\"#btn2\").click(function(){ alert(\"HTML: \" + $(\"#test\").html()); }); $(\"#btn1\").click(function(){ alert(\"值为: \" + $(\"#test\").val()); }); 获取属性 - attr()：用于获取属性值。 $(\"button\").click(function(){ alert($(\"#runoob\").attr(\"href\")); }); 设置内容和属性 设置内容： text()、html() 以及 val() 我们将使用前一章中的三个相同的方法来设置内容： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 $(\"#btn1\").click(function(){ $(\"#test1\").text(\"Hello world!\"); }); $(\"#btn2\").click(function(){ $(\"#test2\").html(\"Hello world!\"); }); $(\"#btn3\").click(function(){ $(\"#test3\").val(\"RUNOOB\"); }); text()、html() 以及 val() 的回调函数 上面的三个 jQuery 方法：text()、html() 以及 val()，同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 text() 和 html()： $(\"#btn1\").click(function(){ $(\"#test1\").text(function(i,origText){ return \"旧文本: \" + origText + \" 新文本: Hello world! (index: \" + i + \")\"; }); }); $(\"#btn2\").click(function(){ $(\"#test2\").html(function(i,origText){ return \"旧 html: \" + origText + \" 新 html: Hello world! (index: \" + i + \")\"; }); }); 设置属性 - attr()：用于设置/改变属性值。 $(\"button\").click(function(){ $(\"#runoob\").attr(\"href\",\"http://www.runoob.com/jquery\"); }); attr() 方法也允许您同时设置多个属性。 下面的例子演示如何同时设置 href 和 title 属性： $(\"button\").click(function(){ $(\"#runoob\").attr({ \"href\" : \"http://www.runoob.com/jquery\", \"title\" : \"jQuery 教程\" }); }); attr() 的回调函数 jQuery 方法 attr()，也提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 下面的例子演示带有回调函数的 attr() 方法： $(\"button\").click(function(){ $(\"#runoob\").attr(\"href\", function(i,origValue){ return origValue + \"/jquery\"; }); }); 添加元素 添加新内容的四个 jQuery 方法： append() - 在被选元素的结尾插入内容 prepend() - 在被选元素的开头插入内容 after() - 在被选元素之后插入内容 before() - 在被选元素之前插入内容 append() 方法 jQuery append() 方法在被选元素的结尾插入内容（仍然该元素的内部）。 $(\"p\").append(\"追加文本\"); prepend() 方法 jQuery prepend() 方法在被选元素的开头插入内容。 $(\"p\").prepend(\"在开头追加文本\"); 通过 append() 和 prepend() 方法添加若干新元素 在上面的例子中，我们只在被选元素的开头/结尾插入文本/HTML。 不过，append() 和 prepend() 方法能够通过参数接收无限数量的新元素。可以通过 jQuery 来生成文本/HTML（就像上面的例子那样），或者通过 JavaScript 代码和 DOM 元素。 在下面的例子中，我们创建若干个新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 append() 方法把这些新元素追加到文本中（对 prepend() 同样有效）： function appendText() { var txt1=\"文本。\"; // 使用 HTML 标签创建文本 var txt2=$(\"\").text(\"文本。\"); // 使用 jQuery 创建文本 var txt3=document.createElement(\"p\"); txt3.innerHTML=\"文本。\"; // 使用 DOM 创建文本 text with DOM $(\"body\").append(txt1,txt2,txt3); // 追加新元素 } jQuery after() 和 before() 方法 $(\"img\").after(\"在后面添加文本\"); $(\"img\").before(\"在前面添加文本\"); 通过 after() 和 before() 方法添加若干新元素 after() 和 before() 方法能够通过参数接收无限数量的新元素。可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建新元素。 在下面的例子中，我们创建若干新元素。这些元素可以通过 text/HTML、jQuery 或者 JavaScript/DOM 来创建。然后我们通过 after() 方法把这些新元素插到文本中（对 before() 同样有效）： function afterText() { var txt1=\"I \"; // 使用 HTML 创建元素 var txt2=$(\"\").text(\"love \"); // 使用 jQuery 创建元素 var txt3=document.createElement(\"big\"); // 使用 DOM 创建元素 txt3.innerHTML=\"jQuery!\"; $(\"img\").after(txt1,txt2,txt3); // 在图片后添加文本 } append/prepend和after/before有什么区别？ append s1 $(\"p\").append('s2'); 结果是这样的: s1 s2 after s1 $(\"p\").after('s2'); 结果是这样的: s1 s2 总结： append/prepend 是在选择元素内部嵌入。 after/before 是在元素外面追加。 删除元素 使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 jQuery remove() 方法：删除被选元素及其子元素。 $(\"#div1\").remove(); jQuery empty() 方法：删除被选元素的子元素。 $(\"#div1\").empty(); 过滤被删除的元素 jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=\"italic\" 的所有 元素： $(\"p\").remove(\".italic\"); CSS CSS类和方法 jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些： addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - 设置或返回样式属性 实例样式表 .important { font-weight:bold; font-size:xx-large; } .blue { color:blue; } addClass() 方法 $(\"button\").click(function(){ $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important\"); }); // 或规定多个类： $(\"button\").click(function(){ $(\"body div:first\").addClass(\"important blue\"); }); removeClass() 方法 $(\"button\").click(function(){ $(\"h1,h2,p\").removeClass(\"blue\"); }); toggleClass() 方法 该方法对被选元素进行添加/删除类的切换操作： $(\"button\").click(function(){ $(\"h1,h2,p\").toggleClass(\"blue\"); }); css() 方法 设置或返回被选元素的一个或多个样式属性。 返回 CSS 属性 如需返回指定的 CSS 属性的值，请使用如下语法： css(\"propertyname\"); // 例 $(\"p\").css(\"background-color\"); 设置 CSS 属性 如需设置指定的 CSS 属性，请使用如下语法： css(\"propertyname\",\"value\"); // 例 $(\"p\").css(\"background-color\",\"yellow\"); 设置多个 CSS 属性 如需设置多个 CSS 属性，请使用如下语法： css({\"propertyname\":\"value\",\"propertyname\":\"value\",...}); // 例 $(\"p\").css({\"background-color\":\"yellow\",\"font-size\":\"200%\"}); CSS盒子模型(尺寸) jQuery 提供多个处理尺寸的重要方法： width() height() innerWidth() innerHeight() outerWidth() outerHeight() jQuery尺寸 width() 和 height() 方法 width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 的宽度是: \" + $(\"#div1\").width() + \"\"; txt+=\"div 的高度是: \" + $(\"#div1\").height(); $(\"#div1\").html(txt); }); innerWidth() 和 innerHeight() 方法 innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 宽度，包含内边距: \" + $(\"#div1\").innerWidth() + \"\"; txt+=\"div 高度，包含内边距: \" + $(\"#div1\").innerHeight(); $(\"#div1\").html(txt); }); outerWidth() 和 outerHeight() 方法 outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 $(\"button\").click(function(){ var txt=\"\"; txt+=\"div 宽度，包含内边距和边框: \" + $(\"#div1\").outerWidth() + \"\"; txt+=\"div 高度，包含内边距和边框: \" + $(\"#div1\").outerHeight(); $(\"#div1\").html(txt); }); 效果 隐藏和显示 hide() 和 show() 使用 hide() 和 show() 方法来隐藏和显示 HTML 元素： $(\"#hide\").click(function(){ $(\"p\").hide(); }); $(\"#show\").click(function(){ $(\"p\").show(); }); 语法: $(selector).hide(speed,callback); $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 对于可选的 callback 参数，有以下两点说明： 1.$(selector)选中的元素的个数为n个，则callback函数会执行n次；当 callback 函数加上括号时，函数立即执行，只会调用一次， 如果不加括号，元素显示或隐藏后调用函数，才会调用多次。 2.callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行； 3.callback既可以是函数名，也可以是匿名函数； 下面的例子演示了带有 speed 参数的 hide() 方法： $(\"button\").click(function(){ $(\"p\").hide(1000); }); 下面的例子演示了带有 speed 参数的 hide() 方法，并使用回调函数： $(document).ready(function(){ $(\".hidebtn\").click(function(){ $(\"div\").hide(1000,\"linear\",function(){ alert(\"Hide() 方法已完成!\"); }); }); }); 第二个参数是一个字符串，表示过渡使用哪种缓动函数。（译者注：jQuery自身提供\"linear\" 和 \"swing\"，其他可以使用相关的插件）。 toggle() 使用 toggle() 方法来切换 hide() 和 show() 方法。显示被隐藏的元素，并隐藏已显示的元素： $(\"button\").click(function(){ $(\"p\").toggle(); }); 语法: $(selector).toggle(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 淡入淡出 jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() fadeIn() 方法：用于淡入已隐藏的元素。 语法: $(selector).fadeIn(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。. 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeIn() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000); }); fadeOut() 方法：用于淡出可见元素。 语法: $(selector).fadeOut(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeOut() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000); }); fadeToggle() 方法： jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。 如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 语法: $(selector).fadeToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeToggle() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000); }); fadeTo() 方法 jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。 语法: 必需的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。 可选的 callback 参数是该函数完成后所执行的函数名称。 下面的例子演示了带有不同参数的 fadeTo() 方法： $(\"button\").click(function(){ $(\"#div1\").fadeTo(\"slow\",0.15); $(\"#div2\").fadeTo(\"slow\",0.4); $(\"#div3\").fadeTo(\"slow\",0.7); }); 滑动 jQuery 拥有以下滑动方法： slideDown() slideUp() slideToggle() slideDown() 方法 jQuery slideDown() 方法用于向下滑动元素。 语法: $(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideDown() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideDown(); }); slideUp() 方法 jQuery slideUp() 方法用于向上滑动元素。 语法: $(selector).slideUp(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideUp() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideUp(); }); slideToggle() 方法 jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。 如果元素向下滑动，则 slideToggle() 可向上滑动它们。 如果元素向上滑动，则 slideToggle() 可向下滑动它们。 $(selector).slideToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 下面的例子演示了 slideToggle() 方法： $(\"#flip\").click(function(){ $(\"#panel\").slideToggle(); }); 动画 animate() 方法 用于创建自定义动画。 语法： $(selector).animate({params},speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 下面的例子演示 animate() 方法的简单应用。它把 元素往右边移动了 250 像素： $(\"button\").click(function(){ $(\"div\").animate({left:'250px'}); }); 默认情况下，所有 HTML 元素都有一个静态位置，且无法移动。 如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！ 操作多个属性 生成动画的过程中可同时使用多个属性： 实例 $(\"button\").click(function(){ $(\"div\").animate({ left:'250px', opacity:'0.5', height:'150px', width:'150px' }); }); 使用相对值 也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=： $(\"button\").click(function(){ $(\"div\").animate({ left:'250px', height:'+=150px', width:'+=150px' }); }); 使用预定义的值 甚至可以把属性的动画值设置为 \"show\"、\"hide\" 或 \"toggle\"： $(\"button\").click(function(){ $(\"div\").animate({ height:'toggle' }); }); 使用队列功能 默认地，jQuery 提供针对动画的队列功能。 这意味着如果您在彼此之后编写多个 animate() 调用，jQuery 会创建包含这些方法调用的\"内部\"队列。然后逐一运行这些 animate 调用。 $(\"button\").click(function(){ var div=$(\"div\"); div.animate({height:'300px',opacity:'0.4'},\"slow\"); div.animate({width:'300px',opacity:'0.8'},\"slow\"); div.animate({height:'100px',opacity:'0.4'},\"slow\"); div.animate({width:'100px',opacity:'0.8'},\"slow\"); }); // 下面的例子把 元素往右边移动了 100 像素，然后增加文本的字号： $(\"button\").click(function(){ var div=$(\"div\"); div.animate({left:'100px'},\"slow\"); div.animate({fontSize:'3em'},\"slow\"); }); 可以用 animate() 方法来操作所有 CSS 属性吗？ 是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，您需要从 jquery.com 下载 颜色动画 插件。 停止动画 stop() 方法 用于停止动画或效果，在它们完成之前。 stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。 语法: $(selector).stop(stopAll,goToEnd); 可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。 可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。 因此，默认地，stop() 会清除在被选元素上指定的当前动画。 下面的例子演示 stop() 方法，不带参数： $(\"#stop\").click(function(){ $(\"#panel\").stop(); }); 动画队列停止动画测试，只停止当前正在进行的动画，停止当前动画后，队列中的下一个动画开始进行： $(document).ready(function(){ $(\"#flip\").click(function(){ $(\"#panel\").slideDown(5000); $(\"#panel\").slideUp(5000); }); $(\"#stop\").click(function(){ $(\"#panel\").stop(); }); }); 可以在 stop() 中设置 stopAll 的参数为 true，这样就可以停止所有动画效果而不是只停止当前动画： $(document).ready(function(){ $(\"#flip\").click(function(){ $(\"#panel\").slideDown(5000); $(\"#panel\").slideUp(5000); }); $(\"#stop\").click(function(){ $(\"#panel\").stop(true); }); }); Callback(回调) 方法 Callback 函数在当前动画 100% 完成之后执行。 jQuery 动画的问题 许多 jQuery 函数涉及动画。这些函数也许会将 speed 或 duration 作为可选参数。 例子：$(\"p\").hide(\"slow\") speed 或 duration 参数可以设置许多不同的值，比如 \"slow\", \"fast\", \"normal\" 或毫秒。 实例 以下实例在隐藏效果完全实现后回调函数: $(\"button\").click(function(){ $(\"p\").hide(\"slow\",function(){ alert(\"段落现在被隐藏了\"); }); }); 以下实例没有回调函数，警告框会在隐藏效果完成前弹出： $(\"button\").click(function(){ $(\"p\").hide(1000); alert(\"段落现在被隐藏了\"); }); 被立即停止的动画不会触发回调，被立即完成的动画会触发回调。 $(document).ready(function(){ $(\"button\").click(function(){ $(\"p\").hide(3000,function(){ alert(\"段落现在被隐藏了\"); }); }); $(\"#happy\").click(function(){ $(\"p\").stop(false,true); }); }); 如果动画有队列的话，想实现其快速完成所有动画并停止，就要相应的与队列数对应条数的停止语句。 $(document).ready(function(){ $(\"#start\").click(function(){ $(\"div\").animate({left:'300px'},5000); $(\"div\").animate({fontSize:'3em'},5000); }); $(\"#stop1\").click(function(){ $(\"div\").stop(); }); $(\"#stop2\").click(function(){ $(\"div\").stop(true); }); $(\"#stop3\").click(function(){ $(\"div\").stop(false,true); $(\"div\").stop(false,true); }); }); 链(Chaining) 通过 jQuery，可以把动作/方法链接在一起。 Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）。 直到现在，我们都是一次写一条 jQuery 语句（一条接着另一条）。 不过，有一种名为链接（chaining）的技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。 提示： 这样的话，浏览器就不必多次查找相同的元素。 如需链接一个动作，您只需简单地把该动作追加到之前的动作上。 下面的例子把 css()、slideUp() 和 slideDown() 链接在一起。\"p1\" 元素首先会变为红色，然后向上滑动，再然后向下滑动： $(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000); 如果需要，我们也可以添加多个方法调用。 提示：当进行链接时，代码行会变得很长。不过，jQuery 语法不是很严格；您可以按照希望的格式来写，包含换行和缩进。 如下书写也可以很好地运行： $(\"#p1\").css(\"color\",\"red\") .slideUp(2000) .slideDown(2000); jQuery - AJAX 简介 AJAX 是与服务器交换数据的技术，它在不重载全部页面的情况下，实现了对部分网页的更新。 什么是 AJAX？ AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。 使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。 您可以在 jQuery Ajax 参考手册学会 jQuery Ajax 的具体应用。 您可以在菜鸟教程中的 AJAX 教程中学到更多有关 AJAX 的知识。 关于 jQuery 与 AJAX jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 如果没有 jQuery，AJAX 编程还是有些难度的。 编写常规的 AJAX 代码并不容易，因为不同的浏览器对 AJAX 的实现并不相同。这意味着您必须编写额外的代码对浏览器进行测试。不过，jQuery 团队为我们解决了这个难题，我们只需要一行简单的代码，就可以实现 AJAX 功能。 AJAX load() 方法 jQuery load() 方法 jQuery load() 方法是简单但强大的 AJAX 方法。 load() 方法从服务器加载数据，并把返回的数据放入被选元素中。 语法: $(selector).load(URL,data,callback); 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是 load() 方法完成后所执行的函数名称。 这是示例文件（\"demo_test.txt\"）的内容： jQuery AJAX 是个非常棒的功能！ 这是段落的一些文本。 下面的例子会把文件 \"demo_test.txt\" 的内容加载到指定的 元素中： $(\"#div1\").load(\"demo_test.txt\"); 也可以把 jQuery 选择器添加到 URL 参数。 下面的例子把 \"demo_test.txt\" 文件中 id=\"p1\" 的元素的内容，加载到指定的 元素中： 实例 $(\"#div1\").load(\"demo_test.txt #p1\"); 可选的 callback 参数规定当 load() 方法完成后所要允许的回调函数。回调函数可以设置不同的参数： responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法已成功，则显示\"外部内容加载成功！\"，而如果失败，则显示错误消息： $(\"button\").click(function(){ $(\"#div1\").load(\"demo_test.txt\",function(responseTxt,statusTxt,xhr){ if(statusTxt==\"success\") alert(\"外部内容加载成功!\"); if(statusTxt==\"error\") alert(\"Error: \"+xhr.status+\": \"+xhr.statusText); }); }); 为了避免多页面情形下的代码重复，可以利用 load() 方法，将重复的部分（例如导航栏）放入单独的文件，使用下列方法进行导入： //1.当前文件中要插入的地方使用此结构： //2.***.html中放入内容，用html格式仅仅因为会有编辑器的书写辅助。。 //3.代码： $(\".include\").each(function() { if (!!$(this).attr(\"file\")) { var $includeObj = $(this); $(this).load($(this).attr(\"file\"), function(html) { $includeObj.after(html).remove(); //加载的文件内容写入到当前标签后面并移除当前标签 }) } }); 或者在index文件里只写重复部分，剩下的一股脑放各自单独文件 load() 进来~ AJAX get() 和 post() 方法 jQuery get() 和 post() 方法用于通过 HTTP GET 或 POST 请求从服务器请求数据。 HTTP 请求：GET vs. POST 两种在客户端和服务器端进行请求-响应的常用方法是：GET 和 POST。 GET - 从指定的资源请求数据 POST - 向指定的资源提交要处理的数据 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 $.get() 方法 通过 HTTP GET 请求从服务器上请求数据。 语法： $.get(URL,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.get() 方法从服务器上的一个文件中取回数据： $(\"button\").click(function(){ $.get(\"demo_test.php\",function(data,status){ alert(\"数据: \" + data + \"\\n状态: \" + status); }); }); $.get() 的第一个参数是我们希望请求的 URL（\"demo_test.php\"）。 第二个参数是回调函数。第一个回调参数存有被请求页面的内容，第二个回调参数存有请求的状态。 $.post() 方法 通过 HTTP POST 请求向服务器提交数据。 语法: $.post(URL,data,callback); 必需的 URL 参数规定您希望请求的 URL。 可选的 data 参数规定连同请求发送的数据。 可选的 callback 参数是请求成功后所执行的函数名。 下面的例子使用 $.post() 连同请求一起发送数据： $(\"button\").click(function(){ $.post(\"/try/ajax/demo_test_post.php\", { name:\"菜鸟教程\", url:\"http://www.runoob.com\" }, function(data,status){ alert(\"数据: \\n\" + data + \"\\n状态: \" + status); }); }); $.post() 的第一个参数是我们希望请求的 URL (\"demo_test_post.php\")。 然后我们连同请求（name 和 url）一起发送数据。 \"demo_test_post.php\" 中的 PHP 脚本读取这些参数，对它们进行处理，然后返回结果。 第三个参数是回调函数。第一个回调参数存有被请求页面的内容，而第二个参数存有请求的状态。 遍历 祖先 这些 jQuery 方法很有用，它们用于向上遍历 DOM 树： parent() parents() parentsUntil() parent() 方法 parent() 方法返回被选元素的直接父元素。 该方法只会向上一级对 DOM 树进行遍历。 下面的例子返回每个 元素的的直接父元素： $(document).ready(function(){ $(\"span\").parent(); }); parents() 方法 parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。 下面的例子返回所有 元素的所有祖先： $(document).ready(function(){ $(\"span\").parents(); }); 您也可以使用可选参数来过滤对祖先元素的搜索。 下面的例子返回所有 元素的所有祖先，并且它是 元素： $(document).ready(function(){ $(\"span\").parents(\"ul\"); }); parentsUntil() 方法 parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。 下面的例子返回介于 与 ` 元素之间的所有祖先元素： $(document).ready(function(){ $(\"span\").parentsUntil(\"div\"); }); 后代 下面是两个用于向下遍历 DOM 树的 jQuery 方法： children() find() children() 方法 children() 方法返回被选元素的所有直接子元素。 该方法只会向下一级对 DOM 树进行遍历。 下面的例子返回每个 元素的所有直接子元素： $(document).ready(function(){ $(\"div\").children(); }); 您也可以使用可选参数来过滤对子元素的搜索。 下面的例子返回类名为 \"1\" 的所有 元素，并且它们是 的直接子元素： $(document).ready(function(){ $(\"div\").children(\"p.1\"); }); find() 方法 find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。 下面的例子返回属于 后代的所有 元素： $(document).ready(function(){ $(\"div\").find(\"span\"); }); 下面的例子返回 的所有后代： $(document).ready(function(){ $(\"div\").find(\"*\"); }); 同胞(siblings) 有许多有用的方法让我们在 DOM 树进行水平遍历： siblings() next() nextAll() nextUntil() prev() prevAll() prevUntil() siblings() 方法 siblings() 方法返回被选元素的所有同胞元素。 下面的例子返回 h2> 的所有同胞元素： $(document).ready(function(){ $(\"h2\").siblings(); }); 您也可以使用可选参数来过滤对同胞元素的搜索。 下面的例子返回属于 的同胞元素的所有 元素： $(document).ready(function(){ $(\"h2\").siblings(\"p\"); }); next() 方法 next() 方法返回被选元素的下一个同胞元素。 该方法只返回一个元素。 下面的例子返回 的下一个同胞元素： $(document).ready(function(){ $(\"h2\").next(); }); nextAll() 方法 nextAll() 方法返回被选元素的所有跟随的同胞元素。 下面的例子返回 的所有跟随的同胞元素： $(document).ready(function(){ $(\"h2\").nextAll(); }); nextUntil() 方法 nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。 下面的例子返回介于 与 元素之间的所有同胞元素： $(document).ready(function(){ $(\"h2\").nextUntil(\"h6\"); }); prev(), prevAll() & prevUntil() 方法 prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。 过滤 缩小搜索元素的范围 三个最基本的过滤方法是：first(), last() 和 eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。 其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。 first() 方法 first() 方法返回被选元素的首个元素。 下面的例子选取首个 元素内部的第一个 元素： $(document).ready(function(){ $(\"div p\").first(); }); last() 方法 last() 方法返回被选元素的最后一个元素。 下面的例子选择最后一个 元素中的最后一个 元素： $(document).ready(function(){ $(\"div p\").last(); }); eq() 方法 eq() 方法返回被选元素中带有指定索引号的元素。 索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。下面的例子选取第二个 元素（索引号 1）： $(document).ready(function(){ $(\"p\").eq(1); }); filter() 方法 filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 下面的例子返回带有类名 \"url\" 的所有 元素： $(document).ready(function(){ $(\"p\").filter(\".url\"); }); not() 方法 not() 方法返回不匹配标准的所有元素。 提示：not() 方法与 filter() 相反。 下面的例子返回不带有类名 \"url\" 的所有 元素： $(document).ready(function(){ $(\"p\").not(\".url\"); }); "},"Web/JavaScript/框架/jQuery方法大全.html":{"url":"Web/JavaScript/框架/jQuery方法大全.html","title":"JQuery方法大全","keywords":"","body":"datetime:2019/7/10 15:29 author:nzb 选择器 选择器 实例 选取 * $(\"*\") 所有元素 #id $(\"#lastname\") id=\"lastname\" 的元素 .class $(\".intro\") class=\"intro\" 的所有元素 .class,.class $(\".intro,.demo\") class 为 \"intro\" 或 \"demo\" 的所有元素 element $(\"p\") 所有 元素 el1,el2,el3 $(\"h1,div,p\") 所有 、 和 元素 :first $(\"p:first\") 第一个 元素 :last $(\"p:last\") 最后一个 元素 :even $(\"tr:even\") 所有偶数 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :odd $(\"tr:odd\") 所有奇数 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。 :first-child $(\"p:first-child\") 属于其父元素的第一个子元素的所有 元素 :first-of-type $(\"p:first-of-type\") 属于其父元素的第一个 元素的所有 元素 :last-child $(\"p:last-child\") 属于其父元素的最后一个子元素的所有 元素 :last-of-type $(\"p:last-of-type\") 属于其父元素的最后一个 元素的所有 元素 :nth-child(n) $(\"p:nth-child(2)\") 属于其父元素的第二个子元素的所有 元素 :nth-last-child(n) $(\"p:nth-last-child(2)\") 属于其父元素的第二个子元素的所有 元素，从最后一个子元素开始计数 :nth-of-type(n) $(\"p:nth-of-type(2)\") 属于其父元素的第二个 元素的所有 元素 :nth-last-of-type(n) $(\"p:nth-last-of-type(2)\") 属于其父元素的第二个 元素的所有 元素，从最后一个子元素开始计数 :only-child $(\"p:only-child\") 属于其父元素的唯一子元素的所有 元素 :only-of-type $(\"p:only-of-type\") 属于其父元素的特定类型的唯一子元素的所有 元素 parent > child $(\"div > p\") 元素的直接子元素的所有 元素 parent descendant $(\"div p\") 元素的后代的所有 元素 element + next $(\"div + p\") 每个 元素相邻的下一个 元素 element ~ siblings $(\"div ~ p\") 元素同级的所有 元素 :eq(index) $(\"ul li:eq(3)\") 列表中的第四个元素（index 值从 0 开始） :gt(no) $(\"ul li:gt(3)\") 列举 index 大于 3 的元素 :lt(no) $(\"ul li:lt(3)\") 列举 index 小于 3 的元素 :not(selector) $(\"input:not(:empty)\") 所有不为空的输入元素 :header $(\":header\") 所有标题元素 , ... :animated $(\":animated\") 所有动画元素 :focus $(\":focus\") 当前具有焦点的元素 :contains(text) $(\":contains('Hello')\") 所有包含文本 \"Hello\" 的元素 :has(selector) $(\"div:has(p)\") 所有包含有 元素在其内的 元素 :empty $(\":empty\") 所有空元素 :parent $(\":parent\") 匹配所有含有子元素或者文本的父元素。 :hidden $(\"p:hidden\") 所有隐藏的 元素 :visible $(\"table:visible\") 所有可见的表格 :root $(\":root\") 文档的根元素 :lang(language) $(\"p:lang(de)\") 所有 lang 属性值为 \"de\" 的 元素 [attribute] $(\"[href]\") 所有带有 href 属性的元素 [attribute=value] $(\"[href='default.htm']\") 所有带有 href 属性且值等于 \"default.htm\" 的元素 [attribute!=value] $(\"[href!='default.htm']\") 所有带有 href 属性且值不等于 \"default.htm\" 的元素 [attribute$=value] $(\"[href$='.jpg']\") 所有带有 href 属性且值以 \".jpg\" 结尾的元素 [attribute|=value] $(\"[title|='Tomorrow']\") 所有带有 title 属性且值等于 'Tomorrow' 或者以 'Tomorrow' 后跟连接符作为开头的字符串 [attribute^=value] $(\"[title^='Tom']\") 所有带有 title 属性且值以 \"Tom\" 开头的元素 [attribute~=value] $(\"[title~='hello']\") 所有带有 title 属性且值包含单词 \"hello\" 的元素 [attribute*=value] $(\"[title*='hello']\") 所有带有 title 属性且值包含字符串 \"hello\" 的元素 [name=value]、[name2=value2] $(\"input[id][name$='man']\") 带有 id 属性，并且 name 属性以 man 结尾的输入框 :input $(\":input\") 所有 input 元素 :text $(\":text\") 所有带有 type=\"text\" 的 input 元素 :password $(\":password\") 所有带有 type=\"password\" 的 input 元素 :radio $(\":radio\") 所有带有 type=\"radio\" 的 input 元素 :checkbox $(\":checkbox\") 所有带有 type=\"checkbox\" 的 input 元素 :submit $(\":submit\") 所有带有 type=\"submit\" 的 input 元素 :reset $(\":reset\") 所有带有 type=\"reset\" 的 input 元素 :button $(\":button\") 所有带有 type=\"button\" 的 input 元素 :image $(\":image\") 所有带有 type=\"image\" 的 input 元素 :file $(\":file\") 所有带有 type=\"file\" 的 input 元素 :enabled $(\":enabled\") 所有启用的元素 :disabled $(\":disabled\") 所有禁用的元素 :selected $(\":selected\") 所有选定的下拉列表元素 :checked $(\":checked\") 所有选中的复选框选项 .selector $(selector).selector 在jQuery 1.7中已经不被赞成使用。返回传给jQuery()的原始选择器 :target $( \"p:target\" ) 选择器将选中ID和URI中一个格式化的标识符相匹配的元素 jQuery 事件方法 方法 描述 bind() 向元素添加事件处理程序 blur() 添加/触发失去焦点事件 change() 添加/触发 change 事件 click() 添加/触发 click 事件 dblclick() 添加/触发 double click 事件 delegate() 向匹配元素的当前或未来的子元素添加处理程序 die() 在版本 1.9 中被移除。移除所有通过 live() 方法添加的事件处理程序 error() 在版本 1.8 中被废弃。添加/触发 error 事件 event.currentTarget 在事件冒泡阶段内的当前 DOM 元素 event.data 包含当前执行的处理程序被绑定时传递到事件方法的可选数据 event.delegateTarget 返回当前调用的 jQuery 事件处理程序所添加的元素 event.isDefaultPrevented() 返回指定的 event 对象上是否调用了 event.preventDefault() event.isImmediatePropagationStopped() 返回指定的 event 对象上是否调用了 event.stopImmediatePropagation() event.isPropagationStopped() 返回指定的 event 对象上是否调用了 event.stopPropagation() event.namespace 返回当事件被触发时指定的命名空间 event.pageX 返回相对于文档左边缘的鼠标位置 event.pageY 返回相对于文档上边缘的鼠标位置 event.preventDefault() 阻止事件的默认行为 event.relatedTarget 返回当鼠标移动时哪个元素进入或退出 event.result 包含由被指定事件触发的事件处理程序返回的最后一个值 event.stopImmediatePropagation() 阻止其他事件处理程序被调用 event.stopPropagation() 阻止事件向上冒泡到 DOM 树，阻止任何父处理程序被事件通知 event.target 返回哪个 DOM 元素触发事件 event.timeStamp 返回从 1970 年 1 月 1 日到事件被触发时的毫秒数 event.type 返回哪种事件类型被触发 event.which 返回指定事件上哪个键盘键或鼠标按钮被按下 event.metaKey 事件触发时 META 键是否被按下 focus() 添加/触发 focus 事件 focusin() 添加事件处理程序到 focusin 事件 focusout() 添加事件处理程序到 focusout 事件 hover() 添加两个事件处理程序到 hover 事件 keydown() 添加/触发 keydown 事件 keypress() 添加/触发 keypress 事件 keyup() 添加/触发 keyup 事件 live() 在版本 1.9 中被移除。添加一个或多个事件处理程序到当前或未来的被选元素 load() 在版本 1.8 中被废弃。添加一个事件处理程序到 load 事件 mousedown() 添加/触发 mousedown 事件 mouseenter() 添加/触发 mouseenter 事件 mouseleave() 添加/触发 mouseleave 事件 mousemove() 添加/触发 mousemove 事件 mouseout() 添加/触发 mouseout 事件 mouseover() 添加/触发 mouseover 事件 mouseup() 添加/触发 mouseup 事件 off() 移除通过 on() 方法添加的事件处理程序 on() 向元素添加事件处理程序 one() 向被选元素添加一个或多个事件处理程序。该处理程序只能被每个元素触发一次 $.proxy() 接受一个已有的函数，并返回一个带特定上下文的新的函数 ready() 规定当 DOM 完全加载时要执行的函数 resize() 添加/触发 resize 事件 scroll() 添加/触发 scroll 事件 select() 添加/触发 select 事件 submit() 添加/触发 submit 事件 toggle() 在版本 1.9 中被移除。添加 click 事件之间要切换的两个或多个函数 trigger() 触发绑定到被选元素的所有事件 triggerHandler() 触发绑定到被选元素的指定事件上的所有函数 unbind() 从被选元素上移除添加的事件处理程序 undelegate() 从现在或未来的被选元素上移除事件处理程序 unload() 在版本 1.8 中被废弃。添加事件处理程序到 unload 事件 contextmenu() 添加事件处理程序到 contextmenu 事件 $.holdReady() 用于暂停或恢复.ready() 事件的执行 jQuery 效果方法 方法 描述 animate() 对被选元素应用\"自定义\"的动画 clearQueue() 对被选元素移除所有排队函数（仍未运行的） delay() 对被选元素的所有排队函数（仍未运行）设置延迟 dequeue() 移除下一个排队函数，然后执行函数 fadeIn() 逐渐改变被选元素的不透明度，从隐藏到可见 fadeOut() 逐渐改变被选元素的不透明度，从可见到隐藏 fadeTo() 把被选元素逐渐改变至给定的不透明度 fadeToggle() 在 fadeIn() 和 fadeOut() 方法之间进行切换 finish() 对被选元素停止、移除并完成所有排队动画 hide() 隐藏被选元素 queue() 显示被选元素的排队函数 show() 显示被选元素 slideDown() 通过调整高度来滑动显示被选元素 slideToggle() slideUp() 和 slideDown() 方法之间的切换 slideUp() 通过调整高度来滑动隐藏被选元素 stop() 停止被选元素上当前正在运行的动画 toggle() hide() 和 show() 方法之间的切换 jQuery HTML / CSS 方法 方法 描述 addClass() 向被选元素添加一个或多个类名 after() 在被选元素后插入内容 append() 在被选元素的结尾插入内容 appendTo() 在被选元素的结尾插入 HTML 元素 attr() 设置或返回被选元素的属性/值 before() 在被选元素前插入内容 clone() 生成被选元素的副本 css() 为被选元素设置或返回一个或多个样式属性 detach() 移除被选元素（保留数据和事件） empty() 从被选元素移除所有子节点和内容 hasClass() 检查被选元素是否包含指定的 class 名称 height() 设置或返回被选元素的高度 html() 设置或返回被选元素的内容 innerHeight() 返回元素的高度（包含 padding，不包含 border） innerWidth() 返回元素的宽度（包含 padding，不包含 border） insertAfter() 在被选元素后插入 HTML 元素 insertBefore() 在被选元素前插入 HTML 元素 offset() 设置或返回被选元素的偏移坐标（相对于文档） offsetParent() 返回第一个定位的祖先元素 outerHeight() 返回元素的高度（包含 padding 和 border） outerWidth() 返回元素的宽度（包含 padding 和 border） position() 返回元素的位置（相对于父元素） prepend() 在被选元素的开头插入内容 prependTo() 在被选元素的开头插入 HTML 元素 prop() 设置或返回被选元素的属性/值 remove() 移除被选元素（包含数据和事件） removeAttr() 从被选元素移除一个或多个属性 removeClass() 从被选元素移除一个或多个类 removeProp() 移除通过 prop() 方法设置的属性 replaceAll() 把被选元素替换为新的 HTML 元素 replaceWith() 把被选元素替换为新的内容 scrollLeft() 设置或返回被选元素的水平滚动条位置 scrollTop() 设置或返回被选元素的垂直滚动条位置 text() 设置或返回被选元素的文本内容 toggleClass() 在被选元素中添加/移除一个或多个类之间切换 unwrap() 移除被选元素的父元素 val() 设置或返回被选元素的属性值（针对表单元素） width() 设置或返回被选元素的宽度 wrap() 在每个被选元素的周围用 HTML 元素包裹起来 wrapAll() 在所有被选元素的周围用 HTML 元素包裹起来 wrapInner() 在每个被选元素的内容周围用 HTML 元素包裹起来 $.escapeSelector() 转义CSS选择器中有特殊意义的字符或字符串 $.cssHooks 提供了一种方法通过定义函数来获取和设置特定的CSS值 jQuery 遍历方法 方法 描述 add() 把元素添加到匹配元素的集合中 addBack() 把之前的元素集添加到当前集合中 andSelf() 在版本 1.8 中被废弃。addBack() 的别名 children() 返回被选元素的所有直接子元素 closest() 返回被选元素的第一个祖先元素 contents() 返回被选元素的所有直接子元素（包含文本和注释节点） each() 为每个匹配元素执行函数 end() 结束当前链中最近的一次筛选操作，并把匹配元素集合返回到前一次的状态 eq() 返回带有被选元素的指定索引号的元素 filter() 把匹配元素集合缩减为匹配选择器或匹配函数返回值的新元素 find() 返回被选元素的后代元素 first() 返回被选元素的第一个元素 has() 返回拥有一个或多个元素在其内的所有元素 is() 根据选择器/元素/jQuery 对象检查匹配元素集合，如果存在至少一个匹配元素，则返回 true last() 返回被选元素的最后一个元素 map() 把当前匹配集合中的每个元素传递给函数，产生包含返回值的新 jQuery 对象 next() 返回被选元素的后一个同级元素 nextAll() 返回被选元素之后的所有同级元素 nextUntil() 返回介于两个给定参数之间的每个元素之后的所有同级元素 not() 从匹配元素集合中移除元素 offsetParent() 返回第一个定位的父元素 parent() 返回被选元素的直接父元素 parents() 返回被选元素的所有祖先元素 parentsUntil() 返回介于两个给定参数之间的所有祖先元素 prev() 返回被选元素的前一个同级元素 prevAll() 返回被选元素之前的所有同级元素 prevUntil() 返回介于两个给定参数之间的每个元素之前的所有同级元素 siblings() 返回被选元素的所有同级元素 slice() 把匹配元素集合缩减为指定范围的子集 jQuery AJAX 方法 方法 描述 $.ajax() 执行异步 AJAX 请求 $.ajaxPrefilter() 在每个请求发送之前且被 $.ajax() 处理之前，处理自定义 Ajax 选项或修改已存在选项 $.ajaxSetup() 为将来的 AJAX 请求设置默认值 $.ajaxTransport() 创建处理 Ajax 数据实际传送的对象 $.get() 使用 AJAX 的 HTTP GET 请求从服务器加载数据 $.getJSON() 使用 HTTP GET 请求从服务器加载 JSON 编码的数据 $.getScript() 使用 AJAX 的 HTTP GET 请求从服务器加载并执行 JavaScript $.param() 创建数组或对象的序列化表示形式（可用于 AJAX 请求的 URL 查询字符串） $.post() 使用 AJAX 的 HTTP POST 请求从服务器加载数据 ajaxComplete() 规定 AJAX 请求完成时运行的函数 ajaxError() 规定 AJAX 请求失败时运行的函数 ajaxSend() 规定 AJAX 请求发送之前运行的函数 ajaxStart() 规定第一个 AJAX 请求开始时运行的函数 ajaxStop() 规定所有的 AJAX 请求完成时运行的函数 ajaxSuccess() 规定 AJAX 请求成功完成时运行的函数 load() 从服务器加载数据，并把返回的数据放置到指定的元素中 serialize() 编码表单元素集为字符串以便提交 serializeArray() 编码表单元素集为 names 和 values 的数组 jQuery 杂项方法 jQuery 杂项方法 方法 描述 data() 向被选元素附加数据，或者从被选元素获取数据 each() 为每个匹配元素执行函数 get() 获取由选择器指定的 DOM 元素 index() 从匹配元素中搜索给定元素 $.noConflict() 释放变量 $ 的 jQuery 控制权 $.param() 创建数组或对象的序列化表示形式（可在生成 AJAX 请求时用于 URL 查询字符串中） removeData() 移除之前存放的数据 size() 在版本 1.8 中被废弃。返回被 jQuery 选择器匹配的 DOM 元素的数量 toArray() 以数组的形式检索所有包含在 jQuery 集合中的所有 DOM 元素 pushStack() 将一个DOM元素集合加入到jQuery栈 $.when() 提供一种方法来执行一个或多个对象的回调函数 jQuery 实用工具 方法 描述 $.boxModel 在版本 1.8 中被废弃。检测浏览器是否使用W3C的CSS盒模型渲染当前页面 $.browser 在版本 1.9 中被废弃。返回用户当前使用的浏览器的相关信息 $.contains() 判断另一个DOM元素是否是指定DOM元素的后代 $.each() 遍历指定的对象和数组 $.extend() 将一个或多个对象的内容合并到目标对象 $.fn.extend() 为jQuery扩展一个或多个实例属性和方法 $.globalEval() 全局性地执行一段JavaScript代码 $.grep() 过滤并返回满足指定函数的数组元素 $.inArray() 在数组中查找指定值并返回它的索引值（如果没有找到，则返回-1） $.isArray() 判断指定参数是否是一个数组 $.isEmptyObject() 检查对象是否为空（不包含任何属性） $.isFunction() 判断指定参数是否是一个函数 $.isNumeric() 判断指定参数是否是一个数字值 $.isPlainObject() 判断指定参数是否是一个纯粹的对象 $.isWindow() 判断指定参数是否是一个窗口 $.isXMLDoc() 判断一个DOM节点是否位于XML文档中，或者其本身就是XML文档 $.makeArray() 将一个类似数组的对象转换为真正的数组对象 $.map() 指定函数处理数组中的每个元素(或对象的每个属性)，并将处理结果封装为新的数组返回 $.merge() 合并两个数组内容到第一个数组 $.noop() 一个空函数 $.now() 返回当前时间 $.parseHTML() 将HTML字符串解析为对应的DOM节点数组 $.parseJSON() 将符合标准格式的JSON字符串转为与之对应的JavaScript对象 $.parseXML() 将字符串解析为对应的XML文档 $.trim() 去除字符串两端的空白字符 $.type() 确定JavaScript内置对象的类型 $.unique() 在jQuery 3.0中被弃用。对DOM元素数组进行排序，并移除重复的元素 $.uniqueSort() 对DOM元素数组进行排序，并移除重复的元素 $.data() 在指定的元素上存取数据，并返回设置值 $.hasData() 确定一个元素是否有相关的jQuery数据 $.sub() 创建一个新的jQuery副本，其属性和方法可以修改，而不会影响原来的jQuery对象 $.speed 创建一个包含一组属性的对象用来定义自定义动画 $.htmlPrefilter() 通过jQuery操作方法修改和过滤HTML字符串 $.readyException() 处理包裹在jQuery()中函数同步抛出的错误 jQuery 回调对象 方法 描述 $.Callbacks() 一个多用途的回调列表对象，用来管理回调函数列表 callbacks.add() 在回调列表中添加一个回调或回调的集合 callbacks.disable() 禁用回调列表中的回调函数 callbacks.disabled() 确定回调列表是否已被禁用 callbacks.empty() 从列表中清空所有的回调 callbacks.fire() 传入指定的参数调用所有的回调 callbacks.fired() 确定回调是否至少已经调用一次 callbacks.firewith() 给定的上下文和参数访问列表中的所有回调 callbacks.has() 判断回调列表中是否添加过某回调函数 callbacks.lock() 锁定当前状态的回调列表 callbacks.locked() 判断回调列表是否被锁定 callbacks.remove() 从回调列表中的删除一个回调或回调集合 jQuery 延迟对象 方法 描述 $.Deferred() 返回一个链式实用对象方法来注册多个回调 deferred.always() 当Deferred（延迟）对象被受理或被拒绝时，调用添加的处理程序 deferred.done() 当Deferred（延迟）对象被受理时，调用添加的处理程序 deferred.fail() 当Deferred（延迟）对象被拒绝时，调用添加的处理程序 deferred.isRejected() 从jQuery1.7开始已经过时，确定 Deferred 对象是否已被拒绝 deferred.isResolved() 从jQuery1.7开始已经过时，确定 Deferred 对象是否已被解决 deferred.notify() 给定一个参数，调用正在延迟对象上进行的回调函数( progressCallbacks ) deferred.notifyWith() 给定上下文和参数，调用正在延迟对象上进行的回调函数( progressCallbacks ) deferred.pipe() 过滤 and/or 链式延迟对象的工具方法 deferred.progress() 当Deferred（延迟）对象生成进度通知时，调用添加处理程序 deferred.promise() 返回 Deferred(延迟)的 Promise 对象 deferred.reject() 拒绝 Deferred（延迟）对象，并根据给定的参数调用任何 failCallbacks 回调函数 deferred.rejectWith() 拒绝 Deferred（延迟）对象，并根据给定的 context 和 args 参数调用任何 failCallbacks 回调函数 deferred.resolve() 解决Deferred（延迟）对象，并根据给定的参数调用任何 doneCallbacks 回调函数 deferred.resolveWith() 解决Deferred（延迟）对象，并根据给定的context 和 args 参数调用任何 doneCallbacks 回调函数 deferred.state() 确定一个Deferred（延迟）对象的当前状态 deferred.then() 当Deferred（延迟）对象解决，拒绝或仍在进行中时，调用添加处理程序 .promise() 返回一个 Promise 对象，观察某种类型被绑定到集合的所有行动，是否已被加入到队列中 jQuery 属性 方法 描述 context 在版本 1.10 中被废弃。包含被传递到 jQuery 的原始上下文 jquery 包含 jQuery 的版本号 jQuery.fx.interval 改变以毫秒计的动画运行速率 jQuery.fx.off 对所有动画进行全局禁用或启用 jQuery.support 包含表示不同浏览器特性或漏洞的属性集（主要用于 jQuery 的内部使用） length 包含 jQuery 对象中元素的数目 jQuery.cssNumber 包含所有可以不使用单位的CSS属性的对象 "},"Web/RESTful.html":{"url":"Web/RESTful.html","title":"RESTful规范","keywords":"","body":"restful api设计（规范，建议） 1、API与用户的通信协议，总是使用HTTPs协议（推荐使用）。 2、域名 --https://api.example.com 尽量将API部署在专用域名（会存在跨域问题） --https://example.org/api/ API很简单 3、版本 --URL，如：https://api.example.com/v1/、https://example.org/api/v1/ --请求头 跨域时，引发发送多次请求 4、路径，视网络上任何东西都是资源，均使用名词表示（可复数） --https://api.example.com/v1/zoos --https://api.example.com/v1/animals --https://api.example.com/v1/employees 5、method --GET ：从服务器取出资源（一项或多项） --POST ：在服务器新建一个资源 --PUT ：在服务器更新资源（客户端提供改变后的完整资源） --PATCH ：在服务器更新资源（客户端提供改变的属性） --DELETE ：从服务器删除资源 6、过滤，通过在url上传参的形式传递搜索条件 --https://api.example.com/v1/zoos?limit=10：指定返回记录的数量 --https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置 --https://api.example.com/v1/zoos?page=2&per_page=100：指定第几页，以及每页的记录数 --https://api.example.com/v1/zoos?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序 --https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件 7、状态码 + 自定义code --200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 --201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 --202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） --204 NO CONTENT - [DELETE]：用户删除数据成功。 --400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 --401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 --403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 --404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 --406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 --410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 --422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 --500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 8、错误处理，状态码是4xx时，应返回错误信息，error当做key。 { error: \"Invalid API key\" } 9、返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档 10、Hypermedia API，RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 {\"link\": { \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\" }} "},"Utils/docker/Docker.html":{"url":"Utils/docker/Docker.html","title":"Docker","keywords":"","body":"1、Docker基本组成 1.1、Docker Client 客户端 1.2、Docker Daemon 守护进程客户端/守护进程C/S模式我们通过客户端发送命令给守护进程，守护进程执行结果返回给客户端 1.3、Docker Image 镜像容器的基石层叠的只读文件系统 1.4、Docker Container 容器通过镜像启动 1.5、Docker Registry 仓库公有私有 1.6、示意图 2、Docker容器相关技术简介 2.1、Docker依赖的Linux内核特性 2.1.1、Namespaces命名空间 编程语言封装 -> 代码隔离 操作系统 系统资源的隔离 进程、网络、文件系统... 分为5种命名空间： PID(Process ID) 进程隔离 NET(Network) 管理网络接口 IPC(InterProcess Communication) 管理跨进程通信的访问 MNT(Mount) 管理挂载点 UTS(Unix Timesharing System) 隔离内核和版本标识 2.1.2、Control groups(cgroups)控制组 用来分配资源 资源限制 优先级设定 资源计量 资源控制 2.2、Docker容器的能力 文件系统隔离：每个容器都有自己的root文件系统 进程隔离：每个容器都运行在自己的进程环境中 网络隔离：容器间的虚拟网络接口和IP地址都是分开的 资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器 3、Docker客户端与守护进程 1、客户端与守护进程通信 2、Remote API与Docker守护进程进行通信 RESTful 风格API 3、连接方式 unix://var/run/docker.sock(默认) tcp://host:port fd://sockerfd 4、Docker守护进程的配置和操作 1、查看守护进程ps -ef | grep dockersudo docker stats 查看docker的运行状态 2、使用service命令管理sudo service docker start/stop/restart 3、Docker的启动选项 docker -d [OPTIONS] 运行相关： -d： 以守护的形式运行 -D,--debug=false -e,--exec-driver=\"native\" -g,--graph=\"/var/lib/docker\" --icc=true -l,--log-level=\"info\" --label=[] 标签区别，key-value形式：name=nzb -p,--pidfile=\"/var/run/docker.pid 服务器连接相关： -G,--group=\"docker\" -H,--host=[] 启动选项，默认 -H unix://var/run/docker.sock --tls=false --tlscacert=\"/home/sven/.docker/ca.pem\" --tlscert=\"/home/sven/.docker/cert.pem\" --tlskey=\"/home/sven/.docker/key.pem\" --tlsverify=false Remote API相关： --api-enable-cors=false 存储相关： -s,--storage-driver=\"\" --selinux-enabled=false --storage-opt=[] Registry相关： --insecure-registry=[] --registry-mirror=[] 网络设置相关： -b,--bridge=\"\" --bip=\"\" --fixed-cidr=\"\" --fixed-cidr-v6=\"\" --dns=[] --dns-search=[] --ip=0.0.0.0 --ip-forward=true --ip-masq=true --iptables=true --ipv6=false --mtu=0 4、启动配置文件 /etc/default/docker 5、Docker的远程访问 1、环境准备 另一台安装Docker的服务器 --label name=server1/2 修改Docker守护进程启动选项，区别服务器-H tcp://0.0.0.0:2375测试：curl http://host:2375/info 保证Client API与Server API 版本一致 修改客户端配置docker -H tcp:host:2375或使用环境变量DOCKER_HOSTexport DOCKER_HOST=\"tcp://host:2375\"测试：docker info 如想访问本地的docker服务：export DOCKER_HOST=\"\" 置空环境变量 如果docker开启了远程服务，如何访问本地：修改启动选项-H，可以有多个： -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 6、Docker容器 1、基本操作 1.1、启动容器docker run IMAGE [COMMAND] [ARG]例： docker run ubuntu echo 'Hello World' 1.2、启动交互式容器docker run -i -t IMAGE /bin/bash -i --interactive=true | false 默认是false -t --tty=true | false 默认是false 1.3、查看容器docker ps [-a] [-l] -a：列出使用容器 -l：列出最新创建的容器 不指定参数则列出所有正在运行的容器 docker inspect 容器id或容器名字：查看容器详细信息 1.4、自定义容器名 docker run --name=自定义名 -i -t IMAGE /bin/bash 1.5、重新启动停止的容器 docker start [-i] 容器名 -i：以交互的方式重新启动容器 1.6、删除停止的容器 docker rm 容器名 2、守护式容器 2.1、以守护形式运行容器 docker run -i -t IMAGE /bin/bash Ctrl+P Ctrl+Q 组合键退出就会在后台运行 2.2、附加到运行中的容器 docker attach 容器名或容器id 2.3、启动守护式容器 docker run -d 镜像名 [COMMAND] [ARG...] -d：启动时使用后台的方式启用 例： docker run --name dc1 -d ubuntu /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 2.4、查看容器日志 docker logs [-f] [-t] [--tail] 容器名 -f --follows=true | false 默认是false 一直跟踪并放回结果 -t --timestamps=true | false 默认是false 加上时间戳 --tail=\"all\" 返回结尾多少条的数据 2.5、查看容器内进程 docker top 容器名 2.6、在运行中的容器内启动新进程 docker exec [-d] [-i] [-t] 容器名 [COMMAND] [ARG...] 进入mysql容器： docker exec -it 容器名 bash 2.7、停止守护式容器 docker stop 容器名 或 docker kill 容器名 7、容器中部署静态网站 7.1、设置容器的端口映射 run [-P] [-p] -P,--publish-all=true | false 默认是false 将为容器暴露的所有端口进行映射 例： docker run -P -i -t ubuntu /bin/bash -p,--pulish=[] 指定映射哪些容器的端口 四种方式： containerPort docker run -p 80 -i -t ubuntu /bin/bash 随机映射 hostPort:containerPort docker run -p 8080:80 -i -t ubuntu /bin/bash ip:containerPort docker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash ip:hostPort:containerPort docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash 7.2、部署流程 创建映射80端口的交互式容器 安装Nginx 安装文本编辑器vim 创建静态文件 修改Nginx配置文件 运行Nginx 验证网站访问 8、查看和删除镜像 1、镜像的存储地址 docker info 查看镜像的存储地址 2、列出镜像 docker images [OPTIONS] [REPOSITORY] -a,--all=false 显示所有镜像，包括中间层镜像 -f,-filter --no-trunc=false id截断 -q,--quiet=false 只显示镜像的唯一IDREPOSITORY仓库是包含一系列的镜像，而REGISTRY仓库包含很多REPOSITORY仓库TAG例如：ubuntu:14.04ubuntu:latest 3、查看镜像 docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...] -f,--format=\"\" 4、删除镜像 docker rmi [OPTIONS] IMAGE [IMAGE...] -f,--force=false 强制删除镜像 - --no-prune=false 不会删除未打标签的镜像 例： docker rmi $(docker images -q ubuntu) 删除所有Ubuntu仓库中的所有镜像 9、获取和推送镜像 1、查找镜像 1.1、Docker Hub https://registry.hub.docker.com 1.2、docker search [OPTIONS] TERM --automated=false 是否是自动构建的镜像 --no-trunc=false -s,--stars=0 最多返回25个结果 2、拉取镜像 docker pull [OPTIONS] NAME[:TAG] -a,--all-tags=false 下载带有标签的的仓库的所有镜像 使用--registry-mirror选项加速拉取镜像速度 修改：etc/default/docker 添加：DOCKER_OPTS=\"--registry-mirror=http://MIRROR-ADDR\" 例：https://www.daocloud.io 注册获取加速地址 3、推送镜像 docker push NAME[:TAG] NAME:仓库名 TAG:标签名 10、构建镜像 1、docker commit 通过容器构建docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] CONTAINER 容器名 -a,--author=\"\" -m,--message=\"\" -p,--pause=true 构建镜像时不暂停运行的容器 2、docker build 通过Dockerfile文件构建 例： #First Dockerfile From ubuntu:14.04 MAINTAINER dormancypress \"dormancypress@outlook.com\" RUN apt-get update RUN apt-get install -y nginx EXPOSE 80 docker build [OPTIONS] PATH | URL | - --force-rm=false --no-cache=false 不使用缓存 --pull=false -q,--quite=false 不显示构建过程 --rm=true -t,--tag=\"\" 指定构建的镜像的名字 PATH | URL 构建镜像的路径，可以使用“.”表示当前文件夹 11、Dockerfile指令 1、指令格式 # Comment 注释 INSTRUCTION argument 指令 2、指令 2.1、FROM FROM FROM : 已经存在的镜像 基础镜像 必须是第一条非注释指令 2.2、MAINTAINER MAINTAINER 指定镜像的作者信息，包含镜像的所有者和联系信息相当于前面的commit命令的-a选项 2.3、RUN 指定当前镜像中运行的命令(镜像构建时运行的) -RUN (shell模式) /bin/sh -c command 例： RUN echo hello -RUN [\"executable\",\"param1\",\"param2\"] (exec模式) 例： RUN [\"/bin/bash\",\"-c\",\"echo hello\"] 2.4、EXPOSE EXPOSE [...] 指定运行该镜像的容器使用的端口（只是告诉容器使用的端口） 为了安全起见，run命令中还要指定端口 docker run -p 80 -d dormancypress/df_test1 nginx -g \"daemon off;\" 2.5、CMD容器运行时运行的指令，会被docker run 命令中的指令覆盖 CMD [\"executable\",\"param1\",\"param2\"] (exec模式) CMD command param1 param2 (shell模式) CMD [\"param1\",\"param2\"] (作为ENTERYPOINT指令的默认参数) 例：CMD [\"/usr/sbin/nginx\", \"-g\", \"daemon off;\"] 2.6、ENTERYPOINT 容器运行时运行的指令，不会被docker run 命令中的指令覆盖 ENTERYPOINT [\"executable\",\"param1\",\"param2\"] (exec模式) ENTERYPOINT command param1 param2 (shell模式) 2.7、ADD ADD ... ADD [\"\"...\"\"](适用于文件路径中有空格的情况) 2.8、COPY COPY ... COPY [\"\"...\"\"](适用于文件路径中有空格的情况) ADD vs COPY ADD包含类型tar的解压功能 如果当纯复制文件，Docker推荐使用COPY 2.9、VOLUME添加容器卷VOLUME [\"/data\"] 2.10、WORKDIR WORKDIR /path/to/workdir 一般不使用绝对路径，如果使用相对路径，会一直传递下去 2.11、ENV 设置环境变量与WORKDIR类似 ENV ENV = 2.12、USER 指定镜像会以什么用户来运行 2.13、ONBUILD 镜像触发器 当一个镜像被其他镜像作为基础镜像时执行 会在构建过程中插入指令 12、构建过程 1、构建过程 从基础镜像运行一个容器 执行一条指令，对容器做出修改 执行类似docker commit的操作，提交一个新的镜像层 在基于刚提交的镜像运行一个新容器 执行Dockerfile中的下一条指令，直至所有指令执行完毕 ps:构建中会删除中间层容器，而不会删除中间层镜像，所以可以使用中间层镜像进行调试，查找错误 2、镜像缓存 构建缓存: 构建一次后再构建就会使用构建缓存 不使用缓存 使用--no-cache选项 或 ENV REFRESH_DATE 2019-4-7 3、查看镜像构建的过程 docker history [image] --no-trunc: 不截断输出完整信息 13、容器的网络连接 1、Docker容器的网络基础 Linux虚拟网桥特点： 可设置IP地址 相当于拥有一个隐藏的虚拟网卡 docker0的地址划分： IP：172.17.42.1 子网掩码：255.255.0.0 MAC:02:42:ac:11:00:00到02:42:11:ff:ff 总共提供了65534个地址 需要使用网桥管理工具：sudo apt-get install bridge-utils 查看网桥：sudo brctl show 添加虚拟网桥：sudo brctl add br0 修改地址：sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0 修改docker0地址： sudo ifconfig docker0 192.168.200.1 netmask 255.255.255.0 更改docker守护进程的启动配置 /etc/default/docker 中添加DOCKER_OPS值 DOCKER_OPS=\"-b=br0\" 2、Docker容器的互联 2.1、运行所有容器互联（默认） 因为每次关闭重启容器IP地址都会改变所有使用--link选项可以使新启动的容器为其起别名，就不用担心IP改变 --linkdocker run --link=[CONTAINER_NAME]:[ALIAS] [IMAGE] [COMMAND] 2.2、拒绝容器间的互联 --icc=false 2.3、允许特点容器间的连接 --icc=false --iptables=true --link 3、Docker容器与外部网络的连接 3.1、ip-forward --ip-forward=true(默认) 允许数据转发 查看ip_forward的值： sysctl net.ipv4.conf.all.forwarding 3.2、iptables 什么是iptables: Iptables是Linux内核集成的包过滤防火墙系统，几乎所有的Linux发行版本都会包含IPtables的功能。 表(table):下图中的nat、mangle、raw、filter... 链(chain):代表数据处理的不同环节 规则(rule):每个链下的操作 ACCEPT、REJECT、DROP filter表中包含的链： INPUT FORWARD OUTPUT 查看iptables： sudo iptables [-t filter] -L -n -t:指定表名（默认） 3.3、允许特定IP访问容器 sudo iptables -I DOCKER -s 禁止访问ip -d 目的ip -p TCP --dport 80 -j ACCEPT 3.4、限制IP访问容器 sudo iptables -I DOCKER -s 禁止访问ip -d 目的ip -p TCP --dport 80 -j DROP 14、Docker容器的数据卷 什么是数据卷： 数据卷是经过特殊设计的目录，可以绕过联合文件系统（UFS）,为一个或多个容器提供访问。 数据卷设计的目的，在于设计的永久化，他完全独立于容器的生存周期，因此，Docker不会再容器删除时删除其挂载的数据卷， 也不会存在类似的垃圾收集机制，对容器引用的数据卷进行处理。 1、为容器添加数据卷 docker run -v ~/container_data:/data -it ubuntu /bin/bash ~/container_data： 本机目录 /data： 容器目录 2、为数据卷添加访问权限 docker run -v ~/container_data:/data:ro -it ubuntu /bin/bash ro: 只读 3、使用Dockerfile构建包含数据卷的镜像 Dockerfile指令 VOLUME[\"/data\"] 但是，利用这个镜像创建的容器构建的数据卷都是不一样的，则不能实现共享。 15、Docker的数据卷容器 1、挂载数据卷容器的方法 docker run --volumes-from [CONTAINER NAME] 即时删除了数据卷容器，挂载了这个数据卷容器的容器还是能正常使用。因为只要一个数据卷还在被使用就不会被删除。 16、Docker数据卷的备份和还原 1、数据备份方法 docker run --volumes-from [container name] -v $(pwd):/backup:wr ubuntu tar -cvf /backup/backup.tar [container data volume] $(pwd):备份文件存储的目录 /backup：容器中的目录 wr ：读写（默认） [container data volume]：需要压缩的数据卷目录 tar -cvf/backup/backup.tar [container data volume]：备份操作（压缩） 2、数据还原方法 docker run --volumes-from [container name] -v $(pwd):/backup:wr ubuntu tar -xvf /backup/backup.tar [container data volume] 17、Docker容器的跨主机连接 1、使用网桥实现跨主机容器连接 1.1、环境准备 Mac OS X + Parallels 两台Ubuntu14.04虚拟机 安装网桥管理工具： apt-get install bridge-utils ip地址： Host1:10.211.55.3 Host2:10.211.55.5 修改/etc/network/interfaces文件 auto bro iface bro inet static address 10.211.55.3 netmask 255.255.255.0 geteway 10.211.55.1 bridge_ports eth0 Docker设置 修改/etc/default/docker文件 -b指定使用自定义网桥 -b=br0 --fixed-cidr限制ip地址分配范围 IP地址划分： Host1:10.211.55.64/26 地址范围：10.211.55.65~10.211.55.126 Host2:10.211.55.128/26 地址范围：10.211.55.129~10.211.55.190 2、使用Open vSwitch实现跨主机容器连接 3、使用Weave实现跨主机容器连接 Docker 磁盘空间占用和清理 磁盘空间占用 Docker 的内置 CLI 指令docker system df，可用于查询镜像（Images）、容器（Containers）和本地卷（Local Volumes）等空间使用大户的空间占用情况。 [root@dockercon ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE kalilinux/kali-linux-docker latest c927a54ec8a4 8 days ago 1.88GB nginx latest 3f8a4339aadd 9 days ago 108MB busybox latest 6ad733544a63 2 months ago 1.13MB [root@dockercon ~]# docker system df TYPE TOTAL ACTIVE SIZE RECLAIMABLE Images 3 0 1.994GB 1.994GB (100%) Containers 0 0 0B 0B Local Volumes 0 0 0B 0B Build Cache 0B 0B 可以进一步通过-v参数查看空间占用细节 [root@dockercon ~]# docker system df -v #镜像空间使用情况 Images space usage: REPOSITORY TAG IMAGE ID CREATED ago SIZE SHARED SIZE UNIQUE SiZE CONTAINERS kalilinux/kali-linux-docker latest c927a54ec8a4 8 days ago ago 1.884GB 0B 1.884GB 0 nginx latest 3f8a4339aadd 9 days ago ago 108.5MB 0B 108.5MB 0 busybox latest 6ad733544a63 2 months ago ago 1.129MB 0B 1.129MB 0 #容器空间使用情况 Containers space usage: CONTAINER ID IMAGE COMMAND LOCAL VOLUMES SIZE CREATED ago STATUS NAMES #本地卷使用情况 Local Volumes space usage: VOLUME NAME LINKS SIZE Build cache usage: 0B 空间清理 不同状态 已使用镜像（used image） 未引用镜像（unreferenced image） 悬空镜像（dangling image） 镜像含义 指所有已被容器（包括已停止的）关联的镜像 没有被分配或使用在容器中的镜像 未配置任何 Tag （也就无法被引用）的镜像 Docker内置自动清理 通过 Docker 内置的 CLI 指令docker system prune来进行自动空间清理。 [root@dockercon ~]# docker system prune --help Usage: docker system prune [OPTIONS] Remove unused data Options: -a, --all Remove all unused images not just dangling ones --filter filter Provide filter values (e.g. 'label==') -f, --force Do not prompt for confirmation --volumes Prune volumes docker system prune 自动清理说明 该指令默认会清除所有如下资源： 已停止的容器（container） 未被任何容器所使用的卷（volume） 未被任何容器所关联的网络（network） 所有悬空镜像（image）。 该指令默认只会清除悬空镜像，未被使用的镜像不会被删除。添加-a 或 --all参数后，可以一并清除所有未使用的镜像和悬空镜像。 可以添加-f 或 --force参数用以忽略相关告警确认信息。 [root@dockercon ~]# docker system prune --help Usage: docker system prune [OPTIONS] Remove unused data Options: -a, --all Remove all unused images not just dangling ones --filter filter Provide filter values (e.g. 'label==') -f, --force Do not prompt for confirmation --volumes Prune volumes [root@dockercon ~]# docker system prune --all WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all images without at least one container associated to them - all build cache Are you sure you want to continue? [y/N] y Deleted Containers: f095899e7343e160d5b32d0688a6561a1a7f6af91c42ffe966649240b58ca23f Deleted Images: untagged: busybox:latest untagged: busybox@sha256:e3789c406237e25d6139035a17981be5f1ccdae9c392d1623a02d31621a12bcc deleted: sha256:6ad733544a6317992a6fac4eb19fe1df577d4dec7529efec28a5bd0edad0fd30 deleted: sha256:0271b8eebde3fa9a6126b1f2335e170f902731ab4942f9f1914e77016540c7bb untagged: kalilinux/kali-linux-docker:latest untagged: kalilinux/kali-linux-docker@sha256:28ff9e4bf40f7399e0570394a2d3d388a7b60c748be1b0a180c14c87afad1968 deleted: sha256:c927a54ec8a46164d7046b2a6dc09b2fce52b3066317d50cf73d14fa9778ca48 untagged: alpine:latest untagged: alpine@sha256:ccba511b1d6b5f1d83825a94f9d5b05528db456d9cf14a1ea1db892c939cda64 untagged: alpine-io:latest Total reclaimed space: 5.219GB "},"Utils/docker/FastDFS.html":{"url":"Utils/docker/FastDFS.html","title":"FastDFS","keywords":"","body":"datetime:2020/1/3 14:24 author:nzb 使用Docker安装FastDFS分布式文件系统 拉取镜像 docker image pull delron/fastdfs 运行tracker docker run -itd --network=host --name fastdfs-tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs 将fastDFS tracker运行目录映射到本机的 /var/fdfs/tracker目录中。 查看是否允许起来 docker ls 停止运行 docker stop fastdfs-tracker 重新运行 docker start fastdfs-tracker 运行storage docker run -itd --network=host --name fastdfs-storage -e TRACKER_SERVER=192.168.1.218:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage TRACKER_SERVER=本机的ip地址:22122 本机ip地址不要使用127.0.0.1 将fastDFS storage运行目录映射到本机的/var/fdfs/storage目录中 查看是否允许起来 docker ls 停止运行 docker stop fastdfs-storage 重新运行 docker start fastdfs-storage 注意：如果无法重新运行，可以删除/var/fdfs/storage/data目录下的fdfs_storaged.pid 文件，然后重新运行storage。 Django项目之FastDFS文件存储系统 FastDFS的Python客户端 python版本的FastDFS客户端使用说明参考：https://github.com/jefforeilly/fdfs_client-py 安装 安装fdfs_client-py-master.zip到虚拟环境中 pip install fdfs_client-py-master.zip pip install mutagen pip install requests 配置 在项目/utils目录下新建fastdfs目录，新建client.conf配置文件 # connect timeout in seconds # default value is 30s connect_timeout=30 # network timeout in seconds # default value is 30s network_timeout=60 # the base path to store log files base_path=FastDFS客户端存放日志文件的目录 # tracker_server can ocur more than once, and tracker_server format is # \"host:port\", host can be hostname or ip address tracker_server=172.17.0.1:22122 #standard log level as syslog, case insensitive, value list: ### emerg for emergency ### alert ### crit for critical ### error ### warn for warning ### notice ### info ### debug log_level=info # if use connection pool # default value is false # since V4.05 use_connection_pool = false # connections whose the idle time exceeds this time will be closed # unit: second # default value is 3600 # since V4.05 connection_pool_max_idle_time = 3600 # if load FastDFS parameters from tracker server # since V4.05 # default value is false load_fdfs_parameters_from_tracker=false # if use storage ID instead of IP address # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # default value is false # since V4.05 use_storage_id = false # specify storage ids filename, can use relative or absolute path # same as tracker.conf # valid only when load_fdfs_parameters_from_tracker is false # since V4.05 storage_ids_filename = storage_ids.conf #HTTP settings http.tracker_server_port=80 #use \"#include\" directive to include HTTP other settiongs ##include http.conf 注意：需要修改一下client.conf配置文件 # FastDFS客户端存放日志文件的目录 base_path= # 运行tracker服务的机器ip tracker_server=172.17.0.1:22122 自定义Django文件存储系统 Django自带文件存储系统，但是默认文件存储在本地，将文件保存到FastDFS服务器上，所以需要自定义文件存储系统。 在项目/utils/fastdfs目录中创建fdfs_storage.py文件，实现可以使用FastDFS存储文件的存储类如下 from django.conf import settings from django.core.files.storage import Storage from django.utils.deconstruct import deconstructible from fdfs_client.client import Fdfs_client @deconstructible class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): \"\"\" 初始化 :param base_url: 用于构造图片完整路径使用，图片服务器的域名 :param client_conf: FastDFS客户端配置文件的路径 \"\"\" if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf def _open(self, name, mode='rb'): \"\"\" 用不到打开文件，所以省略 \"\"\" pass def _save(self, name, content): \"\"\" 在FastDFS中保存文件 :param name: 传入的文件名 :param content: 文件内容 :return: 保存到数据库中的FastDFS的文件名 \"\"\" client = Fdfs_client(self.client_conf) ret = client.upload_by_buffer(content.read()) if ret.get(\"Status\") != \"Upload successed.\": raise Exception(\"upload file failed\") file_name = ret.get(\"Remote file_id\") return file_name def url(self, name): \"\"\" 返回文件的完整URL路径 :param name: 数据库中保存的文件名 :return: 完整的URL \"\"\" return self.base_url + name def exists(self, name): \"\"\" 判断文件是否存在，FastDFS可以自行解决文件的重名问题 所以此处返回False，告诉Django上传的都是新文件 :param name: 文件名 :return: False \"\"\" return False 说明: 自定义文件存储系统的方法如下： 1）需要继承自django.core.files.storage.Storage，如 from django.core.files.storage import Storage class FastDFSStorage(Storage): ... 2）支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取 from django.conf import settings from django.core.files.storage import Storage class FastDFSStorage(Storage): def __init__(self, base_url=None, client_conf=None): if base_url is None: base_url = settings.FDFS_URL self.base_url = base_url if client_conf is None: client_conf = settings.FDFS_CLIENT_CONF self.client_conf = client_conf 3）存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。 _open(name, mode='rb') 被Storage.open()调用，在打开文件时被使用。 _save(name, content) 被Storage.save()调用，name是传入的文件名，content是Django接收到的文件内容，该方法需要将content文件内容保存。 Django会将该方法的返回值保存到数据库中对应的文件字段，也就是说该方法应该返回要保存在数据库中的文件名称信息。 exists(name) 如果名为name的文件在文件系统中存在，则返回True，否则返回False。 url(name) 返回文件的完整访问URL delete(name) 删除name的文件 listdir(path) 列出指定路径的内容 size(name) 返回name文件的总大小 注意，并不是这些方法全部都要实现，可以省略用不到的方法。 4）需要为存储类添加django.utils.deconstruct.deconstructible装饰器 在Django配置中设置自定义文件存储类 在settings.py文件中添加设置 # django文件存储 DEFAULT_FILE_STORAGE = '项目名.utils.fastdfs.fdfs_storage.FastDFSStorage' # FastDFS FDFS_URL = 'http://域名:端口' FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf') 添加image域名 在/etc/hosts中添加访问FastDFS storage服务器的域名 127.0.0.1 xx域名 "},"Utils/Git基本命令.html":{"url":"Utils/Git基本命令.html","title":"Git","keywords":"","body":"Git常用命令 帮助信息 git help 显示常用的git 和使用简短说明 git help -a 显示所有的命令 git help -g 查看使用手册 git help 命令 / git 命令 help 查看某命令的使用说明, F键下一页，B键上一页，Q退出 git 配置（全局配置） 所有的配置都会保存到当前用户目录下的: .gitconfig 文件中 git config --global user.name '名称' 配置用户名 git config --global user.email '邮箱名' 配置邮箱 git config --list 查看配置信息 git config --unset --global user.name '名称' 重置信息 git config --global corlor.ui true 初始化项目 git init 初始化项目 查看状态 git status 状态： untracked:未跟踪的文件 modified: 修改后未添加提交的文件 添加文件 git add .或具体文件 添加当前文件夹的文件或具体文件 提交文件 git commit -m '提交信息' 提交 git commit -am '提交信息' 添加提交 查看提交日志 git log --oneline --decorate --all -10 --graph --author='作者' --index='文件名' --before='2019-3-1/1 week' --oneline:一行显示提交日志 --decorate:显示详细 --all:显示在所有分支上的提交 -10:显示数量 --graph:显示分支信息 --author:指定作者 --grep:搜索某文件 --before:某时间之前 查看文件修改前和修改后的区别 git diff 文件名 查看文件修改的区别，不指明文件则所以修改文件的区别 Git跟踪rename文件/移动文件 git mv 原文件名 新文件名 重命名/移动文件夹或文件名 git add . git commit -m '信息' 删除文件 git rm 文件名1 文件名2 。。。 git rm -r 文件夹名 递归删除 恢复文件 git checkout HEAD^ -- 需要恢复的文件名 HEAD:最近的一次提交 HEAD^:最近的一次提交的上一次提交 HEAD^^:最近的一次提交的上两次提交 HEAD^^...:最近的一次提交的上n次提交 --:当前分支 恢复提交 git revert 提交号 重置提交指针 git reset 选项 提交号 --soft:软重置，不会影响工作区和暂存区的东西 --hard:工作区和暂存区直接重置到指定的状态 --mixed: 默认，会把暂存区重置到指定的状态，并把指针指到当前位置 git status 先看一下add 中的文件 git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 - HEAD^ 表示上一个版本，即上一次的commit，也可以写成HEAD~1 - 如果进行两次的commit，想要都撤回，可以使用HEAD~2 git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了 查看/创建/切换分支 git branch -a 查看分支 git branch -r 查看远程分支 git branch 分支名 创建分支 git checkout 分支名 切换分支 查看两个分支之间的区别 git diff master..branch1 文件名 查看两个分支（文件）之间的区别，a表示两点左边的分支，b表示右边的分支 合并分支 git checkout master git merge 分支名 解决合并冲突 手动解决冲突 Git用>>>>>>标记出不同分支的内容 重命名/删除分支 git branch -m 原分支名 新分支名 git branch -d 分支名 保存修改进度 git stash save '描述信息' git stash list 查看工作进度信息 git stash show -p 工作进度代号 查看工作进度和现在的区别 git apply 工作进度代号 恢复工作进度 git shash drop 工作进度代号 删除工作进度 git apply pop 工作进度代号 恢复工作进度同时删除 添加别名 git config --global alias.co(别名) checkout(命令) 或 编辑当前用户文件夹下的.bash_profile文件 alias gco='git checkout' 保存退出 source ~/.bash_profile或重启终端 全局忽略跟踪文件 git config --global core.excludesfile ~/.gitignore_global 告诉git全局范围中忽略的文件包含在.gitignore_global文件中 编辑.gitignore_global需要忽略的文件 项目级忽略文件 在项目根目录下创建.gitignore文件 在.gitignore文件下添加忽略文件 如果你不想推什么文件到git 可以运行这个命令： git update-index --assume-unchanged xxx/xxx.py 忽略已被跟踪的文件 忽略规则只针对还没有被git跟踪的文件及文件夹有效。若需要忽略规则对已被跟踪的文件及文件夹有效，则需要取消对文件或文件夹的跟踪 git rm -r --cached ：取消对文件夹及文件夹下的所有子文件夹、文件的跟踪，文件夹及文件夹下的所有子文件夹、文件的状态将从跟踪状态变为未跟踪状态 git rm --cached ：取消对文件的跟踪，文件的跟踪状态将变为未跟踪状态 取消对文件或文件夹的跟踪之后，.gitignore文件中的忽略规则将会对取消了跟踪状态的文件或文件夹生效 创建远程版本库 git remote add origin 远程版本库url地址 git remote -v 查看远程库信息 git remote rm 移除远程库 推送版本库 git push [-u] origin 分支名 -u:跟踪远程分支的变化 修改远程仓库地址 1.修改命令 git remote origin set-url [url] 2.先删后加 git remote rm origin git remote add origin [url] 3.直接修改config文件 克隆版本库到本地 git clone 远程版本库url地址 目录名 克隆到指定目录下 更新本地版本库 git fetch 拉取版本库 git merge origin/master 合并 或 git pull = git fetch + git merge 第一种比较安全 基于版本库开发自己的版本库，fork到自己账户然后克隆到本地 git fork 远程版本库url地址 添加pull request git pull request 添加贡献者 GitHub中的setting中的collaborator添加贡献者 详情图 "},"Utils/Nginx.html":{"url":"Utils/Nginx.html","title":"Nginx","keywords":"","body":"datetime:2019/9/5 16:14 author:nzb Nginx的配置 安装Nginx。 yum -y install nginx 修改全局配置文件（/etc/nginx/nginx.conf）。 # 配置用户 user root; # 工作进程数(建议跟CPU的核数量一致) worker_processes auto; # 错误日志 error_log /var/log/nginx/error.log; # 进程文件 pid /run/nginx.pid; # 包含其他的配置 include /usr/share/nginx/modules/*.conf; # 工作模式(多路IO复用方式)和连接上限 events { use epoll; worker_connections 1024;(单进程的并发量, 总并发=进程数*单个进程的并发量) } # HTTP服务器相关配置 http { # 日志格式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; # 访问日志 access_log /var/log/nginx/access.log main; # 开启高效文件传输模式 sendfile on; # 用sendfile传输文件时有利于改善性能 tcp_nopush on; # 禁用Nagle来解决交互性问题 tcp_nodelay on; # 客户端保持连接时间 keepalive_timeout 30; types_hash_max_size 2048; # 包含MIME类型的配置 include /etc/nginx/mime.types; # 默认使用二进制流格式 default_type application/octet-stream; # 包含其他配置文件 include /etc/nginx/conf.d/*.conf; # 包含项目的Nginx配置文件 include /root/project/conf/*.conf; } 编辑局部配置文件（/root/project/conf/nginx.conf）。 server { # 默认端口 listen 80; # 域名解析 server_name _; # 网站根目录 root /root/project/www; # 缓存图片文件 location ~ \\.(jpeg|jpg|png)${ # 缓存文件类型 # 缓存时间为1day expires 1d; # h:小时, d:天 } access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; # 默认访问页 location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; index index.html index.htm; } location /static/ { alias /root/project/stat/; expires 30d; } } server { listen 443; server_name _; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { include uwsgi_params; uwsgi_pass 172.18.61.250:8000; } location /static/ { alias /root/project/static/; expires 30d; } } 到此为止，我们可以启动Nginx来访问我们的应用程序，HTTP和HTTPS都是没有问题的，如果Nginx已经运行，在修改配置文件后，我们可以用下面的命令重新启动Nginx。 重启Nginx服务器。 nginx -s reload 或 systemctl restart nginx 说明：可以对Django项目使用python manage.py collectstatic命令将静态资源收集到指定目录下，要做到这点只需要在项目的配置文件settings.py中添加STATIC_ROOT配置即可。 负载均衡配置 下面的配置中我们使用Nginx实现负载均衡，为另外的三个Nginx服务器（通过Docker创建）提供反向代理服务。 docker run -d -p 801:80 --name nginx1 nginx:latest docker run -d -p 802:80 --name nginx2 nginx:latest docker run -d -p 803:80 --name nginx3 nginx:latest user root; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } # 为HTTP服务配置负载均衡 http { upstream fangtx { # 分发：IP：端口 weight权重 max_fails失败次数 fail_timeout分发失败超时时间 server 172.18.61.250:801 weight=4; server 172.18.61.250:802 weight=2; server 172.18.61.250:803 weight=2; # 配置同一用户访问同一个web服务器(解决session丢失问题导致无法登陆和验证码验证(生成和验证不在同一台服务器)) ip_hash; } server { listen 80 default_server; listen [::]:80 default_server; listen 443 ssl; listen [::]:443 ssl; ssl on; access_log /root/project/logs/access.log; error_log /root/project/logs/error.log; ssl_certificate /root/project/conf/cert/214915882850706.pem; ssl_certificate_key /root/project/conf/cert/214915882850706.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_buffering off; proxy_pass http://fangtx; # 跟上面的upstream后的值一样 } } } 说明：Nginx在配置负载均衡时，默认使用WRR（加权轮询算法），除此之外还支持ip_hash、fair（需要安装upstream_fair模块）和url_hash算法。此外，在配置upstream模块时可以指定服务器的状态值，包括：backup（备份机器，其他服务器不可用时才将请求分配到该机器）、down、fail_timeout（请求失败达到max_fails后的暂停服务时间）、max_fails（允许请求失败的次数）和weight（轮询的权重）。 Keepalived 当使用Nginx进行负载均衡配置时，要考虑负载均衡服务器宕机的情况。为此可以使用Keepalived来实现负载均衡主机和备机的热切换，从而保证系统的高可用性。Keepalived的配置还是比较复杂，通常由专门做运维的人进行配置，一个基本的配置可以参照《Keepalived的配置和使用》。 "},"InterviewPreparation/ClassicQuestion/20201027/":{"url":"InterviewPreparation/ClassicQuestion/20201027/","title":"面试题","keywords":"","body":"datetime:2020/10/27 16:58 author:nzb 文件操作 现在要处理一个大小为 10 G 的文件，但是内存只有 4 G，如果在只修改 get_lines 函数而其他代码保持不变的情况下，应该如何实现？需要考虑的问题都有那些？ def get_lines(): with open('file.txt','rb') as f: for i in f: yield i 遍历目录与子目录 抓取.pyc文件 第一种 ```python import os def get_files(dir,suffix): res = [] for root,dirs,files in os.walk(dir): for filename in files: name,suf = os.path.splitext(filename) if suf == suffix: res.append(os.path.join(root,filename)) print(res) get_files(\"./\",'.pyc') - 第二种 ```python import os def pick(obj): if obj.endswith(\".pyc\"): print(obj) def scan_path(ph): file_list = os.listdir(ph) for obj in file_list: if os.path.isfile(obj): pick(obj) elif os.path.isdir(obj): scan_path(obj) if __name__=='__main__': path = input('输入目录') scan_path(path) 第三种 ```python from glob import iglob def func(fp, postfix): for i in iglob(f\"{fp}/*/{postfix}\", recursive=True): print(i) if name == \"main\": postfix = \".pyc\" func(\"K:\\Python_script\", postfix) # 数字字符串转整形 字符串 \"123\" 转换成 123 ，不使用内置api，例如 int() - 第一种 ```python def atoi(s): num = 0 for v in s: for j in range(10): if v == str(j): num = num * 10 + j return num 第二种def atoi(s): num = 0 for v in s: num = num * 10 + ord(v) - ord('0') return num 第三种def atoi(s): num = 0 for v in s: t = \"%s * 1\" % v n = eval(t) num = num * 10 + n return num 第四种from functools import reduce def atoi(s): return reduce(lambda num, v: num * 10 + ord(v) - ord('0'), s, 0) 数字字符串排序 让所有奇数都在偶数前面，而且奇数升序排列，偶数降序排序，如字符串'1982376455',变成'1355798642' print(\"\".join(sorted('1982376455', key=lambda x: int(x) % 2 == 0 and 20 - int(x) or int(x)))) # 分解 int(x) % 2 == 0 and 20 - int(x)：这是排序偶数，降序排序 int(x)：剩下的奇数升序排序 python函数重载机制？ 函数重载主要是为了解决两个问题。 1。可变参数类型。 2。可变参数个数。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同 的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字 不同的函数。 好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处 理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中 很可能是相同的代码，没有必要做成两个不同函数。 那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参 数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数 终归是需要用的。 好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 回调函数，如何通信的? 回调函数是把函数的指针(地址)作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。 闭包延迟 详情 下面这段代码的输出结果将是什么？请解释。 def multipliers(): return [lambda x: i *x for i in range(4)] print([m(2) for m in multipliers()]) 上面代码的输出结果是 [6,6,6,6]，不是我们想的 [0,2,4,6] 上述问题产生的原因是python闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。 因此，当任何由multipliers()返回的函数被调用时,i的值将在附近的范围进行查找。 那时，不管返回的函数是否被调用，for循环已经完成，i被赋予了最终的值3. def multipliers(): for i in range(4): yield lambda x: i *x 你如何修改上面的 multipliers 的定义产生想要的结果？ def multipliers(): return [lambda x,i = i: i*x for i in range(4)] 单例模式 装饰器 from functools import wraps def singleton(cls): _instance = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return wrapper 使用基类 class SingletonMeta(object): def __new__(cls, *args, **kwargs): if not hasattr(cls, \"__instance\"): setattr(cls, \"__instance\", super().__new__(cls, *args, **kwargs)) return getattr(cls, \"__instance\") class Foo(SingletonMeta): pass 使用元类 class SingletonMeta(type): \"\"\"自定义元类\"\"\" def __call__(cls, *args, **kwargs): if not hasattr(cls, \"__instance\"): setattr(cls, \"__instance\", super().__call__(*args, **kwargs)) return getattr(cls, \"__instance\") class Foo(metaclass=SingletonMeta): pass 请用一行代码实现将 1-N 的整数列表以 3 为单位分组 N =100 print ([[x for x in range(1,100)] [i:i+3] for i in range(0,100,3)]) Python的魔法方法 魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被Python所调用， 你可以定义自己想要的行为，而这一切都是自动发生的，它们经常是两个下划线包围来命名的（比如 __init__ , __len__ ), Python的魔法方法是非常强的所以了解其使大用方法也变得尤为重要! __init__： 构造器，当一个实例被创建的时候初始化的方法，但是它并不是实例化调用的第一个方法。 __new__：才是实例化对象调用的第一个方法，它只取下 cls 参数，并把其他参数传给 __init___。 ___new__： 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元祖或者字符串这样不经常改变的类型的时候。 __call__： 让一个类的实例像函数一样被调用 __getitem__： 定义获取容器中指定元素的行为，相当于 self[key] __getattr__： 定义当用户试图访问一个不存在属性的时候的行为。 __setattr__： 定义当一个属性被设置的时候的行为 __getattribute___： 定义当一个属性被访问的时候的行为 多进程多线程以及协程的理解 这个问题被问的概念相当之大， 进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单 位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。 线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线 程，叫主线程，而多个线程共享内存（数据共享，共享全局变量),从而极大地提高了程序的运行效率。 协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。 协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和 栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 协程 python asyncio的原理？ asyncio 这个库就是使用 python 的 yield 这个可以打断保存当前函数的上下文的机制， 封装好了 selector 摆脱掉了复杂的回调关系 单线程+异步 I/O Python异步使用场景有那些 1、 不涉及共享资源，获对共享资源只读，即非互斥操作 2、 没有时序上的严格关系 3、 不需要原子操作，或可以通过其他方式控制原子性 4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能 5、 不影响主线程逻辑 多线程竞争 线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全 那么怎么解决多线程竞争问题？---锁 锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。 锁的坏处： 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了 锁的致命问题: 死锁 Python的线程同步 setDaemon(False) 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在 Python 中， 默认情况下就是 setDaemon(False) ,主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。 import threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.start() print('---主线程--结束') if __name__ =='__main__': main() #执行结果 ---主线程--结束 ---子线程结束--- setDaemon（True) 当我们使用 setDaemon(True) 时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止 ```python import threading import time def thread(): time.sleep(2) print(’---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True)#设置子线程守护主线程 t1.start() print('---主线程结束---') if name =='main': main() 执行结果 ---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束 - join（线程同步) join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。 当设置守护线程时，含义是主线程对于子线程等待 timeout 的时间将会杀死该子线程，最后退出程序，所以说，如果有 10 个子线程， 全部的等待时间就是每个 timeout 的累加和，简单的来说，就是给每个子线程一个 timeout 的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。 没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。 ```python import threading import time def thread(): time.sleep(2) print('---子线程结束---') def main(): t1 = threading.Thread(target=thread) t1.setDaemon(True) t1.start() t1.join(timeout=1) #1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行 #2 如果不设置timeout参数就等子线程结束主线程再结束 #3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束 print('---主线程结束---') if __name__=='__main___': main() 锁及其分类 定义：锁(Lock)是 python 提供的对线程控制的对象。 分类：互斥锁，可重入锁，死锁 死锁 若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。 GIL锁 全局解释器锁（互斥锁） 作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！ 所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。 进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换 三者的关系：进程里有线程，线程里有协程。 多线程交互访问数据，怎么避免重读？ 创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。 什么是线程安全，什么是互斥锁？ 每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。 同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作， 导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。 同步、异步、阻塞、非阻塞 同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。 异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！ 阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。 非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。 同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。 僵尸进程和孤儿进程及怎么避免僵尸进程？ 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（进程号为 1 ）所收养，并由 init 进程对他们完成状态收集工作。 僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 避免僵尸进程的方法： 1.fork 两次用孙子进程去完成子进程的任务 2.用 wait() 函数使父进程阻塞 3.使用信号量，在 signal handler 中调用 waitpid , 这样父进程不用阻塞 IO密集型和CPU密集型区别？ IO密集型：系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写。 CPU密集型：大部分时间用来做计算，逻辑判断等 CPU 动作的程序称之 CPU 密集型。 python中进程与线程的使用场景？ 多进程适合在 CPU 密集操作（ cpu 操作指令比较多，如位多的的浮点运算）。 多线程适合在 IO 密性型操作（读写数据操作比多的的，比如爬虫） 线程是并发还是并行，进程是并发还是并行？ 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 线程是并发，进程是并行; 进程之间互相独立，是系统分配资源的最小单位，同一个进程中的所有线程共享资源。 TCP和UDP 详情 TCP 套接字：是使用 TCP 协议提供的传输服务来实现网络通信的编程接口。 UDP 套接字：一种非常轻便的传输协议，也称做用户数据报协议，简称 UDP。 TCP 和 UDP 都是提供端到端传输服务的协议。 二者的差别：就如同打电话和发短信的区别， 后者不对传输的可靠性和可达性做出任何承诺从而避免了 TCP 中握手和重传的开销， 所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP 可能是更好的选择。 可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏， 这无非就是部分数据传丢或传错造成的。 浏览器通过WSGI请求动态资源的过程? 浏览器发送的请求被 Nginx 监听到，Nginx 根据请求的 URL 的 PATH 或者后缀把请求静态资源的分发到静态资源的目录， 别的请求根据配置好的转发到相应端口。 实现了 WSGI 的程序会监听某个端口，监听到 Nginx 转发过来的请求接收后 (一般用 socket 的 recv 来接收 HTTP 的报文)以后把请求的报文封装成 environ 的字典对象， 然后再提供一个 startresponse 的方法。把这两个对象当成参数传入某个方法比如 wsgiapp(environ, start_response) 或者实现了 __call(self, environ, start_response) 方法的某个实例。这个实例再调用 start_response 返回给实现了 WSGI 的中间件，再由中间件返回给 Nginx。 Django 项目中有个 wsgi.py 的文件，里面设置了 DJANGO_SETTINGS_MODULE 为项目的配置文件，如何获取 wsgi 的APP。 浏览器访问www.baidu.com的过程 (1) 浏览器获取输入的域名 www.baidu.com (2) 浏览器向 DNS 请求解析 www.baidu.com 的 IP 地址 (3) 域名系统 DNS 解析出百度服务器的 IP 地址-通过网关出去 (4) 浏览器与该服务器建立 TCP 连接(默认端口号 80 ) (5) 浏览器发出 HTTP 请求，请求百度首页 (6) 服务器通过 HTTP 响应把首页文件发送给浏览器 (7) TCP 连接释放 (8) 浏览器将首页文件进行解析，并将 Web 页显示给用户。 Post和Get请求的区别 GET： 1.请求参数在请求行中，在url后。 2.请求的url长度有限制的 3.不太安全 4.发送一次TCP数据包 POST： 1.请求参数在请求体中 2.请求的url长度没有限制的 3.相对安全 4.发送两次TCP数据包 cookie和session的区别 cookie： 客户端技术，数据保存在客户端，数据不够安全，只能存储 4kb 数据 单个 cookie 保存的数据不超过4K，浏览器限制一个站点最多保存 20 个 cookie session：服务器端技术，数据保存在服务器，数据相对安全，用户看不到数据只能看到 sessionid， 数据存储根据服务器的容量而定 session 会在一定时间内保存在服务器上，当访问增多，会较占用服务器的性能，考虑到减轻服务器性能，应使用 cookie 可以考虑将登陆信息等重要信息存放在 session，其他信息如果需要保留，可以放在 cookie 中 三次握手和四次挥手 三次握手主要有两个目的：信息对等和防止超时。 信息对等 两台机器通信时都需要确认四个信息： 自己发报文的能力 自己收报文的能力 对方发报文的能力 对方收报文的通知 握手 第一次握手：第一次握手 A 机器向 B 机器发送 SYN 数据包，此时只有 B 机器能确认自己收报文的能力和对方发报文的能力。 第二次握手：每二次握手后 B 响应 A 机器的 SYN 数据包，此时 A 机器就能确认：自己发报文的能力、自己收报文的能力、对方发报文的能力、对方收报文的能力 第三次握手：每三次握手后 A 应答 B 机器的 SYN + ACK 数据包，此时 B 机器就能确认：自己发报文的能力、对方收报文的能力 防止超时 三次握手除了保证信息对等也是了防止请求超时导致脏连接。TTL网络报文的生存往往会超过TCP请求超时时间，如果两次握手就能创建连接，传输数据并释放连接后，第一个超时的连接请求才到达B机器，B机器 会以为是 A 创建新连接的请求，然后确认同意创建连接。因为A机器的状态不是SYN_SENT，所以会直接丢弃了B的确认数据，导致 B 机器单方面的创建连接完毕。 四次挥手 一次 客户端发送关闭数据包 服务端收到关闭连接请求后，通知应用程序处理完剩下的数据 二次 服务端响应客户端的关闭连接请求，说需要处理完剩下的数据，然后再发消息给你 客户端收到应答后继续等待 三次 服务端处理完剩下的数据后，主动向客户端发送数据包 客户端收到应答后，发送数据包 四次 服务端收到数据包后关闭连接 客户端 TIME_WAIT 状态等待 2MSL 后，关闭连接 什么是2MSL：MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”， 2MSL即两倍的MSL 为什么要有TIME_WAIT 确认被动关闭（机器B）能够顺利进入CLOSED状态 假如A机器发送最后一个ACK后，但由于网络原因ACK包未能到达 B 机器，此时 B机器通常会认为 A机器 没有收到 FIN+ACK报文，会重发一次FIN+ACK报文。如果 A机器 发送最后一个ACK后，自私的关闭连接进入 CLOSED状态，就可能导致 B 无法收到ACK报文，无法正常关闭。 HTTPS和HTTP的区别 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 使用Socket套接字需要传入哪些参数 Address Family 和 Type，分别表示套接字应用场景和类型。 family 的值可以是 AF_UNIX(Unix 域，用于同一台机器上的进程间通讯)，也可以是 AF_INET（对于 IPV4 协议的 TCP 和 UDP） type 参数， 流套接字(SOCK_STREAM) 数据报文套接字(SOCK_DGRAM) 原始套接字(SOCK_RAW) HTTP常见请求头 请求头 说明 Accept 浏览器可接受的MIME类型 Accept-Charset 浏览器可接受的字符集 Accept-Encoding 浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间 Accept-Language 浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到 Authorization 授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中 Connection 表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小 Content-Length 表示请求消息正文的长度 Cookie 这是最重要的请求头信息之一 From 请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它 Host 初始URL中的主机和端口 If-Modified-Since 只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答 Pragma 指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝 Referer 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面 User-Agent 浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用 UA-Pixels，UA-Color，UA-OS，UA-CPU 由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型 OSI七层模型和TCP/IP四层模型以及五层模型 OSI 7、应用层（Application）：为用户的应用程序提供网络服务 6、表示层（Presentation）：将信息表示为一定形式和格式的数据流 5、会话层（Session）：负责通信主机之间会话的建立、管理和拆除，协调通信双方的会话 4、传输层（Transport）：负责通信主机间端到端的连接 3、网络层（Network）：负责将分组从源机送到目的机，包括寻址和最优路径选择等 2、数据链路层（Data Link）：提供可靠的帧传递，实现差错控制、流控等等 1、物理层（Physical）：提供透明的比特流（01流）传递 TCP/IP 4、应用层（Application）：为用户提供所需要的各种服务 3、传输层（Transport）：为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性 2、网际层（Internet）：主要解决主机到主机的通信问题 1、网络接口层（Network Access）：负责监视数据在主机和网络之间的交换 url的形式 URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。 也可认为由4部分组成：协议、主机、端口、路径 什么是WSGI和uwsgi以及uWSGI? WSGI：web 服务网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给 web 框架。 实现 wsgi 协议的模块： wsgiref：本质上就是编写一 socket 服务端，用于接收用户请求（django) werkzeug：本质上就是编写一个 socket 服务端，用于接收用户请求(flask) uwsgi：是实现了 wsgi 协议的一个模块，模块本质：一个 socket 服务器 uWSGI：是一个 web 服务器，它实现了WSGI协议、uwsgi、http等协议。 三种区别 WSGI 是一种通信协议。 uwsgi 是一种线路协议而不是通信协议，在此常用于在 uWSGI 服务器与其他网络服务器的数据通信。 uWSGI 是实现了 uwsgi 和 WSGI 两种协议的 Web 服务器。 Nginx nginx 是一个开源的高性能的HTTP服务器和反向代理： 1.作为web服务器，它处理静态文件和索引文件效果非常高 2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间 3.稳定性高，配置简洁。 4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用 同源策略 协议相同 域名相同 端口相同 只要有一项不同就会出现跨域 Django请求生命周期 1.wsgi ,请求封装后交给web框架（Flask，Django) 2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session 3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数 4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates 5.中间件，对响应的数据进行处理 6.wsgi，将响应的内容发送给浏览器 scrapy和scrapy-redis有什么区别？为什么选择redis数据库？ 1) scrapy 是一个 Python 爬虫框架，爬取效率极高，具有高度定制性，但是不支持分布式。 而 scrapy-redis 一套基于 redis 数据库、运行在 scrapy 框架之上的组件，可以让 scrapy 支持分布式策略， Slave 端共享 Master 端 redis 数据库里的 item 队列、请求队列和请求指纹集合。 2)为什么选择 redis 数据库，因为 redis 支持主从同步，而且数据都是缓存在内存中的，所以基于 redis 的分布式爬虫，对请求和数据的高频读取效率非常高。 分布式爬虫主要解决什么问题？ 1、ip 2、带宽 3、cpu 4、io scrapy的去重与过滤器的使用 InnoDB和MyISAM以及MEMORY的区别 InnoDB：支持事务（提交、回滚）、支持外键、支持奔溃修复和并发控制，适合频繁更新和删除 清空整个表时：一行一行删除，效率慢 MyISAM：插入数据快，空间内存使用比较低，适合只插入和读取的相关业务 清空整个表时：重建表 MEMORY：所有数据都存在内存中，数据的处理速度快，但安全性不高，只适合相对较小的数据库表 drop,delete与truncate的区别 drop 直接删掉表；truncate 删除表中数据，再插入时自增长 id 又从 1 开始；delete 删除表中数据，可以加where字句 1.delete 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。 truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。 并且在删除的过程中不会激活与表有关的删除触发器，执行速度快。 2.表和索引所占空间。当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。 drop语句将表所占用的空间全释放掉。 3.一般而言，drop>truncate>delete 4.应用范围。truncate只能对table，delete可以是table和view 5.truncate和delete只删除数据，而drop则删除整个表（结构和数据) 6.truncate与不带where的delete：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束(constrain), 触发器（trigger)索引(index);依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid. 索引的工作原理及其种类 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常使用B树以其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动） 悲观锁和乐观锁 悲观锁：就是很悲观，每次去拿数据的时候认为别人会修改，所以每次拿数据的时候都会上锁，这样只要别人想要这个数据就会block直到它拿到锁， 传统的关系型数据库就有很多这样机制的锁：行锁、表锁、读锁、写锁等，都是在操作之前上锁 乐观锁：就是很乐观，每次去拿数据的时候认为别人不会修改，所以每次拿数据的时候都不会上锁，但是在更新的时候会去判断一下在此期间有没有别人更新这个数据， 可以使用版本号等机制，乐观锁适用于多读的应用类型，可以提高吞吐量 存储函数与存储过程的区别 语法 存储函数不能有输出参数，因为存储函数本身就是输出参数，而存储过程可以有输出参数 可以直接对存储函数进行调用，不需要使用 call 存储函数必须包含一条 return 语句，而这条语句不允许包含于存储过程中 Redis宕机怎么解决? 宕机:服务器停止服务 如果只有一台 redis，肯定会造成数据丢失，无法挽救 多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看： slave从redis宕机，配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志1，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据; 如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：在slave数据上执行SLAVEOF ON ONE,来断开主从关系并把slave升级为主库，此时重新启动主数据 库，执行SLAVEOF，把它设置为从库，连接到主的redis上面做主从复制，自动备份数据。 以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法:redis的哨兵(sentinel)的功能 值传递和引用传递 def fn(k, v, d={}): d[k] = v print(d) fn('1', 1) fn('2', 2) fn('3', 3, {}) # 结果 {'1': 1} # 直接将键值对传递给字典 {'1': 1, '2': 2} # 因为字典在内存中是可变对象类型，指向了同一个地址，传递了新的键值对后相当于给字典添加的新键值对 {'3': 3} # 给了一个新的字典，所以不是原来默认参数的字典 copy和deepcopy 复制不可变类型 数值、字符串、元组 不管是 copy 还是 deepcopy，都是同一个地址，和 “=” 赋值一样，id() 后的值都相同 复制可变类型 列表、字典 第一种：复制的对象中无复杂对象，原来的值改变不会影响浅复制的值，同时浅复制的值改变不会影响原来的值，两者 id 值不同 第二种：复制的对象中有复杂对象（例如：一个列表中的一个元素是列表） copy：改变原来的值中的复杂对象的值，会影响浅复制的值 deepcopy：完全独立复制，包括内层列表或字典 排序 正数从小到大，负数从大到小a = [-8, 5, 7, -5, -1, 6, -2, 3, 4, -3, 9] sorted(a, key=lambda x: (x 数字相同，按字符串排序a = [['op', 55], ['ef', 30],['ab', 10], ['gh', 55], ['cd', 20], ['xy', 55]] sorted(a, key=lambda x: x[1] and x[0]) # 或 sorted(a, key=lambda x: (x[1], x[0])) int(\"1.4\") 和 int(1.4) 结果 int(\"1.4\")：报错 int(1.4)：1 "},"FinancialManagement/股票/01-股票市场常用名称解释.html":{"url":"FinancialManagement/股票/01-股票市场常用名称解释.html","title":"股票市场常用名词","keywords":"","body":"股票市场常用名词解释 一、基础知识部分 　　- 1、资本市场：资本市场是指证券融资和经营一年以上中长期资金借贷的金融市场。货币市场是经营一年以内短期资金融通的金融市场，资金需求者通过资本市场筹集长期资金，通过货币市场筹集短期资金。 　　- 2、股票：股票是股份有限公司在筹集资本时向出资人发行的股份凭证，代表着其持有者对股份公司的所有权。具有以下基本特征：不可偿还性，参与性，收益性（股票通常被高通货膨胀期间可优先选择的投资对象），流通性，价格波动性和风险性。 　　- 3、债券：债券是政府、金融机构、工商企业等机构直接向社会借债筹措资金时，向投资者发行，并且承诺按一定利率支付利息并按约定条件偿还本金的债权债务凭证。具有如下特征：偿还性，流通性，安全性，收益性。 　　- 4、可转换证券：是一种其持有人有权将其转换成为另一种不同性质的证券，主要包括可转换公司债券和可转换优先股。 　　- 5、权证：是指标的证券发行人或其以外的第三人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买或出售标的证券，或以现金结算方式收取结算差价的有价证券。 　　- 6、认购权证：发行人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人购买标的证券的有价证券。 　　- 7、认沽权证：发行人发行的，约定持有人在规定期间内或特定到期日，有权按约定价格向发行人出售标的证券的有价证券。 　　- 8、证券投资基金：基金是指一种利益共享、风险共担的集合证券投资方式，即通过发行基金单位，集中投资者的资金，由基金托管人托管，由基金管理人管理和运用资金，从事股票、债券等金融工具投资。 　　- 9、开放式基金：是指基金发行总额不固定，基金单位总数随时增减，投资者可以按基金的报价在国家规定的营业场所申购或者赎回基金单位的一种基金。 　　- 10、封闭式基金：是指事先确定发行总额，在封闭期内基金单位总数不变，基金上市后投资者可以通过证券市场转让、买卖基金单位的一种基金。 　　- 11、一级市场：指股票的初级市场也即发行市场，在这个市场上投资者可以认购公司发行的股票。 　　- 12、IPO：全称Initial public offering( 首次公开募股）指某公司（股份有限公司或有限责任公司）首次向社会公众公开招股的发行方式。 　　- 13、发行价：当股票上市发行时，上市公司从公司自身利益及确保股票上市成功等角度出发，对上市的股票不按面值发行，而制订一个较为合理的价格来发行，这个价格就称为股票的发行价。 　　- 14、溢价发行：指新上市公司以高于面值的价格办理公开发行或已上市公司以高于面值的价格办理现金增资。 　　- 15、折价发行：指以低于面前的价格发行。 　　- 16、二级市场：指流通市场，是已发行股票进行买卖交易的场所。 　　- 17、A股：A股的正式名称是人民币普通股票。 　　- 18、B股：B股的正式名称是人民币特种股票。 　　- 19、H股：H股即注册地在内地、上市地在香港的外资股。 　　- 20、S股：沪深证券交易所2006年10月9日起一次性调整有关A股股票的证券简称。其中，1014家G公司取消“G”标记，恢复股改方案实施前的股票简称；其余276家未进行股改或已进行股改但尚未实施的公司，其简称前被冠以“S”标记，以提示投资者。 　　- 21、ST股票：ST板块股就是指在沪深股市上挂牌的股票，因经营亏损或其他异常情况中国证监会为了提醒股民注意特别处理的股票。 　　- 22、ST股票：ST板块股就是指在沪深股市上挂牌的股票，对有终止上市风险的个股中国证监会为了提醒股民注意特殊处理的股票。 　　- 23、蓝筹股：蓝筹股是指资本雄厚,股本和市值较大的信誉优良的上市公司发行的股票。 　　- 24、红筹股：红筹股是香港和国际投资者把在境外注册、在香港上市的那些带有中国大陆概念的股票。 　　- 25、绩优股：是指过去几年业绩和盈余较佳,展望未来几年仍可看好，只是不会再有高度成长的可能的股票。该行业远景尚佳，投资报酬率也能维持一定的高水平。 　　- 26、垃圾股：垃圾股指的是业绩较差的公司的股票。这类上中公司或者由于行业前景不好，或者由于经营不善等，有的甚至进入亏损行列。其股票在市场上的表现萎靡不振，股价走低，交投不活跃，年终分红也差。 　　- 27、成长股：指新添的有前途的产业中，利润增长率较高的企业股票。成长股的股价呈不断上涨趋势。 　　- 28、冷门股：是指交易量小，流通性差，价格变动小的股票。 　　- 29、龙头股：龙头股指的是某一时期在股票市场的炒作中对同行业板块的其他股票具有影响和号召力的股票，它的涨跌往往对其他同行业板块股票的涨跌起引导和示范作用。龙头股并不是一成不变的，它的地位往往只能维持一段时间。 　　- 30、国家股：国家股是指有权代表国家投资的部门或机构（国资委）以国有资产向公司投资形成的股份，包括公司现有国有资产折算成的股份。它是国有股权的一个组成部分。 　　- 31、法人股：法人股是指企业法人或具有法人资格的事业单位和社会团体，以其依法可支配的资产投入公司形成的非上市流通的股份。 　　- 32、公众股：公众股是指社会公众依法以其拥有的财产投入公司时形成的可上市流通的股份。 　　- 33、基本面： 基本面包括宏观经济运行态势和上市公司基本情况。宏观经济运行态势反映出上市公司整体经营业绩，也为上市公司进一步的发展确定了背景，因此宏观经济与上市公司及相应的股票价格有密切的关系。上市公司的基本面包括财务状况、盈利状况、市场占有率、经营管理体制、人才构成等各个方面。 　　- 34、技术面：技术面指反映介变化的技术指标、走势形态以及K线组合等。技术分析有三个前提假设，即市场行为包容一切信息；价格变化有一定的趋势或规律；历史会重演。由于认为市场行为包括了所有信息，那么对于宏观面、政策面等因素都可以忽略，而认为价格变化具有规律和历史会重演，就使得以历史交易数据判断未来趋势变得简单了。 　　- 35、牛市：牛市也称多头市场，指市场行情普通看涨，延续时间较长的大升市。 　　- 36、熊市：熊市也称空头市场，指行情普通看淡，延续时间相对较长的大跌市。 　　- 37、牛皮市：指在所考察交易日里，证券价格上升、下降的幅度很小，价格变化不大，市价像被钉住了似的，如牛皮之坚韧。 　　- 38、集合竞价：所谓集合竞价就是在当天还没有成交价的时候，根据前一天的收盘价和对当日股市的预测来输入股票价格，而在这段时间里输入计算机主机的所有价格都是平等的，不需要按照时间优先和价格优先的原则交易，而是按最大成交量的原则来定出股票的价位，这个价位就被称为集合竞价的价位，而这个过程被称为集合竞价。 　　- 39、连续竞价：所谓连续竞价，即是指对申报的每一笔买卖委托。 　　- 40、零股交易：不到一个成交单位(1手=100股)的股票，如1股、10股，称为零股．在卖出股票时，可以用零股进行委托；但买进股票时不能以零股进行委托，最小单位是1手，即100股。 　　- 41、涨跌幅限制：涨跌幅限制是指在一个交易日内，除上市首日证券外，证券的交易价格相对上一交易日收市价格的涨跌幅度不得超过10%；超过涨跌限价的委托为无效委托。 　　- 42、涨停板：证券市场中交易当天股价的最高限度称为涨停板，涨停板时的股价叫涨停板价。 　　- 43、跌停板：证券交易当天股价的最低限度称为跌停板，跌停板时的股价称跌停板价。 　　- 44、托管：托管是在托管券商制度下，投资者在一个或几个券商处以认购、买入、转换等方式委托这些券商管理自己的股份，并且只可以在这些券商处卖出自己的证券；券商为投资者提供证券买、分红派息自动到帐、证券与资金的查询、转托管等各项业务服务。 　　- 45、转托管：转托管是在托管券商制度下，投资者要将其托管股份从一个券商处转移到另一个券商处托管，就必须办理一定的手续，实现股份委托管理的转移，即所谓的转托管。 　　- 46、指定交易：指定交易指投资者可以指定某一证券营业部为自己买卖证券的唯一的交易营业部。 　　- 47、派息：股票前一日收盘价减去上市公司发放的股息称为派息。 　　- 48、含权：凡是有股票有权未送配的均称含权。 　　- 49、除权：除权是由于公司股本增加，每股股票所代表的企业实际价值（每股净资产）有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。 　　- 50、填权：指除权后该股票价格出现上涨，将除权前后的价格落差部分完全补回的情形。 　　- 51、贴权：贴权是指在除权除息后的一段时间里，如果多数人不看好该股，交易市价低于除权（除息）基准价，即股价比除权除息前有所下降，则为贴权。 　　- 52、XR：证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利。当股票名称前出现XR 的字样时，表明当日是这只股票的除权日。 　　- 53、除息：除息由于公司股东分配红利，每股股票所代表的企业实际价值（每股净资产）有所减少，需要在发生该事实之后从股票市场价格中剔除这部分因素，而形成的剔除行为。 　　- 54、DR：证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利。 　　- 55、XD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 　　- 56、配股：配股是上市公司根据公司发展的需要，依据有关规定和相应程序，旨在向原股东进一步发行新股、筹集资金的行为。 　　- 57、分红配股：分红即是上市公司对股东的投资回报；配股是上市公司按照公司发展的需要，根据有关规定和相应程序，向原股东增发新股，进一步筹集资金的行为。 　　- 58、送红股：送红股是上市公司将本年的利润留在公司里，发放股票作为红利，从而将利润转化为股本。 　　- 59、转增股本：转增股本是指公司将资本公积转化为股本，转增股本并没有改变股东的权股益，但却增加了股本规模，因而客观结果与送红股相似。 　　- 60、股权登记日：上市公司在送股、配股和派息的时候，需要定出某一天，界定哪些股东可以参加分红或参与配股，定出的这一天就是股权登记日。 　　- 61、买壳上市：买壳上市是指一些非上市公司通过收购一些业绩较差、筹资能力弱化的上市公司，剥离被购公司资产，注入自己的资产，从而实现间接上市的目的。 　　- 62、大小非减持：非是指非流通股，由于股改使非流通股可以流通持股低于5%的非流通股叫小非,大于5%的叫大非。非流通股可以流通后,他们就会抛出来套现，就叫减持。 　　- 63、估值：股票估值是使用一定的方法发现股票内在价值，并买入价值被低估的股票或卖出价值被高估的股票来获得投资收益的股票投资方法和理念。 　　- 64、价值回归：当股指或股票价格和其内在价值严重背离后，股指或股票价格降低至其内在价值的过程。 　　- 65、QFII：合格境外机构投资者。 　　- 66、DQII：合格境内机构投资者。 二、技术分析部分 　　- 67、K线：又称为日本线，起源于日本。K线是一条柱状的线条，由影线和实体组成。影线在实体上方的部分叫上影线，下方的部分叫下影线。实体分阳线和阴线两种，又称红（阳）线和黑（阴）线。一条K线的记录就是某一种股票一天的价格变动情况。 　　- 68、实体：当日收盘价与开盘价之差。收盘价大于开盘价叫做阳实体，收盘价小于开盘价叫做阴实体。一般情况下，出现阳实体说明买盘比较旺盛，推动股价向上攀升，出现阴实体说明卖盘踊跃，迫使股价节节走低。 　　- 69、阳线(红线)：在K线图中中间的矩形长条叫实体，如果收盘价高于开盘价，则实体为阳线或红线。 　　- 70、阴线(绿线)：在K线图中中间的矩形长条叫实体，如果开盘价高于收盘价，则实体为阴线线或绿线。 　　- 71、上影线：在K线图中，从实体向上延伸的细线叫上影线。在阳线中，它是当日最高价与收盘价之差；在阴线中，它是当日最高价与开盘价之差。 　　- 72、下影线：在K线图中，从实体向下延伸的细线叫下影线。在阳线中，它是当日开盘价与最低价之差；在阴线中，它是当日收盘价与最低价之差。 　　- 73、趋势：就是股票价格市场运动的方向；趋势的方向有三个：上升方向；下降方向和水平方向。趋势的类型有主要趋势、次要趋势和短暂趋势三种。 　　- 74、趋势线：趋势线是用来衡量价格波动的方向的直线，由趋势线的方向可以明确地看出股价的趋势。在上升趋势中，将两个低点连成一条直线，就得到上升趋势线。在下降趋势中，将两个高点连成一条直线，就得到下降趋势线。上升趋势线起支撑作用，下降趋势线起压力作用，也就是说，上升趋势线是支撑线的一种，下降趋势线是压力线的一种。 　　- 75、支撑线：又称为抵抗线。当股价跌到某个价位附近时，股价停止下跌甚至有可能回升，这是因为多方在此买入造成的。支撑线起阻止股价继续下跌的作用。这个起着阻止股价继续下跌的价位就是支撑线所在的位置。 　　- 76、压力线：又称为阻力线。当股价上涨到某个价位附近时，股价会停止上涨，甚至回落，这是因为空方在此抛出造成的。压力线起阻止股价继续上市的作用。这个起着阻止股价继续上升的价位就是压力线所在的位置。 　　- 77、轨道线：又称通道线或管道线，是基于趋势线的一种方法。在已经得到了趋势线后，通过第一个峰和谷可以做出这条趋势线的平行线，这条平行线就是轨道线。轨道的作用是限制股价的变动范围，让它不能变得太离谱。一个轨道一旦得到确认，那么价格将在这个通道里变动。对上面的或下面的直线的突破将意味着有一个大的变化。 　　- 78、骗线：主力或大户利用市场心理，在趋势线上做手脚，使散户做出错误的决定。 三、交易术语部分 　　- 79、筹码：投资人手中持有一定数量的股票。 　　- 80、多头：预期未来价格上涨，以目前价格买入一定数量的股票等价格上涨后，高价卖出，从而赚取差价利润的交易行为，特点为先买后卖的交易行为。 　　- 81、空头：预期未来行情下跌，将手中股票按目前价格卖出，待行情跌后买进，获利差价利润。其特点为先卖后买的交易行为。 　　- 82、利多：对于多头有利，能刺激股价上涨的各种因素和消息，如：银根放松，GDP增长加速等。 　　- 83、利空：对空头有利，能促使股价下跌的因素和信息，如：利率上升，经济衰退，公司经营亏损等。 　　- 84、多头陷阱（诱多）：即为多头设置的陷阱，通常发生在指数或股价屡创新高，并迅速突破原来的指数区且达到新高点，随后迅速滑跌破以前的支撑位，结果使在高位买进的投资者严重被套。 　　- 85、空头陷阱（诱空）：通常出现在指数或股价从高位区以高成交量跌至一个新的低点区，并造成向下突破的假象，使恐慌性抛盘涌出后迅速回升至原先的密集成交区，并向上突破原压力线，使在低点卖出者踏空。 　　- 86、跳空缺口与回补：是指相邻的两根 K线间没有发生任何交易,由于突发消息的影响,或者投资者比较看好或看空时,股价在走势图上出现空白区域,这就是跳空缺口；在股价之后的走势中，将跳空的缺口补回，称之为补空。 　　- 87、反弹：在股市上，股价呈不断下跌趋势，终因股价下跌速度过快而反转回升到某一价位的调整现象称为反弹。 　　- 88、反转：股价朝原来趋势的相反方向移动分为向上反转和向下反转。 　　- 89、回档：在股市上，股价呈不断上涨趋势，终因股价上涨速度过快而反转回跌到某一价位，这一调整现象称为回档。 　　- 90、回探：股指或股票价格在缓慢上升后，趋势发生改变，缓慢下跌到前期低点区域时，即为回探。 　　- 91、盘整：股价经过一段快捷上升或下降后，遭遇阻力或支撑而呈小幅涨跌变动，做换手整理。股价在有限幅度内波动，一般是指上下5%的幅度内的波动。 　　- 92、超买：股价持续上升到一定高度，买方力量基本用尽，股价即将下跌。 　　- 93、超卖：股价持续下跌到一定低点，卖方力量基本用尽，股价即将回升。 　　- 94、吃货：指庄家在低价时暗中买进股票，叫做吃货。 　　- 95、出货：指庄家在高价时，不动声色地卖出股票，称为出货。 　　- 96、多翻空：原本看好行情的买方，看法改变，变为卖方。 　　- 97、空翻多：原本打算卖出股票的一方，看法改变，变为买方。 　　- 98、多杀多：普遍认为当天股价将上涨，于是抢多头帽子的人持多，然而股价却没有大幅上涨，无法高价卖出，等到交易快要结束时，竟相卖出，因而造成收盘时股价大幅下挫的情形。 　　- 99、满仓：手上全是股票，钱都买了股票。 　　- 100、半仓：一半股票，一半资金。 　　- 101、空仓：手上没有股票，全都卖空了。 　　- 102、斩仓：一般来说是忍痛把赔了钱的股票卖掉。 　　- 103、建仓：投资者开始买入看涨的股票。 　　- 104、补仓：把以前卖掉的股票再买回来，或许是在某只股票上再追买一些。 　　- 105、增仓：你的第一笔买入某股票称建仓；在以后的过程中继续买入称增仓。 　　- 106、突破：指股价经过一段盘档时间后，产生的一种价格波动。 　　- 107、探底：股价持续跌挫至某价位时便止跌回升，如此一次或数次。 　　- 108、割肉：指高价买进股票后，大势下跌，为避免继续损失，低价赔本卖出股票。 　　- 109、追高：当股价处于绝对高位时，不断的买入股票。 　　- 110、逼空：是指多头连续大幅上涨，逼迫空头止损投降。 　　- 111、抛售：立刻卖出手中所有的股票。 　　- 112、离场：当下跌趋势形成时，预计未来一段时间不参与操作股票，简称离场。 　　- 113、死多：是看好股市前景，买进股票后，如果股价下跌，宁愿放上几年，不赚钱绝不脱手。 　　- 114、护盘：庄家为了保持股价稳定，而投入资金购买市场上抛售的股票，以保持股价相对稳定。 　　- 115、崩盘：崩盘即证券市场上由于某种利空原因，出现了证券大量抛出，导致证券市场价格无限度下跌，不知到什么程度才可以停止。这种接连不断地大量抛出证券的现象也称为卖盘大量涌现。 　　- 116、跳水：跳水即指短时间内快速下跌；大盘或某股票不顾一切大幅度迅猛地下跌，即走势像高台挑水一样在短时间内直线向下。 　　- 117、抬拉：抬拉是用非常方法，将股价大幅度抬起。通常大户在抬拉之后便大抛出以牟取暴利。 　　- 118、打压：打是用非常方法，将股价大幅度压低。通常大户在打压之后便大量买进以取暴利。 　　- 118、洗盘：指庄家大户为降低拉升成本和阻力，先把股价大幅度杀低，回收散户恐慌抛售的股票，然后抬高股价乘机获取价差利益的行为。 　　- 119、整理：股市上的股价经过大幅度迅速上涨或下跌后，遇到阻力线或支撑线，原先上涨或下跌趋势明显放慢，开始出现幅度为15％左右的上下跳动，并持续一段时间，这种现象称为整理。 　　- 120、获利盘和套牢盘：获利盘一般是指股票交易中，能够卖出赚钱的那部分股票。每一只股票都有获利盘和套牢盘，套牢盘就是买入的股票亏本。他们相互作用。 　　- 121、放量缩量：它们是指股票的交易量，与前一天或者前一段时间相比，放大了或是缩小了，称为放量，缩量。 　　- 122、止损：是指当某一投资出现的亏损达到预定数额时，及时斩仓出局，以避免形成 更大的亏损。其目的就在于投资失误时把损失限定在较小的范围内。 　　- 123、利空出尽：在证券市场上，证券价格因各种不利消息的影响而下跌，这种趋势持续一段时间，跌到一定的程度，空方的力量开始减弱，投资者须不再被这些利空的因素所影响，证券价格开始反弹上升，这种现象就被称作利空出尽。 　　- 124、强势调整：就是主力在洗盘，通过洗盘，将意志不坚定的获利盘和解套盘清洗出去，同时又抬高了行情的市场成本，从而为主力扫清障碍和减轻上行压力。 　　- 125、惯性：处于涨势或者跌势的时候，其趋势一般将延续。 　　- 126、冲高回落：指股指或股价在一段时间内涨到一定位置后，趋势发生改变，形成下跌。 　　- 127、大幅振荡：指在较短时间内股指或股票价格在最高点与最低点不断变化，幅度大于5%。 　　- 128、震荡调整：买方与卖方的力量相当，在某一价格上上下波动，把价格尽力调整到它的价值，围绕着价值而上下波动、震荡。 　　- 129、背离 ：背离是指当股票或指数在下跌或上涨过程中，不断创新低（高），而一些技术指标不跟随创新低（高），称为背离。 　　- 130、钝化：当股票走势形成单边上涨（或下跌）时，技术指标产生死叉（或金叉）后，股价并不向相反方向运行，只是在高位（或低位）横盘，指标线有时会拧在一起，像绳子一样。这种情况被称为“钝化”。 　　- 131、震仓：震仓就是指主力明明想把股价做上去，但是由于有短线买家利用图表分析跟风持货，或收到该股票的小道消息入货，而主力又不想让这些人白坐轿子白赚钱，于是明明想往上拉抬的，偏偏有意把股价打下去。多数短线炒家都是买涨不买跌，或追涨杀跌的，当股价出乎意料地向下跌，就会令很多数短线跟风者斩仓离场，被主力震出来。也有人称此为洗盘。 　　- 132、套牢：预期股价上涨而买入股票，结果股价却下跌，又不甘心将股票卖出，被动等等获利时机的出现。 　　- 133、阴跌：指股价进一步退两步，缓慢下滑的情况，如阴雨连绵，长期不止。 　　- 134、做多动能：支持股价上涨的所有条件。 　　- 135、空仓观望：判断未来不易操作股票，即空仓观望。 四、行情术语部分 　　- 136、日开盘价：日开盘价是指每个交易日的第一笔成交价格，这是传统的开盘价定义。目前中国市场采用集合竞价的方式产生开盘价。 　　- 137、日收盘价：日收盘价是指每个交易日的最后一笔成交价格。因为收盘价是当日行情的标准，又是下一个交易日开盘价的依据，可据以预测未来证券市场行情，所以投资者对行情分析时一般采用收盘价作为计算依据。 　　- 138、日最低价：指当天该股票成交价格中的最低价格。 　　- 139、日最高价：指当天该股票成交价格中的最高价格。 　　- 140、日成交额：指当天已成交股票的金额总数。 　　- 141、日成交量：指当天成交的股票数量。 　　- 142、总手：总手是到目前为止该股的总成交量（手数）。 　　- 143、现手：现手是刚成交的一笔交易的手数。 　　- 144、盘口：股票交易中,具体到个股买进\\卖出5个挡位的交易信息。“盘口”是在股市交易过程中，看盘观察交易动向的俗称。 　　- 145、内盘：委托以买方成交的纳入“内盘”，成交价是买入价时成交的手数总和称为内盘。 当外盘累计数量比内盘累计数量大很多，而股价也在上涨时，表明很多人在抢盘买入股票。 　　- 146、外盘：委托以卖方成交的纳入“外盘”，成交价是卖出价时成交的手数总和称为外盘。 　　- 147、量比：当日总成交手数与近期平均成交手数的比值。如果量比数值大于1，表示这个时刻的成交总手量已经放大；若量比数值小于1，表示这个时刻成交总手萎缩。 　　- 148、委比：通过对委买手数和委卖手数之差与委买手数和委卖手。 　　- 149、换手率：换手率是指在一定时间内市场中股票转手买卖的频率，是反映股票流通性的指标之一。计算公式为:换手率=(某一段时间内的成交量/流通股数)×100%。 五、财务名词部分 　　- 150、市盈率（PE）：市盈率又称股份收益比率或本益比，是股票市价与其每股收益的比值，计算公式是：市盈率=当前每股市场价格/每股税后利润。 　　- 151、市净率（PB）：是股票市价与每股净资产的比值，市净率=股票市价/每股净资产。 　　- 152、每股税后利润：每股税后利润又称每股盈利，可用公司税后利润除以公司总股数来计算。 　　- 153、市值：即为股票的市场价值，亦可以说是股票的市场价格，它包括股票的发行价格和交易买卖价格。股票的市场价格是由市场决定的。股票的面值和市值往往事不一致的。 六、宏观经济名词部分 　　- 154、货币政策：指中央银行为实现既定的经济目标（稳定物价，促进经济增长，实现充分就业和平衡国际收支）运用各种工具调节货币供给和利率，进而影响宏观经济的方针和措施的总合。 　　- 155、财政政策：是指国家根据一定时期政治、经济、社会发展的任务而规定的财政工作的指导原则，通过财政支出与税收政策来调节总需求。增加政府支出，可以刺激总需求，从而增加国民收入，反之则压抑总需求，减少国民收入。税收对国民收入是一种收缩性力量，因此，增加政府税收，可以抑制总需求从而减少国民收入，反之，则刺激总需求增加国民收入。 　　- 156、通货紧缩：当市场上流通的货币减少，人民的货币所得减少，购买力下降，影响物价之下跌，造成通货紧缩。长期的货币紧缩会抑制投资与生产，导致失业率升高及经济衰退。 　　- 157、通货膨胀：通货膨胀是指流通中货币量超过实际需要量所引起的货币贬值、物价上涨的经济现象。 　　- 158、消费者物价指数(CPI)：是反映与居民生活有关的商品及劳务价格统计出来的物价变动指标，通常作为观察通货膨胀水平的重要指标。 　　- 159、生产者物价指数（PPI）：生产者物价指数主要的目的在衡量各种商品在不同的生产阶段的价格变化情形。PPI是衡量工业企业产品出厂价格变动趋势和变动程度的指数，是反映某一时期生产领域价格变动情况的重要经济指标，也是制定有关经济政策和国民经济核算的重要依据。 　　- 160、再贴现率：商业银行在票据未到期以前将票据卖给中央银行，得到中央银行的贷款，称为再贴现。中央银行在对商业银行办理贴现贷款中所收取的利息率，称为再贴现率。 　　- 161、公开市场业务：是指中央银行通过买进或卖出有价证券，吞吐基础货币，调节货币供应量的活动。 　　- 162、法定存款准备金率：是法律规定的商业银行准备金与商业银行吸收存款的比率。商业银行吸收的存款不能全部放贷出去，必须按照法定比率留存一部分作为随时应付存款人提款的准备金。 七、基金名词部分 　　- 163、指数基金：是一种以拟和目标指数、跟踪目标指数变化为原则，实现与市场同步成长的基金品种。 　　- 164、保本基金：是指在其招募说明书中明确规定相关的担保条款，即在满足一定持有期限后，为投资人提供本金或收益保障的一类基金。 　　- 165、货币市场基金：指投资于货币市场（一年以内，平均期限120天）的投资基金。 　　- 166、交易所交易基金（ETFs）：指可以在交易所上市交易的基金，其代表的是一揽子股票的投资组合。 　　- 167、上市型开放式基金（LOF）：即可以在一级市场申购赎回又可以在二级市场买卖的开放式基金。 　　- 168、基金成立日：指基金达到成立条件后，基金管理人宣布基金成立的日期。 　　- 169、基金募集期：指自招募说明书公告之日起到基金成立日的时间段。 　　- 170、存续期：指基金合同生效至终止之间的不定期期限。 　　- 171、认购：指在基金募集期内，投资者按照基金合同的规定申请购买基金份额的行为。 　　- 172、申购：指在基金合同生效后的存续期间，投资者申请购买基金份额的行为。 　　- 173、赎回：指在基金合同生效后的存续期间，基金份额持有人按基金合同规定的条件要求基金管理人购回基金份额的行为。 　　- 174、基金转换：指基金份额持有人按基金管理人规定的条件，申请将其持有的基金管理人管理的某一基金的基金份额转换为基金管理人管理的，且由同一登记结算机构办理登记结算的其他基金的基金份额的行为。 　　- 175、开放日：指为投资者办理基金申购、赎回等业务的工作日。 　　- 176、基金单位净值：基金所拥有的资产每个营业日根据市场收盘价所计算出之总资产价值，扣除基金当日之各类成本及费用后，所得到的就是该基金当日之净资产价值。除以基金当日所发行在外的单位总数，就是每单位净值。 　　- 177、基金累计净值：是指基金最新净值与成立以来的分红业绩之和，体现了基金从成立以来所取得的累计收益(减去一元面值即是实际收益)，可以比较直观和全面地反映基金在运作期间的历史表现，结合基金的运作时间，则可以更准确地体现基金的真实业绩水平。 　　- 178、资本利得：二级市场上买卖证券的价差。 　　- 179、红利再投资：将投资者分得的收益再投资于基金，并折算成相应数量的基金单位，这实际上是将应分配的收益折为等额的新的基金单位送给投资者。 "}}