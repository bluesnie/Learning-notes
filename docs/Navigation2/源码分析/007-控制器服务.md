###### datetime:2024/03/14 16:53

###### author:nzb

# 导航

> https://github.com/ros-planning/navigation2.git
>
> 分支：humble
>
> 节点：3ed4c2d

![](./imgs/architectural_diagram-16525447663514.png)

# 控制器服务

- `nav2_controller` ｜ 控制器服务
- `nav2_dwb_controller` | DWB控制器，Nav2控制器的一个实现
- `nav2_regulated_pure_pursuit_controller` | 纯追踪控制器，Nav2控制器的一个实现
- `nav2_rotation_shim_controller` | 旋转控制器

| 插件 | 描述 | 支持的机器人类型 |
| -----  | ----- | ----- |
| nav2_dwb_controller  | 基于DWA的可高度配置的实现，并提供插件接口 | 差分式、全向式、腿足式 |
| TEB Controller | 一个类似MPC的控制器，适用于阿克曼式、差分式和具备完整约束的机器人。 | **阿克曼式（Ackermann）**、腿足式、全向式、差分式  | 	
| nav2_regulated_pure_pursuit_controller | 针对服务/工业机器人在追踪算法的基础上增加了自适应性。 |  **阿克曼式（Ackermann）**、腿足式、差分式 | 	
| nav2_rotation_shim_controller | 在主控制器进行路径跟踪之前， "shim" 控制器负责将机器人旋转到路径的方向。 |  差速式，全向式、模型旋转到位 | 	

## nav2_controller

### 控制服务

- **ControllerServer**：控制服务器，继承于`nav2_util::LifecycleNode`，该类托管不同算法的各种插件，从公开的 `FollowPath` 操作服务器完成控制任务。
    - 重要属性
      ```text
        // The controller needs a costmap node,                                                           代价地图相关
        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;
        std::unique_ptr<nav2_util::NodeThread> costmap_thread_;
      
        // Publishers and subscribers
        std::unique_ptr<nav_2d_utils::OdomSubscriber> odom_sub_;                                          odom订阅
        rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>::SharedPtr vel_publisher_;        速度发布
        rclcpp::Subscription<nav2_msgs::msg::SpeedLimit>::SharedPtr speed_limit_sub_;                     限速订阅
      
        // Progress Checker Plugin                                                                        进度检查插件
        pluginlib::ClassLoader<nav2_core::ProgressChecker> progress_checker_loader_;                      进度检查插件加载器
        nav2_core::ProgressChecker::Ptr progress_checker_;                                                速度检查
        std::string default_progress_checker_id_;                                                     
        std::string default_progress_checker_type_;
        std::string progress_checker_id_;
        std::string progress_checker_type_;
      
        // Goal Checker Plugin                                                                            目标检查插件
        pluginlib::ClassLoader<nav2_core::GoalChecker> goal_checker_loader_;                              目标检查插件加载器
        GoalCheckerMap goal_checkers_;                                                                    目标检查插件Map
        std::vector<std::string> default_goal_checker_ids_;
        std::vector<std::string> default_goal_checker_types_;
        std::vector<std::string> goal_checker_ids_;
        std::vector<std::string> goal_checker_types_;
        std::string goal_checker_ids_concat_, current_goal_checker_;
      
        // Controller Plugins                                                                             控制器插件
        pluginlib::ClassLoader<nav2_core::Controller> lp_loader_;                                         控制器插件加载器
        ControllerMap controllers_;                                                                       控制器插件Map
        std::vector<std::string> default_ids_;
        std::vector<std::string> default_types_;
        std::vector<std::string> controller_ids_;
        std::vector<std::string> controller_types_;
        std::string controller_ids_concat_, current_controller_;
      ```
    - `ControllerServer`：构造函数
        - 节点名称`controller_server`
        - 初始化加载器和属性
            - `progress_checker_loader_("nav2_core", "nav2_core::ProgressChecker")`
            - `goal_checker_loader_("nav2_core", "nav2_core::GoalChecker")`
            - `lp_loader_("nav2_core", "nav2_core::Controller")`
            - `default_progress_checker_type_` -> `nav2_controller::SimpleProgressChecker`
            - `default_goal_checker_types_` -> `nav2_controller::SimpleGoalChecker`
            - `default_types_` -> `dwb_core::DWBLocalPlanner`
        - 初始化节点参数
            - `controller_frequency` -> `20.0`
            - `progress_checker_plugin` -> `progress_checker`
            - `goal_checker_plugins` -> `goal_checker`
            - `controller_plugins` -> `FollowPath`
            - `min_x_velocity_threshold` -> `0.0001`
            - `min_y_velocity_threshold` -> `0.0001`
            - `min_theta_velocity_threshold` -> `0.0001`
            - `speed_limit_topic` -> `speed_limit`
            - `failure_tolerance` -> `0.0`
        - 创建代价地图节点：`costmap_ros_ = std::make_shared<nav2_costmap_2d::Costmap2DROS>("local_costmap",...)`
    - `on_configure`：配置控制器插件，代价地图，初始化`odom`订阅，速度发布和`follow path`动作服务
        - 调用`get_parameter`获取目标检测、进度检查，控制器插件，并调用`declare_parameter_if_not_declared`设置参数
        - 获取节点相关参数
        - `costmap_ros_->configure()` -> 单独启一个线程跑代价地图节点
          `costmap_thread_ = std::make_unique<nav2_util::NodeThread>(costmap_ros_)`
        - 查询和创建进度检查实例，并调用实例`progress_checker_->initialize`
        - 查询和创建目标检查实例，并调用实例`goal_checker_->initialize`，并保存到相关Map中
        - 查询和创建控制器实例，并调用实例`controller->configure`，并保存到相关Map中
        - 创建`odom`话题订阅`odom_sub_ = std::make_unique<nav_2d_utils::OdomSubscriber>(node)`
        - 创建`cmd_vel`话题订阅`vel_publisher_ = create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 1)`
        - 创建动作服务`action_server_ = std::make_unique<ActionServer>(shared_from_this(),"follow_path",...)`
          ，绑定`computeControl`
        - 创建限速话题订阅`speed_limit_sub_ = create_subscription<nav2_msgs::msg::SpeedLimit>(speed_limit_topic,...)`
          ，绑定`speedLimitCallback`
    - `on_activate`：激活控制器，代价地图，速度发布和动作服务
        - `costmap_ros_->activate()`,`vel_publisher_->on_activate()`,`action_server_->activate()`
        - 遍历控制器插件调用插件的`activate`
        - 绑定参数变更回调，创建连接`createBond()`
    - `on_deactivate`：取消激活动作服务，控制器，代价地图和速度发布，调用之前，速度设置为0
        - `action_server_->deactivate()`
        - 遍历控制器插件调用插件的`deactivate`
        - `costmap_ros_->deactivate()`
        - 调用`publishZeroVelocity()`，使机器人停下来
        - `vel_publisher_->on_deactivate()`
        - `dyn_params_handler_.reset()`
        - `destroyBond()`
    - `on_cleanup`：控制器和代价地图清理，其余变量重置
    - `on_shutdown`：节点关闭
    - `computeControl`：`FollowPath`动作服务回调函数，处理操作和更新直到到达目标位置，接收到全局路径。 使用控制器以指定的速率计算并发布机器人的扭转速度，直到达到目标。
        - 调用`findControllerId`, `findGoalCheckerId`
        - 调用`setPlannerPath(action_server_->get_current_goal()->path);progress_checker_->reset()`
        - 以`controller_frequency_`频率循环控制
            - 动作服务为空或未激活直接返回
            - 收到取消请求，调用`publishZeroVelocity()`，然后直接返回
            - `while`循环等待代价地图直到有效
            - 调用`updateGlobalPath()`
            - 调用`computeAndPublishVelocity()`
            - 如果`isGoalReached()`，控制结束，跳出循环
            - 如果出错，调用`publishZeroVelocity()`，并结束动作，然后直接返回
        - 控制成功，调用`publishZeroVelocity()`，动作成功
    - `findControllerId`：根据请求的名称查询有效的控制器ID名称
    - `findGoalCheckerId`：根据请求的参数查询有效的目标检测ID名称
    - `setPlannerPath`：设置规划路径
        - 调用控制插件：`controllers_[current_controller_]->setPlan(path)`
        - 重置目标检测：`goal_checkers_[current_goal_checker_]->reset()`
    - `computeAndPublishVelocity`：计算速度并发布`cmd_vel`话题
        - 获取校验机器人位姿和目标位姿失败，失败抛错
        - 获取`odom`数据：`twist = getThresholdedTwist(odom_sub_->getTwist())`
        - 调用控制插件计算速度：`cmd_vel_2d = controllers_[current_controller_]->computeVelocityCommands(pose,...)`
        - 反馈信息更新
            - `feedback->speed = std::hypot(cmd_vel_2d.twist.linear.x, cmd_vel_2d.twist.linear.y)`
            - `feedback->distance_to_goal = nav2_util::geometry_utils::calculate_path_length(current_path_, find_closest_pose_idx())`
        - 发布反馈`action_server_->publish_feedback(feedback)`
        - 发布速度`publishVelocity(cmd_vel_2d)`
    - `updateGlobalPath`：收到新的路径调用`setPlannerPath`更新路径
        - 调用`findControllerId()`和`findGoalCheckerId()`，更新当前控制插件和目标检查插件
        - 调用`setPlannerPath(goal->path)`
    - `publishVelocity`：调用速度发布器发布`cmd_vel`话题，话题激活并且有订阅者，调用`vel_publisher_->publish(std::move(cmd_vel)`发布
    - `publishZeroVelocity`：调用速度发布器发布0速度，所有参数设置为0，然后调用`publishVelocity(velocity)`
    - `isGoalReached`：目标是否到达
        - 调用`getRobotPose(pose)`获取机器人位姿
        - 调用`twist = getThresholdedTwist(odom_sub_->getTwist())`获取`odom`信息
        - 调用`nav_2d_utils::transformPose(costmap_ros_->getTfBuffer(), costmap_ros_->getGlobalFrameID(), end_pose_,...)`
        - 检查是否到达调用`goal_checkers_[current_goal_checker_]->isGoalReached(pose.pose, transformed_end_pose.pose, velocity)`
    - `getRobotPose`：获取机器人当前位姿，调用`costmap_ros_->getRobotPose(current_pose)`
    - `getThresholdedVelocity`：获取单个速度阈值`(std::abs(velocity) > threshold) ? velocity : 0.0`
    - `getThresholdedTwist`：获取`Twist`速度阈值，依次调用`getThresholdedVelocity`
    - `dynamicParametersCallback`：参数变更回调
    - `speedLimitCallback`：速度限制回调，遍历控制插件，调用插件实例的`setSpeedLimit()`

### 控制相关插件

#### 进度检查插件

- **SimpleProgressChecker**：用于检查机器人的位置以确保它实际上正在朝着目标前进，继承于`nav2_core::ProgressChecker`
    - `initialize`：重写函数
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".required_movement_radius"` -> `0.5`
            - `plugin_name + ".movement_time_allowance"` -> `10.0`
        - 绑定参数回调`dynamicParametersCallback`
    - `check`：重写函数
        - 如果`!baseline_pose_set_) || (isRobotMovedEnough(current_pose2d)` -> 调用`resetBaselinePose(current_pose2d)`
        - 否则查看是否超时
    - `reset`：重写函数，`baseline_pose_set_ = false;`
    - `isRobotMovedEnough`：根据基线姿势计算机器人运动，调用`pose_distance(pose, baseline_pose_) > radius_`
    - `resetBaselinePose`：使用机器人的当前姿势重置基线姿势，第一次直接重置，后续没经过`required_movement_radius`重置更新基线位姿
    - `pose_distance`：两点距离
    - `dynamicParametersCallback`：参数变更回调
- **PoseProgressChecker**：用于检查机器人的位置和角度，以确保它实际上正在朝着目标前进或旋转，继承于`SimpleProgressChecker`
    - `initialize`：重写函数
        - 调用父类`SimpleProgressChecker::initialize(parent, plugin_name)`
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".required_movement_angle"` -> `0.5`
        - 绑定参数回调`dynamicParametersCallback`
    - `check`：重写函数，同父类
    - `isRobotMovedEnough`：根据基线姿势计算机器人运动，
      调用`pose_distance(pose, baseline_pose_) > radius_ || poseAngleDistance(pose, baseline_pose_) > required_movement_angle_`
    - `poseAngleDistance`：检查角度`abs(angles::shortest_angular_distance(pose1.theta, pose2.theta))`
    - `dynamicParametersCallback`：参数变更回调

#### 到达目标位置检查插件

- **SimpleGoalChecker**：仅检查位置差异的目标检查器插件，继承于`nav2_core::GoalChecker`
    - `initialize`：重写函数
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".xy_goal_tolerance"` -> `0.25`
            - `plugin_name + ".yaw_goal_tolerance"` -> `0.25`
            - `plugin_name + ".stateful"` -> `true`
        - 绑定参数回调`dynamicParametersCallback`
    - `reset`：重写函数，`check_xy_ = true`
    - `isGoalReached`：重写函数
        - 查询点到目标点距离是否小于`xy_goal_tolerance**2`，小于表示进入`xy`容错范围窗口，不在检查`xy`
        - 后续继续检查角度是否满足
    - `getTolerances`：重写函数，赋值位置容错值并返回，速度相关赋值最小值
    - `dynamicParametersCallback`：参数变更回调
- **StoppedGoalChecker**：目标检查器插件，用于检查位置差和速度，继承于`SimpleGoalChecker`
    - `initialize`：重写函数
        - 调用父类`SimpleGoalChecker::initialize(parent, plugin_name, costmap_ros)`
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - 旋转速度：`plugin_name + ".rot_stopped_velocity"` -> `0.25`
            - 移动速度：`plugin_name + ".trans_stopped_velocity"` -> `0.25`
        - 绑定参数回调`dynamicParametersCallback`
    - `isGoalReached`：重写函数
        - 先调用父类`SimpleGoalChecker::isGoalReached(query_pose, goal_pose, velocity)`，`false`直接返回
        - 否则检查
          `fabs(velocity.angular.z) <= rot_stopped_velocity_ && hypot(velocity.linear.x, velocity.linear.y) <= trans_stopped_velocity_`
    - `getTolerances`：重写函数，调用父类`getTolerances`，然后赋值速度容错值并返回
    - `dynamicParametersCallback`：参数变更回调

## nav2_dwb_controller

`DWB` 控制器是 `ROS1` 中基本局部规划器（`base local planner`）和 `DWA` 控制器的后继者。它是由 `David Lu` 在 `Locus Robotics`
公司作为 `robot_navigation` 项目的一部分在 `ROS 1` 中创建的。然后，它被移植到 `ROS 2` 中，用作 `Nav2` 中的基于评论的控制器算法。

DWB 在几个重要方面对 DWA 进行了改进：

- 它实现了基于插件的评论器（`critic`），允许用户指定新的评论函数来在系统中使用。这些评论器可以动态重新配置、重新加权和调整，以获得在机器人系统中非常特定的行为。
- 它实现了基于插件的轨迹生成技术，使用户可以以任意方式生成轨迹，适用于任意类型的车辆。
- 包括许多常见用途的插件实现。

可以调整 `DWB` 以获得 `DWA` 和基本局部规划器行为，也可以通过新插件扩展到完全特定用例的行为。当前的轨迹生成器插件适用于全向和差分驱动机器人，尽管添加 阿克曼式（Ackermann）
生成器将是微不足道的。当前的评论器插件适用于圆形和非圆形机器人，并包括构建具有各种属性的路径跟踪系统所需的许多成本函数。

### DWB 插件

DWB 通过插件的使用进行高度配置。有三种类型的插件用于：

- 轨迹生成器插件：这些插件生成应由评论器评估的可能轨迹集。得分最高的轨迹确定输出的命令速度。`Navigation 2` 提供了两种轨迹生成器。一次只能加载一个。
    - `StandardTrajectoryGenerator` - 这类似于 `ROS 1` 中的 `base_local_planner` 中使用的轨迹滚动算法。
    - `LimitedAccelGenerator` - 这类似于 `ROS 1` 中使用的 `DWA`。
- 评论器插件：这些插件根据轨迹生成器生成的轨迹进行评分。可以加载多个插件，其得分之和确定了选择的命令速度。
    - `BaseObstacle` - 根据路径通过的代价地图上的位置对轨迹进行评分。要正确使用这个插件，必须使用代价地图中的膨胀层，将障碍物扩展到机器人的半径范围内。
    - `ObstacleFootprint` - 根据验证机器人轮廓中的所有点是否触碰代价地图中标记的障碍物来对轨迹进行评分。
    - `GoalAlign` - 根据轨迹与目标姿态的对齐程度对轨迹进行评分。
    - `GoalDist` - 根据轨迹使机器人靠近目标姿态的程度对轨迹进行评分。
    - `PathAlign` - 根据轨迹与全局规划器提供的路径的对齐程度对轨迹进行评分。
    - `PathDist` - 根据轨迹距离全局规划器提供的路径的距离对轨迹进行评分。
    - `PreferForward` - 更高分的轨迹是将机器人前进的轨迹。
    - `RotateToGoal` - 只有当机器人足够靠近目标位置时，才允许机器人旋转到目标方向。
    - `Oscillation` - 防止机器人只是前后移动。
    - `Twirling` - 防止全向机器人在前往目标的过程中旋转。