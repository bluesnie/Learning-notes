###### datetime:2023-07-04 19:30

###### author:nzb

# 堆、桶排序及排序总结

## 堆

- 1、堆结构就是用数组实现的完全二叉树结构
- 2、完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
    - 大根堆：每一颗子树的最大值就是头结点的值
- 3、完全二叉树中如果每棵子树的最小值都在顶部就是小根堆
    - 小根堆：每一颗子树的最小值就是头结点的值
- 4、堆结构的`heapInsert`与`heapify`操作
- 5、堆结构的增大和减少
- 6、**优先级队列结构，就是堆结构**

```python
"""
idx = [0,1,2,3,4,5,6]
arr = [3,5,2,7,1,9,6]

         0
      /     \
    1        2
  /   \    /   \
 3     4  5     6
 
 size = 7
 i位置
 左孩子：2 * i + 1
 右孩子：2 * i + 2
 父：(i - 1) // 2
 
"""
```

- `heapinsert`：调整时间复杂度，往上走高度，`O(logN)`

```python
def heap_insert(arr: list, index: int):
    """某个数现在在index位置，继续往上移"""

    def parent_idx():
        idx = (index - 1) // 2
        if idx < 0:
            idx = 0
        return idx

    while arr[index] > arr[parent_idx()]:  # 到头结点，arr[0] > arr[0] 肯定不满足
        arr[index], arr[parent_idx()] = arr[parent_idx()], arr[index]
        index = parent_idx()
```

- `heapify`：调整时间复杂度，往下走高度，`O(logN)`

```python
def heapify(arr: list, index: int, heap_size: int):
    """某个数在index位置，能否往下移动"""
    left = 2 * index + 1  # 左孩子下标
    while left < heap_size:  # 下方还有孩子
        # 左右孩子哪个大
        largest = left + 1 if left + 1 < heap_size and arr[left + 1] > arr[left] else left
        # 父与孩子之间，哪个大
        largest = largest if arr[largest] > arr[index] else index
        if largest == index:
            break
        arr[largest], arr[index] = arr[index], arr[largest]
        index = largest
        left = index * 2 - 1
```

### 堆排序

> **堆排序远远没有堆结构重要、堆排序远远没有堆结构重要、堆排序远远没有堆结构重要**

- 1、先让整个数组都变成大根堆结构，建立堆的过程:
    - 1、从上到下的方法，时间复杂度为`O(N*logN)`
    - 2、从下到上的方法，时间复杂度为`O(N)`
- 2、把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为`O(N*logN)`
- 3、堆的大小减小成`0`之后，排序完成

```python
def heap_insert(arr: list, index: int):
    """某个数现在在index位置，继续往上移"""

    def parent_idx():
        idx = (index - 1) // 2
        if idx < 0:
            idx = 0
        return idx

    while arr[index] > arr[parent_idx()]:  # 到头结点，arr[0] > arr[0] 肯定不满足
        arr[index], arr[parent_idx()] = arr[parent_idx()], arr[index]
        index = parent_idx()


def heapify(arr: list, index: int, heap_size: int):
    """某个数在index位置，能否往下移动"""
    left = 2 * index + 1  # 左孩子下标
    while left < heap_size:  # 下方还有孩子
        # 左右孩子哪个大
        largest = left + 1 if left + 1 < heap_size and arr[left + 1] > arr[left] else left
        # 父与孩子之间，哪个大
        largest = largest if arr[largest] > arr[index] else index
        if largest == index:
            break
        arr[largest], arr[index] = arr[index], arr[largest]
        index = largest
        left = index * 2 - 1


def heap_sort(arr: list):
    if not arr or len(arr) < 2:
        return

    # 首先变成大根堆 O(N*logN)
    for k, v in enumerate(arr):  # 时间复杂度：0(N)
        heap_insert(arr, k)  # 时间复杂度 O(logN)

    """
    变成大根堆优化版，不heap_insert，而是heapify
    假设，数不是一个一个加，而是给一个不是大根堆的数组，从下往上，一颗一颗小树搞成大根堆
    复杂度分析
        假设满二叉树，N个节点
        叶节点=N/2，每个节点往下复杂度，看一次1
        叶节点=N/4，每个节点往下复杂度，看一次1，移动一次1，代价2
        叶节点=N/8，每个节点往下复杂度，看一次1，移动两次2，代价2
        叶节点=N/16，每个节点往下复杂度，看一次1，移动两次3，代价4
        复杂度：①T(N) = N/2 + N/4 * 2 + N/8 * 3 + N/16 * 4 + N/32 * 5 + ...
        求：等号左右两边乘以2
        ②2T(N) = N + N/2 * 2 + N/4 * 3 + N/8 * 4 + N/16 * 5 + ...
        错位相减②-①：T(N) = N + N/2  + N/4 + N/8 + N/16 + ...
        等比数列求和公式：Sn = a(1-q^n)/(1-q), a=N, q = 2，忽略常数项
    所以时间复杂度：O(N)  
    """
    # # 优化版
    # for i in range(len(arr))[::-1]:
    #     heapify(arr, i, heap_size=len(arr))

    # 每个头结点跟尾部交互，然后长度减一，O(N*logN)
    heap_size = len(arr)
    while heap_size > 0:  # 时间复杂度 0(N)
        heap_size -= 1
        arr[0], arr[heap_size] = arr[heap_size], arr[0]  # 空间复杂度： O(1)
        heapify(arr, 0, heap_size)  # 时间复杂度： O(logN)


data = [4, 6, 5, 2, 3, 1, 8, 7, 9, 10, 15, 13]
heap_sort(data)
print(data)
```

### 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以**不超过k**，并且**k**相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

- 解决思路：利用小根堆，把数组前k+1，个数建立成小根堆，然后加一个，弹出最小的，因为每个元素移动的距离不超过k

```python
import heapq


def heapq_sort_distance_less_k(arr: list, k: int):
    pq = []
    # 建立小根堆，heapq 默认就是
    min_val = min(len(arr), k + 1)  # 怕给的 K 过大
    for i in range(min_val):  # 移动不超过 k
        heapq.heappush(pq, arr[i])

    x = 0
    for y in range(min_val, len(arr)):
        heapq.heappush(pq, arr[y])  # 添加一个
        arr[x] = heapq.heappop(pq)  # 弹出一个
        x += 1
    # 没数了，把最后的堆，pop完
    while True:
        try:
            arr[x] = heapq.heappop(pq)
            x += 1
        except:
            break


data = [4, 6, 5, 2, 3, 1, 8, 7, 9, 10, 15, 13]
heapq_sort_distance_less_k(data, 5)
print(data)
```

## 比较器的使用

- 1）比较器的实质就是重载比较运算符
- 2）比较器可以很好的应用在特殊标准的排序上
- 3）比较器可以很好的应用在根据特殊标准排序的结构上

```python
# -*-: encoding: utf8 -*-
from filecmp import cmp


class Demo():

    def __init__(self, age):
        self.age = age

    def __gt__(self, other):
        """>"""
        return self.age > other.age

    def __ge__(self, other):
        """>="""
        return self.age >= other.age

    def __lt__(self, other):
        """<"""
        return self.age < other.age

    def __le__(self, other):
        """<="""
        return self.age <= other.age

    def __eq__(self, other):
        """=="""
        return self.age == other.age

    def __ne__(self, other):
        """!="""
        return self.age != other.age


if __name__ == '__main__':
    ins1 = Demo(5)
    ins2 = Demo(6)
    print(ins1 > ins2)
    print(ins1 >= ins2)
    print(ins1 < ins2)
    print(ins1 <= ins2)
    print(ins1 == ins2)
    print(ins1 != ins2)

```

## 桶排序

> 之前讲的所有排序都是基于比较的排序

桶排序思想下的排序 
- 1）计数排序
  - 一个数组，里面都是员工的整数年龄，员工年龄16~200，16岁以下
- 2）基数排序

## 排序总结