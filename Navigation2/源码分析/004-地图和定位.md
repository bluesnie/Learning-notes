###### datetime:2024/01/10 18:18

###### author:nzb

# 导航

> https://github.com/ros-planning/navigation2.git
>
> 分支：humble
>
> 节点：3ed4c2d

![](./imgs/architectural_diagram-16525447663514.png)

# 地图和定位

- `nav2_map_server` ｜ 地图服务器
- `nav2_costmap_2d` ｜ 2D代价地图
- `nav2_voxel_grid` | 实现体素栅格的类
- `nav2_amcl` | 自适应蒙特卡洛定位。 状态估计，输入地图、激光、里程计数据，输出机器人map和odom之间的位姿关系。

## nav2_map_server

### 工具

- `loadMapYaml`：加载和解析给定的地图yaml文件参数，包括地图文件名，分辨率，地图原点，空闲阈值，占据阈值，模式，
- `loadMapFromFile`：从地图文件加载地图图像以及生成占用网格
- `loadMapFromYaml`：加载地图 YAML、地图文件中的图像以及生成占用网格`nav_msgs::msg::OccupancyGrid`返回
    - 调用`loadMapYaml`
    - 调用`loadMapFromFile`
- `saveMapToFile`：保存占据地图到文件
    - 调用`checkSaveParameters`
    - 调用`tryWriteMapToFile`
- `checkSaveParameters`：检查地图保存参数
- `tryWriteMapToFile`：分类型把地图写入文件，包括`Trinary`、`Scale`和`Raw`

```text
for (size_t y = 0; y < map.info.height; y++) {
  for (size_t x = 0; x < map.info.width; x++) {
    int8_t map_cell = map.data[map.info.width * (map.info.height - y - 1) + x];
    
nav_msgs::msg::OccupancyGrid 的data的是一维数组，其结构为

            |——————————————————————————————————> x(width)
            | (0,0) (0,1) (0,2) (0,3) ...  (0, w)
            | (1,0) (1,1)     ...
            |                 ...
            |                 ...
            | (h,0)           ...          (h, w)
  y(height) v
    
    data的数据排序为：[(0,0) ... (0,w) ... (h,0) ... (h, w)]
    
    比如width * height =5 * 4的20个元素，下图是索引表
  
 
  y(height) ^
            | 0   1   2   3   4 
            | 5   6   7   8   9
            | 10  11  12  13  14
            | 15  16  17  18  19
            |————————————————————> x(width)
    
    idx = width * (height - y - 1) + x
    y(height) = 0
        x(width) = 0, idx = 5 * (4 - 0 -1 ) + 0 = 15 
        x = 1, idx = 5 * (4 - 0 -1 ) + 1 = 16 
        x = 2, idx = 5 * (4 - 0 -1 ) + 2 = 17 
        x = 3, idx = 5 * (4 - 0 -1 ) + 3 = 18 
        x = 4, idx = 5 * (4 - 0 -1 ) + 4 = 19 
    y(height) = 1
        x(width) = 0, idx = 5 * (4 - 1 -1 ) + 0 = 10
        x = 1, idx = 5 * (4 - 1 -1 ) + 1 = 11 
        x = 2, idx = 5 * (4 - 1 -1 ) + 2 = 12 
        x = 3, idx = 5 * (4 - 1 -1 ) + 3 = 13 
        x = 4, idx = 5 * (4 - 1 -1 ) + 4 = 14 
    
    ... 
    
    y(height) = 3
        x(width) = 0, idx = 5 * (4 - 3 -1 ) + 0 = 0
        x = 1, idx = 5 * (4 - 3 -1 ) + 1 = 1
        x = 2, idx = 5 * (4 - 3 -1 ) + 2 = 2 
        x = 3, idx = 5 * (4 - 3 -1 ) + 3 = 3 
        x = 4, idx = 5 * (4 - 3 -1 ) + 4 = 4 
```

### 主要的类

- **MapServer**：解析地图yaml文件以及提供一个服务和一个话题发布占据网格地图，继承于`nav2_util::LifecycleNode`
    - `MapServer`：
        - 初始化节点`map_server`
        - 声明节点参数
            - `yaml_filename` -> `rclcpp::PARAMETER_STRING`
            - `topic_name` -> `map`
            - `frame_id` -> `map`
        - 创建一个`occ_service_`的`节点名称/map`的服务，绑定`getMapCallback`
        - 创建一个`occ_pub_`的`map`的发布话题
        - 创建一个`load_map_service_`的`节点名称/load_map`的服务，绑定`loadMapCallback`
    - `on_configure`：
        - 调用`loadMapResponseFromYaml`
        - 调用`updateMsgHeader`
    - `on_activate`：
        - `occ_pub_->on_activate()`
        - `occ_pub_->publish()`
        - `createBond()`
    - `on_deactivate`：
        - `occ_pub_->on_deactivate()`
        - `destroyBond()`
    - `on_cleanup`：属性重置
    - `on_shutdown`：
    - `loadMapResponseFromYaml`：加载地图yaml和图像，以及生成包含 `OccupancyGrid` 的输出响应。
    - `updateMsgHeader`：更新`msg`头信息，更新加载时间和帧id
    - `getMapCallback`：获取地图服务`map`的回调，返回最新的地图
    - `loadMapCallback`：更新加载地图服务`load_map`的回调
        - 调用`loadMapResponseFromYaml`，重新加载地图
        - 话题发布最新地图

- **MapSaver**：提供地图保存方法和服务的类，继承于`nav2_util::LifecycleNode`
    - `MapSaver`：
        - 初始化节点`map_saver`
        - 声明节点参数
            - `save_map_timeout` -> `2.0`
            - `free_thresh_default` -> `0.25`
            - `occupied_thresh_default` -> `0.65`
            - `map_subscribe_transient_local` -> `true`
    - `saveMapTopicToFile`：从地图话题读取信息并且保存到一个文件
        - 参数校验
        - 创建`map`(默认)名称的地图话题订阅
        - 调用`saveMapToFile`
    - `on_configure`：
        - 获取上述节点参数
        - 创建`save_map_service_`保存地图服务`节点名称/save_map`，绑定`saveMapCallback`
    - `on_activate`：调用`createBond()`
    - `on_deactivate`：调用`destroyBond()`
    - `on_cleanup`：属性重置
    - `on_shutdown`：
    - `saveMapCallback`：地图保存服务回调
        - 初始化保存地图参数
        - 调用`saveMapTopicToFile`

- **map_saver_cli**：可执行文件用于保存地图文件
    - `parse_arguments`：解析命令行参数
    - `main`：主函数
        - 调用`parse_arguments`
        - 实例化`map_saver = std::make_shared<nav2_map_server::MapSaver>()`
        - 调用`map_saver->on_configure`启动`map_saver`节点
        - 调用`map_saver->saveMapTopicToFile`保存地图文件

- **CostmapFilterInfoServer**：代价地图过滤器信息服务器，继承于`nav2_util::LifecycleNode`
    - `CostmapFilterInfoServer`
        - 初始化节点`costmap_filter_info_server`
        - 声明节点参数
            - `filter_info_topic` -> `costmap_filter_info`
            - `type` -> `0`
            - `mask_topic` -> `filter_mask`
            - `base` -> `0.0`
            - `multiplier` -> `1.0`
    - `on_configure`
        - 创建`costmap_filter_info`话题`publisher_ = this->create_publisher`，发布代价地图过滤器信息
    - `on_activate`
        - 调用`publisher_->on_activate()`
        - 调用`publisher_->publish`
        - 调用`createBond()`
    - `on_deactivate`
        - 调用`publisher_->on_deactivate()`
        - 调用`destroyBond()`
    - `on_cleanup`
    - `on_shutdown`

## nav2_voxel_grid

> TODO，先了解工作流以及有哪些功能，具体实现需要再深入，比较难懂

### 什么是体素(Voxel)?

![](imgs/voxel.png)

题图中是3D数据的不同表示类型:

- a)、点云（Point clouds）；点云是三维空间(xyz坐标)点的集合。
- b)、体素网格(Voxel grids)；体素是3D空间的像素。量化的，大小固定的点云。每个单元都是固定大小和离散坐标。
- c) 多边形网格(Polygon meshes)；mesh是面片的集合。
- d) 多视图表示(Multi-view representations)；多视图表示是从不同模拟视点渲染的2D图像集合。

为了解释体素网格(Voxel grid),首先我们要了解占据栅格地图（Occupancy Grid Map）

![](imgs/v2-31903c9629c149dc34d8d085fff22c59_720w.png)

画一个二维网格，每个网格单元里有实体的话就为占据状态（1），空的话就为（0）。很好理解。

而体素就是固定分辨率的三维栅格地图。

![](imgs/v2-e67a92616f73185843f1cbd0dfbfdaa8_720w.png)

体素网格是固定分辨率的，与之对应可变分辨率的网格叫八叉树地图(Octomap)。

![](imgs/v2-c55943227d7089621adb2a5ba9a18385_720w.png)

图左是八叉树地图(Octomap)，图右是八叉树(Octotree)。

总结：

- 体素网格是用固定大小的立方块作为最小单元，来表示三维物体的一种数据结构。
- 体素可以看成粗略版的点云。

### 主要的类

- **VoxelGrid**
    - `VoxelGrid`：仅支持z<=16
        - ` ~((uint32_t)0) >> 16` 表示32位二进制中所有位都为1的数，然后通过右移16位操作 (>> 16) 来将高16位设置为1，低16位设置为0
            - `~0`：得到全1
            - 等于`python`的`unknown_col = 0xFFFFFFFF >> 16`
            - 结果：`0b00000000000000001111111111111111`
    - `resize`：调整体素网格的尺寸
    - `reset`：重置体素网格
    - `getData`：返回指向表示体素网格的数据数组的指针
    - `markVoxel`：操作单个体素。它们检查边界并执行标记或检查阈值等操作
        - `full_mask = ((uint32_t)1 << z << 16) | (1 << z);`：注意：`z<=16`
        - `data_[y * size_x_ + x] |= full_mask`：标记或清错
    - `markVoxelInMap`：操作单个体素。它们检查边界并执行标记或检查阈值等操作
        - `marked_bits = (*col |= full_mask) >> 16`，然后调用`bitsBelowThreshold`
    - `clearVoxel`：操作单个体素。它们检查边界并执行清除或检查阈值等操作，`data_[y * size_x_ + x] &= ~(full_mask);`
    - `clearVoxelInMap`：检查边界并执行清除或检查阈值等操作，并**重置代价地图**
        - `*col &= ~(full_mask);`
        - `unknown_bits = uint16_t(*col >> 16) ^ uint16_t(*col);`
        - `marked_bits = *col >> 16`
        - `bitsBelowThreshold(unknown_bits, 1) && bitsBelowThreshold(marked_bits, 1)` -> `costmap[index] = 0;`
    - `clearVoxelColumn`：清除指定索引的体素
    - `bitsBelowThreshold`：查看位数是否低于阈值
    - `numBits`：计算一个数有多少个bit位是1，使用了一种称为`Brian Kernighan's Algorithm`的方法，它通过反复清除 `n` 中的最低位的1来计算1的个数。
      算法的思路是每次清除最低位的1，然后计数器增加1，直到 `n` 变成0。最终，函数返回整数 `n` 中位为1的个数。这个算法的优势在于它只需要循环次数等于 `n` 中位为1的个数，而不是整个32位。
    - `getVoxel`：获取指定坐标处的体素状态（静态方法）
        - `result = data[y * size_x + x] & full_mask;`
        - `bits = numBits(result)`
        - `known marked: 11 = 2 bits, unknown: 01 = 1 bit, known free: 00 = 0 bits`
    - `markVoxelLine`：用于在网格中标记或清除一条体素线的函数
        - 实例化函数对象`MarkVoxel`
        - 调用`raytraceLine`
    - `clearVoxelLine`：用于在网格中标记或清除一条体素线的函数，实例化函数对象`MarkVoxel`，调用`raytraceLine`
    - `clearVoxelLineInMap`：用于在网格中标记或清除一条体素线的函数
        - 如果没有代价地图，调用`clearVoxelLine`
        - 否则实例化函数对象`ClearVoxelInMap`
        - 调用`raytraceLine`
    - `getVoxel`：获取指定坐标处的体素状态（非静态方法）
    - `getVoxelColumn`：用于获取指定 `(x, y)` 上的体素状态
    - `printVoxelGrid`：用于调试的打印体素网格或网格列的函数
    - `printColumnGrid`：用于调试的打印体素网格或网格列的函数
    - `sizeX`：返回体素网格的尺寸
    - `sizeY`：返回体素网格的尺寸
    - `sizeZ`：返回体素网格的尺寸
    - `raytraceLine`：模板函数，在体素网格中执行射线跟踪，沿着线标记或清除体素
        - 实例化`GridOffset`、`ZOffset`
        - 根据数据状况调用`bresenham3D`
    - `bresenham3D`：`Bresenham` 算法在三维空间中的实现，最后调用`MarkVoxel`实例函数更新体素状态
    - `sign`：签名，大于0，返回1，否则返回-1
    - `max`：最大值
    - 函数对象
        - `MarkVoxel`：标记：`data_[offset] |= z_mask;`
        - `ClearVoxel`：清除：`data_[offset] &= ~(z_mask)`
        - `ClearVoxelInMap`：清除并**重置代价地图**：类似上面的`clearVoxelInMap`
        - `GridOffset`：更新偏移量
        - `ZOffset`：如果 `offset_val` 大于0，则执行左移操作 `z_mask_ <<= 1`；否则，执行右移操作 `z_mask_ >>= 1`

用于标记、清除和更新偏移量的函数对象。

## nav2_costmap_2d

### 主要的类

- **Costmap2DROS**：`2D Costmap`的ROS包装器。 处理订阅`PointCloud`或`LaserScan`提供障碍等相关消息。继承于`nav2_util::LifecycleNode`
    - `Costmap2DROS`：构造函数
        - 节点名称：`costmap`
        - 初始化参数：
            - `default_plugins_`->`{"static_layer", "obstacle_layer", "inflation_layer"}`，依次为静态层，避障层，膨胀层
            - 对应的插件`default_types__`
              ->`{"nav2_costmap_2d::StaticLayer", "nav2_costmap_2d::ObstacleLayer", "nav2_costmap_2d::InflationLayer"}`
            - `clearable_layers`->`{"obstacle_layer", "voxel_layer", "range_layer"}`，可清除的层，包括避障层、体素层、测距层
            -
          | 参数 | 默认值 | 说明 |
                    |--- | ---| --- |
          | `always_send_full_costmap` | `false` |  |
          | `footprint_padding` | `0.01` | 足迹补偿值 |
          | `footprint` | `"[]"` |  |
          | `global_frame` | `map` |  |
          | `height` | `5` |  |
          | `width` | `5` |  |
          | `lethal_cost_threshold` | `100` | 障碍物阈值 |
          | `map_topic` | `/map` |  |
          | `observation_sources` |  |  |
          | `origin_x` |  |  |
          | `origin_y` |  |  |
          | `plugins` | `default_plugins` |  |
          | `filters` |  |  |
          | `publish_frequency` | `1.0` |  |
          | `resolution` | `0.1` |  |
          | `robot_base_frame` | `base_link` |  |
          | `robot_radius` | `0.1` |  |
          | `rolling_window` | `false` |  |
          | `track_unknown_space` | `false` |  |
          | `transform_tolerance` | `0.3` |  |
          | `trinary_costmap` | `true` |  |
          | `unknown_cost_value` | `0xff` |  |
          | `update_frequency` | `5.0` |  |
          | `use_maximum` | `false` |  |
          | `clearable_layers` | 上面的`clearable_layers` |  |
    - `on_configure`：配置
        - 调用`getParameters`
        - 创建主代价地图层`layered_costmap_ = std::make_unique<LayeredCostmap>`
        - 初始化`tf_buffer_`
        - 加载配置的`plugin_names_`插件
            - 创建插件实例`plugin = std::shared_ptr<Layer>`
            - 插件实例添加到主代价地图层`layered_costmap_->addPlugin(plugin)`
            - 插件初始化`plugin->initialize()`
        - 加载配置的`filter_names_`过滤插件
            - 创建插件实例`filter = std::shared_ptr<Layer>`
            - 插件实例添加到主代价地图层`layered_costmap_->addFilter(filter)`
            - 插件初始化`filter->initialize()`
        - 创建话题发布和订阅
            - 机器人足迹`footprint`订阅`footprint_sub_`：绑定`setRobotFootprintPolygon`
            - 机器人足迹`published_footprint`发布`footprint_pub_`
            - 代价地图`costmap`发布`costmap_publisher_ = std::make_unique<Costmap2DPublisher>`，话题名`costmap`，`frame_id`->`map`
        - 设置`footprint`
            - 圆：`setRobotFootprint(makeFootprintFromRadius(robot_radius_));`
            - 多边形：
                - 调用`makeFootprintFromString(footprint_, new_footprint);`
                - 调用`setRobotFootprint(new_footprint);`
        - 初始化清除代价地图服务`clear_costmap_service_ = std::make_unique<ClearCostmapService>`
    - `on_activate`：
        - 调用`costmap_publisher_->on_activate()`
        - 调用`footprint_pub_->on_activate()`
        - 检验`tf`是否正常运转
        - 开线程更新地图，绑定`mapUpdateLoop`
        - 调用`start()`
        - 添加参数变更回调`dynamicParametersCallback`
    - `on_deactivate`：
        - 调用`stop()`
        - 地图更新线程停掉，`map_update_thread_->join()`
        - 调用`costmap_publisher_->on_deactivate()`
        - 调用`footprint_pub_->on_deactivate()`
    - `on_cleanup`：属性指针重置
    - `on_shutdown`：
    - `start`：调用了代价地图的`stop`和`pause`之后可以调用该函数，订阅话题更新代价地图
        - 获取默认插件和过滤插件`layered_costmap_->getPlugins()和getFilters()`，依次调用插件的`->activate()`，然后等待初始化完成
    - `stop`：停止代价地图更新并且停止话题订阅，依次调用插件的`deactivate`，并且相关属性切换
    - `pause`：暂停地图更新，但话题数据还是会传输
    - `resume`：恢复地图更新，知道初始化完成
    - `updateMap`：更新分层代价地图/插件地图
        - 调用`getRobotPose`
        - 调用`layered_costmap_->updateMap`
        - 调用`transformFootprint`更新最新的`footprint`
        - 调用`footprint_pub_->publish`发布`footprint`
    - `resetLayers`：重置地图
        - 重置主地图`layered_costmap_->getCostmap()->resetMap`
        - 重置所有插件地图`->reset()`
    - `isCurrent`：是否当前层地图
    - `getRobotPose`：获取小车位姿，调用`nav2_util::getCurrentPose`
    - `transformPoseToGlobalFrame`：代价地图坐标转换成全局坐标，帧ID相等直接返回，否则调用`nav2_util::transformPoseInTargetFrame`
    - `getName`：获取代价地图名称
    - `getTransformTolerance`：获取tf转换容差（单位秒）
    - `getCostmap`：返回指向“主”成本地图的指针，该成本图接收来自所有层的更新。
    - `getGlobalFrameID`：返回主成本地图的帧ID
    - `getBaseFrameID`：返回本地成本地图的帧ID
    - `getLayeredCostmap`：获取单层代价地图指针
    - `getRobotFootprintPolygon`：获取机器人`footprint`的多边形`msg`，`std::vector<geometry_msgs::msg::Point>`
      ->`geometry_msgs::msg::Polygon`
    - `getRobotFootprint`：获取机器人`footprint`的配置，增补后的，可以通过配置重写或发布`footprint`话题修改
    - `getUnpaddedRobotFootprint`：获取机器人`footprint`的配置，未增补的，可以通过配置重写或发布`footprint`话题修改
    - `getOrientedFootprint`：获取有方向的足迹，调用`getRobotPose`和`transformFootprint`
    - `setRobotFootprint`：设置机器人的足迹
        - 调用`padFootprint`
        - 调用`layered_costmap_->setFootprint(padded_footprint_)`
    - `setRobotFootprintPolygon`：设置机器人足迹多边形，调用`setRobotFootprint(toPointVector(footprint))`
    - `getTfBuffer`：返回`tf`指针
    - `getUseRadius`：获取`use_radius_`参数，机器人足迹是否使用圆
    - `getRobotRadius`：获取`robot_radius_`，如果`use_radius_ == true`则有值
    - `mapUpdateLoop`：地图更新循环
        - `start()`调用后所有的插件激活，调用`updateMap()`
        - 调用获取地图边界`layered_costmap_->getBounds()`
        - 更新地图边界`costmap_publisher_->updateBounds()`
        - 发布代价地图`costmap_publisher_->publishCostmap()`
    - `getParameters`：获取节点参数
        - 获取构造函数里面那些节点参数及`filters`地图过滤插件
        - 设置插件信息到节点参数里面，例如：`static_layer.plugin`->`nav2_costmap_2d::StaticLayer`
        - 获取地图过滤插件
        - 参数校验
        - 如果设置了`footprint`，调用`makeFootprintFromString`生成机器人足迹，否则使用圆
    - `dynamicParametersCallback`：参数变更回调函数，根据变更的参数做对应的操作

### 工具

- `array_parser.hpp`
    - **parseVVF**函数，解析二维数组字符串
        - 解析字符串二维数组，例如`[[1.0, 2.0], [3.3, 4.4, 5.5], ...]`
        - `input_ss.peek()`：获取下一个字符，但不消费
        - `input_ss.get()`：用于从流中获取字符
        - 碰到`[`，深度增加1，
        - 碰到`]`深度减一，如果深度为1，内层数组已结束
        - 碰到`,`、`\t`和空字符串，跳过`get()`跳过
        - 其他则是数字，`peek()`一直移，一直`input_ss >> value`，添加到当前层数组，直到碰到上面情况，`get()`出去

- `footprint.hpp`
    - **makeFootprintFromString**函数：根据字符串生成足迹`footprint`，调用`parseVVF()`
    - **makeFootprintFromRadius**函数：根据半径生成，16个点的园
    - **padFootprint**函数：足迹增补
    - **transformFootprint**函数：转换机器人足迹，更新到机器人最新位置
    - **toPointVector**函数：转换多边形到点，`geometry_msgs::msg::Polygon`->`std::vector<geometry_msgs::msg::Point>`

- `costmap_math.hpp`
    - **sign**函数：`x < 0.0 ? -1.0 : 1.0;`
    - **sign0**函数：`x < 0.0 ? -1.0 : (x > 0.0 ? 1.0 : 0.0);`
    - **distance**函数：` hypot(x1 - x0, y1 - y0)`
    - **distanceToLine**函数：点到线距离

- **常量**
    - `NO_INFORMATION = 255;`：未知
    - `LETHAL_OBSTACLE = 254;`致命障碍物
    - `INSCRIBED_INFLATED_OBSTACLE = 253;`：膨胀层障碍物
    - `MAX_NON_OBSTACLE = 252;`：无障碍物的阈值上限，只要低于该值都不算障碍物
    - `FREE_SPACE = 0;`：无障碍物

## nav2_amcl

> TODO，先了解工作流以及有哪些功能，具体实现需要再深入，比较难懂