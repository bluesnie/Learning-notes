###### datetime:2024/01/10 18:18

###### author:nzb

# 导航

> https://github.com/ros-planning/navigation2.git
>
> 分支：humble
>
> 节点：3ed4c2d

![](./imgs/architectural_diagram-16525447663514.png)

# 地图和定位

- `nav2_map_server` ｜ 地图服务器
- `nav2_costmap_2d` ｜ 2D代价地图
- `nav2_voxel_grid` | 实现体素栅格的类
- `nav2_amcl` | 自适应蒙特卡洛定位。 状态估计，输入地图、激光、里程计数据，输出机器人map和odom之间的位姿关系。

## nav2_map_server

### 工具

- `loadMapYaml`：加载和解析给定的地图yaml文件参数，包括地图文件名，分辨率，地图原点，空闲阈值，占据阈值，模式，
- `loadMapFromFile`：从地图文件加载地图图像以及生成占用网格
- `loadMapFromYaml`：加载地图 YAML、地图文件中的图像以及生成占用网格`nav_msgs::msg::OccupancyGrid`返回
    - 调用`loadMapYaml`
    - 调用`loadMapFromFile`
- `saveMapToFile`：保存占据地图到文件
    - 调用`checkSaveParameters`
    - 调用`tryWriteMapToFile`
- `checkSaveParameters`：检查地图保存参数
- `tryWriteMapToFile`：分类型把地图写入文件，包括`Trinary`、`Scale`和`Raw`

```text
for (size_t y = 0; y < map.info.height; y++) {
  for (size_t x = 0; x < map.info.width; x++) {
    int8_t map_cell = map.data[map.info.width * (map.info.height - y - 1) + x];
    
nav_msgs::msg::OccupancyGrid 的data的是一维数组，其结构为

            |——————————————————————————————————> x(width)
            | (0,0) (0,1) (0,2) (0,3) ...  (0, w)
            | (1,0) (1,1)     ...
            |                 ...
            |                 ...
            | (h,0)           ...          (h, w)
  y(height) v
    
    data的数据排序为：[(0,0) ... (0,w) ... (h,0) ... (h, w)]
    
    比如width * height =5 * 4的20个元素，下图是索引表
  
 
  y(height) ^
            | 0   1   2   3   4 
            | 5   6   7   8   9
            | 10  11  12  13  14
            | 15  16  17  18  19
            |————————————————————> x(width)
    
    idx = width * (height - y - 1) + x
    y(height) = 0
        x(width) = 0, idx = 5 * (4 - 0 -1 ) + 0 = 15 
        x = 1, idx = 5 * (4 - 0 -1 ) + 1 = 16 
        x = 2, idx = 5 * (4 - 0 -1 ) + 2 = 17 
        x = 3, idx = 5 * (4 - 0 -1 ) + 3 = 18 
        x = 4, idx = 5 * (4 - 0 -1 ) + 4 = 19 
    y(height) = 1
        x(width) = 0, idx = 5 * (4 - 1 -1 ) + 0 = 10
        x = 1, idx = 5 * (4 - 1 -1 ) + 1 = 11 
        x = 2, idx = 5 * (4 - 1 -1 ) + 2 = 12 
        x = 3, idx = 5 * (4 - 1 -1 ) + 3 = 13 
        x = 4, idx = 5 * (4 - 1 -1 ) + 4 = 14 
    
    ... 
    
    y(height) = 3
        x(width) = 0, idx = 5 * (4 - 3 -1 ) + 0 = 0
        x = 1, idx = 5 * (4 - 3 -1 ) + 1 = 1
        x = 2, idx = 5 * (4 - 3 -1 ) + 2 = 2 
        x = 3, idx = 5 * (4 - 3 -1 ) + 3 = 3 
        x = 4, idx = 5 * (4 - 3 -1 ) + 4 = 4 
```

### 主要的类

- **MapServer**：解析地图yaml文件以及提供一个服务和一个话题发布占据网格地图，继承于`nav2_util::LifecycleNode`
    - `MapServer`：
        - 初始化节点`map_server`
        - 声明节点参数
            - `yaml_filename` -> `rclcpp::PARAMETER_STRING`
            - `topic_name` -> `map`
            - `frame_id` -> `map`
        - 创建一个`occ_service_`的`节点名称/map`的服务，绑定`getMapCallback`
        - 创建一个`occ_pub_`的`map`的发布话题
        - 创建一个`load_map_service_`的`节点名称/load_map`的服务，绑定`loadMapCallback`
    - `on_configure`：
        - 调用`loadMapResponseFromYaml`
        - 调用`updateMsgHeader`
    - `on_activate`：
        - `occ_pub_->on_activate()`
        - `occ_pub_->publish()`
        - `createBond()`
    - `on_deactivate`：
        - `occ_pub_->on_deactivate()`
        - `destroyBond()`
    - `on_cleanup`：属性重置
    - `on_shutdown`：
    - `loadMapResponseFromYaml`：加载地图yaml和图像，以及生成包含 `OccupancyGrid` 的输出响应。
    - `updateMsgHeader`：更新`msg`头信息，更新加载时间和帧id
    - `getMapCallback`：获取地图服务`map`的回调，返回最新的地图
    - `loadMapCallback`：更新加载地图服务`load_map`的回调
        - 调用`loadMapResponseFromYaml`，重新加载地图
        - 话题发布最新地图

- **MapSaver**：提供地图保存方法和服务的类，继承于`nav2_util::LifecycleNode`
    - `MapSaver`：
        - 初始化节点`map_saver`
        - 声明节点参数
            - `save_map_timeout` -> `2.0`
            - `free_thresh_default` -> `0.25`
            - `occupied_thresh_default` -> `0.65`
            - `map_subscribe_transient_local` -> `true`
    - `saveMapTopicToFile`：从地图话题读取信息并且保存到一个文件
        - 参数校验
        - 创建`map`(默认)名称的地图话题订阅
        - 调用`saveMapToFile`
    - `on_configure`：
        - 获取上述节点参数
        - 创建`save_map_service_`保存地图服务`节点名称/save_map`，绑定`saveMapCallback`
    - `on_activate`：调用`createBond()`
    - `on_deactivate`：调用`destroyBond()`
    - `on_cleanup`：属性重置
    - `on_shutdown`：
    - `saveMapCallback`：地图保存服务回调
        - 初始化保存地图参数
        - 调用`saveMapTopicToFile`

- **map_saver_cli**：可执行文件用于保存地图文件
    - `parse_arguments`：解析命令行参数
    - `main`：主函数
        - 调用`parse_arguments`
        - 实例化`map_saver = std::make_shared<nav2_map_server::MapSaver>()`
        - 调用`map_saver->on_configure`启动`map_saver`节点
        - 调用`map_saver->saveMapTopicToFile`保存地图文件

- **CostmapFilterInfoServer**：代价地图过滤器信息服务器，继承于`nav2_util::LifecycleNode`
    - `CostmapFilterInfoServer`
        - 初始化节点`costmap_filter_info_server`
        - 声明节点参数
            - `filter_info_topic` -> `costmap_filter_info`
            - `type` -> `0`
            - `mask_topic` -> `filter_mask`
            - `base` -> `0.0`
            - `multiplier` -> `1.0`
    - `on_configure`
        - 创建`costmap_filter_info`话题`publisher_ = this->create_publisher`，发布代价地图过滤器信息
    - `on_activate`
        - 调用`publisher_->on_activate()`
        - 调用`publisher_->publish`
        - 调用`createBond()`
    - `on_deactivate`
        - 调用`publisher_->on_deactivate()`
        - 调用`destroyBond()`
    - `on_cleanup`
    - `on_shutdown`

## nav2_voxel_grid

> TODO，先了解工作流以及有哪些功能，具体实现需要再深入，比较难懂

### 什么是体素(Voxel)?

![](imgs/voxel.png)

题图中是3D数据的不同表示类型:

- a)、点云（Point clouds）；点云是三维空间(xyz坐标)点的集合。
- b)、体素网格(Voxel grids)；体素是3D空间的像素。量化的，大小固定的点云。每个单元都是固定大小和离散坐标。
- c) 多边形网格(Polygon meshes)；mesh是面片的集合。
- d) 多视图表示(Multi-view representations)；多视图表示是从不同模拟视点渲染的2D图像集合。

为了解释体素网格(Voxel grid),首先我们要了解占据栅格地图（Occupancy Grid Map）

![](imgs/v2-31903c9629c149dc34d8d085fff22c59_720w.png)

画一个二维网格，每个网格单元里有实体的话就为占据状态（1），空的话就为（0）。很好理解。

而体素就是固定分辨率的三维栅格地图。

![](imgs/v2-e67a92616f73185843f1cbd0dfbfdaa8_720w.png)

体素网格是固定分辨率的，与之对应可变分辨率的网格叫八叉树地图(Octomap)。

![](imgs/v2-c55943227d7089621adb2a5ba9a18385_720w.png)

图左是八叉树地图(Octomap)，图右是八叉树(Octotree)。

总结：

- 体素网格是用固定大小的立方块作为最小单元，来表示三维物体的一种数据结构。
- 体素可以看成粗略版的点云。

### 主要的类

- **VoxelGrid**
    - `VoxelGrid`：仅支持z<=16
        - ` ~((uint32_t)0) >> 16` 表示32位二进制中所有位都为1的数，然后通过右移16位操作 (>> 16) 来将高16位设置为1，低16位设置为0
            - `~0`：得到全1
            - 等于`python`的`unknown_col = 0xFFFFFFFF >> 16`
            - 结果：`0b00000000000000001111111111111111`
    - `resize`：调整体素网格的尺寸
    - `reset`：重置体素网格
    - `getData`：返回指向表示体素网格的数据数组的指针
    - `markVoxel`：操作单个体素。它们检查边界并执行标记或检查阈值等操作
        - `full_mask = ((uint32_t)1 << z << 16) | (1 << z);`：注意：`z<=16`
        - `data_[y * size_x_ + x] |= full_mask`：标记或清错
    - `markVoxelInMap`：操作单个体素。它们检查边界并执行标记或检查阈值等操作
        - `marked_bits = (*col |= full_mask) >> 16`，然后调用`bitsBelowThreshold`
    - `clearVoxel`：操作单个体素。它们检查边界并执行清除或检查阈值等操作，`data_[y * size_x_ + x] &= ~(full_mask);`
    - `clearVoxelInMap`：检查边界并执行清除或检查阈值等操作，并**重置代价地图**
        - `*col &= ~(full_mask);`
        - `unknown_bits = uint16_t(*col >> 16) ^ uint16_t(*col);`
        - `marked_bits = *col >> 16`
        - `bitsBelowThreshold(unknown_bits, 1) && bitsBelowThreshold(marked_bits, 1)` -> `costmap[index] = 0;`
    - `clearVoxelColumn`：清除指定索引的体素
    - `bitsBelowThreshold`：查看位数是否低于阈值
    - `numBits`：计算一个数有多少个bit位是1，使用了一种称为`Brian Kernighan's Algorithm`的方法，它通过反复清除 `n` 中的最低位的1来计算1的个数。
      算法的思路是每次清除最低位的1，然后计数器增加1，直到 `n` 变成0。最终，函数返回整数 `n` 中位为1的个数。这个算法的优势在于它只需要循环次数等于 `n` 中位为1的个数，而不是整个32位。
    - `getVoxel`：获取指定坐标处的体素状态（静态方法）
        - `result = data[y * size_x + x] & full_mask;`
        - `bits = numBits(result)`
        - `known marked: 11 = 2 bits, unknown: 01 = 1 bit, known free: 00 = 0 bits`
    - `markVoxelLine`：用于在网格中标记或清除一条体素线的函数
        - 实例化函数对象`MarkVoxel`
        - 调用`raytraceLine`
    - `clearVoxelLine`：用于在网格中标记或清除一条体素线的函数，实例化函数对象`MarkVoxel`，调用`raytraceLine`
    - `clearVoxelLineInMap`：用于在网格中标记或清除一条体素线的函数
        - 如果没有代价地图，调用`clearVoxelLine`
        - 否则实例化函数对象`ClearVoxelInMap`
        - 调用`raytraceLine`
    - `getVoxel`：获取指定坐标处的体素状态（非静态方法）
    - `getVoxelColumn`：用于获取指定 `(x, y)` 上的体素状态
    - `printVoxelGrid`：用于调试的打印体素网格或网格列的函数
    - `printColumnGrid`：用于调试的打印体素网格或网格列的函数
    - `sizeX`：返回体素网格的尺寸
    - `sizeY`：返回体素网格的尺寸
    - `sizeZ`：返回体素网格的尺寸
    - `raytraceLine`：模板函数，在体素网格中执行射线跟踪，沿着线标记或清除体素
        - 实例化`GridOffset`、`ZOffset`
        - 根据数据状况调用`bresenham3D`
    - `bresenham3D`：`Bresenham` 算法在三维空间中的实现，最后调用`MarkVoxel`实例函数更新体素状态
    - `sign`：签名，大于0，返回1，否则返回-1
    - `max`：最大值
    - 函数对象
        - `MarkVoxel`：标记：`data_[offset] |= z_mask;`
        - `ClearVoxel`：清除：`data_[offset] &= ~(z_mask)`
        - `ClearVoxelInMap`：清除并**重置代价地图**：类似上面的`clearVoxelInMap`
        - `GridOffset`：更新偏移量
        - `ZOffset`：如果 `offset_val` 大于0，则执行左移操作 `z_mask_ <<= 1`；否则，执行右移操作 `z_mask_ >>= 1`

用于标记、清除和更新偏移量的函数对象。

## nav2_costmap_2d

### 工具

- **parseVVF**
    - 解析字符串二维数组，例如`[[1.0, 2.0], [3.3, 4.4, 5.5], ...]`
    - `input_ss.peek()`：获取下一个字符，但不消费
    - `input_ss.get()`：用于从流中获取字符
    - 碰到`[`，深度增加1，
    - 碰到`]`深度减一，如果深度为1，内层数组已结束
    - 碰到`,`、`\t`和空字符串，跳过`get()`跳过
    - 其他则是数字，`peek()`一直移，一直`input_ss >> value`，添加到当前层数组，直到碰到上面情况，`get()`出去

## nav2_amcl

> TODO，先了解工作流以及有哪些功能，具体实现需要再深入，比较难懂