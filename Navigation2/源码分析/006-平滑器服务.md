###### datetime:2024/03/11 11:35

###### author:nzb

# 导航

> https://github.com/ros-planning/navigation2.git
>
> 分支：humble
>
> 节点：3ed4c2d

![](./imgs/architectural_diagram-16525447663514.png)

# 规划平滑器服务

- `nav2_smoother` | Nav2规划平滑器

## nav2_smoother

- 主要类

    - **SimpleSmoother**：平滑实现类，继承于`nav2_core::Smoother`
        - `SimpleSmoother`：
        - `configure`：
            - `declare_parameter_if_not_declared`初始化声明参数
                - `name + .tolerance` -> `1e-10`
                - `name + .max_its` -> `1000`
                - `name + .w_data` -> `0.2`
                - `name + .w_smooth` -> `0.3`
                - `name + .do_refinement` -> `true`
        - `cleanup`：`costmap_sub_.reset();`
        - `activate`
            - `deactivate`
            - `smooth`：重写函数
                - 调用`findDirectionalPathSegments(path)`
                - 路径段的索引差值大于9就处理，否则跳过
                    - 调用`smoothImpl`函数对当前路径段进行平滑操作
                    - 将处理更改后的路径组装更新到主路径中
            - `smoothImpl`：平滑实现
                - 循环执行路径平滑的迭代过程
                    - 每次迭代，都会检查迭代次数是否超过了设定的最大迭代次数 `max_its`_。如果超过了最大迭代次数，会发出警告并将路径恢复到上一次迭代的状态`last_path`
                      ，并调用 `updateApproximatePathOrientations` 函数更新路径的方向。
                    - 每次迭代都会检查当前时间与平滑操作开始时间的差值是否超过了设定的最大平滑时间。如果超过了最大时间，会发出警告并将路径恢复到上一次迭代的状态`last_path`
                      ，并调用 `updateApproximatePathOrientations` 函数更新路径的方向。
                    - 除了首尾点之外的路径中的每个点。在每个点上，通过使用该点和其相邻点的坐标值进行平滑计算，并更新当前点的坐标。同时计算平滑程度的变化量 `change`
                    - 在平滑后的点进行地图代价检查，确保平滑后的路径不会与障碍物发生碰撞。如果平滑后的路径发生碰撞，则回滚到上一次迭代的状态`last_path`
                      ，并调用 `updateApproximatePathOrientations` 函数更新路径的方向。
                    - 在每次迭代平滑成功结束时，将 `new_path` 更新到 `last_path`，以保存当前的路径状态
                - 如果启用了路径细化选项，并且细化次数未达到上限（4次），则进行额外的路径细化操作，传入`new_path`递归调用`smoothImpl`继续平滑。
                - 最后，更新路径的方向，并将平滑后的路径更新到原始路径中，然后返回操作成功的标志。
            - `getFieldByDim`：获取维度信息`xyz`的值
            - `setFieldByDim`：设置维度信息`xyz`的值

    - **SmootherServer**：用于托管不同算法的平滑器类，继承于`nav2_util::LifecycleNode`
        - `SmootherServer`：构造函数
            - 节点名称：`smoother_server`
            - 初始化成员变量
                - `default_ids_ -> {simple_smoother}`
                - `default_types_ -> {nav2_smoother::SimpleSmoother}`
            - 初始化节点参数
                - `costmap_topic -> global_costmap/costmap_raw`
                - `footprint_topic -> global_costmap/published_footprint`
                - `robot_base_frame -> base_link`
                - `transform_tolerance -> 0.1`
                - `smoother_plugins -> default_ids_`
        - `on_configure`：配置平滑插件，代价地图，初始化`odom`订阅，速度发布以及平滑路径动作服务
            - 获取参数
                - `smoother_plugins`，如果`==default_ids_`声明设置参数：`default_ids_[i] + ".plugin" -> default_types_[i]`
                - `costmap_topic`,`footprint_topic`,`transform_tolerance`,`robot_base_frame`
            - 创建代价地图订阅：`costmap_sub_ = std::make_shared<nav2_costmap_2d::CostmapSubscriber>`
            - 创建机器人足迹订阅：`footprint_sub_ = std::make_shared<nav2_costmap_2d::FootprintSubscriber>`
            - 创建碰撞检测：`collision_checker_ = std::make_shared<nav2_costmap_2d::CostmapTopicCollisionChecker>`
            - 调用`loadSmootherPlugins`
            - 创建平滑规划结果发布话题：`plan_publisher_ = create_publisher<nav_msgs::msg::Path>("plan_smoothed", 1)`
            - 创建平滑动作服务：`  action_server_ = std::make_unique<ActionServer>(shared_from_this(), "smooth_path",...)`
              ，绑定`smoothPlan`
        - `loadSmootherPlugins`：从参数文件加载平滑插件
            - 遍历`smoother_ids_`查找插件：`smoother_types_[i] = nav2_util::get_plugin_type_param`
            - 创建插件实例：`smoother = lp_loader_.createUniqueInstance(smoother_types_[i])`
            - 配置插件：`smoother->configure`
            - 添加到键值map里面
        - `on_activate`：激活平滑，代价地图，速度发布和平滑路径动作服务
            - `plan_publisher_->on_activate()`
            - 遍历插件map，激活`activate`
            - `action_server_->activate()`
            - 创建连接`createBond()`
        - `on_deactivate`：激活平滑，代价地图，速度发布和平滑路径动作服务，在调用该方法前，速度会被设置成0
            - `action_server_->deactivate()`
            - 遍历插件map，激活`deactivate`
            - `plan_publisher_->on_deactivate()`
            - 销毁连接`destroyBond()`
        - `on_cleanup`：平滑和代价地图清理，其余变量`reset`，插件`reset`
        - `on_shutdown`：节点关闭
        - `smoothPlan`：平滑路径动作服务回调函数，处理动作更新并轮询服务直到到达目标
            - 调用`findSmootherId`，不存在直接结束返回
            - `goal = action_server_->get_current_goal(); result->path = goal->path`
            - 调用插件`result->was_completed=smoothers_[current_smoother_]->smooth(result->path, ...)`
            - 调用`plan_publisher_->publish(result->path)`发布平滑后路径
            - 如果开启了碰撞检测，遍历路径点，调用`collision_checker_->isCollisionFree(pose2d, fetch_data)`，存在碰撞直接结束返回
            - 完成返回
        - `findSmootherId`：查找给定请求有效的平滑ID名称
            - 插件map未找到
                - 如果插件map大小为1，传入的名称为空，则使用插件map的第一个
                - 否则返回失败
            - 插件map找到，返回查询的名称

- 工具`smoother_utils.hpp`
    - `findDirectionalPathSegments`：遍历路径数组组装，同方向的段数组
        - 同方向的段：当前点的前一个点和后一个点的向量点积，小于0，则存在拐点，生成一个段
        - 原点旋转的段：如果当前点和后一个点的`xy`差值都很小，接近于零，但是角度差超过了某个阈值（`1e-4`），则说明存在原地旋转，生成一个段
    - `updateApproximatePathOrientations`：更新路径中每个点的方向（`orientation`），使其指向路径上相邻点之间的方向
        - 选择了第二个和第三个点进行方向比较，是因为这样更加健壮。例如，如果使用第一个点和第二个点，可能会受到初始点方向的影响， 而这个方向有可能并不代表整个路径段的走向。因此，选择第二个和第三个点进行比较可以减少这种影响

## nav2_velocity_smoother













































