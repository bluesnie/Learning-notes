###### datetime:2024/03/14 16:53

###### author:nzb

# 导航

> https://github.com/ros-planning/navigation2.git
>
> 分支：humble
>
> 节点：3ed4c2d

![](./imgs/architectural_diagram-16525447663514.png)

# 控制器服务

- `nav2_controller` ｜ 控制器服务
- `nav2_dwb_controller` | DWB控制器，Nav2控制器的一个实现
- `nav2_regulated_pure_pursuit_controller` | 纯追踪控制器，Nav2控制器的一个实现
- `nav2_rotation_shim_controller` | 旋转控制器

| 插件 | 描述 | 支持的机器人类型 |
| -----  | ----- | ----- |
| nav2_dwb_controller  | 基于DWA的可高度配置的实现，并提供插件接口 | 差分式、全向式、腿足式 |
| TEB Controller | 一个类似MPC的控制器，适用于阿克曼式、差分式和具备完整约束的机器人。 | **阿克曼式（Ackermann）**、腿足式、全向式、差分式  | 	
| nav2_regulated_pure_pursuit_controller | 针对服务/工业机器人在追踪算法的基础上增加了自适应性。 |  **阿克曼式（Ackermann）**、腿足式、差分式 | 	
| nav2_rotation_shim_controller | 在主控制器进行路径跟踪之前， "shim" 控制器负责将机器人旋转到路径的方向。 |  差速式，全向式、模型旋转到位 | 	

## nav2_controller

### 控制服务

- **ControllerServer**：控制服务器，继承于`nav2_util::LifecycleNode`，该类托管不同算法的各种插件，从公开的 `FollowPath` 操作服务器完成控制任务。
    - 重要属性
      ```text
        // The controller needs a costmap node,                                                           代价地图相关
        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;
        std::unique_ptr<nav2_util::NodeThread> costmap_thread_;
      
        // Publishers and subscribers
        std::unique_ptr<nav_2d_utils::OdomSubscriber> odom_sub_;                                          odom订阅
        rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>::SharedPtr vel_publisher_;        速度发布
        rclcpp::Subscription<nav2_msgs::msg::SpeedLimit>::SharedPtr speed_limit_sub_;                     限速订阅
      
        // Progress Checker Plugin                                                                        进度检查插件
        pluginlib::ClassLoader<nav2_core::ProgressChecker> progress_checker_loader_;                      进度检查插件加载器
        nav2_core::ProgressChecker::Ptr progress_checker_;                                                速度检查
        std::string default_progress_checker_id_;                                                     
        std::string default_progress_checker_type_;
        std::string progress_checker_id_;
        std::string progress_checker_type_;
      
        // Goal Checker Plugin                                                                            目标检查插件
        pluginlib::ClassLoader<nav2_core::GoalChecker> goal_checker_loader_;                              目标检查插件加载器
        GoalCheckerMap goal_checkers_;                                                                    目标检查插件Map
        std::vector<std::string> default_goal_checker_ids_;
        std::vector<std::string> default_goal_checker_types_;
        std::vector<std::string> goal_checker_ids_;
        std::vector<std::string> goal_checker_types_;
        std::string goal_checker_ids_concat_, current_goal_checker_;
      
        // Controller Plugins                                                                             控制器插件
        pluginlib::ClassLoader<nav2_core::Controller> lp_loader_;                                         控制器插件加载器
        ControllerMap controllers_;                                                                       控制器插件Map
        std::vector<std::string> default_ids_;
        std::vector<std::string> default_types_;
        std::vector<std::string> controller_ids_;
        std::vector<std::string> controller_types_;
        std::string controller_ids_concat_, current_controller_;
      ```
    - `ControllerServer`：构造函数
        - 节点名称`controller_server`
        - 初始化加载器和属性
            - `progress_checker_loader_("nav2_core", "nav2_core::ProgressChecker")`
            - `goal_checker_loader_("nav2_core", "nav2_core::GoalChecker")`
            - `lp_loader_("nav2_core", "nav2_core::Controller")`
            - `default_progress_checker_type_` -> `nav2_controller::SimpleProgressChecker`
            - `default_goal_checker_types_` -> `nav2_controller::SimpleGoalChecker`
            - `default_types_` -> `dwb_core::DWBLocalPlanner`
        - 初始化节点参数
            - `controller_frequency` -> `20.0`
            - `progress_checker_plugin` -> `progress_checker`
            - `goal_checker_plugins` -> `goal_checker`
            - `controller_plugins` -> `FollowPath`
            - `min_x_velocity_threshold` -> `0.0001`
            - `min_y_velocity_threshold` -> `0.0001`
            - `min_theta_velocity_threshold` -> `0.0001`
            - `speed_limit_topic` -> `speed_limit`
            - `failure_tolerance` -> `0.0`
        - 创建代价地图节点：`costmap_ros_ = std::make_shared<nav2_costmap_2d::Costmap2DROS>("local_costmap",...)`
    - `on_configure`：配置控制器插件，代价地图，初始化`odom`订阅，速度发布和`follow path`动作服务
        - 调用`get_parameter`获取目标检测、进度检查，控制器插件，并调用`declare_parameter_if_not_declared`设置参数
        - 获取节点相关参数
        - `costmap_ros_->configure()` -> 单独启一个线程跑代价地图节点
          `costmap_thread_ = std::make_unique<nav2_util::NodeThread>(costmap_ros_)`
        - 查询和创建进度检查实例，并调用实例`progress_checker_->initialize`
        - 查询和创建目标检查实例，并调用实例`goal_checker_->initialize`，并保存到相关Map中
        - 查询和创建控制器实例，并调用实例`controller->configure`，并保存到相关Map中
        - 创建`odom`话题订阅`odom_sub_ = std::make_unique<nav_2d_utils::OdomSubscriber>(node)`
        - 创建`cmd_vel`话题订阅`vel_publisher_ = create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 1)`
        - 创建动作服务`action_server_ = std::make_unique<ActionServer>(shared_from_this(),"follow_path",...)`
          ，绑定`computeControl`
        - 创建限速话题订阅`speed_limit_sub_ = create_subscription<nav2_msgs::msg::SpeedLimit>(speed_limit_topic,...)`
          ，绑定`speedLimitCallback`
    - `on_activate`：激活控制器，代价地图，速度发布和动作服务
        - `costmap_ros_->activate()`,`vel_publisher_->on_activate()`,`action_server_->activate()`
        - 遍历控制器插件调用插件的`activate`
        - 绑定参数变更回调，创建连接`createBond()`
    - `on_deactivate`：取消激活动作服务，控制器，代价地图和速度发布，调用之前，速度设置为0
        - `action_server_->deactivate()`
        - 遍历控制器插件调用插件的`deactivate`
        - `costmap_ros_->deactivate()`
        - 调用`publishZeroVelocity()`，使机器人停下来
        - `vel_publisher_->on_deactivate()`
        - `dyn_params_handler_.reset()`
        - `destroyBond()`
    - `on_cleanup`：控制器和代价地图清理，其余变量重置
    - `on_shutdown`：节点关闭
    - `computeControl`：`FollowPath`动作服务回调函数，处理操作和更新直到到达目标位置，接收到全局路径。 使用控制器以指定的速率计算并发布机器人的扭转速度，直到达到目标。
        - 调用`findControllerId`, `findGoalCheckerId`
        - 调用`setPlannerPath(action_server_->get_current_goal()->path);progress_checker_->reset()`
        - 以`controller_frequency_`频率循环控制
            - 动作服务为空或未激活直接返回
            - 收到取消请求，调用`publishZeroVelocity()`，然后直接返回
            - `while`循环等待代价地图直到有效
            - 调用`updateGlobalPath()`
            - 调用`computeAndPublishVelocity()`
            - 如果`isGoalReached()`，控制结束，跳出循环
            - 如果出错，调用`publishZeroVelocity()`，并结束动作，然后直接返回
        - 控制成功，调用`publishZeroVelocity()`，动作成功
    - `findControllerId`：根据请求的名称查询有效的控制器ID名称
    - `findGoalCheckerId`：根据请求的参数查询有效的目标检测ID名称
    - `setPlannerPath`：设置规划路径
        - 调用控制插件：`controllers_[current_controller_]->setPlan(path)`
        - 重置目标检测：`goal_checkers_[current_goal_checker_]->reset()`
    - `computeAndPublishVelocity`：计算速度并发布`cmd_vel`话题
        - 获取校验机器人位姿和目标位姿失败，失败抛错
        - 获取`odom`数据：`twist = getThresholdedTwist(odom_sub_->getTwist())`
        - 调用控制插件计算速度：`cmd_vel_2d = controllers_[current_controller_]->computeVelocityCommands(pose,...)`
        - 反馈信息更新
            - `feedback->speed = std::hypot(cmd_vel_2d.twist.linear.x, cmd_vel_2d.twist.linear.y)`
            - `feedback->distance_to_goal = nav2_util::geometry_utils::calculate_path_length(current_path_, find_closest_pose_idx())`
        - 发布反馈`action_server_->publish_feedback(feedback)`
        - 发布速度`publishVelocity(cmd_vel_2d)`
    - `updateGlobalPath`：收到新的路径调用`setPlannerPath`更新路径
        - 调用`findControllerId()`和`findGoalCheckerId()`，更新当前控制插件和目标检查插件
        - 调用`setPlannerPath(goal->path)`
    - `publishVelocity`：调用速度发布器发布`cmd_vel`话题，话题激活并且有订阅者，调用`vel_publisher_->publish(std::move(cmd_vel)`发布
    - `publishZeroVelocity`：调用速度发布器发布0速度，所有参数设置为0，然后调用`publishVelocity(velocity)`
    - `isGoalReached`：目标是否到达
        - 调用`getRobotPose(pose)`获取机器人位姿
        - 调用`twist = getThresholdedTwist(odom_sub_->getTwist())`获取`odom`信息
        - 调用`nav_2d_utils::transformPose(costmap_ros_->getTfBuffer(), costmap_ros_->getGlobalFrameID(), end_pose_,...)`
        - 检查是否到达调用`goal_checkers_[current_goal_checker_]->isGoalReached(pose.pose, transformed_end_pose.pose, velocity)`
    - `getRobotPose`：获取机器人当前位姿，调用`costmap_ros_->getRobotPose(current_pose)`
    - `getThresholdedVelocity`：获取单个速度阈值`(std::abs(velocity) > threshold) ? velocity : 0.0`
    - `getThresholdedTwist`：获取`Twist`速度阈值，依次调用`getThresholdedVelocity`
    - `dynamicParametersCallback`：参数变更回调
    - `speedLimitCallback`：速度限制回调，遍历控制插件，调用插件实例的`setSpeedLimit()`

### 控制相关插件

#### 进度检查插件

- **SimpleProgressChecker**：用于检查机器人的位置以确保它实际上正在朝着目标前进，继承于`nav2_core::ProgressChecker`
    - `initialize`：重写函数
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".required_movement_radius"` -> `0.5`
            - `plugin_name + ".movement_time_allowance"` -> `10.0`
        - 绑定参数回调`dynamicParametersCallback`
    - `check`：重写函数
        - 如果`!baseline_pose_set_) || (isRobotMovedEnough(current_pose2d)` -> 调用`resetBaselinePose(current_pose2d)`
        - 否则查看是否超时
    - `reset`：重写函数，`baseline_pose_set_ = false;`
    - `isRobotMovedEnough`：根据基线姿势计算机器人运动，调用`pose_distance(pose, baseline_pose_) > radius_`
    - `resetBaselinePose`：使用机器人的当前姿势重置基线姿势，第一次直接重置，后续没经过`required_movement_radius`重置更新基线位姿
    - `pose_distance`：两点距离
    - `dynamicParametersCallback`：参数变更回调
- **PoseProgressChecker**：用于检查机器人的位置和角度，以确保它实际上正在朝着目标前进或旋转，继承于`SimpleProgressChecker`
    - `initialize`：重写函数
        - 调用父类`SimpleProgressChecker::initialize(parent, plugin_name)`
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".required_movement_angle"` -> `0.5`
        - 绑定参数回调`dynamicParametersCallback`
    - `check`：重写函数，同父类
    - `isRobotMovedEnough`：根据基线姿势计算机器人运动，
      调用`pose_distance(pose, baseline_pose_) > radius_ || poseAngleDistance(pose, baseline_pose_) > required_movement_angle_`
    - `poseAngleDistance`：检查角度`abs(angles::shortest_angular_distance(pose1.theta, pose2.theta))`
    - `dynamicParametersCallback`：参数变更回调

#### 到达目标位置检查插件

- **SimpleGoalChecker**：仅检查位置差异的目标检查器插件，继承于`nav2_core::GoalChecker`
    - `initialize`：重写函数
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - `plugin_name + ".xy_goal_tolerance"` -> `0.25`
            - `plugin_name + ".yaw_goal_tolerance"` -> `0.25`
            - `plugin_name + ".stateful"` -> `true`
        - 绑定参数回调`dynamicParametersCallback`
    - `reset`：重写函数，`check_xy_ = true`
    - `isGoalReached`：重写函数
        - 查询点到目标点距离是否小于`xy_goal_tolerance**2`，小于表示进入`xy`容错范围窗口，不在检查`xy`
        - 后续继续检查角度是否满足
    - `getTolerances`：重写函数，赋值位置容错值并返回，速度相关赋值最小值
    - `dynamicParametersCallback`：参数变更回调
- **StoppedGoalChecker**：目标检查器插件，用于检查位置差和速度，继承于`SimpleGoalChecker`
    - `initialize`：重写函数
        - 调用父类`SimpleGoalChecker::initialize(parent, plugin_name, costmap_ros)`
        - 调用`declare_parameter_if_not_declared`和`get_parameter_or`初始化声明和获取节点参数
            - 旋转速度：`plugin_name + ".rot_stopped_velocity"` -> `0.25`
            - 移动速度：`plugin_name + ".trans_stopped_velocity"` -> `0.25`
        - 绑定参数回调`dynamicParametersCallback`
    - `isGoalReached`：重写函数
        - 先调用父类`SimpleGoalChecker::isGoalReached(query_pose, goal_pose, velocity)`，`false`直接返回
        - 否则检查
          `fabs(velocity.angular.z) <= rot_stopped_velocity_ && hypot(velocity.linear.x, velocity.linear.y) <= trans_stopped_velocity_`
    - `getTolerances`：重写函数，调用父类`getTolerances`，然后赋值速度容错值并返回
    - `dynamicParametersCallback`：参数变更回调

## nav2_dwb_controller

`DWB` 控制器是 `ROS1` 中基本局部规划器（`base local planner`）和 `DWA` 控制器的后继者。它是由 `David Lu` 在 `Locus Robotics`
公司作为 `robot_navigation` 项目的一部分在 `ROS 1` 中创建的。然后，它被移植到 `ROS 2` 中，用作 `Nav2` 中的基于评论的控制器算法。

DWB 在几个重要方面对 DWA 进行了改进：

- 它实现了基于插件的评论器（`critic`），允许用户指定新的评论函数来在系统中使用。这些评论器可以动态重新配置、重新加权和调整，以获得在机器人系统中非常特定的行为。
- 它实现了基于插件的轨迹生成技术，使用户可以以任意方式生成轨迹，适用于任意类型的车辆。
- 包括许多常见用途的插件实现。

可以调整 `DWB` 以获得 `DWA` 和基本局部规划器行为，也可以通过新插件扩展到完全特定用例的行为。当前的轨迹生成器插件适用于全向和差分驱动机器人，尽管添加 阿克曼式（Ackermann）
生成器将是微不足道的。当前的评论器插件适用于圆形和非圆形机器人，并包括构建具有各种属性的路径跟踪系统所需的许多成本函数。

### DWB 插件

DWB 通过插件的使用进行高度配置。有三种类型的插件用于：

- 轨迹生成器插件：这些插件生成应由评论器评估的可能轨迹集。得分最高的轨迹确定输出的命令速度。`Navigation 2` 提供了两种轨迹生成器。一次只能加载一个。
    - `StandardTrajectoryGenerator` - 这类似于 `ROS 1` 中的 `base_local_planner` 中使用的轨迹滚动算法。
    - `LimitedAccelGenerator` - 这类似于 `ROS 1` 中使用的 `DWA`。
- 评论器插件：这些插件根据轨迹生成器生成的轨迹进行评分。可以加载多个插件，其得分之和确定了选择的命令速度。
    - `BaseObstacle` - 根据路径通过的代价地图上的位置对轨迹进行评分。要正确使用这个插件，必须使用代价地图中的膨胀层，将障碍物扩展到机器人的半径范围内。
    - `ObstacleFootprint` - 根据验证机器人轮廓中的所有点是否触碰代价地图中标记的障碍物来对轨迹进行评分。
    - `GoalAlign` - 根据轨迹与目标姿态的对齐程度对轨迹进行评分。
    - `GoalDist` - 根据轨迹使机器人靠近目标姿态的程度对轨迹进行评分。
    - `PathAlign` - 根据轨迹与全局规划器提供的路径的对齐程度对轨迹进行评分。
    - `PathDist` - 根据轨迹距离全局规划器提供的路径的距离对轨迹进行评分。
    - `PreferForward` - 更高分的轨迹是将机器人前进的轨迹。
    - `RotateToGoal` - 只有当机器人足够靠近目标位置时，才允许机器人旋转到目标方向。
    - `Oscillation` - 防止机器人只是前后移动。
    - `Twirling` - 防止全向机器人在前往目标的过程中旋转。

#### dwb_core

- 异常类
    - **PlannerTFException**：当规划器由于 `TF` 错误而无法完成其操作时抛出，继承于`nav2_core::PlannerException`
    - **IllegalTrajectoryException**：当评论者之一遇到致命错误时抛出，继承于`nav2_core::PlannerException`
        - `getCriticName`：获取评论者名称

- 辅助函数
    - **getClosestPose**：找到轨迹中具有特定时间 `time_offset` 的位姿
    - **projectPose**：通过在现有姿势之间进行线性插值来创建具有精确 `time_offset` 的位姿

- 非法轨迹跟踪工具
    - **IllegalTrajectoryTracker**：非法轨迹跟踪器类
        - `addIllegalTrajectory`：添加非法轨迹计数
        - `addLegalTrajectory`：添加合法轨迹计数
        - `getPercentages`：获取非法轨迹百分比
        - `getMessage`：获取合法和非法轨迹数量字符串
    - **NoLegalTrajectoriesException**：当所有探索的轨迹都不合法时抛出的异常类，继承于`nav2_core::PlannerException`

- 轨迹相关类
    - **TrajectoryGenerator**：用于迭代可能的速度并创建轨迹的接口(元类)
        - 此类定义了两个独立但相关组件的插件接口，这两个组件都严重依赖于机器人的运动学模型，并且可以共享许多参数，这就是为什么它们被分组到一个类中的原因
            - 一个迭代器接口，用于探索给定当前速度时要搜索的所有速度
            - 一个独立的接口，用于从扭矩创建轨迹，即将其在时间和空间中投射出来
        - `TrajectoryGenerator`：构造函数
        - `initialize`：纯虚函数，初始化所需的参数
        - `reset`：
        - `startNewIteration`：纯虚函数，基于当前速度开始新迭代
        - `hasMoreTwists`：纯虚函数，是否还有更多的刚体运动(速度)
        - `nextTwist`：纯虚函数，获取下一个刚体运动(速度)，并进行迭代
        - `getTwists`：获得迭代的所有刚体运动(速度)。注意：如果迭代器正在处理中，则重置迭代器
            - 调用`startNewIteration`
            - 循环调用`hasMoreTwists`，调用`twists.push_back(nextTwist())`加入数组，最后返回
        - `generateTrajectory`：纯虚函数，根据给定机器人坐标系中的 `cmd_vel` 和初始条件，生成 `Trajectory2D`
        - `setSpeedLimit`：纯虚函数，设置机器人最大的线速度
    - **TrajectoryCritic**：轨迹评论者类，评估 `Trajectory2D` 以生成分数
        - 定义了 `TrajectoryCritic` 的插件接口，用于给轨迹打分，其中较低的数字更好，但负分被视为无效。 一般的生命周期如下
            - `initialize` 在开始时调用一次，它反过来调用 `onInit`。派生类可以重写 `onInit` 来根据需要加载参数。
            - `prepare` 在每组轨迹之前调用一次。假设有多个我们想要评估的轨迹，并且可能有一些共享的工作可以在评估每个单独的轨迹之前进行优化。
            - `scoreTrajectory` 每个轨迹调用一次，并返回分数。
            - `debrief` 在每组轨迹之后调用，带有选择的轨迹。这可以用于监视轨迹通过时间的有状态评判者。
            - 可选项，对于某些类型的评判者，还有一种调试机制在 `addCriticVisualization` 方法中。如果轨迹的分数取决于它与成本地图的关系，`addCriticVisualization`
              可以向 `dwb_core` 提供该信息， `dwb_core` 将其发布为 `PointCloud2` 的网格分数。
        - `initialize`：初始化轨迹评论者
            - 初始化参数
                - `dwb_plugin_name_ + "." + name_ + ".scale"` -> `1.0`
                - 调用`onInit()`
        - `onInit`：
        - `reset`：重置评论者状态，当规划收到一个新的全局规划时，会被调用，这可以用于丢弃一个特定的规划信息
        - `prepare`：在评估任何轨迹之前，请查看所有轨迹中恒定的上下文信息，派生类可能会重写，如果有错返回`false`
        - `scoreTrajectory`：返回轨迹原始评分，分数小于0，无效，比如碰撞，这是原始分数，缩放不会应用到它上
        - `debrief`：汇报告诉批评者所选择的 `cmd_vel` 是什么（如果它关心的话）
        - `addCriticVisualization`：虚函数，将给定的点云信息添加到用于调试成本地图网格分数的指定点云中
        - `getName`：获取轨迹评论者名称
        - `getScale`：获取缩放
        - `setScale`：设置缩放
    - **DWBPublisher**：`DWB`本地规划器所有发布逻辑的整合。
        - 发布包括以下
            - 全局规划（通过 `setPath` 传入）
            - 本地规划（在计算后）
            - 转换后的全局规划（因为它可能与全局规划不同）
            - 完整的本地规划评估
            - 表示不同评估轨迹的标记
            - 成本网格（以复杂的 `PointCloud2` 形式）
        - `DWBPublisher`：构造函数
        - `on_configure`：
            - 初始化声明和获取参数
                - `plugin_name_ + ".publish_evaluation"` -> `true`
                - `plugin_name_ + ".publish_global_plan"` -> `true`
                - `plugin_name_ + ".publish_transformed_plan"` -> `true`
                - `plugin_name_ + ".publish_local_plan"` -> `true`
                - `plugin_name_ + ".publish_local_plan"` -> `true`
                - `plugin_name_ + ".publish_trajectories"` -> `true`
                - `plugin_name_ + ".publish_cost_grid_pc"` -> `false`
                - `plugin_name_ + ".marker_lifetime"` -> `0.1`
            - 创建上述话题发布实例
        - `on_activate`：调用发布器的`on_activate`
        - `on_deactivate`：调用发布器的`on_deactivate`
        - `on_cleanup`：调用发布器的`reset`
        - `shouldRecordEvaluation`：发布者是否要求保存 `LocalPlanEvaluation`
        - `publishEvaluation`：完整的本地规划评估
            - `publish_evaluation_ && eval_pub_->get_subscription_count() > 0`为真，则调用`publish`发布评估话题
            - 然后调用`publishTrajectories`
        - `publishLocalPlan(const std_msgs::msg::Header & header, const dwb_msgs::msg::Trajectory2D & traj)`：本地规划（在计算后）
            - 调用`nav_2d_utils::poses2DToPath`
            - 然后调用对应的话题实例的`publish`
        - `publishCostGrid`：发布成本网格，具体查看代码
        - `publishGlobalPlan`：全局规划（通过 `setPath` 传入），调用`publishGenericPlan`
        - `publishTransformedPlan`：发布转换后的全局规划，调用`publishGenericPlan`
        - `publishLocalPlan(const nav_2d_msgs::msg::Path2D plan)`：完整的本地规划评估，调用`publishGenericPlan`
        - `publishTrajectories`：表示不同评估轨迹的标记，组装相关数据，然后调用对应的话题实例的`publish`
        - `publishGenericPlan`：发布通用规划，根据传入的发布实例和标识发布规划
    - **DWBLocalPlanner**：`DWB`局部规划，基于插件的灵活控制器，继承于`nav2_core::Controller`
        - `DWBLocalPlanner`：构造函数
        - `configure`：
            - 初始化声明配置参数
                - `dwb_plugin_name_ + ".critics"` -> `rclcpp::PARAMETER_STRING_ARRAY`
                - `dwb_plugin_name_ + ".default_critic_namespaces"` -> `std::vector<std::string>())`
                - `dwb_plugin_name_ + ".prune_plan"` -> `true`
                - `dwb_plugin_name_ + ".prune_distance"` -> `2.0`
                - `dwb_plugin_name_ + ".forward_prune_distance"` -> `2.0`
                - `dwb_plugin_name_ + ".debug_trajectory_details"` -> `false`
                - `dwb_plugin_name_ + ".trajectory_generator_name"` -> `dwb_plugins::StandardTrajectoryGenerator`
                - `dwb_plugin_name_ + ".transform_tolerance"` -> `0.1`
                - `dwb_plugin_name_ + ".shorten_transformed_plan"` -> `true`
                - `dwb_plugin_name_ + ".short_circuit_trajectory_evaluation"` -> `true`
            - 创建发布实例`pub_ = std::make_unique<DWBPublisher>(node, dwb_plugin_name_)` -> 并配置`pub_->on_configure()`
            - 创建轨迹生成插件实例`traj_generator_ = traj_gen_loader_.createUniqueInstance(traj_generator_name)` ->
              并初始化`traj_generator_->initialize(node, dwb_plugin_name_)`
            - 调用`loadCritics()`
        - `activate`：调用`DWBPublisher`的`on_activate`
        - `deactivate`：调用`DWBPublisher`的`on_deactivate`
        - `cleanup`：调用`DWBPublisher`的`on_cleanup`
        - `setPlan`：设置全局规划
            - 调用`path2d = nav_2d_utils::pathToPath2D(path)`
            - 遍历评论家插件调用插件的`reset`
            - 调用`traj_generator_->reset()`
            - 发布路径调用`pub_->publishGlobalPlan(path2d)`
        - `computeVelocityCommands`：根据给定的速度和位姿，计算最佳的命令
            - 如果`pub_->shouldRecordEvaluation()`，初始化`msg`
            - 调用第二个重载函数`cmd_vel2d = computeVelocityCommands`
            - 发布评估`pub_->publishEvaluation(results)`
            - 调用`nav_2d_utils::twist2Dto3D(cmd_vel2d.velocity)`，返回速度结果
        - `scoreTrajectory`：利用评论家给给定的轨迹命令打分
            - 遍历评论家
            - 如果`critic->getScale() == 0.0` 跳过，下一个评论家
            - 调用`critic_score = critic->scoreTrajectory(traj)`打分
            - 然后分数累加，如果累加分数打印最佳的分数，`break`停止遍历评论，返回分数，再遍历评论无意义了
        - `computeVelocityCommands`：根据给定的速度和位姿，计算最佳的命令
            - 调用`prepareGlobalPlan`
            - 遍历评论家，调用`critic->prepare`
            - 调用`best = coreScoringAlgorithm`获取最好的轨迹指令
            - 组装返回值`cmd_vel`
            - 遍历评论家，调用`critic->debrief`
            - 发布：`pub_->publishLocalPlan(pose.header, best.traj)`
            - 发布：`pub_->publishCostGrid(costmap_ros_, critics_)`
        - `setSpeedLimit`：设置最大线速度，
          调用轨迹生成实例的`TrajectoryGenerator::Ptr traj_generator_->setSpeedLimit(speed_limit, percentage)`
        - `prepareGlobalPlan`：相对于姿势变换全局规划（存储在 `global_plan_ `中的）并将其保存在 `transformed_plan` 中并可能发布它。
          然后它采用最后一个姿势并将其转换以匹配本地成本图
            - 调用`transformGlobalPlan`
            - 调用`nav_2d_utils::transformPose`转换坐标
        - `coreScoringAlgorithm`：迭代所有的刚体运动(`twists`)并找到最好的一个
            - 调用`traj_generator_->startNewIteration(velocity)`
            - `traj_generator_->hasMoreTwists()`开启`while`循环
                - 获取下一个`twist`，调用`twist = traj_generator_->nextTwist()`
                - 生成轨迹，调用`traj = traj_generator_->generateTrajectory(pose, velocity, twist)`
                - 打分，调用`score = scoreTrajectory(traj, best.total)`
                - 添加到数组，设置最好和最差分数索引
                - 出错打印日志抛错，否则返回最好的轨迹信息
        - `transformGlobalPlan`：将全局规划转换为与给定姿态相同的坐标系，裁剪远处的姿态，可能修剪已经通过的姿态
            - 三个关键操作
                - 将全局规划转换为给定姿态的坐标系
                - 仅返回靠近机器人的姿态，即它们可能在本地代价地图上
                - 如果 `prune_plan_` 为 `true`，则会从转换后的规划和保存的全局规划中移除已经通过的所有点。
            - 在技术上，它会迭代到路径上与机器人距离小于 `prune_distance_` 的姿态，并擦除之前的所有姿态。
            - 此外，`shorten_transformed_plan_` 确定是否将完整规划传递到导航目标上，或者仅传递靠近机器人的一部分规划。
                - `True` 表示仅传递一部分。这给了 `DWB` 较少的自由来决定如何到达导航目标。
                - 相反，它被鼓励尝试进入全局规划生成的路径。
            - 详细步骤
                - 首先，它对传入的全局规划进行了一些基本的有效性检查，例如检查全局规划是否为空。
                - 然后，它将机器人当前的姿态从机器人所在的坐标系转换为全局规划使用的坐标系。这一步确保了机器人当前的位置是以与全局规划相同的坐标系表示的。
                - 接下来，它计算了两个阈值，用于决定要保留的全局规划的部分。其中一个阈值用于确定在机器人附近的规划部分，而另一个阈值用于确定机器人已经通过的规划部分。
                - 随后，它根据这些阈值在全局规划中找到机器人附近的部分，并将其转换为机器人所在的坐标系。转换后的部分被存储在 `transformed_plan` 中。
                - 最后，根据是否启用了 `prune_plan_`，它可能会从全局规划中删除已经通过的部分，并将新的全局规划发布出去。
                - 函数返回转换后的部分，以便后续的规划评估。
        - `resolveCriticClassName`：尝试使用默认命名空间和后缀`Critic`解析可能缩短的评论家名称
        - `loadCritics`：从命名空间加载评论家参数
            - 初始化声明评论家节点参数
            - 获取插件类名`plugin_class = resolveCriticClassName(plugin_class)`
            - 插件插件实例：`TrajectoryCritic::Ptr plugin = critic_loader_.createUniqueInstance(plugin_class)`
            - 插件初始化`plugin->initialize`

#### 轨迹生成器插件

- 运动学相关
    - **KinematicParameters**：包含机器人运动学的一种表示的结构体
    - **KinematicsHandler**：管理机器人运动学表示的类
        - `KinematicsHandler`：构造函数，`new`一个`KinematicParameters`数据
        - `initialize`：初始化
            - 参数不存在则初始化声明节点参数，然后获取参数，设置运动学结构体
            - 绑定参数变更回调
            - 调用`update_kinematics(kinematics)`
        - `getKinematics`：返回运动学结构体指针
        - `setSpeedLimit`：设置速度限制，最后调用`update_kinematics(kinematics)`
        - `dynamicParametersCallback`：参数变更回调
        - `update_kinematics`：更新运动学信息，重新`new`一个`KinematicParameters`数据
- 速度迭代器
    - **projectVelocity**：辅助内联函数，用于计算在给定初始条件和时间后的结束速度。
    - **OneDVelocityIterator**：用于在给定范围内生成一系列速度样本的迭代器。主要用于在机器人运动控制中选择合适的速度。
        - `OneDVelocityIterator`：构造函数，根据给定的参数初始化迭代器，计算可达速度范围并确定样本数量
        - `getVelocity`：获取当前迭代器位置的速度值。
        - `operator++`：使迭代器前进到下一个速度样本
        - `reset`：将迭代器重置到第一个速度样本
        - `isFinished`：检查是否已经返回所有速度样本
    - **VelocityIterator**：速度迭代器抽象类
        - `initialize`：纯虚函数，初始化
        - `startNewIteration`：纯虚函数，开始新的迭代
        - `hasMoreTwists`：纯虚函数，是否还有`twist`
        - `nextTwist`：纯虚函数，下个`twist`
    - **XYThetaIterator**：速度迭代器实现类，继承于`VelocityIterator`
        - `initialize`：重写函数
            - 入参`KinematicsHandler::Ptr kinematics_handler_ = kinematics`
            - 初始化声明节点参数
                - `plugin_name + ".vx_samples"` -> `20`
                - `plugin_name + ".vy_samples"` -> `5`
                - `plugin_name + ".vtheta_samples"` -> `20`
        - `startNewIteration`：重写函数
            - 初始化`x`迭代器`x_it_ = std::make_shared<OneDVelocityIterator>(current_velocity.x,...)`
            - 初始化`y`迭代器`y_it_ = std::make_shared<OneDVelocityIterator>(current_velocity.y,...)`
            - 初始化`theta`迭代器`th_it_ = std::make_shared<OneDVelocityIterator>(current_velocity.theta,...)`
            - 调用`isValidVelocity()`，失败调用`iterateToValidVelocity()`
        - `hasMoreTwists`：重写函数，`x_it_ && !x_it_->isFinished()`
        - `nextTwist`：重写函数，获取当前`x/y/theta`速度，调用`iterateToValidVelocity()`，最后返回获取的速度
        - `isValidSpeed`：检查组合的 `x/y/theta` 速度是否有效，校验最小值最大值
        - `isValidVelocity`：检查组合的 `x/y/theta`
          速度是否有效，调用`isValidSpeed(x_it_->getVelocity(), y_it_->getVelocity(), th_it_->getVelocity())`
        - `iterateToValidVelocity`：检查组合的 `x/y/theta` 速度是否有效
            - 调用`!valid && hasMoreTwists()`是否需要开启`while`循环进行迭代
            - `++(*th_it_)`
                - `th_it_->isFinished()` -> `th_it_->reset()` -> `++(*y_it_)`
                    - `y_it_->isFinished()` -> `y_it_->reset()` -> `++(*x_it_)`
            - `valid = isValidVelocity()`

- 轨迹生成类
    - **StandardTrajectoryGenerator**：类似 `DWA` 的标准轨迹生成器。继承于`dwb_core::TrajectoryGenerator`
        - `initialize`：重写函数
            - 初始化`kinematics_handler_ = std::make_shared<KinematicsHandler>()`
              -> `kinematics_handler_->initialize(nh, plugin_name_)`
            - 调用`initializeIterator(nh)`
            - 初始化声明参数
                - `plugin_name + ".sim_time"` -> `1.7`
                - `plugin_name + ".discretize_by_time"` -> `false`
                - `plugin_name + ".time_granularity"` -> `0.5`
                - `plugin_name + ".linear_granularity"` -> `0.5`
                - `plugin_name + ".angular_granularity"` -> `0.025`
                - `plugin_name + ".include_last_point"` -> `true`
        - `startNewIteration`：重写函数，调用`velocity_iterator_->startNewIteration`
        - `hasMoreTwists`：重写函数，调用`velocity_iterator_->hasMoreTwists()`
        - `nextTwist`：重写函数，调用`velocity_iterator_->nextTwist()`
        - `generateTrajectory`：重写函数，仿真模拟生成轨迹
            - 调用`getTimeSteps`获取时间步长
            - 遍历时间步长
                - 计算速度`vel = computeNewVelocity(cmd_vel, vel, dt)`
                - 使用上面计算的速度计算新位置`pose = computeNewPosition(pose, vel, dt)`
                - 添加轨迹点和时间偏移量，最后返回轨迹
        - `setSpeedLimit`：重写函数，调用`kinematics_handler_->setSpeedLimit`
        - `initializeIterator`：虚函数，初始化 `VelocityIterator` 指针。 放入自己的函数以便于覆盖
            - 初始化速度迭代器`velocity_iterator_ = std::make_shared<XYThetaIterator>()`
            - 速度迭代器初始化`velocity_iterator_->initialize`
        - `computeNewVelocity`：虚函数，给定所需的速度和加速度限制，计算一段设定时间后的速度，调用`projectVelocity`
        - `computeNewPosition`：虚函数，使用机器人的运动学模型来预测机器人的新位置
        - `getTimeSteps`：虚函数，计算生成轨迹中各点之间的时间增量数组。更新速度等相关参数生成轨迹所需的时间步长
    - **LimitedAccelGenerator**：将生成轨迹的加速度限制为模拟时间的一小部分。继承于`StandardTrajectoryGenerator`
        - `initialize`
            - 调用`StandardTrajectoryGenerator::initialize`
            - 初始化声明参数：`plugin_name + ".sim_period"`->`PARAMETER_DOUBLE`
        - `startNewIteration`：调用`velocity_iterator_->startNewIteration`
        - `computeNewVelocity`：给定所需的速度和加速度限制，与 `StandardTrajectoryGenerator` 不同，
          `LimitedAccelGenerator` 中的速度保持恒定，计算一段设定时间后的速度。`return cmd_vel`

#### 评论器插件

- 评论家工具
    - **getForwardPose**：函数，将给定姿势沿 `x` 方向向前投影指定距离。
    - **getOrientedFootprint**：函数，将足迹转换为以给定姿势为中心。

- 评论家
    - **BaseObstacleCritic**：使用`costmap 2d`来分配负成本，如果圆形机器人在轨迹的任何点都会碰撞。继承于`dwb_core::TrajectoryCritic`
        - 该类只能用于确定圆形机器人是否发生碰撞。如果与轨迹中的任何姿势对应的单元格是障碍物、内切障碍物或未知的，它将返回一个负成本。 否则，它将返回最终姿势的成本，或者所有姿势的总和，取决于`sum_scores`参数。
        - 其他类（如`ObstacleFootprintCritic`）可以进行更高级的碰撞检查。
        - `onInit`：重写函数，初始化节点参数，为`true`累加评分：`dwb_plugin_name_ + "." + name_ + ".sum_scores"` -> `false`
        - `scoreTrajectory`：重写函数，遍历传入的轨迹，调用`scorePose`，根据`sum_scores`计算分数
        - `addCriticVisualization`：重写函数，代价可视化
        - `scorePose`：
            - 调用`costmap_->worldToMap`世界坐标转代价地图坐标
            - 调用`cost = costmap_->getCost(cell_x, cell_y)`获取代价
            - 调用`isValidCost(cost)`
        - `isValidCost`
          ：`cost != nav2_costmap_2d::LETHAL_OBSTACLE && cost != nav2_costmap_2d::INSCRIBED_INFLATED_OBSTACLE && cost != nav2_costmap_2d::NO_INFORMATION;`
    - **ObstacleFootprintCritic**：继承于`BaseObstacleCritic`，一个更健壮的类可以在不膨胀障碍物的情况下检查机器人足迹内的每个单元格，但会增加一些计算成本。
        - `prepare`：重写函数，校验是否有`footprint`
        - `scorePose(const geometry_msgs::msg::Pose2D & pose)`：重写函数
            - 转换坐标调用`costmap_->worldToMap`
            - 然后调用`scorePose(pose, getOrientedFootprint(pose, footprint_spec_))`
        - `scorePose(const geometry_msgs::msg::Pose2D & pose, const Footprint & oriented_footprint)`：虚函数
            - 遍历`footprint`，调用`costmap_->worldToMap`，调用`lineCost()`获取线代价，返回最大的线代价
        - `getScale`：重写函数，`return costmap_->getResolution() * scale_;`
        - `lineCost`：线代价，迭代线上的点`LineIterator`，调用`pointCost()`获取点代价，返回最大的代价
        - `pointCost`：点代价
            - 调用`cost = costmap_->getCost`获取代价
            - 如果等于`nav2_costmap_2d::LETHAL_OBSTACLE`和`nav2_costmap_2d::NO_INFORMATION`抛错，否则返回代价值
    - **MapGridCritic**：对`costmap`中所有单元格进行广度优先评分。继承于`dwb_core::TrajectoryCritic`
        - `onInit`：重写函数
            - 初始化`queue_ = std::make_shared<MapGridQueue>(*costmap_ros_->getCostmap(), *this)`
            - 初始化声明参数
                - `dwb_plugin_name_ + "." + name_ + ".aggregation_type"` -> `last`
        - `scoreTrajectory`：重写函数
            - 根据`aggregation_type`初始化开始轨迹点索引
            - 遍历轨迹点，调用`scorePose`
            - 根据`aggregation_type`处理分数返回
        - `addCriticVisualization`：重写函数，代价可视化
        - `getScale`：重写函数，`costmap_->getResolution() * 0.5 * scale_;`
        - `scorePose`：虚函数，检索单个位置的分数，调用`costmap_->worldToMap` -> `getScore(cell_x, cell_y)`
        - `getScore`：检索成本图特定单元格的分数，`cell_values_[costmap_->getIndex(x, y)]`
        - `setAsObstacle`：将特定单元格的分数设置为障碍代价值
        - **ScoreAggregationType**：分数聚合类型枚举
            - `Last`：轨迹最后一个位置的分数
            - `Sum`：所有分数和
            - `Product`：返回所有（非零）分数的乘积
        - **MapGridQueue**：地图网格队列类，继承于`costmap_queue::CostmapQueue`
            - `validCellToQueue`：重写函数，`return true`
        - `reset`：重写函数，重置属性数据
        - `propogateManhattanDistances`：遍历队列并将单元格设置为距父母的曼哈顿距离
            - `queue_->isEmpty()`
                - `CellData cell = queue_->getNextCell()`
                - `cell_values`
                  初始化，`cell_values_[cell.index_] = CellData::absolute_difference(cell.src_x_, cell.x_) + CellData::absolute_difference(cell.src_y_, cell.y_)`
    - **GoalDistCritic**：距离评论器，继承于`MapGridCritic`
        - `prepare`：重写函数
            - 调用`reset()`
            - 调用`getLastPoseOnCostmap()`获取在代价地图中最后一个点，入单元格队列
            - 调用`propogateManhattanDistances()`
        - `getLastPoseOnCostmap`：找到轨迹路径中在代价地图中的最后一个点坐标
            - 调用`nav_2d_utils::adjustPlanResolution(global_plan,costmap_->getResolution())`，填充轨迹，根据适配代价地图分配率填充轨迹
            - 遍历填充后的轨迹，找到在代价地图中最后一个点
    - **GoalAlignCritic**：距离评论器，类似`GoalDistCritic`，继承于`MapGridCritic`
        - 新增了一个`forward_point_distance_`参数
        - `onInit`：重写函数
            - 调用`nav_2d_utils::searchAndGetParam`，获取`dwb_plugin_name_ + "." + name_ + ".forward_point_distance"`
              -> `0.325`
        - `prepare`：重写函数，修改路径最后一个点，往前`forward_point_distance_`
          距离，然后调用父类方法`GoalDistCritic::prepare(pose, vel, goal, target_poses)`
        - `scorePose`：重写函数，`GoalDistCritic::scorePose(getForwardPose(pose, forward_point_distance_))`
    - **PathDistCritic**：全局轨迹根据代价地图分辨率填充评论器，继承于`MapGridCritic`
        - `prepare`：重写函数
            - 调用`reset()`
            - 调用`nav_2d_utils::adjustPlanResolution(global_plan,costmap_->getResolution())`，填充轨迹，根据适配代价地图分配率填充轨迹
            - 遍历填充后的轨迹，将全局路径点放入单元格队列，直到达到本地地图的边界。
            - 调用`propogateManhattanDistances()`
    - **PathAlignCritic**：继承于`PathDistCritic`
        - 新增了一个`forward_point_distance_`和`zero_scale_`参数
            - `onInit`：重写函数
                - 调用`PathDistCritic::onInit()`
                - 调用`nav_2d_utils::searchAndGetParam`，获取`dwb_plugin_name_ + "." + name_ + ".forward_point_distance"`
                  -> `0.325`
            - `prepare`：重写函数，
                - 如果机器人当前位置到目标位置距离小于`forward_point_distance_`的平方，`zero_scale_=true`，直接返回`true`
                - 否则`zero_scale_=false`，调用父类方法`GoalDistCritic::prepare(pose, vel, goal, target_poses)`
            - `getScale`：重写函数
                - `zero_scale_=true`：返回`0`
                - `zero_scale_=true`：返回`costmap_->getResolution() * 0.5 * scale_`
            - `scorePose`：重写函数，`GoalDistCritic::scorePose(getForwardPose(pose, forward_point_distance_))`
    - **OscillationCritic**：检查命令速度的符号是否频繁翻转震荡(速度方向正负变化)，继承于`dwb_core::TrajectoryCritic`
        - 该评价器通过检查命令的轨迹是否振荡来判断，即看看是否有一个维度（`x、y、theta`）从正变为负，然后再变回正（或反之），而没有移动足够远或等待足够长的时间。
            - 情况1：机器人向前移动一米，然后向后移动两毫米。另一个前进的动作将被视为振荡，因为x维度将从正变为负，然后再次变为负。因此，在评分不同的轨迹时，正的速度命令将获得振荡分数（`-5.0`
              ，或无效），只有负的速度命令将被视为有效。
            - 情况2：机器人向前移动一米，然后向后移动一米。因此，机器人在x方向的符号翻转后移动了一米，这大于我们的振荡重置距离，因此它不被认为是振荡的，因此所有轨迹都被视为有效。
            - 注意：评价器只会在某个特定值（`x_only_threshold_`）超过时检查`x`维度的振荡。
            - 如果它下降到该幅度以下，它还将检查`y`和`theta`维度的振荡。
            - 如果`x_only_threshold_`为负，则评价器将始终检查所有维度。
        - 实现细节：
            - 评价器在准备时保存机器人的当前位置以及在详细说明步骤中实际的命令速度是什么。
            - 在详细说明时，如果任何维度的符号自上次命令以来发生了翻转，则将位置保存为`prev_stationary_pose_`。
            - 如果从`prev_stationary_pose_`到当前姿态的线性或角距离超出了限制，则振荡标志将被重置，以便不再记住先前的符号更改。
            - 这假设`oscillation_reset_dist_`或`oscillation_reset_angle_`为正。否则，它将使用基于时间的延迟重置函数。
        - `onInit`：重写函数
            - 初始化节点参数，`nav_2d_utils::searchAndGetParam`
                - `dwb_plugin_name_ + "." + name_ + ".oscillation_reset_dist"` -> `0.05`
                - `dwb_plugin_name_ + "." + name_ + ".oscillation_reset_angle"` -> `0.2`
                - `dwb_plugin_name_ + "." + name_ + ".oscillation_reset_time"` -> `-1.0`
                - `dwb_plugin_name_ + "." + name_ + ".x_only_threshold"` -> `0.05`
            - 调用`reset()`
        - `prepare`：重写函数
        - `scoreTrajectory`：重写函数，调用`x,y,theta`的`isOscillating`，只要有一个为真，抛错，表明有震荡，否则返回`0`分
        - `reset`：重写函数，调用`x_trend_.reset()`、` y_trend_.reset()`、`theta_trend_.reset()`
        - `debrief`：重写函数
            - 调用`setOscillationFlags(cmd_vel)` -> 设置`prev_stationary_pose_`和`prev_reset_time_`
            - 调用`x,y,theta`的`hasSignFlipped()`如果在检测
                - 调用`resetAvailable()`，如果走了足够远或超过足够时间，则调用`reset()`
        - `setOscillationFlags`：给定已选择的命令，跟踪每个组件的符号以检测振荡。
            - 前进和后退的时候，`flag_set |= x_trend_.update(cmd_vel.x)`
            - 否则根据参数阈值更新`y和theta` -> `x_only_threshold_ < 0.0 || fabs(cmd_vel.x) <= x_only_threshold_`
                - `flag_set |= y_trend_.update(cmd_vel.y)`
                - `flag_set |= theta_trend__.update(cmd_vel.theta)`
        - `resetAvailable`：如果机器人已经移动了足够远或等待了足够长的时间，则返回 `true`。
        - **CommandTrend**：用于在 `x`、`y` 和 `theta` 维度上执行相同逻辑的辅助类
            - `CommandTrend`：调用`reset()`
            - `reset`：重置属性
            - `update`：更新设置相关`flag`
            - `isOscillating`：检查所提出的速度是否会被视为振荡，`positive_only_ && velocity < 0.0) || (negative_only_ && velocity > 0.0`
            - `hasSignFlipped`：检查我们当前是否正在跟踪一个翻转的符号，`positive_only_ || negative_only_`

#### 代价地图工具

- **MapBasedQueue**：优先级队列模板类
    - `MapBasedQueue`：构造函数，调用`reset`
    - `reset`：清空队列
    - `enqueue`：入队
    - `isEmpty`：队列是否为空
    - `front`：返回队列最前元素
    - `pop`：移除并销毁最前元素

- **CellData**：单元格数据
    - `absolute_difference`：差值

- **CostmapQueue**：代价地图队列，继承于`MapBasedQueue`
    - `CostmapQueue`：构造函数，调用`reset`
    - `reset`：清空队列
        - 调用`computeCache()`
        - 调用`MapBasedQueue::reset()`
    - `enqueueCell`：单元格数据入队，调用`enqueueCell(index, x, y, x, y)`
    - `getNextCell`：获取下一个要检查的单元格，并根据需要将其邻居排队
        - 调用`front()`和`pop()`
        - 调用`enqueueCell()`把上下左右入队
    - `validCellToQueue`：检查我们是否应该将此单元添加到队列中，该方法永远`true`除非子类重写
    - `enqueueCell`：使用给定的坐标和给定的源单元格对单元格进行排队
        - 调用`distance = distanceLookup`
        - 调用`validCellToQueue`
        - 调用`enqueue(distance, data)`
    - `computeCache`：计算缓存距离，`max_distance_ + 2`的二维表，计算曼哈顿距离或欧式距离
    - `distanceLookup`：查找预先计算的距离

- **LimitedCostmapQueue**：`Costmap`队列的扩展，其中距离限制为距源单元的给定距离，继承于`CostmapQueue`
    - `validCellToQueue`：重写函数，`cell.distance_ <= max_distance_`

#### 工具

- `tf`工具
    - `transformPose`，转换入参类型`geometry_msgs::msg::PoseStamped`
    - `transformPose`，转换入参类型`nav_2d_msgs::msg::Pose2DStamped`
- `msg`转换工具
    - `twist2Dto3D`
    - `twist3Dto2D`
    - `poseStampedToPose2D`
    - `poseToPose2D`
    - `pose2DToPose`
    - `pose2DToPoseStamped`，转换入参类型`nav_2d_msgs::msg::Pose2DStamped`
    - `pose2DToPoseStamped`，转换入参类型`geometry_msgs::msg::Pose2D`
    - `posesToPath`
    - `pathToPath2D`
    - `poses2DToPath`
    - `pathToPath`

- 节点参数工具
    - `searchAndGetParam`
        - 调用`nav2_util::declare_parameter_if_not_declared`
        - 调用`nh->get_parameter`
- 其他工具
    - `adjustPlanResolution`：通过在点之间线性添加点来提高计划分辨率以匹配成本图的分辨率





































